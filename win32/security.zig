//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (232)
//--------------------------------------------------------------------------------
pub const CVT_SECONDS = @as(u32, 1);
pub const CRYPTPROTECT_PROMPT_ON_UNPROTECT = @as(u32, 1);
pub const CRYPTPROTECT_PROMPT_ON_PROTECT = @as(u32, 2);
pub const CRYPTPROTECT_PROMPT_RESERVED = @as(u32, 4);
pub const CRYPTPROTECT_PROMPT_STRONG = @as(u32, 8);
pub const CRYPTPROTECT_PROMPT_REQUIRE_STRONG = @as(u32, 16);
pub const CRYPTPROTECT_UI_FORBIDDEN = @as(u32, 1);
pub const CRYPTPROTECT_LOCAL_MACHINE = @as(u32, 4);
pub const CRYPTPROTECT_CRED_SYNC = @as(u32, 8);
pub const CRYPTPROTECT_AUDIT = @as(u32, 16);
pub const CRYPTPROTECT_NO_RECOVERY = @as(u32, 32);
pub const CRYPTPROTECT_VERIFY_PROTECTION = @as(u32, 64);
pub const CRYPTPROTECT_CRED_REGENERATE = @as(u32, 128);
pub const CRYPTPROTECT_FIRST_RESERVED_FLAGVAL = @as(u32, 268435455);
pub const CRYPTPROTECT_LAST_RESERVED_FLAGVAL = @as(u32, 4294967295);
pub const CRYPTPROTECTMEMORY_BLOCK_SIZE = @as(u32, 16);
pub const CRYPTPROTECTMEMORY_SAME_PROCESS = @as(u32, 0);
pub const CRYPTPROTECTMEMORY_CROSS_PROCESS = @as(u32, 1);
pub const CRYPTPROTECTMEMORY_SAME_LOGON = @as(u32, 2);
pub const DSSI_READ_ONLY = @as(u32, 1);
pub const DSSI_NO_ACCESS_CHECK = @as(u32, 2);
pub const DSSI_NO_EDIT_SACL = @as(u32, 4);
pub const DSSI_NO_EDIT_OWNER = @as(u32, 8);
pub const DSSI_IS_ROOT = @as(u32, 16);
pub const DSSI_NO_FILTER = @as(u32, 32);
pub const DSSI_NO_READONLY_MESSAGE = @as(u32, 64);
pub const CRYPTCAT_MAX_MEMBERTAG = @as(u32, 64);
pub const CRYPTCAT_MEMBER_SORTED = @as(u32, 1073741824);
pub const CRYPTCAT_ATTR_AUTHENTICATED = @as(u32, 268435456);
pub const CRYPTCAT_ATTR_UNAUTHENTICATED = @as(u32, 536870912);
pub const CRYPTCAT_ATTR_NAMEASCII = @as(u32, 1);
pub const CRYPTCAT_ATTR_NAMEOBJID = @as(u32, 2);
pub const CRYPTCAT_ATTR_DATAASCII = @as(u32, 65536);
pub const CRYPTCAT_ATTR_DATABASE64 = @as(u32, 131072);
pub const CRYPTCAT_ATTR_DATAREPLACE = @as(u32, 262144);
pub const CRYPTCAT_ATTR_NO_AUTO_COMPAT_ENTRY = @as(u32, 16777216);
pub const CRYPTCAT_E_AREA_HEADER = @as(u32, 0);
pub const CRYPTCAT_E_AREA_MEMBER = @as(u32, 65536);
pub const CRYPTCAT_E_AREA_ATTRIBUTE = @as(u32, 131072);
pub const CRYPTCAT_E_CDF_UNSUPPORTED = @as(u32, 1);
pub const CRYPTCAT_E_CDF_DUPLICATE = @as(u32, 2);
pub const CRYPTCAT_E_CDF_TAGNOTFOUND = @as(u32, 4);
pub const CRYPTCAT_E_CDF_MEMBER_FILE_PATH = @as(u32, 65537);
pub const CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA = @as(u32, 65538);
pub const CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND = @as(u32, 65540);
pub const CRYPTCAT_E_CDF_BAD_GUID_CONV = @as(u32, 131073);
pub const CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES = @as(u32, 131074);
pub const CRYPTCAT_E_CDF_ATTR_TYPECOMBO = @as(u32, 131076);
pub const CRYPTCAT_ADDCATALOG_NONE = @as(u32, 0);
pub const CRYPTCAT_ADDCATALOG_HARDLINK = @as(u32, 1);
pub const MSSIP_FLAGS_PROHIBIT_RESIZE_ON_CREATE = @as(u32, 65536);
pub const MSSIP_FLAGS_USE_CATALOG = @as(u32, 131072);
pub const MSSIP_FLAGS_MULTI_HASH = @as(u32, 262144);
pub const SPC_INC_PE_RESOURCES_FLAG = @as(u32, 128);
pub const SPC_INC_PE_DEBUG_INFO_FLAG = @as(u32, 64);
pub const SPC_INC_PE_IMPORT_ADDR_TABLE_FLAG = @as(u32, 32);
pub const SPC_EXC_PE_PAGE_HASHES_FLAG = @as(u32, 16);
pub const SPC_INC_PE_PAGE_HASHES_FLAG = @as(u32, 256);
pub const SPC_DIGEST_GENERATE_FLAG = @as(u32, 512);
pub const SPC_DIGEST_SIGN_FLAG = @as(u32, 1024);
pub const SPC_DIGEST_SIGN_EX_FLAG = @as(u32, 16384);
pub const SPC_RELAXED_PE_MARKER_CHECK = @as(u32, 2048);
pub const SPC_MARKER_CHECK_SKIP_SIP_INDIRECT_DATA_FLAG = @as(u32, 1);
pub const SIP_CAP_SET_VERSION_2 = @as(u32, 2);
pub const SIP_CAP_SET_VERSION_3 = @as(u32, 3);
pub const SIP_CAP_SET_CUR_VER = @as(u32, 3);
pub const SIP_CAP_FLAG_SEALING = @as(u32, 1);
pub const SIP_MAX_MAGIC_NUMBER = @as(u32, 4);
pub const cNodetypeSceTemplateServices = Guid.initString("24a7f717-1f0c-11d1-affb-00c04fb984f9");
pub const cNodetypeSceAnalysisServices = Guid.initString("678050c7-1ff8-11d1-affb-00c04fb984f9");
pub const cNodetypeSceEventLog = Guid.initString("2ce06698-4bf3-11d1-8c30-00c04fb984f9");
pub const SCESTATUS_SUCCESS = @as(i32, 0);
pub const SCESTATUS_INVALID_PARAMETER = @as(i32, 1);
pub const SCESTATUS_RECORD_NOT_FOUND = @as(i32, 2);
pub const SCESTATUS_INVALID_DATA = @as(i32, 3);
pub const SCESTATUS_OBJECT_EXIST = @as(i32, 4);
pub const SCESTATUS_BUFFER_TOO_SMALL = @as(i32, 5);
pub const SCESTATUS_PROFILE_NOT_FOUND = @as(i32, 6);
pub const SCESTATUS_BAD_FORMAT = @as(i32, 7);
pub const SCESTATUS_NOT_ENOUGH_RESOURCE = @as(i32, 8);
pub const SCESTATUS_ACCESS_DENIED = @as(i32, 9);
pub const SCESTATUS_CANT_DELETE = @as(i32, 10);
pub const SCESTATUS_PREFIX_OVERFLOW = @as(i32, 11);
pub const SCESTATUS_OTHER_ERROR = @as(i32, 12);
pub const SCESTATUS_ALREADY_RUNNING = @as(i32, 13);
pub const SCESTATUS_SERVICE_NOT_SUPPORT = @as(i32, 14);
pub const SCESTATUS_MOD_NOT_FOUND = @as(i32, 15);
pub const SCESTATUS_EXCEPTION_IN_SERVER = @as(i32, 16);
pub const SCESTATUS_NO_TEMPLATE_GIVEN = @as(i32, 17);
pub const SCESTATUS_NO_MAPPING = @as(i32, 18);
pub const SCESTATUS_TRUST_FAIL = @as(i32, 19);
pub const SCESVC_ENUMERATION_MAX = @as(i32, 100);
pub const TPMVSC_DEFAULT_ADMIN_ALGORITHM_ID = @as(u32, 130);
pub const SAFER_SCOPEID_MACHINE = @as(u32, 1);
pub const SAFER_SCOPEID_USER = @as(u32, 2);
pub const SAFER_LEVELID_FULLYTRUSTED = @as(u32, 262144);
pub const SAFER_LEVELID_NORMALUSER = @as(u32, 131072);
pub const SAFER_LEVELID_CONSTRAINED = @as(u32, 65536);
pub const SAFER_LEVELID_UNTRUSTED = @as(u32, 4096);
pub const SAFER_LEVELID_DISALLOWED = @as(u32, 0);
pub const SAFER_LEVEL_OPEN = @as(u32, 1);
pub const SAFER_MAX_FRIENDLYNAME_SIZE = @as(u32, 256);
pub const SAFER_MAX_DESCRIPTION_SIZE = @as(u32, 256);
pub const SAFER_MAX_HASH_SIZE = @as(u32, 64);
pub const SAFER_CRITERIA_IMAGEPATH = @as(u32, 1);
pub const SAFER_CRITERIA_NOSIGNEDHASH = @as(u32, 2);
pub const SAFER_CRITERIA_IMAGEHASH = @as(u32, 4);
pub const SAFER_CRITERIA_AUTHENTICODE = @as(u32, 8);
pub const SAFER_CRITERIA_URLZONE = @as(u32, 16);
pub const SAFER_CRITERIA_APPX_PACKAGE = @as(u32, 32);
pub const SAFER_CRITERIA_IMAGEPATH_NT = @as(u32, 4096);
pub const SAFER_POLICY_JOBID_MASK = @as(u32, 4278190080);
pub const SAFER_POLICY_JOBID_CONSTRAINED = @as(u32, 67108864);
pub const SAFER_POLICY_JOBID_UNTRUSTED = @as(u32, 50331648);
pub const SAFER_POLICY_ONLY_EXES = @as(u32, 65536);
pub const SAFER_POLICY_SANDBOX_INERT = @as(u32, 131072);
pub const SAFER_POLICY_HASH_DUPLICATE = @as(u32, 262144);
pub const SAFER_POLICY_ONLY_AUDIT = @as(u32, 4096);
pub const SAFER_POLICY_BLOCK_CLIENT_UI = @as(u32, 8192);
pub const SAFER_POLICY_UIFLAGS_MASK = @as(u32, 255);
pub const SAFER_POLICY_UIFLAGS_INFORMATION_PROMPT = @as(u32, 1);
pub const SAFER_POLICY_UIFLAGS_OPTION_PROMPT = @as(u32, 2);
pub const SAFER_POLICY_UIFLAGS_HIDDEN = @as(u32, 4);
pub const WINTRUST_MAX_HEADER_BYTES_TO_MAP_DEFAULT = @as(u32, 10485760);
pub const WINTRUST_MAX_HASH_BYTES_TO_MAP_DEFAULT = @as(u32, 1048576);
pub const WSS_VERIFY_SEALING = @as(u32, 4);
pub const WSS_INPUT_FLAG_MASK = @as(u32, 7);
pub const WSS_OUT_SEALING_STATUS_VERIFIED = @as(u32, 2147483648);
pub const WSS_OUT_HAS_SEALING_INTENT = @as(u32, 1073741824);
pub const WSS_OUT_FILE_SUPPORTS_SEAL = @as(u32, 536870912);
pub const WSS_OUTPUT_FLAG_MASK = @as(u32, 3758096384);
pub const TRUSTERROR_STEP_WVTPARAMS = @as(u32, 0);
pub const TRUSTERROR_STEP_FILEIO = @as(u32, 2);
pub const TRUSTERROR_STEP_SIP = @as(u32, 3);
pub const TRUSTERROR_STEP_SIPSUBJINFO = @as(u32, 5);
pub const TRUSTERROR_STEP_CATALOGFILE = @as(u32, 6);
pub const TRUSTERROR_STEP_CERTSTORE = @as(u32, 7);
pub const TRUSTERROR_STEP_MESSAGE = @as(u32, 8);
pub const TRUSTERROR_STEP_MSG_SIGNERCOUNT = @as(u32, 9);
pub const TRUSTERROR_STEP_MSG_INNERCNTTYPE = @as(u32, 10);
pub const TRUSTERROR_STEP_MSG_INNERCNT = @as(u32, 11);
pub const TRUSTERROR_STEP_MSG_STORE = @as(u32, 12);
pub const TRUSTERROR_STEP_MSG_SIGNERINFO = @as(u32, 13);
pub const TRUSTERROR_STEP_MSG_SIGNERCERT = @as(u32, 14);
pub const TRUSTERROR_STEP_MSG_CERTCHAIN = @as(u32, 15);
pub const TRUSTERROR_STEP_MSG_COUNTERSIGINFO = @as(u32, 16);
pub const TRUSTERROR_STEP_MSG_COUNTERSIGCERT = @as(u32, 17);
pub const TRUSTERROR_STEP_VERIFY_MSGHASH = @as(u32, 18);
pub const TRUSTERROR_STEP_VERIFY_MSGINDIRECTDATA = @as(u32, 19);
pub const TRUSTERROR_STEP_FINAL_WVTINIT = @as(u32, 30);
pub const TRUSTERROR_STEP_FINAL_INITPROV = @as(u32, 31);
pub const TRUSTERROR_STEP_FINAL_OBJPROV = @as(u32, 32);
pub const TRUSTERROR_STEP_FINAL_SIGPROV = @as(u32, 33);
pub const TRUSTERROR_STEP_FINAL_CERTPROV = @as(u32, 34);
pub const TRUSTERROR_STEP_FINAL_CERTCHKPROV = @as(u32, 35);
pub const TRUSTERROR_STEP_FINAL_POLICYPROV = @as(u32, 36);
pub const TRUSTERROR_STEP_FINAL_UIPROV = @as(u32, 37);
pub const TRUSTERROR_MAX_STEPS = @as(u32, 38);
pub const WSS_OBJTRUST_SUPPORT = @as(u32, 1);
pub const WSS_SIGTRUST_SUPPORT = @as(u32, 2);
pub const WSS_CERTTRUST_SUPPORT = @as(u32, 4);
pub const WT_CURRENT_VERSION = @as(u32, 512);
pub const WT_ADD_ACTION_ID_RET_RESULT_FLAG = @as(u32, 1);
pub const SPC_UUID_LENGTH = @as(u32, 16);
pub const WIN_CERT_REVISION_1_0 = @as(u32, 256);
pub const WIN_CERT_REVISION_2_0 = @as(u32, 512);
pub const WIN_CERT_TYPE_X509 = @as(u32, 1);
pub const WIN_CERT_TYPE_PKCS_SIGNED_DATA = @as(u32, 2);
pub const WIN_CERT_TYPE_RESERVED_1 = @as(u32, 3);
pub const WIN_CERT_TYPE_TS_STACK_SIGNED = @as(u32, 4);
pub const WT_TRUSTDBDIALOG_NO_UI_FLAG = @as(u32, 1);
pub const WT_TRUSTDBDIALOG_ONLY_PUB_TAB_FLAG = @as(u32, 2);
pub const WT_TRUSTDBDIALOG_WRITE_LEGACY_REG_FLAG = @as(u32, 256);
pub const WT_TRUSTDBDIALOG_WRITE_IEAK_STORE_FLAG = @as(u32, 512);
pub const WLX_VERSION_1_0 = @as(u32, 65536);
pub const WLX_VERSION_1_1 = @as(u32, 65537);
pub const WLX_VERSION_1_2 = @as(u32, 65538);
pub const WLX_VERSION_1_3 = @as(u32, 65539);
pub const WLX_VERSION_1_4 = @as(u32, 65540);
pub const WLX_SAS_TYPE_TIMEOUT = @as(u32, 0);
pub const WLX_SAS_TYPE_CTRL_ALT_DEL = @as(u32, 1);
pub const WLX_SAS_TYPE_SCRNSVR_TIMEOUT = @as(u32, 2);
pub const WLX_SAS_TYPE_SCRNSVR_ACTIVITY = @as(u32, 3);
pub const WLX_SAS_TYPE_USER_LOGOFF = @as(u32, 4);
pub const WLX_SAS_TYPE_SC_INSERT = @as(u32, 5);
pub const WLX_SAS_TYPE_SC_REMOVE = @as(u32, 6);
pub const WLX_SAS_TYPE_AUTHENTICATED = @as(u32, 7);
pub const WLX_SAS_TYPE_SC_FIRST_READER_ARRIVED = @as(u32, 8);
pub const WLX_SAS_TYPE_SC_LAST_READER_REMOVED = @as(u32, 9);
pub const WLX_SAS_TYPE_SWITCHUSER = @as(u32, 10);
pub const WLX_SAS_TYPE_MAX_MSFT_VALUE = @as(u32, 127);
pub const WLX_LOGON_OPT_NO_PROFILE = @as(u32, 1);
pub const WLX_PROFILE_TYPE_V1_0 = @as(u32, 1);
pub const WLX_PROFILE_TYPE_V2_0 = @as(u32, 2);
pub const WLX_SAS_ACTION_LOGON = @as(u32, 1);
pub const WLX_SAS_ACTION_NONE = @as(u32, 2);
pub const WLX_SAS_ACTION_LOCK_WKSTA = @as(u32, 3);
pub const WLX_SAS_ACTION_LOGOFF = @as(u32, 4);
pub const WLX_SAS_ACTION_PWD_CHANGED = @as(u32, 6);
pub const WLX_SAS_ACTION_TASKLIST = @as(u32, 7);
pub const WLX_SAS_ACTION_UNLOCK_WKSTA = @as(u32, 8);
pub const WLX_SAS_ACTION_FORCE_LOGOFF = @as(u32, 9);
pub const WLX_SAS_ACTION_SHUTDOWN_SLEEP = @as(u32, 12);
pub const WLX_SAS_ACTION_SHUTDOWN_SLEEP2 = @as(u32, 13);
pub const WLX_SAS_ACTION_SHUTDOWN_HIBERNATE = @as(u32, 14);
pub const WLX_SAS_ACTION_RECONNECTED = @as(u32, 15);
pub const WLX_SAS_ACTION_DELAYED_FORCE_LOGOFF = @as(u32, 16);
pub const WLX_SAS_ACTION_SWITCH_CONSOLE = @as(u32, 17);
pub const WLX_WM_SAS = @as(u32, 1625);
pub const WLX_DLG_SAS = @as(u32, 101);
pub const WLX_DLG_INPUT_TIMEOUT = @as(u32, 102);
pub const WLX_DLG_SCREEN_SAVER_TIMEOUT = @as(u32, 103);
pub const WLX_DLG_USER_LOGOFF = @as(u32, 104);
pub const WLX_DIRECTORY_LENGTH = @as(u32, 256);
pub const WLX_CREDENTIAL_TYPE_V1_0 = @as(u32, 1);
pub const WLX_CREDENTIAL_TYPE_V2_0 = @as(u32, 2);
pub const WLX_CONSOLESWITCHCREDENTIAL_TYPE_V1_0 = @as(u32, 1);
pub const STATUSMSG_OPTION_NOANIMATION = @as(u32, 1);
pub const STATUSMSG_OPTION_SETFOREGROUND = @as(u32, 2);
pub const WLX_DESKTOP_NAME = @as(u32, 1);
pub const WLX_DESKTOP_HANDLE = @as(u32, 2);
pub const WLX_CREATE_INSTANCE_ONLY = @as(u32, 1);
pub const WLX_CREATE_USER = @as(u32, 2);
pub const WLX_OPTION_USE_CTRL_ALT_DEL = @as(u32, 1);
pub const WLX_OPTION_CONTEXT_POINTER = @as(u32, 2);
pub const WLX_OPTION_USE_SMART_CARD = @as(u32, 3);
pub const WLX_OPTION_FORCE_LOGOFF_TIME = @as(u32, 4);
pub const WLX_OPTION_IGNORE_AUTO_LOGON = @as(u32, 8);
pub const WLX_OPTION_NO_SWITCH_ON_SAS = @as(u32, 9);
pub const WLX_OPTION_SMART_CARD_PRESENT = @as(u32, 65537);
pub const WLX_OPTION_SMART_CARD_INFO = @as(u32, 65538);
pub const WLX_OPTION_DISPATCH_TABLE_SIZE = @as(u32, 65539);

//--------------------------------------------------------------------------------
// Section: Types (303)
//--------------------------------------------------------------------------------
pub const TOKEN_PRIVILEGES_ATTRIBUTES = enum(u32) {
    ENABLED = 2,
    ENABLED_BY_DEFAULT = 1,
    REMOVED = 4,
    USED_FOR_ACCESS = 2147483648,
    _,
    pub fn initFlags(o: struct {
        ENABLED: u1 = 0,
        ENABLED_BY_DEFAULT: u1 = 0,
        REMOVED: u1 = 0,
        USED_FOR_ACCESS: u1 = 0,
    }) TOKEN_PRIVILEGES_ATTRIBUTES {
        return @intToEnum(TOKEN_PRIVILEGES_ATTRIBUTES,
              (if (o.ENABLED == 1) @enumToInt(TOKEN_PRIVILEGES_ATTRIBUTES.ENABLED) else 0)
            | (if (o.ENABLED_BY_DEFAULT == 1) @enumToInt(TOKEN_PRIVILEGES_ATTRIBUTES.ENABLED_BY_DEFAULT) else 0)
            | (if (o.REMOVED == 1) @enumToInt(TOKEN_PRIVILEGES_ATTRIBUTES.REMOVED) else 0)
            | (if (o.USED_FOR_ACCESS == 1) @enumToInt(TOKEN_PRIVILEGES_ATTRIBUTES.USED_FOR_ACCESS) else 0)
        );
    }
};
pub const SE_PRIVILEGE_ENABLED = TOKEN_PRIVILEGES_ATTRIBUTES.ENABLED;
pub const SE_PRIVILEGE_ENABLED_BY_DEFAULT = TOKEN_PRIVILEGES_ATTRIBUTES.ENABLED_BY_DEFAULT;
pub const SE_PRIVILEGE_REMOVED = TOKEN_PRIVILEGES_ATTRIBUTES.REMOVED;
pub const SE_PRIVILEGE_USED_FOR_ACCESS = TOKEN_PRIVILEGES_ATTRIBUTES.USED_FOR_ACCESS;

pub const LOGON32_PROVIDER = enum(u32) {
    DEFAULT = 0,
    WINNT50 = 3,
    WINNT40 = 2,
};
pub const LOGON32_PROVIDER_DEFAULT = LOGON32_PROVIDER.DEFAULT;
pub const LOGON32_PROVIDER_WINNT50 = LOGON32_PROVIDER.WINNT50;
pub const LOGON32_PROVIDER_WINNT40 = LOGON32_PROVIDER.WINNT40;

pub const SCE_LOG_ERR_LEVEL = enum(u32) {
    ALWAYS = 0,
    ERROR = 1,
    DETAIL = 2,
    DEBUG = 3,
};
pub const SCE_LOG_LEVEL_ALWAYS = SCE_LOG_ERR_LEVEL.ALWAYS;
pub const SCE_LOG_LEVEL_ERROR = SCE_LOG_ERR_LEVEL.ERROR;
pub const SCE_LOG_LEVEL_DETAIL = SCE_LOG_ERR_LEVEL.DETAIL;
pub const SCE_LOG_LEVEL_DEBUG = SCE_LOG_ERR_LEVEL.DEBUG;

pub const CREATE_RESTRICTED_TOKEN_FLAGS = enum(u32) {
    DISABLE_MAX_PRIVILEGE = 1,
    SANDBOX_INERT = 2,
    LUA_TOKEN = 4,
    WRITE_RESTRICTED = 8,
    _,
    pub fn initFlags(o: struct {
        DISABLE_MAX_PRIVILEGE: u1 = 0,
        SANDBOX_INERT: u1 = 0,
        LUA_TOKEN: u1 = 0,
        WRITE_RESTRICTED: u1 = 0,
    }) CREATE_RESTRICTED_TOKEN_FLAGS {
        return @intToEnum(CREATE_RESTRICTED_TOKEN_FLAGS,
              (if (o.DISABLE_MAX_PRIVILEGE == 1) @enumToInt(CREATE_RESTRICTED_TOKEN_FLAGS.DISABLE_MAX_PRIVILEGE) else 0)
            | (if (o.SANDBOX_INERT == 1) @enumToInt(CREATE_RESTRICTED_TOKEN_FLAGS.SANDBOX_INERT) else 0)
            | (if (o.LUA_TOKEN == 1) @enumToInt(CREATE_RESTRICTED_TOKEN_FLAGS.LUA_TOKEN) else 0)
            | (if (o.WRITE_RESTRICTED == 1) @enumToInt(CREATE_RESTRICTED_TOKEN_FLAGS.WRITE_RESTRICTED) else 0)
        );
    }
};
pub const DISABLE_MAX_PRIVILEGE = CREATE_RESTRICTED_TOKEN_FLAGS.DISABLE_MAX_PRIVILEGE;
pub const SANDBOX_INERT = CREATE_RESTRICTED_TOKEN_FLAGS.SANDBOX_INERT;
pub const LUA_TOKEN = CREATE_RESTRICTED_TOKEN_FLAGS.LUA_TOKEN;
pub const WRITE_RESTRICTED = CREATE_RESTRICTED_TOKEN_FLAGS.WRITE_RESTRICTED;

pub const LOGON32_LOGON = enum(u32) {
    BATCH = 4,
    INTERACTIVE = 2,
    NETWORK = 3,
    NETWORK_CLEARTEXT = 8,
    NEW_CREDENTIALS = 9,
    SERVICE = 5,
    UNLOCK = 7,
};
pub const LOGON32_LOGON_BATCH = LOGON32_LOGON.BATCH;
pub const LOGON32_LOGON_INTERACTIVE = LOGON32_LOGON.INTERACTIVE;
pub const LOGON32_LOGON_NETWORK = LOGON32_LOGON.NETWORK;
pub const LOGON32_LOGON_NETWORK_CLEARTEXT = LOGON32_LOGON.NETWORK_CLEARTEXT;
pub const LOGON32_LOGON_NEW_CREDENTIALS = LOGON32_LOGON.NEW_CREDENTIALS;
pub const LOGON32_LOGON_SERVICE = LOGON32_LOGON.SERVICE;
pub const LOGON32_LOGON_UNLOCK = LOGON32_LOGON.UNLOCK;

pub const ACE_FLAGS = enum(u32) {
    CONTAINER_INHERIT_ACE = 2,
    FAILED_ACCESS_ACE_FLAG = 128,
    INHERIT_ONLY_ACE = 8,
    INHERITED_ACE = 16,
    NO_PROPAGATE_INHERIT_ACE = 4,
    OBJECT_INHERIT_ACE = 1,
    SUCCESSFUL_ACCESS_ACE_FLAG = 64,
    SUB_CONTAINERS_AND_OBJECTS_INHERIT = 3,
    // SUB_CONTAINERS_ONLY_INHERIT = 2, this enum value conflicts with CONTAINER_INHERIT_ACE
    // SUB_OBJECTS_ONLY_INHERIT = 1, this enum value conflicts with OBJECT_INHERIT_ACE
    // INHERIT_NO_PROPAGATE = 4, this enum value conflicts with NO_PROPAGATE_INHERIT_ACE
    // INHERIT_ONLY = 8, this enum value conflicts with INHERIT_ONLY_ACE
    NO_INHERITANCE = 0,
    // INHERIT_ONLY_ACE_ = 8, this enum value conflicts with INHERIT_ONLY_ACE
    _,
    pub fn initFlags(o: struct {
        CONTAINER_INHERIT_ACE: u1 = 0,
        FAILED_ACCESS_ACE_FLAG: u1 = 0,
        INHERIT_ONLY_ACE: u1 = 0,
        INHERITED_ACE: u1 = 0,
        NO_PROPAGATE_INHERIT_ACE: u1 = 0,
        OBJECT_INHERIT_ACE: u1 = 0,
        SUCCESSFUL_ACCESS_ACE_FLAG: u1 = 0,
        SUB_CONTAINERS_AND_OBJECTS_INHERIT: u1 = 0,
        NO_INHERITANCE: u1 = 0,
    }) ACE_FLAGS {
        return @intToEnum(ACE_FLAGS,
              (if (o.CONTAINER_INHERIT_ACE == 1) @enumToInt(ACE_FLAGS.CONTAINER_INHERIT_ACE) else 0)
            | (if (o.FAILED_ACCESS_ACE_FLAG == 1) @enumToInt(ACE_FLAGS.FAILED_ACCESS_ACE_FLAG) else 0)
            | (if (o.INHERIT_ONLY_ACE == 1) @enumToInt(ACE_FLAGS.INHERIT_ONLY_ACE) else 0)
            | (if (o.INHERITED_ACE == 1) @enumToInt(ACE_FLAGS.INHERITED_ACE) else 0)
            | (if (o.NO_PROPAGATE_INHERIT_ACE == 1) @enumToInt(ACE_FLAGS.NO_PROPAGATE_INHERIT_ACE) else 0)
            | (if (o.OBJECT_INHERIT_ACE == 1) @enumToInt(ACE_FLAGS.OBJECT_INHERIT_ACE) else 0)
            | (if (o.SUCCESSFUL_ACCESS_ACE_FLAG == 1) @enumToInt(ACE_FLAGS.SUCCESSFUL_ACCESS_ACE_FLAG) else 0)
            | (if (o.SUB_CONTAINERS_AND_OBJECTS_INHERIT == 1) @enumToInt(ACE_FLAGS.SUB_CONTAINERS_AND_OBJECTS_INHERIT) else 0)
            | (if (o.NO_INHERITANCE == 1) @enumToInt(ACE_FLAGS.NO_INHERITANCE) else 0)
        );
    }
};
pub const CONTAINER_INHERIT_ACE = ACE_FLAGS.CONTAINER_INHERIT_ACE;
pub const FAILED_ACCESS_ACE_FLAG = ACE_FLAGS.FAILED_ACCESS_ACE_FLAG;
pub const INHERIT_ONLY_ACE = ACE_FLAGS.INHERIT_ONLY_ACE;
pub const INHERITED_ACE = ACE_FLAGS.INHERITED_ACE;
pub const NO_PROPAGATE_INHERIT_ACE = ACE_FLAGS.NO_PROPAGATE_INHERIT_ACE;
pub const OBJECT_INHERIT_ACE = ACE_FLAGS.OBJECT_INHERIT_ACE;
pub const SUCCESSFUL_ACCESS_ACE_FLAG = ACE_FLAGS.SUCCESSFUL_ACCESS_ACE_FLAG;
pub const SUB_CONTAINERS_AND_OBJECTS_INHERIT = ACE_FLAGS.SUB_CONTAINERS_AND_OBJECTS_INHERIT;
pub const SUB_CONTAINERS_ONLY_INHERIT = ACE_FLAGS.CONTAINER_INHERIT_ACE;
pub const SUB_OBJECTS_ONLY_INHERIT = ACE_FLAGS.OBJECT_INHERIT_ACE;
pub const INHERIT_NO_PROPAGATE = ACE_FLAGS.NO_PROPAGATE_INHERIT_ACE;
pub const INHERIT_ONLY = ACE_FLAGS.INHERIT_ONLY_ACE;
pub const NO_INHERITANCE = ACE_FLAGS.NO_INHERITANCE;
pub const INHERIT_ONLY_ACE_ = ACE_FLAGS.INHERIT_ONLY_ACE;

pub const SECURITY_AUTO_INHERIT_FLAGS = enum(u32) {
    AVOID_OWNER_CHECK = 16,
    AVOID_OWNER_RESTRICTION = 4096,
    AVOID_PRIVILEGE_CHECK = 8,
    DACL_AUTO_INHERIT = 1,
    DEFAULT_DESCRIPTOR_FOR_OBJECT = 4,
    DEFAULT_GROUP_FROM_PARENT = 64,
    DEFAULT_OWNER_FROM_PARENT = 32,
    MACL_NO_EXECUTE_UP = 1024,
    MACL_NO_READ_UP = 512,
    MACL_NO_WRITE_UP = 256,
    SACL_AUTO_INHERIT = 2,
    _,
    pub fn initFlags(o: struct {
        AVOID_OWNER_CHECK: u1 = 0,
        AVOID_OWNER_RESTRICTION: u1 = 0,
        AVOID_PRIVILEGE_CHECK: u1 = 0,
        DACL_AUTO_INHERIT: u1 = 0,
        DEFAULT_DESCRIPTOR_FOR_OBJECT: u1 = 0,
        DEFAULT_GROUP_FROM_PARENT: u1 = 0,
        DEFAULT_OWNER_FROM_PARENT: u1 = 0,
        MACL_NO_EXECUTE_UP: u1 = 0,
        MACL_NO_READ_UP: u1 = 0,
        MACL_NO_WRITE_UP: u1 = 0,
        SACL_AUTO_INHERIT: u1 = 0,
    }) SECURITY_AUTO_INHERIT_FLAGS {
        return @intToEnum(SECURITY_AUTO_INHERIT_FLAGS,
              (if (o.AVOID_OWNER_CHECK == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.AVOID_OWNER_CHECK) else 0)
            | (if (o.AVOID_OWNER_RESTRICTION == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.AVOID_OWNER_RESTRICTION) else 0)
            | (if (o.AVOID_PRIVILEGE_CHECK == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.AVOID_PRIVILEGE_CHECK) else 0)
            | (if (o.DACL_AUTO_INHERIT == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.DACL_AUTO_INHERIT) else 0)
            | (if (o.DEFAULT_DESCRIPTOR_FOR_OBJECT == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_DESCRIPTOR_FOR_OBJECT) else 0)
            | (if (o.DEFAULT_GROUP_FROM_PARENT == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_GROUP_FROM_PARENT) else 0)
            | (if (o.DEFAULT_OWNER_FROM_PARENT == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_OWNER_FROM_PARENT) else 0)
            | (if (o.MACL_NO_EXECUTE_UP == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_EXECUTE_UP) else 0)
            | (if (o.MACL_NO_READ_UP == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_READ_UP) else 0)
            | (if (o.MACL_NO_WRITE_UP == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_WRITE_UP) else 0)
            | (if (o.SACL_AUTO_INHERIT == 1) @enumToInt(SECURITY_AUTO_INHERIT_FLAGS.SACL_AUTO_INHERIT) else 0)
        );
    }
};
pub const SEF_AVOID_OWNER_CHECK = SECURITY_AUTO_INHERIT_FLAGS.AVOID_OWNER_CHECK;
pub const SEF_AVOID_OWNER_RESTRICTION = SECURITY_AUTO_INHERIT_FLAGS.AVOID_OWNER_RESTRICTION;
pub const SEF_AVOID_PRIVILEGE_CHECK = SECURITY_AUTO_INHERIT_FLAGS.AVOID_PRIVILEGE_CHECK;
pub const SEF_DACL_AUTO_INHERIT = SECURITY_AUTO_INHERIT_FLAGS.DACL_AUTO_INHERIT;
pub const SEF_DEFAULT_DESCRIPTOR_FOR_OBJECT = SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_DESCRIPTOR_FOR_OBJECT;
pub const SEF_DEFAULT_GROUP_FROM_PARENT = SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_GROUP_FROM_PARENT;
pub const SEF_DEFAULT_OWNER_FROM_PARENT = SECURITY_AUTO_INHERIT_FLAGS.DEFAULT_OWNER_FROM_PARENT;
pub const SEF_MACL_NO_EXECUTE_UP = SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_EXECUTE_UP;
pub const SEF_MACL_NO_READ_UP = SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_READ_UP;
pub const SEF_MACL_NO_WRITE_UP = SECURITY_AUTO_INHERIT_FLAGS.MACL_NO_WRITE_UP;
pub const SEF_SACL_AUTO_INHERIT = SECURITY_AUTO_INHERIT_FLAGS.SACL_AUTO_INHERIT;

pub const SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS = enum(u32) {
    NULL_IF_EQUAL = 1,
    COMPARE_ONLY = 2,
    MAKE_INERT = 4,
    WANT_FLAGS = 8,
    _,
    pub fn initFlags(o: struct {
        NULL_IF_EQUAL: u1 = 0,
        COMPARE_ONLY: u1 = 0,
        MAKE_INERT: u1 = 0,
        WANT_FLAGS: u1 = 0,
    }) SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS {
        return @intToEnum(SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS,
              (if (o.NULL_IF_EQUAL == 1) @enumToInt(SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.NULL_IF_EQUAL) else 0)
            | (if (o.COMPARE_ONLY == 1) @enumToInt(SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.COMPARE_ONLY) else 0)
            | (if (o.MAKE_INERT == 1) @enumToInt(SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.MAKE_INERT) else 0)
            | (if (o.WANT_FLAGS == 1) @enumToInt(SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.WANT_FLAGS) else 0)
        );
    }
};
pub const SAFER_TOKEN_NULL_IF_EQUAL = SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.NULL_IF_EQUAL;
pub const SAFER_TOKEN_COMPARE_ONLY = SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.COMPARE_ONLY;
pub const SAFER_TOKEN_MAKE_INERT = SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.MAKE_INERT;
pub const SAFER_TOKEN_WANT_FLAGS = SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS.WANT_FLAGS;

pub const WINTRUST_GET_DEFAULT_FOR_USAGE_ACTION = enum(u32) {
    ALLOCANDFILL = 1,
    FREE = 2,
};
pub const DWACTION_ALLOCANDFILL = WINTRUST_GET_DEFAULT_FOR_USAGE_ACTION.ALLOCANDFILL;
pub const DWACTION_FREE = WINTRUST_GET_DEFAULT_FOR_USAGE_ACTION.FREE;

pub const ACE_REVISION = enum(u32) {
    N = 2,
    _DS = 4,
};
pub const ACL_REVISION = ACE_REVISION.N;
pub const ACL_REVISION_DS = ACE_REVISION._DS;

pub const WINTRUST_POLICY_FLAGS = enum(u32) {
    TRUSTTEST = 32,
    TESTCANBEVALID = 128,
    IGNOREEXPIRATION = 256,
    IGNOREREVOKATION = 512,
    OFFLINEOK_IND = 1024,
    OFFLINEOK_COM = 2048,
    OFFLINEOKNBU_IND = 4096,
    OFFLINEOKNBU_COM = 8192,
    VERIFY_V1_OFF = 65536,
    IGNOREREVOCATIONONTS = 131072,
    ALLOWONLYPERTRUST = 262144,
    _,
    pub fn initFlags(o: struct {
        TRUSTTEST: u1 = 0,
        TESTCANBEVALID: u1 = 0,
        IGNOREEXPIRATION: u1 = 0,
        IGNOREREVOKATION: u1 = 0,
        OFFLINEOK_IND: u1 = 0,
        OFFLINEOK_COM: u1 = 0,
        OFFLINEOKNBU_IND: u1 = 0,
        OFFLINEOKNBU_COM: u1 = 0,
        VERIFY_V1_OFF: u1 = 0,
        IGNOREREVOCATIONONTS: u1 = 0,
        ALLOWONLYPERTRUST: u1 = 0,
    }) WINTRUST_POLICY_FLAGS {
        return @intToEnum(WINTRUST_POLICY_FLAGS,
              (if (o.TRUSTTEST == 1) @enumToInt(WINTRUST_POLICY_FLAGS.TRUSTTEST) else 0)
            | (if (o.TESTCANBEVALID == 1) @enumToInt(WINTRUST_POLICY_FLAGS.TESTCANBEVALID) else 0)
            | (if (o.IGNOREEXPIRATION == 1) @enumToInt(WINTRUST_POLICY_FLAGS.IGNOREEXPIRATION) else 0)
            | (if (o.IGNOREREVOKATION == 1) @enumToInt(WINTRUST_POLICY_FLAGS.IGNOREREVOKATION) else 0)
            | (if (o.OFFLINEOK_IND == 1) @enumToInt(WINTRUST_POLICY_FLAGS.OFFLINEOK_IND) else 0)
            | (if (o.OFFLINEOK_COM == 1) @enumToInt(WINTRUST_POLICY_FLAGS.OFFLINEOK_COM) else 0)
            | (if (o.OFFLINEOKNBU_IND == 1) @enumToInt(WINTRUST_POLICY_FLAGS.OFFLINEOKNBU_IND) else 0)
            | (if (o.OFFLINEOKNBU_COM == 1) @enumToInt(WINTRUST_POLICY_FLAGS.OFFLINEOKNBU_COM) else 0)
            | (if (o.VERIFY_V1_OFF == 1) @enumToInt(WINTRUST_POLICY_FLAGS.VERIFY_V1_OFF) else 0)
            | (if (o.IGNOREREVOCATIONONTS == 1) @enumToInt(WINTRUST_POLICY_FLAGS.IGNOREREVOCATIONONTS) else 0)
            | (if (o.ALLOWONLYPERTRUST == 1) @enumToInt(WINTRUST_POLICY_FLAGS.ALLOWONLYPERTRUST) else 0)
        );
    }
};
pub const WTPF_TRUSTTEST = WINTRUST_POLICY_FLAGS.TRUSTTEST;
pub const WTPF_TESTCANBEVALID = WINTRUST_POLICY_FLAGS.TESTCANBEVALID;
pub const WTPF_IGNOREEXPIRATION = WINTRUST_POLICY_FLAGS.IGNOREEXPIRATION;
pub const WTPF_IGNOREREVOKATION = WINTRUST_POLICY_FLAGS.IGNOREREVOKATION;
pub const WTPF_OFFLINEOK_IND = WINTRUST_POLICY_FLAGS.OFFLINEOK_IND;
pub const WTPF_OFFLINEOK_COM = WINTRUST_POLICY_FLAGS.OFFLINEOK_COM;
pub const WTPF_OFFLINEOKNBU_IND = WINTRUST_POLICY_FLAGS.OFFLINEOKNBU_IND;
pub const WTPF_OFFLINEOKNBU_COM = WINTRUST_POLICY_FLAGS.OFFLINEOKNBU_COM;
pub const WTPF_VERIFY_V1_OFF = WINTRUST_POLICY_FLAGS.VERIFY_V1_OFF;
pub const WTPF_IGNOREREVOCATIONONTS = WINTRUST_POLICY_FLAGS.IGNOREREVOCATIONONTS;
pub const WTPF_ALLOWONLYPERTRUST = WINTRUST_POLICY_FLAGS.ALLOWONLYPERTRUST;

pub const WLX_SHUTDOWN_TYPE = enum(u32) {
    N = 5,
    _REBOOT = 11,
    _POWER_OFF = 10,
};
pub const WLX_SAS_ACTION_SHUTDOWN = WLX_SHUTDOWN_TYPE.N;
pub const WLX_SAS_ACTION_SHUTDOWN_REBOOT = WLX_SHUTDOWN_TYPE._REBOOT;
pub const WLX_SAS_ACTION_SHUTDOWN_POWER_OFF = WLX_SHUTDOWN_TYPE._POWER_OFF;

pub const CRYPTCAT_VERSION = enum(u32) {
    @"1" = 256,
    @"2" = 512,
};
pub const CRYPTCAT_VERSION_1 = CRYPTCAT_VERSION.@"1";
pub const CRYPTCAT_VERSION_2 = CRYPTCAT_VERSION.@"2";

pub const CRYPTCAT_OPEN_FLAGS = enum(u32) {
    ALWAYS = 2,
    CREATENEW = 1,
    EXISTING = 4,
    EXCLUDE_PAGE_HASHES = 65536,
    INCLUDE_PAGE_HASHES = 131072,
    VERIFYSIGHASH = 268435456,
    NO_CONTENT_HCRYPTMSG = 536870912,
    SORTED = 1073741824,
    FLAGS_MASK = 4294901760,
    _,
    pub fn initFlags(o: struct {
        ALWAYS: u1 = 0,
        CREATENEW: u1 = 0,
        EXISTING: u1 = 0,
        EXCLUDE_PAGE_HASHES: u1 = 0,
        INCLUDE_PAGE_HASHES: u1 = 0,
        VERIFYSIGHASH: u1 = 0,
        NO_CONTENT_HCRYPTMSG: u1 = 0,
        SORTED: u1 = 0,
        FLAGS_MASK: u1 = 0,
    }) CRYPTCAT_OPEN_FLAGS {
        return @intToEnum(CRYPTCAT_OPEN_FLAGS,
              (if (o.ALWAYS == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.ALWAYS) else 0)
            | (if (o.CREATENEW == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.CREATENEW) else 0)
            | (if (o.EXISTING == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.EXISTING) else 0)
            | (if (o.EXCLUDE_PAGE_HASHES == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.EXCLUDE_PAGE_HASHES) else 0)
            | (if (o.INCLUDE_PAGE_HASHES == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.INCLUDE_PAGE_HASHES) else 0)
            | (if (o.VERIFYSIGHASH == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.VERIFYSIGHASH) else 0)
            | (if (o.NO_CONTENT_HCRYPTMSG == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.NO_CONTENT_HCRYPTMSG) else 0)
            | (if (o.SORTED == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.SORTED) else 0)
            | (if (o.FLAGS_MASK == 1) @enumToInt(CRYPTCAT_OPEN_FLAGS.FLAGS_MASK) else 0)
        );
    }
};
pub const CRYPTCAT_OPEN_ALWAYS = CRYPTCAT_OPEN_FLAGS.ALWAYS;
pub const CRYPTCAT_OPEN_CREATENEW = CRYPTCAT_OPEN_FLAGS.CREATENEW;
pub const CRYPTCAT_OPEN_EXISTING = CRYPTCAT_OPEN_FLAGS.EXISTING;
pub const CRYPTCAT_OPEN_EXCLUDE_PAGE_HASHES = CRYPTCAT_OPEN_FLAGS.EXCLUDE_PAGE_HASHES;
pub const CRYPTCAT_OPEN_INCLUDE_PAGE_HASHES = CRYPTCAT_OPEN_FLAGS.INCLUDE_PAGE_HASHES;
pub const CRYPTCAT_OPEN_VERIFYSIGHASH = CRYPTCAT_OPEN_FLAGS.VERIFYSIGHASH;
pub const CRYPTCAT_OPEN_NO_CONTENT_HCRYPTMSG = CRYPTCAT_OPEN_FLAGS.NO_CONTENT_HCRYPTMSG;
pub const CRYPTCAT_OPEN_SORTED = CRYPTCAT_OPEN_FLAGS.SORTED;
pub const CRYPTCAT_OPEN_FLAGS_MASK = CRYPTCAT_OPEN_FLAGS.FLAGS_MASK;

pub const TOKEN_MANDATORY_POLICY_ID = enum(u32) {
    OFF = 0,
    NO_WRITE_UP = 1,
    NEW_PROCESS_MIN = 2,
    VALID_MASK = 3,
};
pub const TOKEN_MANDATORY_POLICY_OFF = TOKEN_MANDATORY_POLICY_ID.OFF;
pub const TOKEN_MANDATORY_POLICY_NO_WRITE_UP = TOKEN_MANDATORY_POLICY_ID.NO_WRITE_UP;
pub const TOKEN_MANDATORY_POLICY_NEW_PROCESS_MIN = TOKEN_MANDATORY_POLICY_ID.NEW_PROCESS_MIN;
pub const TOKEN_MANDATORY_POLICY_VALID_MASK = TOKEN_MANDATORY_POLICY_ID.VALID_MASK;

pub const SYSTEM_AUDIT_OBJECT_ACE_FLAGS = enum(u32) {
    OBJECT_TYPE_PRESENT = 1,
    INHERITED_OBJECT_TYPE_PRESENT = 2,
    _,
    pub fn initFlags(o: struct {
        OBJECT_TYPE_PRESENT: u1 = 0,
        INHERITED_OBJECT_TYPE_PRESENT: u1 = 0,
    }) SYSTEM_AUDIT_OBJECT_ACE_FLAGS {
        return @intToEnum(SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
              (if (o.OBJECT_TYPE_PRESENT == 1) @enumToInt(SYSTEM_AUDIT_OBJECT_ACE_FLAGS.OBJECT_TYPE_PRESENT) else 0)
            | (if (o.INHERITED_OBJECT_TYPE_PRESENT == 1) @enumToInt(SYSTEM_AUDIT_OBJECT_ACE_FLAGS.INHERITED_OBJECT_TYPE_PRESENT) else 0)
        );
    }
};
pub const ACE_OBJECT_TYPE_PRESENT = SYSTEM_AUDIT_OBJECT_ACE_FLAGS.OBJECT_TYPE_PRESENT;
pub const ACE_INHERITED_OBJECT_TYPE_PRESENT = SYSTEM_AUDIT_OBJECT_ACE_FLAGS.INHERITED_OBJECT_TYPE_PRESENT;

pub const CLAIM_SECURITY_ATTRIBUTE_FLAGS = enum(u32) {
    NON_INHERITABLE = 1,
    VALUE_CASE_SENSITIVE = 2,
    USE_FOR_DENY_ONLY = 4,
    DISABLED_BY_DEFAULT = 8,
    DISABLED = 16,
    MANDATORY = 32,
    _,
    pub fn initFlags(o: struct {
        NON_INHERITABLE: u1 = 0,
        VALUE_CASE_SENSITIVE: u1 = 0,
        USE_FOR_DENY_ONLY: u1 = 0,
        DISABLED_BY_DEFAULT: u1 = 0,
        DISABLED: u1 = 0,
        MANDATORY: u1 = 0,
    }) CLAIM_SECURITY_ATTRIBUTE_FLAGS {
        return @intToEnum(CLAIM_SECURITY_ATTRIBUTE_FLAGS,
              (if (o.NON_INHERITABLE == 1) @enumToInt(CLAIM_SECURITY_ATTRIBUTE_FLAGS.NON_INHERITABLE) else 0)
            | (if (o.VALUE_CASE_SENSITIVE == 1) @enumToInt(CLAIM_SECURITY_ATTRIBUTE_FLAGS.VALUE_CASE_SENSITIVE) else 0)
            | (if (o.USE_FOR_DENY_ONLY == 1) @enumToInt(CLAIM_SECURITY_ATTRIBUTE_FLAGS.USE_FOR_DENY_ONLY) else 0)
            | (if (o.DISABLED_BY_DEFAULT == 1) @enumToInt(CLAIM_SECURITY_ATTRIBUTE_FLAGS.DISABLED_BY_DEFAULT) else 0)
            | (if (o.DISABLED == 1) @enumToInt(CLAIM_SECURITY_ATTRIBUTE_FLAGS.DISABLED) else 0)
            | (if (o.MANDATORY == 1) @enumToInt(CLAIM_SECURITY_ATTRIBUTE_FLAGS.MANDATORY) else 0)
        );
    }
};
pub const CLAIM_SECURITY_ATTRIBUTE_NON_INHERITABLE = CLAIM_SECURITY_ATTRIBUTE_FLAGS.NON_INHERITABLE;
pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_CASE_SENSITIVE = CLAIM_SECURITY_ATTRIBUTE_FLAGS.VALUE_CASE_SENSITIVE;
pub const CLAIM_SECURITY_ATTRIBUTE_USE_FOR_DENY_ONLY = CLAIM_SECURITY_ATTRIBUTE_FLAGS.USE_FOR_DENY_ONLY;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED_BY_DEFAULT = CLAIM_SECURITY_ATTRIBUTE_FLAGS.DISABLED_BY_DEFAULT;
pub const CLAIM_SECURITY_ATTRIBUTE_DISABLED = CLAIM_SECURITY_ATTRIBUTE_FLAGS.DISABLED;
pub const CLAIM_SECURITY_ATTRIBUTE_MANDATORY = CLAIM_SECURITY_ATTRIBUTE_FLAGS.MANDATORY;

pub const WINTRUST_DATA_UICHOICE = enum(u32) {
    ALL = 1,
    NONE = 2,
    NOBAD = 3,
    NOGOOD = 4,
};
pub const WTD_UI_ALL = WINTRUST_DATA_UICHOICE.ALL;
pub const WTD_UI_NONE = WINTRUST_DATA_UICHOICE.NONE;
pub const WTD_UI_NOBAD = WINTRUST_DATA_UICHOICE.NOBAD;
pub const WTD_UI_NOGOOD = WINTRUST_DATA_UICHOICE.NOGOOD;

pub const WINTRUST_SIGNATURE_SETTINGS_FLAGS = enum(u32) {
    VERIFY_SPECIFIC = 1,
    GET_SECONDARY_SIG_COUNT = 2,
};
pub const WSS_VERIFY_SPECIFIC = WINTRUST_SIGNATURE_SETTINGS_FLAGS.VERIFY_SPECIFIC;
pub const WSS_GET_SECONDARY_SIG_COUNT = WINTRUST_SIGNATURE_SETTINGS_FLAGS.GET_SECONDARY_SIG_COUNT;

pub const WINTRUST_DATA_STATE_ACTION = enum(u32) {
    IGNORE = 0,
    VERIFY = 1,
    CLOSE = 2,
    AUTO_CACHE = 3,
    AUTO_CACHE_FLUSH = 4,
};
pub const WTD_STATEACTION_IGNORE = WINTRUST_DATA_STATE_ACTION.IGNORE;
pub const WTD_STATEACTION_VERIFY = WINTRUST_DATA_STATE_ACTION.VERIFY;
pub const WTD_STATEACTION_CLOSE = WINTRUST_DATA_STATE_ACTION.CLOSE;
pub const WTD_STATEACTION_AUTO_CACHE = WINTRUST_DATA_STATE_ACTION.AUTO_CACHE;
pub const WTD_STATEACTION_AUTO_CACHE_FLUSH = WINTRUST_DATA_STATE_ACTION.AUTO_CACHE_FLUSH;

pub const CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE = enum(u16) {
    INT64 = 1,
    UINT64 = 2,
    STRING = 3,
    OCTET_STRING = 16,
    FQBN = 4,
    SID = 5,
    BOOLEAN = 6,
};
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_INT64 = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.INT64;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_UINT64 = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.UINT64;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_STRING = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.STRING;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_OCTET_STRING = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.OCTET_STRING;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_FQBN = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.FQBN;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_SID = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.SID;
pub const CLAIM_SECURITY_ATTRIBUTE_TYPE_BOOLEAN = CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE.BOOLEAN;

pub const WINTRUST_DATA_UNION_CHOICE = enum(u32) {
    FILE = 1,
    CATALOG = 2,
    BLOB = 3,
    SIGNER = 4,
    CERT = 5,
};
pub const WTD_CHOICE_FILE = WINTRUST_DATA_UNION_CHOICE.FILE;
pub const WTD_CHOICE_CATALOG = WINTRUST_DATA_UNION_CHOICE.CATALOG;
pub const WTD_CHOICE_BLOB = WINTRUST_DATA_UNION_CHOICE.BLOB;
pub const WTD_CHOICE_SIGNER = WINTRUST_DATA_UNION_CHOICE.SIGNER;
pub const WTD_CHOICE_CERT = WINTRUST_DATA_UNION_CHOICE.CERT;

pub const WINTRUST_DATA_REVOCATION_CHECKS = enum(u32) {
    NONE = 0,
    WHOLECHAIN = 1,
};
pub const WTD_REVOKE_NONE = WINTRUST_DATA_REVOCATION_CHECKS.NONE;
pub const WTD_REVOKE_WHOLECHAIN = WINTRUST_DATA_REVOCATION_CHECKS.WHOLECHAIN;

pub const WINTRUST_DATA_UICONTEXT = enum(u32) {
    EXECUTE = 0,
    INSTALL = 1,
};
pub const WTD_UICONTEXT_EXECUTE = WINTRUST_DATA_UICONTEXT.EXECUTE;
pub const WTD_UICONTEXT_INSTALL = WINTRUST_DATA_UICONTEXT.INSTALL;

pub const PLSA_AP_CALL_PACKAGE_UNTRUSTED = fn(
    ClientRequest: ?*?*c_void,
    // TODO: what to do with BytesParamIndex 3?
    ProtocolSubmitBuffer: ?*c_void,
    ClientBufferBase: ?*c_void,
    SubmitBufferLength: u32,
    ProtocolReturnBuffer: ?*?*c_void,
    ReturnBufferLength: ?*u32,
    ProtocolStatus: ?*i32,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;

pub const SEC_THREAD_START = fn(
    lpThreadParameter: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const TOKEN_ACCESS_MASK = enum(u32) {
    DELETE = 65536,
    READ_CONTROL = 131072,
    WRITE_DAC = 262144,
    WRITE_OWNER = 524288,
    ACCESS_SYSTEM_SECURITY = 16777216,
    ASSIGN_PRIMARY = 1,
    DUPLICATE = 2,
    IMPERSONATE = 4,
    QUERY = 8,
    QUERY_SOURCE = 16,
    ADJUST_PRIVILEGES = 32,
    ADJUST_GROUPS = 64,
    ADJUST_DEFAULT = 128,
    ADJUST_SESSIONID = 256,
    ALL_ACCESS = 983295,
    _,
    pub fn initFlags(o: struct {
        DELETE: u1 = 0,
        READ_CONTROL: u1 = 0,
        WRITE_DAC: u1 = 0,
        WRITE_OWNER: u1 = 0,
        ACCESS_SYSTEM_SECURITY: u1 = 0,
        ASSIGN_PRIMARY: u1 = 0,
        DUPLICATE: u1 = 0,
        IMPERSONATE: u1 = 0,
        QUERY: u1 = 0,
        QUERY_SOURCE: u1 = 0,
        ADJUST_PRIVILEGES: u1 = 0,
        ADJUST_GROUPS: u1 = 0,
        ADJUST_DEFAULT: u1 = 0,
        ADJUST_SESSIONID: u1 = 0,
        ALL_ACCESS: u1 = 0,
    }) TOKEN_ACCESS_MASK {
        return @intToEnum(TOKEN_ACCESS_MASK,
              (if (o.DELETE == 1) @enumToInt(TOKEN_ACCESS_MASK.DELETE) else 0)
            | (if (o.READ_CONTROL == 1) @enumToInt(TOKEN_ACCESS_MASK.READ_CONTROL) else 0)
            | (if (o.WRITE_DAC == 1) @enumToInt(TOKEN_ACCESS_MASK.WRITE_DAC) else 0)
            | (if (o.WRITE_OWNER == 1) @enumToInt(TOKEN_ACCESS_MASK.WRITE_OWNER) else 0)
            | (if (o.ACCESS_SYSTEM_SECURITY == 1) @enumToInt(TOKEN_ACCESS_MASK.ACCESS_SYSTEM_SECURITY) else 0)
            | (if (o.ASSIGN_PRIMARY == 1) @enumToInt(TOKEN_ACCESS_MASK.ASSIGN_PRIMARY) else 0)
            | (if (o.DUPLICATE == 1) @enumToInt(TOKEN_ACCESS_MASK.DUPLICATE) else 0)
            | (if (o.IMPERSONATE == 1) @enumToInt(TOKEN_ACCESS_MASK.IMPERSONATE) else 0)
            | (if (o.QUERY == 1) @enumToInt(TOKEN_ACCESS_MASK.QUERY) else 0)
            | (if (o.QUERY_SOURCE == 1) @enumToInt(TOKEN_ACCESS_MASK.QUERY_SOURCE) else 0)
            | (if (o.ADJUST_PRIVILEGES == 1) @enumToInt(TOKEN_ACCESS_MASK.ADJUST_PRIVILEGES) else 0)
            | (if (o.ADJUST_GROUPS == 1) @enumToInt(TOKEN_ACCESS_MASK.ADJUST_GROUPS) else 0)
            | (if (o.ADJUST_DEFAULT == 1) @enumToInt(TOKEN_ACCESS_MASK.ADJUST_DEFAULT) else 0)
            | (if (o.ADJUST_SESSIONID == 1) @enumToInt(TOKEN_ACCESS_MASK.ADJUST_SESSIONID) else 0)
            | (if (o.ALL_ACCESS == 1) @enumToInt(TOKEN_ACCESS_MASK.ALL_ACCESS) else 0)
        );
    }
};
pub const TOKEN_DELETE = TOKEN_ACCESS_MASK.DELETE;
pub const TOKEN_READ_CONTROL = TOKEN_ACCESS_MASK.READ_CONTROL;
pub const TOKEN_WRITE_DAC = TOKEN_ACCESS_MASK.WRITE_DAC;
pub const TOKEN_WRITE_OWNER = TOKEN_ACCESS_MASK.WRITE_OWNER;
pub const TOKEN_ACCESS_SYSTEM_SECURITY = TOKEN_ACCESS_MASK.ACCESS_SYSTEM_SECURITY;
pub const TOKEN_ASSIGN_PRIMARY = TOKEN_ACCESS_MASK.ASSIGN_PRIMARY;
pub const TOKEN_DUPLICATE = TOKEN_ACCESS_MASK.DUPLICATE;
pub const TOKEN_IMPERSONATE = TOKEN_ACCESS_MASK.IMPERSONATE;
pub const TOKEN_QUERY = TOKEN_ACCESS_MASK.QUERY;
pub const TOKEN_QUERY_SOURCE = TOKEN_ACCESS_MASK.QUERY_SOURCE;
pub const TOKEN_ADJUST_PRIVILEGES = TOKEN_ACCESS_MASK.ADJUST_PRIVILEGES;
pub const TOKEN_ADJUST_GROUPS = TOKEN_ACCESS_MASK.ADJUST_GROUPS;
pub const TOKEN_ADJUST_DEFAULT = TOKEN_ACCESS_MASK.ADJUST_DEFAULT;
pub const TOKEN_ADJUST_SESSIONID = TOKEN_ACCESS_MASK.ADJUST_SESSIONID;
pub const TOKEN_ALL_ACCESS = TOKEN_ACCESS_MASK.ALL_ACCESS;

pub const HDIAGNOSTIC_DATA_QUERY_SESSION = isize;

pub const HDIAGNOSTIC_REPORT = isize;

pub const HDIAGNOSTIC_EVENT_TAG_DESCRIPTION = isize;

pub const HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION = isize;

pub const HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION = isize;

pub const HDIAGNOSTIC_RECORD = isize;

pub const NCRYPT_DESCRIPTOR_HANDLE = isize;

pub const NCRYPT_STREAM_HANDLE = isize;

pub const SAFER_LEVEL_HANDLE = isize;

pub const SC_HANDLE = isize;

pub const GENERIC_MAPPING = extern struct {
    GenericRead: u32,
    GenericWrite: u32,
    GenericExecute: u32,
    GenericAll: u32,
};

pub const LUID_AND_ATTRIBUTES = extern struct {
    Luid: LUID,
    Attributes: TOKEN_PRIVILEGES_ATTRIBUTES,
};

pub const SID_IDENTIFIER_AUTHORITY = extern struct {
    Value: [6]u8,
};

pub const SID = extern struct {
    Revision: u8,
    SubAuthorityCount: u8,
    IdentifierAuthority: SID_IDENTIFIER_AUTHORITY,
    SubAuthority: [1]u32,
};

pub const SID_NAME_USE = enum(i32) {
    User = 1,
    Group = 2,
    Domain = 3,
    Alias = 4,
    WellKnownGroup = 5,
    DeletedAccount = 6,
    Invalid = 7,
    Unknown = 8,
    Computer = 9,
    Label = 10,
    LogonSession = 11,
};
pub const SidTypeUser = SID_NAME_USE.User;
pub const SidTypeGroup = SID_NAME_USE.Group;
pub const SidTypeDomain = SID_NAME_USE.Domain;
pub const SidTypeAlias = SID_NAME_USE.Alias;
pub const SidTypeWellKnownGroup = SID_NAME_USE.WellKnownGroup;
pub const SidTypeDeletedAccount = SID_NAME_USE.DeletedAccount;
pub const SidTypeInvalid = SID_NAME_USE.Invalid;
pub const SidTypeUnknown = SID_NAME_USE.Unknown;
pub const SidTypeComputer = SID_NAME_USE.Computer;
pub const SidTypeLabel = SID_NAME_USE.Label;
pub const SidTypeLogonSession = SID_NAME_USE.LogonSession;

pub const SID_AND_ATTRIBUTES = extern struct {
    Sid: ?PSID,
    Attributes: u32,
};

pub const SID_AND_ATTRIBUTES_HASH = extern struct {
    SidCount: u32,
    SidAttr: ?*SID_AND_ATTRIBUTES,
    Hash: [32]usize,
};

pub const WELL_KNOWN_SID_TYPE = enum(i32) {
    NullSid = 0,
    WorldSid = 1,
    LocalSid = 2,
    CreatorOwnerSid = 3,
    CreatorGroupSid = 4,
    CreatorOwnerServerSid = 5,
    CreatorGroupServerSid = 6,
    NtAuthoritySid = 7,
    DialupSid = 8,
    NetworkSid = 9,
    BatchSid = 10,
    InteractiveSid = 11,
    ServiceSid = 12,
    AnonymousSid = 13,
    ProxySid = 14,
    EnterpriseControllersSid = 15,
    SelfSid = 16,
    AuthenticatedUserSid = 17,
    RestrictedCodeSid = 18,
    TerminalServerSid = 19,
    RemoteLogonIdSid = 20,
    LogonIdsSid = 21,
    LocalSystemSid = 22,
    LocalServiceSid = 23,
    NetworkServiceSid = 24,
    BuiltinDomainSid = 25,
    BuiltinAdministratorsSid = 26,
    BuiltinUsersSid = 27,
    BuiltinGuestsSid = 28,
    BuiltinPowerUsersSid = 29,
    BuiltinAccountOperatorsSid = 30,
    BuiltinSystemOperatorsSid = 31,
    BuiltinPrintOperatorsSid = 32,
    BuiltinBackupOperatorsSid = 33,
    BuiltinReplicatorSid = 34,
    BuiltinPreWindows2000CompatibleAccessSid = 35,
    BuiltinRemoteDesktopUsersSid = 36,
    BuiltinNetworkConfigurationOperatorsSid = 37,
    AccountAdministratorSid = 38,
    AccountGuestSid = 39,
    AccountKrbtgtSid = 40,
    AccountDomainAdminsSid = 41,
    AccountDomainUsersSid = 42,
    AccountDomainGuestsSid = 43,
    AccountComputersSid = 44,
    AccountControllersSid = 45,
    AccountCertAdminsSid = 46,
    AccountSchemaAdminsSid = 47,
    AccountEnterpriseAdminsSid = 48,
    AccountPolicyAdminsSid = 49,
    AccountRasAndIasServersSid = 50,
    NTLMAuthenticationSid = 51,
    DigestAuthenticationSid = 52,
    SChannelAuthenticationSid = 53,
    ThisOrganizationSid = 54,
    OtherOrganizationSid = 55,
    BuiltinIncomingForestTrustBuildersSid = 56,
    BuiltinPerfMonitoringUsersSid = 57,
    BuiltinPerfLoggingUsersSid = 58,
    BuiltinAuthorizationAccessSid = 59,
    BuiltinTerminalServerLicenseServersSid = 60,
    BuiltinDCOMUsersSid = 61,
    BuiltinIUsersSid = 62,
    IUserSid = 63,
    BuiltinCryptoOperatorsSid = 64,
    UntrustedLabelSid = 65,
    LowLabelSid = 66,
    MediumLabelSid = 67,
    HighLabelSid = 68,
    SystemLabelSid = 69,
    WriteRestrictedCodeSid = 70,
    CreatorOwnerRightsSid = 71,
    CacheablePrincipalsGroupSid = 72,
    NonCacheablePrincipalsGroupSid = 73,
    EnterpriseReadonlyControllersSid = 74,
    AccountReadonlyControllersSid = 75,
    BuiltinEventLogReadersGroup = 76,
    NewEnterpriseReadonlyControllersSid = 77,
    BuiltinCertSvcDComAccessGroup = 78,
    MediumPlusLabelSid = 79,
    LocalLogonSid = 80,
    ConsoleLogonSid = 81,
    ThisOrganizationCertificateSid = 82,
    ApplicationPackageAuthoritySid = 83,
    BuiltinAnyPackageSid = 84,
    CapabilityInternetClientSid = 85,
    CapabilityInternetClientServerSid = 86,
    CapabilityPrivateNetworkClientServerSid = 87,
    CapabilityPicturesLibrarySid = 88,
    CapabilityVideosLibrarySid = 89,
    CapabilityMusicLibrarySid = 90,
    CapabilityDocumentsLibrarySid = 91,
    CapabilitySharedUserCertificatesSid = 92,
    CapabilityEnterpriseAuthenticationSid = 93,
    CapabilityRemovableStorageSid = 94,
    BuiltinRDSRemoteAccessServersSid = 95,
    BuiltinRDSEndpointServersSid = 96,
    BuiltinRDSManagementServersSid = 97,
    UserModeDriversSid = 98,
    BuiltinHyperVAdminsSid = 99,
    AccountCloneableControllersSid = 100,
    BuiltinAccessControlAssistanceOperatorsSid = 101,
    BuiltinRemoteManagementUsersSid = 102,
    AuthenticationAuthorityAssertedSid = 103,
    AuthenticationServiceAssertedSid = 104,
    LocalAccountSid = 105,
    LocalAccountAndAdministratorSid = 106,
    AccountProtectedUsersSid = 107,
    CapabilityAppointmentsSid = 108,
    CapabilityContactsSid = 109,
    AccountDefaultSystemManagedSid = 110,
    BuiltinDefaultSystemManagedGroupSid = 111,
    BuiltinStorageReplicaAdminsSid = 112,
    AccountKeyAdminsSid = 113,
    AccountEnterpriseKeyAdminsSid = 114,
    AuthenticationKeyTrustSid = 115,
    AuthenticationKeyPropertyMFASid = 116,
    AuthenticationKeyPropertyAttestationSid = 117,
    AuthenticationFreshKeyAuthSid = 118,
    BuiltinDeviceOwnersSid = 119,
};
pub const WinNullSid = WELL_KNOWN_SID_TYPE.NullSid;
pub const WinWorldSid = WELL_KNOWN_SID_TYPE.WorldSid;
pub const WinLocalSid = WELL_KNOWN_SID_TYPE.LocalSid;
pub const WinCreatorOwnerSid = WELL_KNOWN_SID_TYPE.CreatorOwnerSid;
pub const WinCreatorGroupSid = WELL_KNOWN_SID_TYPE.CreatorGroupSid;
pub const WinCreatorOwnerServerSid = WELL_KNOWN_SID_TYPE.CreatorOwnerServerSid;
pub const WinCreatorGroupServerSid = WELL_KNOWN_SID_TYPE.CreatorGroupServerSid;
pub const WinNtAuthoritySid = WELL_KNOWN_SID_TYPE.NtAuthoritySid;
pub const WinDialupSid = WELL_KNOWN_SID_TYPE.DialupSid;
pub const WinNetworkSid = WELL_KNOWN_SID_TYPE.NetworkSid;
pub const WinBatchSid = WELL_KNOWN_SID_TYPE.BatchSid;
pub const WinInteractiveSid = WELL_KNOWN_SID_TYPE.InteractiveSid;
pub const WinServiceSid = WELL_KNOWN_SID_TYPE.ServiceSid;
pub const WinAnonymousSid = WELL_KNOWN_SID_TYPE.AnonymousSid;
pub const WinProxySid = WELL_KNOWN_SID_TYPE.ProxySid;
pub const WinEnterpriseControllersSid = WELL_KNOWN_SID_TYPE.EnterpriseControllersSid;
pub const WinSelfSid = WELL_KNOWN_SID_TYPE.SelfSid;
pub const WinAuthenticatedUserSid = WELL_KNOWN_SID_TYPE.AuthenticatedUserSid;
pub const WinRestrictedCodeSid = WELL_KNOWN_SID_TYPE.RestrictedCodeSid;
pub const WinTerminalServerSid = WELL_KNOWN_SID_TYPE.TerminalServerSid;
pub const WinRemoteLogonIdSid = WELL_KNOWN_SID_TYPE.RemoteLogonIdSid;
pub const WinLogonIdsSid = WELL_KNOWN_SID_TYPE.LogonIdsSid;
pub const WinLocalSystemSid = WELL_KNOWN_SID_TYPE.LocalSystemSid;
pub const WinLocalServiceSid = WELL_KNOWN_SID_TYPE.LocalServiceSid;
pub const WinNetworkServiceSid = WELL_KNOWN_SID_TYPE.NetworkServiceSid;
pub const WinBuiltinDomainSid = WELL_KNOWN_SID_TYPE.BuiltinDomainSid;
pub const WinBuiltinAdministratorsSid = WELL_KNOWN_SID_TYPE.BuiltinAdministratorsSid;
pub const WinBuiltinUsersSid = WELL_KNOWN_SID_TYPE.BuiltinUsersSid;
pub const WinBuiltinGuestsSid = WELL_KNOWN_SID_TYPE.BuiltinGuestsSid;
pub const WinBuiltinPowerUsersSid = WELL_KNOWN_SID_TYPE.BuiltinPowerUsersSid;
pub const WinBuiltinAccountOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinAccountOperatorsSid;
pub const WinBuiltinSystemOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinSystemOperatorsSid;
pub const WinBuiltinPrintOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinPrintOperatorsSid;
pub const WinBuiltinBackupOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinBackupOperatorsSid;
pub const WinBuiltinReplicatorSid = WELL_KNOWN_SID_TYPE.BuiltinReplicatorSid;
pub const WinBuiltinPreWindows2000CompatibleAccessSid = WELL_KNOWN_SID_TYPE.BuiltinPreWindows2000CompatibleAccessSid;
pub const WinBuiltinRemoteDesktopUsersSid = WELL_KNOWN_SID_TYPE.BuiltinRemoteDesktopUsersSid;
pub const WinBuiltinNetworkConfigurationOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinNetworkConfigurationOperatorsSid;
pub const WinAccountAdministratorSid = WELL_KNOWN_SID_TYPE.AccountAdministratorSid;
pub const WinAccountGuestSid = WELL_KNOWN_SID_TYPE.AccountGuestSid;
pub const WinAccountKrbtgtSid = WELL_KNOWN_SID_TYPE.AccountKrbtgtSid;
pub const WinAccountDomainAdminsSid = WELL_KNOWN_SID_TYPE.AccountDomainAdminsSid;
pub const WinAccountDomainUsersSid = WELL_KNOWN_SID_TYPE.AccountDomainUsersSid;
pub const WinAccountDomainGuestsSid = WELL_KNOWN_SID_TYPE.AccountDomainGuestsSid;
pub const WinAccountComputersSid = WELL_KNOWN_SID_TYPE.AccountComputersSid;
pub const WinAccountControllersSid = WELL_KNOWN_SID_TYPE.AccountControllersSid;
pub const WinAccountCertAdminsSid = WELL_KNOWN_SID_TYPE.AccountCertAdminsSid;
pub const WinAccountSchemaAdminsSid = WELL_KNOWN_SID_TYPE.AccountSchemaAdminsSid;
pub const WinAccountEnterpriseAdminsSid = WELL_KNOWN_SID_TYPE.AccountEnterpriseAdminsSid;
pub const WinAccountPolicyAdminsSid = WELL_KNOWN_SID_TYPE.AccountPolicyAdminsSid;
pub const WinAccountRasAndIasServersSid = WELL_KNOWN_SID_TYPE.AccountRasAndIasServersSid;
pub const WinNTLMAuthenticationSid = WELL_KNOWN_SID_TYPE.NTLMAuthenticationSid;
pub const WinDigestAuthenticationSid = WELL_KNOWN_SID_TYPE.DigestAuthenticationSid;
pub const WinSChannelAuthenticationSid = WELL_KNOWN_SID_TYPE.SChannelAuthenticationSid;
pub const WinThisOrganizationSid = WELL_KNOWN_SID_TYPE.ThisOrganizationSid;
pub const WinOtherOrganizationSid = WELL_KNOWN_SID_TYPE.OtherOrganizationSid;
pub const WinBuiltinIncomingForestTrustBuildersSid = WELL_KNOWN_SID_TYPE.BuiltinIncomingForestTrustBuildersSid;
pub const WinBuiltinPerfMonitoringUsersSid = WELL_KNOWN_SID_TYPE.BuiltinPerfMonitoringUsersSid;
pub const WinBuiltinPerfLoggingUsersSid = WELL_KNOWN_SID_TYPE.BuiltinPerfLoggingUsersSid;
pub const WinBuiltinAuthorizationAccessSid = WELL_KNOWN_SID_TYPE.BuiltinAuthorizationAccessSid;
pub const WinBuiltinTerminalServerLicenseServersSid = WELL_KNOWN_SID_TYPE.BuiltinTerminalServerLicenseServersSid;
pub const WinBuiltinDCOMUsersSid = WELL_KNOWN_SID_TYPE.BuiltinDCOMUsersSid;
pub const WinBuiltinIUsersSid = WELL_KNOWN_SID_TYPE.BuiltinIUsersSid;
pub const WinIUserSid = WELL_KNOWN_SID_TYPE.IUserSid;
pub const WinBuiltinCryptoOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinCryptoOperatorsSid;
pub const WinUntrustedLabelSid = WELL_KNOWN_SID_TYPE.UntrustedLabelSid;
pub const WinLowLabelSid = WELL_KNOWN_SID_TYPE.LowLabelSid;
pub const WinMediumLabelSid = WELL_KNOWN_SID_TYPE.MediumLabelSid;
pub const WinHighLabelSid = WELL_KNOWN_SID_TYPE.HighLabelSid;
pub const WinSystemLabelSid = WELL_KNOWN_SID_TYPE.SystemLabelSid;
pub const WinWriteRestrictedCodeSid = WELL_KNOWN_SID_TYPE.WriteRestrictedCodeSid;
pub const WinCreatorOwnerRightsSid = WELL_KNOWN_SID_TYPE.CreatorOwnerRightsSid;
pub const WinCacheablePrincipalsGroupSid = WELL_KNOWN_SID_TYPE.CacheablePrincipalsGroupSid;
pub const WinNonCacheablePrincipalsGroupSid = WELL_KNOWN_SID_TYPE.NonCacheablePrincipalsGroupSid;
pub const WinEnterpriseReadonlyControllersSid = WELL_KNOWN_SID_TYPE.EnterpriseReadonlyControllersSid;
pub const WinAccountReadonlyControllersSid = WELL_KNOWN_SID_TYPE.AccountReadonlyControllersSid;
pub const WinBuiltinEventLogReadersGroup = WELL_KNOWN_SID_TYPE.BuiltinEventLogReadersGroup;
pub const WinNewEnterpriseReadonlyControllersSid = WELL_KNOWN_SID_TYPE.NewEnterpriseReadonlyControllersSid;
pub const WinBuiltinCertSvcDComAccessGroup = WELL_KNOWN_SID_TYPE.BuiltinCertSvcDComAccessGroup;
pub const WinMediumPlusLabelSid = WELL_KNOWN_SID_TYPE.MediumPlusLabelSid;
pub const WinLocalLogonSid = WELL_KNOWN_SID_TYPE.LocalLogonSid;
pub const WinConsoleLogonSid = WELL_KNOWN_SID_TYPE.ConsoleLogonSid;
pub const WinThisOrganizationCertificateSid = WELL_KNOWN_SID_TYPE.ThisOrganizationCertificateSid;
pub const WinApplicationPackageAuthoritySid = WELL_KNOWN_SID_TYPE.ApplicationPackageAuthoritySid;
pub const WinBuiltinAnyPackageSid = WELL_KNOWN_SID_TYPE.BuiltinAnyPackageSid;
pub const WinCapabilityInternetClientSid = WELL_KNOWN_SID_TYPE.CapabilityInternetClientSid;
pub const WinCapabilityInternetClientServerSid = WELL_KNOWN_SID_TYPE.CapabilityInternetClientServerSid;
pub const WinCapabilityPrivateNetworkClientServerSid = WELL_KNOWN_SID_TYPE.CapabilityPrivateNetworkClientServerSid;
pub const WinCapabilityPicturesLibrarySid = WELL_KNOWN_SID_TYPE.CapabilityPicturesLibrarySid;
pub const WinCapabilityVideosLibrarySid = WELL_KNOWN_SID_TYPE.CapabilityVideosLibrarySid;
pub const WinCapabilityMusicLibrarySid = WELL_KNOWN_SID_TYPE.CapabilityMusicLibrarySid;
pub const WinCapabilityDocumentsLibrarySid = WELL_KNOWN_SID_TYPE.CapabilityDocumentsLibrarySid;
pub const WinCapabilitySharedUserCertificatesSid = WELL_KNOWN_SID_TYPE.CapabilitySharedUserCertificatesSid;
pub const WinCapabilityEnterpriseAuthenticationSid = WELL_KNOWN_SID_TYPE.CapabilityEnterpriseAuthenticationSid;
pub const WinCapabilityRemovableStorageSid = WELL_KNOWN_SID_TYPE.CapabilityRemovableStorageSid;
pub const WinBuiltinRDSRemoteAccessServersSid = WELL_KNOWN_SID_TYPE.BuiltinRDSRemoteAccessServersSid;
pub const WinBuiltinRDSEndpointServersSid = WELL_KNOWN_SID_TYPE.BuiltinRDSEndpointServersSid;
pub const WinBuiltinRDSManagementServersSid = WELL_KNOWN_SID_TYPE.BuiltinRDSManagementServersSid;
pub const WinUserModeDriversSid = WELL_KNOWN_SID_TYPE.UserModeDriversSid;
pub const WinBuiltinHyperVAdminsSid = WELL_KNOWN_SID_TYPE.BuiltinHyperVAdminsSid;
pub const WinAccountCloneableControllersSid = WELL_KNOWN_SID_TYPE.AccountCloneableControllersSid;
pub const WinBuiltinAccessControlAssistanceOperatorsSid = WELL_KNOWN_SID_TYPE.BuiltinAccessControlAssistanceOperatorsSid;
pub const WinBuiltinRemoteManagementUsersSid = WELL_KNOWN_SID_TYPE.BuiltinRemoteManagementUsersSid;
pub const WinAuthenticationAuthorityAssertedSid = WELL_KNOWN_SID_TYPE.AuthenticationAuthorityAssertedSid;
pub const WinAuthenticationServiceAssertedSid = WELL_KNOWN_SID_TYPE.AuthenticationServiceAssertedSid;
pub const WinLocalAccountSid = WELL_KNOWN_SID_TYPE.LocalAccountSid;
pub const WinLocalAccountAndAdministratorSid = WELL_KNOWN_SID_TYPE.LocalAccountAndAdministratorSid;
pub const WinAccountProtectedUsersSid = WELL_KNOWN_SID_TYPE.AccountProtectedUsersSid;
pub const WinCapabilityAppointmentsSid = WELL_KNOWN_SID_TYPE.CapabilityAppointmentsSid;
pub const WinCapabilityContactsSid = WELL_KNOWN_SID_TYPE.CapabilityContactsSid;
pub const WinAccountDefaultSystemManagedSid = WELL_KNOWN_SID_TYPE.AccountDefaultSystemManagedSid;
pub const WinBuiltinDefaultSystemManagedGroupSid = WELL_KNOWN_SID_TYPE.BuiltinDefaultSystemManagedGroupSid;
pub const WinBuiltinStorageReplicaAdminsSid = WELL_KNOWN_SID_TYPE.BuiltinStorageReplicaAdminsSid;
pub const WinAccountKeyAdminsSid = WELL_KNOWN_SID_TYPE.AccountKeyAdminsSid;
pub const WinAccountEnterpriseKeyAdminsSid = WELL_KNOWN_SID_TYPE.AccountEnterpriseKeyAdminsSid;
pub const WinAuthenticationKeyTrustSid = WELL_KNOWN_SID_TYPE.AuthenticationKeyTrustSid;
pub const WinAuthenticationKeyPropertyMFASid = WELL_KNOWN_SID_TYPE.AuthenticationKeyPropertyMFASid;
pub const WinAuthenticationKeyPropertyAttestationSid = WELL_KNOWN_SID_TYPE.AuthenticationKeyPropertyAttestationSid;
pub const WinAuthenticationFreshKeyAuthSid = WELL_KNOWN_SID_TYPE.AuthenticationFreshKeyAuthSid;
pub const WinBuiltinDeviceOwnersSid = WELL_KNOWN_SID_TYPE.BuiltinDeviceOwnersSid;

pub const ACL = extern struct {
    AclRevision: u8,
    Sbz1: u8,
    AclSize: u16,
    AceCount: u16,
    Sbz2: u16,
};

pub const ACE_HEADER = extern struct {
    AceType: u8,
    AceFlags: u8,
    AceSize: u16,
};

pub const ACCESS_ALLOWED_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const ACCESS_DENIED_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_AUDIT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_ALARM_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_RESOURCE_ATTRIBUTE_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_SCOPED_POLICY_ID_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_MANDATORY_LABEL_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const ACCESS_ALLOWED_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const ACCESS_DENIED_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const SYSTEM_AUDIT_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const SYSTEM_ALARM_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: u32,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const ACCESS_ALLOWED_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const ACCESS_DENIED_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_AUDIT_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const SYSTEM_ALARM_CALLBACK_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    SidStart: u32,
};

pub const ACCESS_ALLOWED_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const ACCESS_DENIED_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const SYSTEM_AUDIT_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const SYSTEM_ALARM_CALLBACK_OBJECT_ACE = extern struct {
    Header: ACE_HEADER,
    Mask: u32,
    Flags: SYSTEM_AUDIT_OBJECT_ACE_FLAGS,
    ObjectType: Guid,
    InheritedObjectType: Guid,
    SidStart: u32,
};

pub const ACL_INFORMATION_CLASS = enum(i32) {
    RevisionInformation = 1,
    SizeInformation = 2,
};
pub const AclRevisionInformation = ACL_INFORMATION_CLASS.RevisionInformation;
pub const AclSizeInformation = ACL_INFORMATION_CLASS.SizeInformation;

pub const ACL_REVISION_INFORMATION = extern struct {
    AclRevision: u32,
};

pub const ACL_SIZE_INFORMATION = extern struct {
    AceCount: u32,
    AclBytesInUse: u32,
    AclBytesFree: u32,
};

pub const SECURITY_DESCRIPTOR = extern struct {
    Revision: u8,
    Sbz1: u8,
    Control: u16,
    Owner: ?PSID,
    Group: ?PSID,
    Sacl: ?*ACL,
    Dacl: ?*ACL,
};

pub const OBJECT_TYPE_LIST = extern struct {
    Level: u16,
    Sbz: u16,
    ObjectType: ?*Guid,
};

pub const AUDIT_EVENT_TYPE = enum(i32) {
    ObjectAccess = 0,
    DirectoryServiceAccess = 1,
};
pub const AuditEventObjectAccess = AUDIT_EVENT_TYPE.ObjectAccess;
pub const AuditEventDirectoryServiceAccess = AUDIT_EVENT_TYPE.DirectoryServiceAccess;

pub const PRIVILEGE_SET = extern struct {
    PrivilegeCount: u32,
    Control: u32,
    Privilege: [1]LUID_AND_ATTRIBUTES,
};

pub const SECURITY_IMPERSONATION_LEVEL = enum(i32) {
    Anonymous = 0,
    Identification = 1,
    Impersonation = 2,
    Delegation = 3,
};
pub const SecurityAnonymous = SECURITY_IMPERSONATION_LEVEL.Anonymous;
pub const SecurityIdentification = SECURITY_IMPERSONATION_LEVEL.Identification;
pub const SecurityImpersonation = SECURITY_IMPERSONATION_LEVEL.Impersonation;
pub const SecurityDelegation = SECURITY_IMPERSONATION_LEVEL.Delegation;

pub const TOKEN_TYPE = enum(i32) {
    Primary = 1,
    Impersonation = 2,
};
pub const TokenPrimary = TOKEN_TYPE.Primary;
pub const TokenImpersonation = TOKEN_TYPE.Impersonation;

pub const TOKEN_ELEVATION_TYPE = enum(i32) {
    Default = 1,
    Full = 2,
    Limited = 3,
};
pub const TokenElevationTypeDefault = TOKEN_ELEVATION_TYPE.Default;
pub const TokenElevationTypeFull = TOKEN_ELEVATION_TYPE.Full;
pub const TokenElevationTypeLimited = TOKEN_ELEVATION_TYPE.Limited;

pub const TOKEN_INFORMATION_CLASS = enum(i32) {
    TokenUser = 1,
    TokenGroups = 2,
    TokenPrivileges = 3,
    TokenOwner = 4,
    TokenPrimaryGroup = 5,
    TokenDefaultDacl = 6,
    TokenSource = 7,
    TokenType = 8,
    TokenImpersonationLevel = 9,
    TokenStatistics = 10,
    TokenRestrictedSids = 11,
    TokenSessionId = 12,
    TokenGroupsAndPrivileges = 13,
    TokenSessionReference = 14,
    TokenSandBoxInert = 15,
    TokenAuditPolicy = 16,
    TokenOrigin = 17,
    TokenElevationType = 18,
    TokenLinkedToken = 19,
    TokenElevation = 20,
    TokenHasRestrictions = 21,
    TokenAccessInformation = 22,
    TokenVirtualizationAllowed = 23,
    TokenVirtualizationEnabled = 24,
    TokenIntegrityLevel = 25,
    TokenUIAccess = 26,
    TokenMandatoryPolicy = 27,
    TokenLogonSid = 28,
    TokenIsAppContainer = 29,
    TokenCapabilities = 30,
    TokenAppContainerSid = 31,
    TokenAppContainerNumber = 32,
    TokenUserClaimAttributes = 33,
    TokenDeviceClaimAttributes = 34,
    TokenRestrictedUserClaimAttributes = 35,
    TokenRestrictedDeviceClaimAttributes = 36,
    TokenDeviceGroups = 37,
    TokenRestrictedDeviceGroups = 38,
    TokenSecurityAttributes = 39,
    TokenIsRestricted = 40,
    TokenProcessTrustLevel = 41,
    TokenPrivateNameSpace = 42,
    TokenSingletonAttributes = 43,
    TokenBnoIsolation = 44,
    TokenChildProcessFlags = 45,
    TokenIsLessPrivilegedAppContainer = 46,
    TokenIsSandboxed = 47,
    TokenOriginatingProcessTrustLevel = 48,
    MaxTokenInfoClass = 49,
};
pub const TokenUser = TOKEN_INFORMATION_CLASS.TokenUser;
pub const TokenGroups = TOKEN_INFORMATION_CLASS.TokenGroups;
pub const TokenPrivileges = TOKEN_INFORMATION_CLASS.TokenPrivileges;
pub const TokenOwner = TOKEN_INFORMATION_CLASS.TokenOwner;
pub const TokenPrimaryGroup = TOKEN_INFORMATION_CLASS.TokenPrimaryGroup;
pub const TokenDefaultDacl = TOKEN_INFORMATION_CLASS.TokenDefaultDacl;
pub const TokenSource = TOKEN_INFORMATION_CLASS.TokenSource;
pub const TokenType = TOKEN_INFORMATION_CLASS.TokenType;
pub const TokenImpersonationLevel = TOKEN_INFORMATION_CLASS.TokenImpersonationLevel;
pub const TokenStatistics = TOKEN_INFORMATION_CLASS.TokenStatistics;
pub const TokenRestrictedSids = TOKEN_INFORMATION_CLASS.TokenRestrictedSids;
pub const TokenSessionId = TOKEN_INFORMATION_CLASS.TokenSessionId;
pub const TokenGroupsAndPrivileges = TOKEN_INFORMATION_CLASS.TokenGroupsAndPrivileges;
pub const TokenSessionReference = TOKEN_INFORMATION_CLASS.TokenSessionReference;
pub const TokenSandBoxInert = TOKEN_INFORMATION_CLASS.TokenSandBoxInert;
pub const TokenAuditPolicy = TOKEN_INFORMATION_CLASS.TokenAuditPolicy;
pub const TokenOrigin = TOKEN_INFORMATION_CLASS.TokenOrigin;
pub const TokenElevationType = TOKEN_INFORMATION_CLASS.TokenElevationType;
pub const TokenLinkedToken = TOKEN_INFORMATION_CLASS.TokenLinkedToken;
pub const TokenElevation = TOKEN_INFORMATION_CLASS.TokenElevation;
pub const TokenHasRestrictions = TOKEN_INFORMATION_CLASS.TokenHasRestrictions;
pub const TokenAccessInformation = TOKEN_INFORMATION_CLASS.TokenAccessInformation;
pub const TokenVirtualizationAllowed = TOKEN_INFORMATION_CLASS.TokenVirtualizationAllowed;
pub const TokenVirtualizationEnabled = TOKEN_INFORMATION_CLASS.TokenVirtualizationEnabled;
pub const TokenIntegrityLevel = TOKEN_INFORMATION_CLASS.TokenIntegrityLevel;
pub const TokenUIAccess = TOKEN_INFORMATION_CLASS.TokenUIAccess;
pub const TokenMandatoryPolicy = TOKEN_INFORMATION_CLASS.TokenMandatoryPolicy;
pub const TokenLogonSid = TOKEN_INFORMATION_CLASS.TokenLogonSid;
pub const TokenIsAppContainer = TOKEN_INFORMATION_CLASS.TokenIsAppContainer;
pub const TokenCapabilities = TOKEN_INFORMATION_CLASS.TokenCapabilities;
pub const TokenAppContainerSid = TOKEN_INFORMATION_CLASS.TokenAppContainerSid;
pub const TokenAppContainerNumber = TOKEN_INFORMATION_CLASS.TokenAppContainerNumber;
pub const TokenUserClaimAttributes = TOKEN_INFORMATION_CLASS.TokenUserClaimAttributes;
pub const TokenDeviceClaimAttributes = TOKEN_INFORMATION_CLASS.TokenDeviceClaimAttributes;
pub const TokenRestrictedUserClaimAttributes = TOKEN_INFORMATION_CLASS.TokenRestrictedUserClaimAttributes;
pub const TokenRestrictedDeviceClaimAttributes = TOKEN_INFORMATION_CLASS.TokenRestrictedDeviceClaimAttributes;
pub const TokenDeviceGroups = TOKEN_INFORMATION_CLASS.TokenDeviceGroups;
pub const TokenRestrictedDeviceGroups = TOKEN_INFORMATION_CLASS.TokenRestrictedDeviceGroups;
pub const TokenSecurityAttributes = TOKEN_INFORMATION_CLASS.TokenSecurityAttributes;
pub const TokenIsRestricted = TOKEN_INFORMATION_CLASS.TokenIsRestricted;
pub const TokenProcessTrustLevel = TOKEN_INFORMATION_CLASS.TokenProcessTrustLevel;
pub const TokenPrivateNameSpace = TOKEN_INFORMATION_CLASS.TokenPrivateNameSpace;
pub const TokenSingletonAttributes = TOKEN_INFORMATION_CLASS.TokenSingletonAttributes;
pub const TokenBnoIsolation = TOKEN_INFORMATION_CLASS.TokenBnoIsolation;
pub const TokenChildProcessFlags = TOKEN_INFORMATION_CLASS.TokenChildProcessFlags;
pub const TokenIsLessPrivilegedAppContainer = TOKEN_INFORMATION_CLASS.TokenIsLessPrivilegedAppContainer;
pub const TokenIsSandboxed = TOKEN_INFORMATION_CLASS.TokenIsSandboxed;
pub const TokenOriginatingProcessTrustLevel = TOKEN_INFORMATION_CLASS.TokenOriginatingProcessTrustLevel;
pub const MaxTokenInfoClass = TOKEN_INFORMATION_CLASS.MaxTokenInfoClass;

pub const TOKEN_USER = extern struct {
    User: SID_AND_ATTRIBUTES,
};

pub const TOKEN_GROUPS = extern struct {
    GroupCount: u32,
    Groups: [1]SID_AND_ATTRIBUTES,
};

pub const TOKEN_PRIVILEGES = extern struct {
    PrivilegeCount: u32,
    Privileges: [1]LUID_AND_ATTRIBUTES,
};

pub const TOKEN_OWNER = extern struct {
    Owner: ?PSID,
};

pub const TOKEN_PRIMARY_GROUP = extern struct {
    PrimaryGroup: ?PSID,
};

pub const TOKEN_DEFAULT_DACL = extern struct {
    DefaultDacl: ?*ACL,
};

pub const TOKEN_USER_CLAIMS = extern struct {
    UserClaims: ?*c_void,
};

pub const TOKEN_DEVICE_CLAIMS = extern struct {
    DeviceClaims: ?*c_void,
};

pub const TOKEN_GROUPS_AND_PRIVILEGES = extern struct {
    SidCount: u32,
    SidLength: u32,
    Sids: ?*SID_AND_ATTRIBUTES,
    RestrictedSidCount: u32,
    RestrictedSidLength: u32,
    RestrictedSids: ?*SID_AND_ATTRIBUTES,
    PrivilegeCount: u32,
    PrivilegeLength: u32,
    Privileges: ?*LUID_AND_ATTRIBUTES,
    AuthenticationId: LUID,
};

pub const TOKEN_LINKED_TOKEN = extern struct {
    LinkedToken: ?HANDLE,
};

pub const TOKEN_ELEVATION = extern struct {
    TokenIsElevated: u32,
};

pub const TOKEN_MANDATORY_LABEL = extern struct {
    Label: SID_AND_ATTRIBUTES,
};

pub const TOKEN_MANDATORY_POLICY = extern struct {
    Policy: TOKEN_MANDATORY_POLICY_ID,
};

pub const TOKEN_ACCESS_INFORMATION = extern struct {
    SidHash: ?*SID_AND_ATTRIBUTES_HASH,
    RestrictedSidHash: ?*SID_AND_ATTRIBUTES_HASH,
    Privileges: ?*TOKEN_PRIVILEGES,
    AuthenticationId: LUID,
    TokenType: TOKEN_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    MandatoryPolicy: TOKEN_MANDATORY_POLICY,
    Flags: u32,
    AppContainerNumber: u32,
    PackageSid: ?PSID,
    CapabilitiesHash: ?*SID_AND_ATTRIBUTES_HASH,
    TrustLevelSid: ?PSID,
    SecurityAttributes: ?*c_void,
};

pub const TOKEN_AUDIT_POLICY = extern struct {
    PerUserPolicy: [30]u8,
};

pub const TOKEN_SOURCE = extern struct {
    SourceName: [8]CHAR,
    SourceIdentifier: LUID,
};

pub const TOKEN_STATISTICS = extern struct {
    TokenId: LUID,
    AuthenticationId: LUID,
    ExpirationTime: LARGE_INTEGER,
    TokenType: TOKEN_TYPE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    DynamicCharged: u32,
    DynamicAvailable: u32,
    GroupCount: u32,
    PrivilegeCount: u32,
    ModifiedId: LUID,
};

pub const TOKEN_CONTROL = extern struct {
    TokenId: LUID,
    AuthenticationId: LUID,
    ModifiedId: LUID,
    TokenSource: TOKEN_SOURCE,
};

pub const TOKEN_ORIGIN = extern struct {
    OriginatingLogonSession: LUID,
};

pub const MANDATORY_LEVEL = enum(i32) {
    Untrusted = 0,
    Low = 1,
    Medium = 2,
    High = 3,
    System = 4,
    SecureProcess = 5,
    Count = 6,
};
pub const MandatoryLevelUntrusted = MANDATORY_LEVEL.Untrusted;
pub const MandatoryLevelLow = MANDATORY_LEVEL.Low;
pub const MandatoryLevelMedium = MANDATORY_LEVEL.Medium;
pub const MandatoryLevelHigh = MANDATORY_LEVEL.High;
pub const MandatoryLevelSystem = MANDATORY_LEVEL.System;
pub const MandatoryLevelSecureProcess = MANDATORY_LEVEL.SecureProcess;
pub const MandatoryLevelCount = MANDATORY_LEVEL.Count;

pub const TOKEN_APPCONTAINER_INFORMATION = extern struct {
    TokenAppContainer: ?PSID,
};

pub const CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE = extern struct {
    Version: u64,
    Name: ?PWSTR,
};

pub const CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE = extern struct {
    pValue: ?*c_void,
    ValueLength: u32,
};

pub const CLAIM_SECURITY_ATTRIBUTE_V1 = extern struct {
    Name: ?PWSTR,
    ValueType: CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE,
    Reserved: u16,
    Flags: u32,
    ValueCount: u32,
    Values: extern union {
        pInt64: ?*i64,
        pUint64: ?*u64,
        ppString: ?*?PWSTR,
        pFqbn: ?*CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE,
        pOctetString: ?*CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE,
    },
};

pub const CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1 = extern struct {
    Name: u32,
    ValueType: CLAIM_SECURITY_ATTRIBUTE_VALUE_TYPE,
    Reserved: u16,
    Flags: CLAIM_SECURITY_ATTRIBUTE_FLAGS,
    ValueCount: u32,
    Values: extern union {
        pInt64: [1]u32,
        pUint64: [1]u32,
        ppString: [1]u32,
        pFqbn: [1]u32,
        pOctetString: [1]u32,
    },
};

pub const CLAIM_SECURITY_ATTRIBUTES_INFORMATION = extern struct {
    Version: u16,
    Reserved: u16,
    AttributeCount: u32,
    Attribute: extern union {
        pAttributeV1: ?*CLAIM_SECURITY_ATTRIBUTE_V1,
    },
};

pub const SECURITY_QUALITY_OF_SERVICE = extern struct {
    Length: u32,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    ContextTrackingMode: u8,
    EffectiveOnly: BOOLEAN,
};

pub const SECURITY_CAPABILITIES = extern struct {
    AppContainerSid: ?PSID,
    Capabilities: ?*SID_AND_ATTRIBUTES,
    CapabilityCount: u32,
    Reserved: u32,
};

pub const QUOTA_LIMITS = extern struct {
    PagedPoolLimit: usize,
    NonPagedPoolLimit: usize,
    MinimumWorkingSetSize: usize,
    MaximumWorkingSetSize: usize,
    PagefileLimit: usize,
    TimeLimit: LARGE_INTEGER,
};

pub const SECURITY_ATTRIBUTES = extern struct {
    nLength: u32,
    lpSecurityDescriptor: ?*c_void,
    bInheritHandle: BOOL,
};

pub const CRYPTPROTECT_PROMPTSTRUCT = extern struct {
    cbSize: u32,
    dwPromptFlags: u32,
    hwndApp: ?HWND,
    szPrompt: ?[*:0]const u16,
};

pub const WLX_SC_NOTIFICATION_INFO = extern struct {
    pszCard: ?PWSTR,
    pszReader: ?PWSTR,
    pszContainer: ?PWSTR,
    pszCryptoProvider: ?PWSTR,
};

pub const WLX_PROFILE_V1_0 = extern struct {
    dwType: u32,
    pszProfile: ?PWSTR,
};

pub const WLX_PROFILE_V2_0 = extern struct {
    dwType: u32,
    pszProfile: ?PWSTR,
    pszPolicy: ?PWSTR,
    pszNetworkDefaultUserProfile: ?PWSTR,
    pszServerName: ?PWSTR,
    pszEnvironment: ?PWSTR,
};

pub const WLX_MPR_NOTIFY_INFO = extern struct {
    pszUserName: ?PWSTR,
    pszDomain: ?PWSTR,
    pszPassword: ?PWSTR,
    pszOldPassword: ?PWSTR,
};

pub const WLX_TERMINAL_SERVICES_DATA = extern struct {
    ProfilePath: [257]u16,
    HomeDir: [257]u16,
    HomeDirDrive: [4]u16,
};

pub const WLX_CLIENT_CREDENTIALS_INFO_V1_0 = extern struct {
    dwType: u32,
    pszUserName: ?PWSTR,
    pszDomain: ?PWSTR,
    pszPassword: ?PWSTR,
    fPromptForPassword: BOOL,
};

pub const WLX_CLIENT_CREDENTIALS_INFO_V2_0 = extern struct {
    dwType: u32,
    pszUserName: ?PWSTR,
    pszDomain: ?PWSTR,
    pszPassword: ?PWSTR,
    fPromptForPassword: BOOL,
    fDisconnectOnLogonFailure: BOOL,
};

pub const WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0 = extern struct {
    dwType: u32,
    UserToken: ?HANDLE,
    LogonId: LUID,
    Quotas: QUOTA_LIMITS,
    UserName: ?PWSTR,
    Domain: ?PWSTR,
    LogonTime: LARGE_INTEGER,
    SmartCardLogon: BOOL,
    ProfileLength: u32,
    MessageType: u32,
    LogonCount: u16,
    BadPasswordCount: u16,
    ProfileLogonTime: LARGE_INTEGER,
    LogoffTime: LARGE_INTEGER,
    KickOffTime: LARGE_INTEGER,
    PasswordLastSet: LARGE_INTEGER,
    PasswordCanChange: LARGE_INTEGER,
    PasswordMustChange: LARGE_INTEGER,
    LogonScript: ?PWSTR,
    HomeDirectory: ?PWSTR,
    FullName: ?PWSTR,
    ProfilePath: ?PWSTR,
    HomeDirectoryDrive: ?PWSTR,
    LogonServer: ?PWSTR,
    UserFlags: u32,
    PrivateDataLen: u32,
    PrivateData: ?*u8,
};

pub const WLX_DESKTOP = extern struct {
    Size: u32,
    Flags: u32,
    hDesktop: ?HDESK,
    pszDesktopName: ?PWSTR,
};

pub const PWLX_USE_CTRL_ALT_DEL = fn(
    hWlx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWLX_SET_CONTEXT_POINTER = fn(
    hWlx: ?HANDLE,
    pWlxContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWLX_SAS_NOTIFY = fn(
    hWlx: ?HANDLE,
    dwSasType: u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWLX_SET_TIMEOUT = fn(
    hWlx: ?HANDLE,
    Timeout: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_ASSIGN_SHELL_PROTECTION = fn(
    hWlx: ?HANDLE,
    hToken: ?HANDLE,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_MESSAGE_BOX = fn(
    hWlx: ?HANDLE,
    hwndOwner: ?HWND,
    lpszText: ?PWSTR,
    lpszTitle: ?PWSTR,
    fuStyle: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_DIALOG_BOX = fn(
    hWlx: ?HANDLE,
    hInst: ?HANDLE,
    lpszTemplate: ?PWSTR,
    hwndOwner: ?HWND,
    dlgprc: ?DLGPROC,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_DIALOG_BOX_INDIRECT = fn(
    hWlx: ?HANDLE,
    hInst: ?HANDLE,
    hDialogTemplate: ?*DLGTEMPLATE,
    hwndOwner: ?HWND,
    dlgprc: ?DLGPROC,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_DIALOG_BOX_PARAM = fn(
    hWlx: ?HANDLE,
    hInst: ?HANDLE,
    lpszTemplate: ?PWSTR,
    hwndOwner: ?HWND,
    dlgprc: ?DLGPROC,
    dwInitParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_DIALOG_BOX_INDIRECT_PARAM = fn(
    hWlx: ?HANDLE,
    hInst: ?HANDLE,
    hDialogTemplate: ?*DLGTEMPLATE,
    hwndOwner: ?HWND,
    dlgprc: ?DLGPROC,
    dwInitParam: LPARAM,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_SWITCH_DESKTOP_TO_USER = fn(
    hWlx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_SWITCH_DESKTOP_TO_WINLOGON = fn(
    hWlx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_CHANGE_PASSWORD_NOTIFY = fn(
    hWlx: ?HANDLE,
    pMprInfo: ?*WLX_MPR_NOTIFY_INFO,
    dwChangeInfo: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_GET_SOURCE_DESKTOP = fn(
    hWlx: ?HANDLE,
    ppDesktop: ?*?*WLX_DESKTOP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_SET_RETURN_DESKTOP = fn(
    hWlx: ?HANDLE,
    pDesktop: ?*WLX_DESKTOP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_CREATE_USER_DESKTOP = fn(
    hWlx: ?HANDLE,
    hToken: ?HANDLE,
    Flags: u32,
    pszDesktopName: ?PWSTR,
    ppDesktop: ?*?*WLX_DESKTOP,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_CHANGE_PASSWORD_NOTIFY_EX = fn(
    hWlx: ?HANDLE,
    pMprInfo: ?*WLX_MPR_NOTIFY_INFO,
    dwChangeInfo: u32,
    ProviderName: ?PWSTR,
    Reserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PWLX_CLOSE_USER_DESKTOP = fn(
    hWlx: ?HANDLE,
    pDesktop: ?*WLX_DESKTOP,
    hToken: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_SET_OPTION = fn(
    hWlx: ?HANDLE,
    Option: u32,
    Value: usize,
    OldValue: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_GET_OPTION = fn(
    hWlx: ?HANDLE,
    Option: u32,
    Value: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_WIN31_MIGRATE = fn(
    hWlx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWLX_QUERY_CLIENT_CREDENTIALS = fn(
    pCred: ?*WLX_CLIENT_CREDENTIALS_INFO_V1_0,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_QUERY_IC_CREDENTIALS = fn(
    pCred: ?*WLX_CLIENT_CREDENTIALS_INFO_V1_0,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_QUERY_TS_LOGON_CREDENTIALS = fn(
    pCred: ?*WLX_CLIENT_CREDENTIALS_INFO_V2_0,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_DISCONNECT = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PWLX_QUERY_TERMINAL_SERVICES_DATA = fn(
    hWlx: ?HANDLE,
    pTSData: ?*WLX_TERMINAL_SERVICES_DATA,
    UserName: ?PWSTR,
    Domain: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWLX_QUERY_CONSOLESWITCH_CREDENTIALS = fn(
    pCred: ?*WLX_CONSOLESWITCH_CREDENTIALS_INFO_V1_0,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WLX_DISPATCH_VERSION_1_0 = extern struct {
    WlxUseCtrlAltDel: ?PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: ?PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: ?PWLX_SAS_NOTIFY,
    WlxSetTimeout: ?PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: ?PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: ?PWLX_MESSAGE_BOX,
    WlxDialogBox: ?PWLX_DIALOG_BOX,
    WlxDialogBoxParam: ?PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: ?PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: ?PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: ?PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: ?PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: ?PWLX_CHANGE_PASSWORD_NOTIFY,
};

pub const WLX_DISPATCH_VERSION_1_1 = extern struct {
    WlxUseCtrlAltDel: ?PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: ?PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: ?PWLX_SAS_NOTIFY,
    WlxSetTimeout: ?PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: ?PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: ?PWLX_MESSAGE_BOX,
    WlxDialogBox: ?PWLX_DIALOG_BOX,
    WlxDialogBoxParam: ?PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: ?PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: ?PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: ?PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: ?PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: ?PWLX_CHANGE_PASSWORD_NOTIFY,
    WlxGetSourceDesktop: ?PWLX_GET_SOURCE_DESKTOP,
    WlxSetReturnDesktop: ?PWLX_SET_RETURN_DESKTOP,
    WlxCreateUserDesktop: ?PWLX_CREATE_USER_DESKTOP,
    WlxChangePasswordNotifyEx: ?PWLX_CHANGE_PASSWORD_NOTIFY_EX,
};

pub const WLX_DISPATCH_VERSION_1_2 = extern struct {
    WlxUseCtrlAltDel: ?PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: ?PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: ?PWLX_SAS_NOTIFY,
    WlxSetTimeout: ?PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: ?PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: ?PWLX_MESSAGE_BOX,
    WlxDialogBox: ?PWLX_DIALOG_BOX,
    WlxDialogBoxParam: ?PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: ?PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: ?PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: ?PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: ?PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: ?PWLX_CHANGE_PASSWORD_NOTIFY,
    WlxGetSourceDesktop: ?PWLX_GET_SOURCE_DESKTOP,
    WlxSetReturnDesktop: ?PWLX_SET_RETURN_DESKTOP,
    WlxCreateUserDesktop: ?PWLX_CREATE_USER_DESKTOP,
    WlxChangePasswordNotifyEx: ?PWLX_CHANGE_PASSWORD_NOTIFY_EX,
    WlxCloseUserDesktop: ?PWLX_CLOSE_USER_DESKTOP,
};

pub const WLX_DISPATCH_VERSION_1_3 = extern struct {
    WlxUseCtrlAltDel: ?PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: ?PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: ?PWLX_SAS_NOTIFY,
    WlxSetTimeout: ?PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: ?PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: ?PWLX_MESSAGE_BOX,
    WlxDialogBox: ?PWLX_DIALOG_BOX,
    WlxDialogBoxParam: ?PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: ?PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: ?PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: ?PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: ?PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: ?PWLX_CHANGE_PASSWORD_NOTIFY,
    WlxGetSourceDesktop: ?PWLX_GET_SOURCE_DESKTOP,
    WlxSetReturnDesktop: ?PWLX_SET_RETURN_DESKTOP,
    WlxCreateUserDesktop: ?PWLX_CREATE_USER_DESKTOP,
    WlxChangePasswordNotifyEx: ?PWLX_CHANGE_PASSWORD_NOTIFY_EX,
    WlxCloseUserDesktop: ?PWLX_CLOSE_USER_DESKTOP,
    WlxSetOption: ?PWLX_SET_OPTION,
    WlxGetOption: ?PWLX_GET_OPTION,
    WlxWin31Migrate: ?PWLX_WIN31_MIGRATE,
    WlxQueryClientCredentials: ?PWLX_QUERY_CLIENT_CREDENTIALS,
    WlxQueryInetConnectorCredentials: ?PWLX_QUERY_IC_CREDENTIALS,
    WlxDisconnect: ?PWLX_DISCONNECT,
    WlxQueryTerminalServicesData: ?PWLX_QUERY_TERMINAL_SERVICES_DATA,
};

pub const WLX_DISPATCH_VERSION_1_4 = extern struct {
    WlxUseCtrlAltDel: ?PWLX_USE_CTRL_ALT_DEL,
    WlxSetContextPointer: ?PWLX_SET_CONTEXT_POINTER,
    WlxSasNotify: ?PWLX_SAS_NOTIFY,
    WlxSetTimeout: ?PWLX_SET_TIMEOUT,
    WlxAssignShellProtection: ?PWLX_ASSIGN_SHELL_PROTECTION,
    WlxMessageBox: ?PWLX_MESSAGE_BOX,
    WlxDialogBox: ?PWLX_DIALOG_BOX,
    WlxDialogBoxParam: ?PWLX_DIALOG_BOX_PARAM,
    WlxDialogBoxIndirect: ?PWLX_DIALOG_BOX_INDIRECT,
    WlxDialogBoxIndirectParam: ?PWLX_DIALOG_BOX_INDIRECT_PARAM,
    WlxSwitchDesktopToUser: ?PWLX_SWITCH_DESKTOP_TO_USER,
    WlxSwitchDesktopToWinlogon: ?PWLX_SWITCH_DESKTOP_TO_WINLOGON,
    WlxChangePasswordNotify: ?PWLX_CHANGE_PASSWORD_NOTIFY,
    WlxGetSourceDesktop: ?PWLX_GET_SOURCE_DESKTOP,
    WlxSetReturnDesktop: ?PWLX_SET_RETURN_DESKTOP,
    WlxCreateUserDesktop: ?PWLX_CREATE_USER_DESKTOP,
    WlxChangePasswordNotifyEx: ?PWLX_CHANGE_PASSWORD_NOTIFY_EX,
    WlxCloseUserDesktop: ?PWLX_CLOSE_USER_DESKTOP,
    WlxSetOption: ?PWLX_SET_OPTION,
    WlxGetOption: ?PWLX_GET_OPTION,
    WlxWin31Migrate: ?PWLX_WIN31_MIGRATE,
    WlxQueryClientCredentials: ?PWLX_QUERY_CLIENT_CREDENTIALS,
    WlxQueryInetConnectorCredentials: ?PWLX_QUERY_IC_CREDENTIALS,
    WlxDisconnect: ?PWLX_DISCONNECT,
    WlxQueryTerminalServicesData: ?PWLX_QUERY_TERMINAL_SERVICES_DATA,
    WlxQueryConsoleSwitchCredentials: ?PWLX_QUERY_CONSOLESWITCH_CREDENTIALS,
    WlxQueryTsLogonCredentials: ?PWLX_QUERY_TS_LOGON_CREDENTIALS,
};

pub const PFNMSGECALLBACK = fn(
    bVerbose: BOOL,
    lpMessage: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WLX_NOTIFICATION_INFO = extern struct {
    Size: u32,
    Flags: u32,
    UserName: ?PWSTR,
    Domain: ?PWSTR,
    WindowStation: ?PWSTR,
    hToken: ?HANDLE,
    hDesktop: ?HDESK,
    pStatusCallback: ?PFNMSGECALLBACK,
};

const CLSID_TpmVirtualSmartCardManager_Value = @import("zig.zig").Guid.initString("16a18e86-7f6e-4c20-ad89-4ffc0db7a96a");
pub const CLSID_TpmVirtualSmartCardManager = &CLSID_TpmVirtualSmartCardManager_Value;

const CLSID_RemoteTpmVirtualSmartCardManager_Value = @import("zig.zig").Guid.initString("152ea2a8-70dc-4c59-8b2a-32aa3ca0dcac");
pub const CLSID_RemoteTpmVirtualSmartCardManager = &CLSID_RemoteTpmVirtualSmartCardManager_Value;

pub const TPMVSC_ATTESTATION_TYPE = enum(i32) {
    NONE = 0,
    AIK_ONLY = 1,
    AIK_AND_CERTIFICATE = 2,
};
pub const TPMVSC_ATTESTATION_NONE = TPMVSC_ATTESTATION_TYPE.NONE;
pub const TPMVSC_ATTESTATION_AIK_ONLY = TPMVSC_ATTESTATION_TYPE.AIK_ONLY;
pub const TPMVSC_ATTESTATION_AIK_AND_CERTIFICATE = TPMVSC_ATTESTATION_TYPE.AIK_AND_CERTIFICATE;

pub const TPMVSCMGR_STATUS = enum(i32) {
    VTPMSMARTCARD_INITIALIZING = 0,
    VTPMSMARTCARD_CREATING = 1,
    VTPMSMARTCARD_DESTROYING = 2,
    VGIDSSIMULATOR_INITIALIZING = 3,
    VGIDSSIMULATOR_CREATING = 4,
    VGIDSSIMULATOR_DESTROYING = 5,
    VREADER_INITIALIZING = 6,
    VREADER_CREATING = 7,
    VREADER_DESTROYING = 8,
    GENERATE_WAITING = 9,
    GENERATE_AUTHENTICATING = 10,
    GENERATE_RUNNING = 11,
    CARD_CREATED = 12,
    CARD_DESTROYED = 13,
};
pub const TPMVSCMGR_STATUS_VTPMSMARTCARD_INITIALIZING = TPMVSCMGR_STATUS.VTPMSMARTCARD_INITIALIZING;
pub const TPMVSCMGR_STATUS_VTPMSMARTCARD_CREATING = TPMVSCMGR_STATUS.VTPMSMARTCARD_CREATING;
pub const TPMVSCMGR_STATUS_VTPMSMARTCARD_DESTROYING = TPMVSCMGR_STATUS.VTPMSMARTCARD_DESTROYING;
pub const TPMVSCMGR_STATUS_VGIDSSIMULATOR_INITIALIZING = TPMVSCMGR_STATUS.VGIDSSIMULATOR_INITIALIZING;
pub const TPMVSCMGR_STATUS_VGIDSSIMULATOR_CREATING = TPMVSCMGR_STATUS.VGIDSSIMULATOR_CREATING;
pub const TPMVSCMGR_STATUS_VGIDSSIMULATOR_DESTROYING = TPMVSCMGR_STATUS.VGIDSSIMULATOR_DESTROYING;
pub const TPMVSCMGR_STATUS_VREADER_INITIALIZING = TPMVSCMGR_STATUS.VREADER_INITIALIZING;
pub const TPMVSCMGR_STATUS_VREADER_CREATING = TPMVSCMGR_STATUS.VREADER_CREATING;
pub const TPMVSCMGR_STATUS_VREADER_DESTROYING = TPMVSCMGR_STATUS.VREADER_DESTROYING;
pub const TPMVSCMGR_STATUS_GENERATE_WAITING = TPMVSCMGR_STATUS.GENERATE_WAITING;
pub const TPMVSCMGR_STATUS_GENERATE_AUTHENTICATING = TPMVSCMGR_STATUS.GENERATE_AUTHENTICATING;
pub const TPMVSCMGR_STATUS_GENERATE_RUNNING = TPMVSCMGR_STATUS.GENERATE_RUNNING;
pub const TPMVSCMGR_STATUS_CARD_CREATED = TPMVSCMGR_STATUS.CARD_CREATED;
pub const TPMVSCMGR_STATUS_CARD_DESTROYED = TPMVSCMGR_STATUS.CARD_DESTROYED;

pub const TPMVSCMGR_ERROR = enum(i32) {
    IMPERSONATION = 0,
    PIN_COMPLEXITY = 1,
    READER_COUNT_LIMIT = 2,
    TERMINAL_SERVICES_SESSION = 3,
    VTPMSMARTCARD_INITIALIZE = 4,
    VTPMSMARTCARD_CREATE = 5,
    VTPMSMARTCARD_DESTROY = 6,
    VGIDSSIMULATOR_INITIALIZE = 7,
    VGIDSSIMULATOR_CREATE = 8,
    VGIDSSIMULATOR_DESTROY = 9,
    VGIDSSIMULATOR_WRITE_PROPERTY = 10,
    VGIDSSIMULATOR_READ_PROPERTY = 11,
    VREADER_INITIALIZE = 12,
    VREADER_CREATE = 13,
    VREADER_DESTROY = 14,
    GENERATE_LOCATE_READER = 15,
    GENERATE_FILESYSTEM = 16,
    CARD_CREATE = 17,
    CARD_DESTROY = 18,
};
pub const TPMVSCMGR_ERROR_IMPERSONATION = TPMVSCMGR_ERROR.IMPERSONATION;
pub const TPMVSCMGR_ERROR_PIN_COMPLEXITY = TPMVSCMGR_ERROR.PIN_COMPLEXITY;
pub const TPMVSCMGR_ERROR_READER_COUNT_LIMIT = TPMVSCMGR_ERROR.READER_COUNT_LIMIT;
pub const TPMVSCMGR_ERROR_TERMINAL_SERVICES_SESSION = TPMVSCMGR_ERROR.TERMINAL_SERVICES_SESSION;
pub const TPMVSCMGR_ERROR_VTPMSMARTCARD_INITIALIZE = TPMVSCMGR_ERROR.VTPMSMARTCARD_INITIALIZE;
pub const TPMVSCMGR_ERROR_VTPMSMARTCARD_CREATE = TPMVSCMGR_ERROR.VTPMSMARTCARD_CREATE;
pub const TPMVSCMGR_ERROR_VTPMSMARTCARD_DESTROY = TPMVSCMGR_ERROR.VTPMSMARTCARD_DESTROY;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_INITIALIZE = TPMVSCMGR_ERROR.VGIDSSIMULATOR_INITIALIZE;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_CREATE = TPMVSCMGR_ERROR.VGIDSSIMULATOR_CREATE;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_DESTROY = TPMVSCMGR_ERROR.VGIDSSIMULATOR_DESTROY;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_WRITE_PROPERTY = TPMVSCMGR_ERROR.VGIDSSIMULATOR_WRITE_PROPERTY;
pub const TPMVSCMGR_ERROR_VGIDSSIMULATOR_READ_PROPERTY = TPMVSCMGR_ERROR.VGIDSSIMULATOR_READ_PROPERTY;
pub const TPMVSCMGR_ERROR_VREADER_INITIALIZE = TPMVSCMGR_ERROR.VREADER_INITIALIZE;
pub const TPMVSCMGR_ERROR_VREADER_CREATE = TPMVSCMGR_ERROR.VREADER_CREATE;
pub const TPMVSCMGR_ERROR_VREADER_DESTROY = TPMVSCMGR_ERROR.VREADER_DESTROY;
pub const TPMVSCMGR_ERROR_GENERATE_LOCATE_READER = TPMVSCMGR_ERROR.GENERATE_LOCATE_READER;
pub const TPMVSCMGR_ERROR_GENERATE_FILESYSTEM = TPMVSCMGR_ERROR.GENERATE_FILESYSTEM;
pub const TPMVSCMGR_ERROR_CARD_CREATE = TPMVSCMGR_ERROR.CARD_CREATE;
pub const TPMVSCMGR_ERROR_CARD_DESTROY = TPMVSCMGR_ERROR.CARD_DESTROY;

// TODO: this type is limited to platform 'windows8.0'
const IID_ITpmVirtualSmartCardManagerStatusCallback_Value = @import("zig.zig").Guid.initString("1a1bb35f-abb8-451c-a1ae-33d98f1bef4a");
pub const IID_ITpmVirtualSmartCardManagerStatusCallback = &IID_ITpmVirtualSmartCardManagerStatusCallback_Value;
pub const ITpmVirtualSmartCardManagerStatusCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportProgress: fn(
            self: *const ITpmVirtualSmartCardManagerStatusCallback,
            Status: TPMVSCMGR_STATUS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReportError: fn(
            self: *const ITpmVirtualSmartCardManagerStatusCallback,
            Error: TPMVSCMGR_ERROR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManagerStatusCallback_ReportProgress(self: *const T, Status: TPMVSCMGR_STATUS) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManagerStatusCallback.VTable, self.vtable).ReportProgress(@ptrCast(*const ITpmVirtualSmartCardManagerStatusCallback, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManagerStatusCallback_ReportError(self: *const T, Error: TPMVSCMGR_ERROR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManagerStatusCallback.VTable, self.vtable).ReportError(@ptrCast(*const ITpmVirtualSmartCardManagerStatusCallback, self), Error);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_ITpmVirtualSmartCardManager_Value = @import("zig.zig").Guid.initString("112b1dff-d9dc-41f7-869f-d67fee7cb591");
pub const IID_ITpmVirtualSmartCardManager = &IID_ITpmVirtualSmartCardManager_Value;
pub const ITpmVirtualSmartCardManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateVirtualSmartCard: fn(
            self: *const ITpmVirtualSmartCardManager,
            pszFriendlyName: ?[*:0]const u16,
            bAdminAlgId: u8,
            pbAdminKey: [*:0]const u8,
            cbAdminKey: u32,
            pbAdminKcv: [*:0]const u8,
            cbAdminKcv: u32,
            pbPuk: [*:0]const u8,
            cbPuk: u32,
            pbPin: [*:0]const u8,
            cbPin: u32,
            fGenerate: BOOL,
            pStatusCallback: ?*ITpmVirtualSmartCardManagerStatusCallback,
            ppszInstanceId: ?*?PWSTR,
            pfNeedReboot: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyVirtualSmartCard: fn(
            self: *const ITpmVirtualSmartCardManager,
            pszInstanceId: ?[*:0]const u16,
            pStatusCallback: ?*ITpmVirtualSmartCardManagerStatusCallback,
            pfNeedReboot: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManager_CreateVirtualSmartCard(self: *const T, pszFriendlyName: ?[*:0]const u16, bAdminAlgId: u8, pbAdminKey: [*:0]const u8, cbAdminKey: u32, pbAdminKcv: [*:0]const u8, cbAdminKcv: u32, pbPuk: [*:0]const u8, cbPuk: u32, pbPin: [*:0]const u8, cbPin: u32, fGenerate: BOOL, pStatusCallback: ?*ITpmVirtualSmartCardManagerStatusCallback, ppszInstanceId: ?*?PWSTR, pfNeedReboot: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManager.VTable, self.vtable).CreateVirtualSmartCard(@ptrCast(*const ITpmVirtualSmartCardManager, self), pszFriendlyName, bAdminAlgId, pbAdminKey, cbAdminKey, pbAdminKcv, cbAdminKcv, pbPuk, cbPuk, pbPin, cbPin, fGenerate, pStatusCallback, ppszInstanceId, pfNeedReboot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManager_DestroyVirtualSmartCard(self: *const T, pszInstanceId: ?[*:0]const u16, pStatusCallback: ?*ITpmVirtualSmartCardManagerStatusCallback, pfNeedReboot: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManager.VTable, self.vtable).DestroyVirtualSmartCard(@ptrCast(*const ITpmVirtualSmartCardManager, self), pszInstanceId, pStatusCallback, pfNeedReboot);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITpmVirtualSmartCardManager2_Value = @import("zig.zig").Guid.initString("fdf8a2b9-02de-47f4-bc26-aa85ab5e5267");
pub const IID_ITpmVirtualSmartCardManager2 = &IID_ITpmVirtualSmartCardManager2_Value;
pub const ITpmVirtualSmartCardManager2 = extern struct {
    pub const VTable = extern struct {
        base: ITpmVirtualSmartCardManager.VTable,
        CreateVirtualSmartCardWithPinPolicy: fn(
            self: *const ITpmVirtualSmartCardManager2,
            pszFriendlyName: ?[*:0]const u16,
            bAdminAlgId: u8,
            pbAdminKey: [*:0]const u8,
            cbAdminKey: u32,
            pbAdminKcv: [*:0]const u8,
            cbAdminKcv: u32,
            pbPuk: [*:0]const u8,
            cbPuk: u32,
            pbPin: [*:0]const u8,
            cbPin: u32,
            pbPinPolicy: [*:0]const u8,
            cbPinPolicy: u32,
            fGenerate: BOOL,
            pStatusCallback: ?*ITpmVirtualSmartCardManagerStatusCallback,
            ppszInstanceId: ?*?PWSTR,
            pfNeedReboot: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITpmVirtualSmartCardManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManager2_CreateVirtualSmartCardWithPinPolicy(self: *const T, pszFriendlyName: ?[*:0]const u16, bAdminAlgId: u8, pbAdminKey: [*:0]const u8, cbAdminKey: u32, pbAdminKcv: [*:0]const u8, cbAdminKcv: u32, pbPuk: [*:0]const u8, cbPuk: u32, pbPin: [*:0]const u8, cbPin: u32, pbPinPolicy: [*:0]const u8, cbPinPolicy: u32, fGenerate: BOOL, pStatusCallback: ?*ITpmVirtualSmartCardManagerStatusCallback, ppszInstanceId: ?*?PWSTR, pfNeedReboot: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManager2.VTable, self.vtable).CreateVirtualSmartCardWithPinPolicy(@ptrCast(*const ITpmVirtualSmartCardManager2, self), pszFriendlyName, bAdminAlgId, pbAdminKey, cbAdminKey, pbAdminKcv, cbAdminKcv, pbPuk, cbPuk, pbPin, cbPin, pbPinPolicy, cbPinPolicy, fGenerate, pStatusCallback, ppszInstanceId, pfNeedReboot);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITpmVirtualSmartCardManager3_Value = @import("zig.zig").Guid.initString("3c745a97-f375-4150-be17-5950f694c699");
pub const IID_ITpmVirtualSmartCardManager3 = &IID_ITpmVirtualSmartCardManager3_Value;
pub const ITpmVirtualSmartCardManager3 = extern struct {
    pub const VTable = extern struct {
        base: ITpmVirtualSmartCardManager2.VTable,
        CreateVirtualSmartCardWithAttestation: fn(
            self: *const ITpmVirtualSmartCardManager3,
            pszFriendlyName: ?[*:0]const u16,
            bAdminAlgId: u8,
            pbAdminKey: [*:0]const u8,
            cbAdminKey: u32,
            pbAdminKcv: [*:0]const u8,
            cbAdminKcv: u32,
            pbPuk: [*:0]const u8,
            cbPuk: u32,
            pbPin: [*:0]const u8,
            cbPin: u32,
            pbPinPolicy: [*:0]const u8,
            cbPinPolicy: u32,
            attestationType: TPMVSC_ATTESTATION_TYPE,
            fGenerate: BOOL,
            pStatusCallback: ?*ITpmVirtualSmartCardManagerStatusCallback,
            ppszInstanceId: ?*?PWSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace ITpmVirtualSmartCardManager2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITpmVirtualSmartCardManager3_CreateVirtualSmartCardWithAttestation(self: *const T, pszFriendlyName: ?[*:0]const u16, bAdminAlgId: u8, pbAdminKey: [*:0]const u8, cbAdminKey: u32, pbAdminKcv: [*:0]const u8, cbAdminKcv: u32, pbPuk: [*:0]const u8, cbPuk: u32, pbPin: [*:0]const u8, cbPin: u32, pbPinPolicy: [*:0]const u8, cbPinPolicy: u32, attestationType: TPMVSC_ATTESTATION_TYPE, fGenerate: BOOL, pStatusCallback: ?*ITpmVirtualSmartCardManagerStatusCallback, ppszInstanceId: ?*?PWSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITpmVirtualSmartCardManager3.VTable, self.vtable).CreateVirtualSmartCardWithAttestation(@ptrCast(*const ITpmVirtualSmartCardManager3, self), pszFriendlyName, bAdminAlgId, pbAdminKey, cbAdminKey, pbAdminKcv, cbAdminKcv, pbPuk, cbPuk, pbPin, cbPin, pbPinPolicy, cbPinPolicy, attestationType, fGenerate, pStatusCallback, ppszInstanceId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PFNREADOBJECTSECURITY = fn(
    param0: ?[*:0]const u16,
    param1: u32,
    param2: ?*?*SECURITY_DESCRIPTOR,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNWRITEOBJECTSECURITY = fn(
    param0: ?[*:0]const u16,
    param1: u32,
    param2: ?*SECURITY_DESCRIPTOR,
    param3: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDSCREATEISECINFO = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: u32,
    param3: ?*?*ISecurityInformation,
    param4: ?PFNREADOBJECTSECURITY,
    param5: ?PFNWRITEOBJECTSECURITY,
    param6: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDSCREATEISECINFOEX = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: ?[*:0]const u16,
    param4: ?[*:0]const u16,
    param5: u32,
    param6: ?*?*ISecurityInformation,
    param7: ?PFNREADOBJECTSECURITY,
    param8: ?PFNWRITEOBJECTSECURITY,
    param9: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDSCREATESECPAGE = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: u32,
    param3: ?*?HPROPSHEETPAGE,
    param4: ?PFNREADOBJECTSECURITY,
    param5: ?PFNWRITEOBJECTSECURITY,
    param6: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFNDSEDITSECURITY = fn(
    param0: ?HWND,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: u32,
    param4: ?[*:0]const u16,
    param5: ?PFNREADOBJECTSECURITY,
    param6: ?PFNWRITEOBJECTSECURITY,
    param7: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

const CLSID_CCertSrvSetupKeyInformation_Value = @import("zig.zig").Guid.initString("38373906-5433-4633-b0fb-29b7e78262e1");
pub const CLSID_CCertSrvSetupKeyInformation = &CLSID_CCertSrvSetupKeyInformation_Value;

const CLSID_CCertSrvSetup_Value = @import("zig.zig").Guid.initString("961f180f-f55c-413d-a9b3-7d2af4d8e42f");
pub const CLSID_CCertSrvSetup = &CLSID_CCertSrvSetup_Value;

const CLSID_CMSCEPSetup_Value = @import("zig.zig").Guid.initString("aa4f5c02-8e7c-49c4-94fa-67a5cc5eadb4");
pub const CLSID_CMSCEPSetup = &CLSID_CMSCEPSetup_Value;

const CLSID_CCertificateEnrollmentServerSetup_Value = @import("zig.zig").Guid.initString("9902f3bc-88af-4cf8-ae62-7140531552b6");
pub const CLSID_CCertificateEnrollmentServerSetup = &CLSID_CCertificateEnrollmentServerSetup_Value;

const CLSID_CCertificateEnrollmentPolicyServerSetup_Value = @import("zig.zig").Guid.initString("afe2fa32-41b1-459d-a5de-49add8a72182");
pub const CLSID_CCertificateEnrollmentPolicyServerSetup = &CLSID_CCertificateEnrollmentPolicyServerSetup_Value;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformation_Value = @import("zig.zig").Guid.initString("6ba73778-36da-4c39-8a85-bcfa7d000793");
pub const IID_ICertSrvSetupKeyInformation = &IID_ICertSrvSetupKeyInformation_Value;
pub const ICertSrvSetupKeyInformation = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ProviderName: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ProviderName: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Length: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Length: fn(
            self: *const ICertSrvSetupKeyInformation,
            lVal: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Existing: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_Existing: fn(
            self: *const ICertSrvSetupKeyInformation,
            bVal: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ContainerName: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ContainerName: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HashAlgorithm: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_HashAlgorithm: fn(
            self: *const ICertSrvSetupKeyInformation,
            bstrVal: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ExistingCACertificate: fn(
            self: *const ICertSrvSetupKeyInformation,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        put_ExistingCACertificate: fn(
            self: *const ICertSrvSetupKeyInformation,
            varVal: VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ProviderName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ProviderName(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ProviderName(self: *const T, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ProviderName(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_Length(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_Length(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_Length(self: *const T, lVal: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_Length(@ptrCast(*const ICertSrvSetupKeyInformation, self), lVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_Existing(self: *const T, pVal: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_Existing(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_Existing(self: *const T, bVal: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_Existing(@ptrCast(*const ICertSrvSetupKeyInformation, self), bVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ContainerName(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ContainerName(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ContainerName(self: *const T, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ContainerName(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_HashAlgorithm(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_HashAlgorithm(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_HashAlgorithm(self: *const T, bstrVal: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_HashAlgorithm(@ptrCast(*const ICertSrvSetupKeyInformation, self), bstrVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_get_ExistingCACertificate(self: *const T, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).get_ExistingCACertificate(@ptrCast(*const ICertSrvSetupKeyInformation, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformation_put_ExistingCACertificate(self: *const T, varVal: VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformation.VTable, self.vtable).put_ExistingCACertificate(@ptrCast(*const ICertSrvSetupKeyInformation, self), varVal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetupKeyInformationCollection_Value = @import("zig.zig").Guid.initString("e65c8b00-e58f-41f9-a9ec-a28d7427c844");
pub const IID_ICertSrvSetupKeyInformationCollection = &IID_ICertSrvSetupKeyInformationCollection_Value;
pub const ICertSrvSetupKeyInformationCollection = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            ppVal: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            Index: i32,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Add: fn(
            self: *const ICertSrvSetupKeyInformationCollection,
            pIKeyInformation: ?*ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get__NewEnum(self: *const T, ppVal: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get__NewEnum(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get_Item(self: *const T, Index: i32, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get_Item(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), Index, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_get_Count(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).get_Count(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetupKeyInformationCollection_Add(self: *const T, pIKeyInformation: ?*ICertSrvSetupKeyInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetupKeyInformationCollection.VTable, self.vtable).Add(@ptrCast(*const ICertSrvSetupKeyInformationCollection, self), pIKeyInformation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CASetupProperty = enum(i32) {
    INVALID = -1,
    CATYPE = 0,
    CAKEYINFORMATION = 1,
    INTERACTIVE = 2,
    CANAME = 3,
    CADSSUFFIX = 4,
    VALIDITYPERIOD = 5,
    VALIDITYPERIODUNIT = 6,
    EXPIRATIONDATE = 7,
    PRESERVEDATABASE = 8,
    DATABASEDIRECTORY = 9,
    LOGDIRECTORY = 10,
    SHAREDFOLDER = 11,
    PARENTCAMACHINE = 12,
    PARENTCANAME = 13,
    REQUESTFILE = 14,
    WEBCAMACHINE = 15,
    WEBCANAME = 16,
};
pub const ENUM_SETUPPROP_INVALID = CASetupProperty.INVALID;
pub const ENUM_SETUPPROP_CATYPE = CASetupProperty.CATYPE;
pub const ENUM_SETUPPROP_CAKEYINFORMATION = CASetupProperty.CAKEYINFORMATION;
pub const ENUM_SETUPPROP_INTERACTIVE = CASetupProperty.INTERACTIVE;
pub const ENUM_SETUPPROP_CANAME = CASetupProperty.CANAME;
pub const ENUM_SETUPPROP_CADSSUFFIX = CASetupProperty.CADSSUFFIX;
pub const ENUM_SETUPPROP_VALIDITYPERIOD = CASetupProperty.VALIDITYPERIOD;
pub const ENUM_SETUPPROP_VALIDITYPERIODUNIT = CASetupProperty.VALIDITYPERIODUNIT;
pub const ENUM_SETUPPROP_EXPIRATIONDATE = CASetupProperty.EXPIRATIONDATE;
pub const ENUM_SETUPPROP_PRESERVEDATABASE = CASetupProperty.PRESERVEDATABASE;
pub const ENUM_SETUPPROP_DATABASEDIRECTORY = CASetupProperty.DATABASEDIRECTORY;
pub const ENUM_SETUPPROP_LOGDIRECTORY = CASetupProperty.LOGDIRECTORY;
pub const ENUM_SETUPPROP_SHAREDFOLDER = CASetupProperty.SHAREDFOLDER;
pub const ENUM_SETUPPROP_PARENTCAMACHINE = CASetupProperty.PARENTCAMACHINE;
pub const ENUM_SETUPPROP_PARENTCANAME = CASetupProperty.PARENTCANAME;
pub const ENUM_SETUPPROP_REQUESTFILE = CASetupProperty.REQUESTFILE;
pub const ENUM_SETUPPROP_WEBCAMACHINE = CASetupProperty.WEBCAMACHINE;
pub const ENUM_SETUPPROP_WEBCANAME = CASetupProperty.WEBCANAME;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_ICertSrvSetup_Value = @import("zig.zig").Guid.initString("b760a1bb-4784-44c0-8f12-555f0780ff25");
pub const IID_ICertSrvSetup = &IID_ICertSrvSetup_Value;
pub const ICertSrvSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorId: fn(
            self: *const ICertSrvSetup,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_CAErrorString: fn(
            self: *const ICertSrvSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: fn(
            self: *const ICertSrvSetup,
            bServer: i16,
            bClient: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCASetupProperty: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCASetupProperty: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPropertyEditable: fn(
            self: *const ICertSrvSetup,
            propertyId: CASetupProperty,
            pbEditable: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedCATypes: fn(
            self: *const ICertSrvSetup,
            pCATypes: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: fn(
            self: *const ICertSrvSetup,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashAlgorithmList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPrivateKeyContainerList: fn(
            self: *const ICertSrvSetup,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExistingCACertificates: fn(
            self: *const ICertSrvSetup,
            ppVal: ?*?*ICertSrvSetupKeyInformationCollection,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CAImportPFX: fn(
            self: *const ICertSrvSetup,
            bstrFileName: ?BSTR,
            bstrPasswd: ?BSTR,
            bOverwriteExistingKey: i16,
            ppVal: ?*?*ICertSrvSetupKeyInformation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCADistinguishedName: fn(
            self: *const ICertSrvSetup,
            bstrCADN: ?BSTR,
            bIgnoreUnicode: i16,
            bOverwriteExistingKey: i16,
            bOverwriteExistingCAInDS: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDatabaseInformation: fn(
            self: *const ICertSrvSetup,
            bstrDBDirectory: ?BSTR,
            bstrLogDirectory: ?BSTR,
            bstrSharedFolder: ?BSTR,
            bForceOverwrite: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetParentCAInformation: fn(
            self: *const ICertSrvSetup,
            bstrCAConfiguration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetWebCAInformation: fn(
            self: *const ICertSrvSetup,
            bstrCAConfiguration: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: fn(
            self: *const ICertSrvSetup,
            bClientOnly: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: fn(
            self: *const ICertSrvSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_get_CAErrorId(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).get_CAErrorId(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_get_CAErrorString(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).get_CAErrorString(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_InitializeDefaults(self: *const T, bServer: i16, bClient: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).InitializeDefaults(@ptrCast(*const ICertSrvSetup, self), bServer, bClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetCASetupProperty(self: *const T, propertyId: CASetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetCASetupProperty(@ptrCast(*const ICertSrvSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetCASetupProperty(self: *const T, propertyId: CASetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetCASetupProperty(@ptrCast(*const ICertSrvSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_IsPropertyEditable(self: *const T, propertyId: CASetupProperty, pbEditable: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).IsPropertyEditable(@ptrCast(*const ICertSrvSetup, self), propertyId, pbEditable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetSupportedCATypes(self: *const T, pCATypes: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetSupportedCATypes(@ptrCast(*const ICertSrvSetup, self), pCATypes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetProviderNameList(self: *const T, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetProviderNameList(@ptrCast(*const ICertSrvSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetKeyLengthList(self: *const T, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetKeyLengthList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetHashAlgorithmList(self: *const T, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetHashAlgorithmList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetPrivateKeyContainerList(self: *const T, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetPrivateKeyContainerList(@ptrCast(*const ICertSrvSetup, self), bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_GetExistingCACertificates(self: *const T, ppVal: ?*?*ICertSrvSetupKeyInformationCollection) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).GetExistingCACertificates(@ptrCast(*const ICertSrvSetup, self), ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_CAImportPFX(self: *const T, bstrFileName: ?BSTR, bstrPasswd: ?BSTR, bOverwriteExistingKey: i16, ppVal: ?*?*ICertSrvSetupKeyInformation) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).CAImportPFX(@ptrCast(*const ICertSrvSetup, self), bstrFileName, bstrPasswd, bOverwriteExistingKey, ppVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetCADistinguishedName(self: *const T, bstrCADN: ?BSTR, bIgnoreUnicode: i16, bOverwriteExistingKey: i16, bOverwriteExistingCAInDS: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetCADistinguishedName(@ptrCast(*const ICertSrvSetup, self), bstrCADN, bIgnoreUnicode, bOverwriteExistingKey, bOverwriteExistingCAInDS);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetDatabaseInformation(self: *const T, bstrDBDirectory: ?BSTR, bstrLogDirectory: ?BSTR, bstrSharedFolder: ?BSTR, bForceOverwrite: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetDatabaseInformation(@ptrCast(*const ICertSrvSetup, self), bstrDBDirectory, bstrLogDirectory, bstrSharedFolder, bForceOverwrite);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetParentCAInformation(self: *const T, bstrCAConfiguration: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetParentCAInformation(@ptrCast(*const ICertSrvSetup, self), bstrCAConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_SetWebCAInformation(self: *const T, bstrCAConfiguration: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).SetWebCAInformation(@ptrCast(*const ICertSrvSetup, self), bstrCAConfiguration);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).Install(@ptrCast(*const ICertSrvSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_PreUnInstall(self: *const T, bClientOnly: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).PreUnInstall(@ptrCast(*const ICertSrvSetup, self), bClientOnly);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertSrvSetup_PostUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertSrvSetup.VTable, self.vtable).PostUnInstall(@ptrCast(*const ICertSrvSetup, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const MSCEPSetupProperty = enum(i32) {
    USELOCALSYSTEM = 0,
    USECHALLENGE = 1,
    RANAME_CN = 2,
    RANAME_EMAIL = 3,
    RANAME_COMPANY = 4,
    RANAME_DEPT = 5,
    RANAME_CITY = 6,
    RANAME_STATE = 7,
    RANAME_COUNTRY = 8,
    SIGNINGKEYINFORMATION = 9,
    EXCHANGEKEYINFORMATION = 10,
    CAINFORMATION = 11,
    MSCEPURL = 12,
    CHALLENGEURL = 13,
};
pub const ENUM_CEPSETUPPROP_USELOCALSYSTEM = MSCEPSetupProperty.USELOCALSYSTEM;
pub const ENUM_CEPSETUPPROP_USECHALLENGE = MSCEPSetupProperty.USECHALLENGE;
pub const ENUM_CEPSETUPPROP_RANAME_CN = MSCEPSetupProperty.RANAME_CN;
pub const ENUM_CEPSETUPPROP_RANAME_EMAIL = MSCEPSetupProperty.RANAME_EMAIL;
pub const ENUM_CEPSETUPPROP_RANAME_COMPANY = MSCEPSetupProperty.RANAME_COMPANY;
pub const ENUM_CEPSETUPPROP_RANAME_DEPT = MSCEPSetupProperty.RANAME_DEPT;
pub const ENUM_CEPSETUPPROP_RANAME_CITY = MSCEPSetupProperty.RANAME_CITY;
pub const ENUM_CEPSETUPPROP_RANAME_STATE = MSCEPSetupProperty.RANAME_STATE;
pub const ENUM_CEPSETUPPROP_RANAME_COUNTRY = MSCEPSetupProperty.RANAME_COUNTRY;
pub const ENUM_CEPSETUPPROP_SIGNINGKEYINFORMATION = MSCEPSetupProperty.SIGNINGKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_EXCHANGEKEYINFORMATION = MSCEPSetupProperty.EXCHANGEKEYINFORMATION;
pub const ENUM_CEPSETUPPROP_CAINFORMATION = MSCEPSetupProperty.CAINFORMATION;
pub const ENUM_CEPSETUPPROP_MSCEPURL = MSCEPSetupProperty.MSCEPURL;
pub const ENUM_CEPSETUPPROP_CHALLENGEURL = MSCEPSetupProperty.CHALLENGEURL;

// TODO: this type is limited to platform 'windowsServer2008'
const IID_IMSCEPSetup_Value = @import("zig.zig").Guid.initString("4f7761bb-9f3b-4592-9ee0-9a73259c313e");
pub const IID_IMSCEPSetup = &IID_IMSCEPSetup_Value;
pub const IMSCEPSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorId: fn(
            self: *const IMSCEPSetup,
            pVal: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_MSCEPErrorString: fn(
            self: *const IMSCEPSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeDefaults: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMSCEPSetupProperty: fn(
            self: *const IMSCEPSetup,
            propertyId: MSCEPSetupProperty,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMSCEPSetupProperty: fn(
            self: *const IMSCEPSetup,
            propertyId: MSCEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAccountInformation: fn(
            self: *const IMSCEPSetup,
            bstrUserName: ?BSTR,
            bstrPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMSCEPStoreEmpty: fn(
            self: *const IMSCEPSetup,
            pbEmpty: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProviderNameList: fn(
            self: *const IMSCEPSetup,
            bExchange: i16,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyLengthList: fn(
            self: *const IMSCEPSetup,
            bExchange: i16,
            bstrProviderName: ?BSTR,
            pVal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PreUnInstall: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PostUnInstall: fn(
            self: *const IMSCEPSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_get_MSCEPErrorId(self: *const T, pVal: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).get_MSCEPErrorId(@ptrCast(*const IMSCEPSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_get_MSCEPErrorString(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).get_MSCEPErrorString(@ptrCast(*const IMSCEPSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_InitializeDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).InitializeDefaults(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetMSCEPSetupProperty(self: *const T, propertyId: MSCEPSetupProperty, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetMSCEPSetupProperty(@ptrCast(*const IMSCEPSetup, self), propertyId, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_SetMSCEPSetupProperty(self: *const T, propertyId: MSCEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).SetMSCEPSetupProperty(@ptrCast(*const IMSCEPSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_SetAccountInformation(self: *const T, bstrUserName: ?BSTR, bstrPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).SetAccountInformation(@ptrCast(*const IMSCEPSetup, self), bstrUserName, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_IsMSCEPStoreEmpty(self: *const T, pbEmpty: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).IsMSCEPStoreEmpty(@ptrCast(*const IMSCEPSetup, self), pbEmpty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetProviderNameList(self: *const T, bExchange: i16, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetProviderNameList(@ptrCast(*const IMSCEPSetup, self), bExchange, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_GetKeyLengthList(self: *const T, bExchange: i16, bstrProviderName: ?BSTR, pVal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).GetKeyLengthList(@ptrCast(*const IMSCEPSetup, self), bExchange, bstrProviderName, pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).Install(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_PreUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).PreUnInstall(@ptrCast(*const IMSCEPSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMSCEPSetup_PostUnInstall(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMSCEPSetup.VTable, self.vtable).PostUnInstall(@ptrCast(*const IMSCEPSetup, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CESSetupProperty = enum(i32) {
    USE_IISAPPPOOLIDENTITY = 0,
    CACONFIG = 1,
    AUTHENTICATION = 2,
    SSLCERTHASH = 3,
    URL = 4,
    RENEWALONLY = 5,
    ALLOW_KEYBASED_RENEWAL = 6,
};
pub const ENUM_CESSETUPPROP_USE_IISAPPPOOLIDENTITY = CESSetupProperty.USE_IISAPPPOOLIDENTITY;
pub const ENUM_CESSETUPPROP_CACONFIG = CESSetupProperty.CACONFIG;
pub const ENUM_CESSETUPPROP_AUTHENTICATION = CESSetupProperty.AUTHENTICATION;
pub const ENUM_CESSETUPPROP_SSLCERTHASH = CESSetupProperty.SSLCERTHASH;
pub const ENUM_CESSETUPPROP_URL = CESSetupProperty.URL;
pub const ENUM_CESSETUPPROP_RENEWALONLY = CESSetupProperty.RENEWALONLY;
pub const ENUM_CESSETUPPROP_ALLOW_KEYBASED_RENEWAL = CESSetupProperty.ALLOW_KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentServerSetup_Value = @import("zig.zig").Guid.initString("70027fdb-9dd9-4921-8944-b35cb31bd2ec");
pub const IID_ICertificateEnrollmentServerSetup = &IID_ICertificateEnrollmentServerSetup_Value;
pub const ICertificateEnrollmentServerSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: fn(
            self: *const ICertificateEnrollmentServerSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: fn(
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ICertificateEnrollmentServerSetup,
            propertyId: CESSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ICertificateEnrollmentServerSetup,
            propertyId: CESSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetApplicationPoolCredentials: fn(
            self: *const ICertificateEnrollmentServerSetup,
            bstrUsername: ?BSTR,
            bstrPassword: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertificateEnrollmentServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: fn(
            self: *const ICertificateEnrollmentServerSetup,
            pCAConfig: ?*VARIANT,
            pAuthentication: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_get_ErrorString(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).get_ErrorString(@ptrCast(*const ICertificateEnrollmentServerSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_InitializeInstallDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).InitializeInstallDefaults(@ptrCast(*const ICertificateEnrollmentServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_GetProperty(self: *const T, propertyId: CESSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).GetProperty(@ptrCast(*const ICertificateEnrollmentServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_SetProperty(self: *const T, propertyId: CESSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).SetProperty(@ptrCast(*const ICertificateEnrollmentServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_SetApplicationPoolCredentials(self: *const T, bstrUsername: ?BSTR, bstrPassword: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).SetApplicationPoolCredentials(@ptrCast(*const ICertificateEnrollmentServerSetup, self), bstrUsername, bstrPassword);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).Install(@ptrCast(*const ICertificateEnrollmentServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentServerSetup_UnInstall(self: *const T, pCAConfig: ?*VARIANT, pAuthentication: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentServerSetup.VTable, self.vtable).UnInstall(@ptrCast(*const ICertificateEnrollmentServerSetup, self), pCAConfig, pAuthentication);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CEPSetupProperty = enum(i32) {
    AUTHENTICATION = 0,
    SSLCERTHASH = 1,
    URL = 2,
    KEYBASED_RENEWAL = 3,
};
pub const ENUM_CEPSETUPPROP_AUTHENTICATION = CEPSetupProperty.AUTHENTICATION;
pub const ENUM_CEPSETUPPROP_SSLCERTHASH = CEPSetupProperty.SSLCERTHASH;
pub const ENUM_CEPSETUPPROP_URL = CEPSetupProperty.URL;
pub const ENUM_CEPSETUPPROP_KEYBASED_RENEWAL = CEPSetupProperty.KEYBASED_RENEWAL;

// TODO: this type is limited to platform 'windows6.1'
const IID_ICertificateEnrollmentPolicyServerSetup_Value = @import("zig.zig").Guid.initString("859252cc-238c-4a88-b8fd-a37e7d04e68b");
pub const IID_ICertificateEnrollmentPolicyServerSetup = &IID_ICertificateEnrollmentPolicyServerSetup_Value;
pub const ICertificateEnrollmentPolicyServerSetup = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ErrorString: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            pVal: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InitializeInstallDefaults: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            propertyId: CEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            propertyId: CEPSetupProperty,
            pPropertyValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Install: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnInstall: fn(
            self: *const ICertificateEnrollmentPolicyServerSetup,
            pAuthKeyBasedRenewal: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_get_ErrorString(self: *const T, pVal: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).get_ErrorString(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), pVal);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_InitializeInstallDefaults(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).InitializeInstallDefaults(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_GetProperty(self: *const T, propertyId: CEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).GetProperty(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_SetProperty(self: *const T, propertyId: CEPSetupProperty, pPropertyValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).SetProperty(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), propertyId, pPropertyValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_Install(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).Install(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ICertificateEnrollmentPolicyServerSetup_UnInstall(self: *const T, pAuthKeyBasedRenewal: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const ICertificateEnrollmentPolicyServerSetup.VTable, self.vtable).UnInstall(@ptrCast(*const ICertificateEnrollmentPolicyServerSetup, self), pAuthKeyBasedRenewal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ENUM_PERIOD = enum(i32) {
    INVALID = -1,
    SECONDS = 0,
    MINUTES = 1,
    HOURS = 2,
    DAYS = 3,
    WEEKS = 4,
    MONTHS = 5,
    YEARS = 6,
};
pub const ENUM_PERIOD_INVALID = ENUM_PERIOD.INVALID;
pub const ENUM_PERIOD_SECONDS = ENUM_PERIOD.SECONDS;
pub const ENUM_PERIOD_MINUTES = ENUM_PERIOD.MINUTES;
pub const ENUM_PERIOD_HOURS = ENUM_PERIOD.HOURS;
pub const ENUM_PERIOD_DAYS = ENUM_PERIOD.DAYS;
pub const ENUM_PERIOD_WEEKS = ENUM_PERIOD.WEEKS;
pub const ENUM_PERIOD_MONTHS = ENUM_PERIOD.MONTHS;
pub const ENUM_PERIOD_YEARS = ENUM_PERIOD.YEARS;

pub const LLFILETIME = extern struct {
    Anonymous: extern union {
        ll: i64,
        ft: FILETIME,
    },
};

pub const SIP_SUBJECTINFO = extern struct {
    cbSize: u32,
    pgSubjectType: ?*Guid,
    hFile: ?HANDLE,
    pwsFileName: ?[*:0]const u16,
    pwsDisplayName: ?[*:0]const u16,
    dwReserved1: u32,
    dwIntVersion: u32,
    hProv: usize,
    DigestAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    dwFlags: u32,
    dwEncodingType: u32,
    dwReserved2: u32,
    fdwCAPISettings: u32,
    fdwSecuritySettings: u32,
    dwIndex: u32,
    dwUnionChoice: u32,
    Anonymous: extern union {
        psFlat: ?*MS_ADDINFO_FLAT,
        psCatMember: ?*MS_ADDINFO_CATALOGMEMBER,
        psBlob: ?*MS_ADDINFO_BLOB,
    },
    pClientData: ?*c_void,
};

pub const MS_ADDINFO_FLAT = extern struct {
    cbStruct: u32,
    pIndirectData: ?*SIP_INDIRECT_DATA,
};

pub const MS_ADDINFO_CATALOGMEMBER = extern struct {
    cbStruct: u32,
    pStore: ?*CRYPTCATSTORE,
    pMember: ?*CRYPTCATMEMBER,
};

pub const MS_ADDINFO_BLOB = extern struct {
    cbStruct: u32,
    cbMemObject: u32,
    pbMemObject: ?*u8,
    cbMemSignedMsg: u32,
    pbMemSignedMsg: ?*u8,
};

pub const SIP_CAP_SET_V2 = extern struct {
    cbSize: u32,
    dwVersion: u32,
    isMultiSign: BOOL,
    dwReserved: u32,
};

pub const SIP_CAP_SET_V3 = extern struct {
    cbSize: u32,
    dwVersion: u32,
    isMultiSign: BOOL,
    Anonymous: extern union {
        dwFlags: u32,
        dwReserved: u32,
    },
};

pub const SIP_INDIRECT_DATA = extern struct {
    Data: CRYPT_ATTRIBUTE_TYPE_VALUE,
    DigestAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Digest: CRYPTOAPI_BLOB,
};

pub const pCryptSIPGetSignedDataMsg = fn(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    pdwEncodingType: ?*u32,
    dwIndex: u32,
    pcbSignedDataMsg: ?*u32,
    pbSignedDataMsg: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPPutSignedDataMsg = fn(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    dwEncodingType: u32,
    pdwIndex: ?*u32,
    cbSignedDataMsg: u32,
    pbSignedDataMsg: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPCreateIndirectData = fn(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    pcbIndirectData: ?*u32,
    pIndirectData: ?*SIP_INDIRECT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPVerifyIndirectData = fn(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    pIndirectData: ?*SIP_INDIRECT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPRemoveSignedDataMsg = fn(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SIP_DISPATCH_INFO = extern struct {
    cbSize: u32,
    hSIP: ?HANDLE,
    pfGet: ?pCryptSIPGetSignedDataMsg,
    pfPut: ?pCryptSIPPutSignedDataMsg,
    pfCreate: ?pCryptSIPCreateIndirectData,
    pfVerify: ?pCryptSIPVerifyIndirectData,
    pfRemove: ?pCryptSIPRemoveSignedDataMsg,
};

pub const pfnIsFileSupported = fn(
    hFile: ?HANDLE,
    pgSubject: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pfnIsFileSupportedName = fn(
    pwszFileName: ?PWSTR,
    pgSubject: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SIP_ADD_NEWPROVIDER = extern struct {
    cbStruct: u32,
    pgSubject: ?*Guid,
    pwszDLLFileName: ?PWSTR,
    pwszMagicNumber: ?PWSTR,
    pwszIsFunctionName: ?PWSTR,
    pwszGetFuncName: ?PWSTR,
    pwszPutFuncName: ?PWSTR,
    pwszCreateFuncName: ?PWSTR,
    pwszVerifyFuncName: ?PWSTR,
    pwszRemoveFuncName: ?PWSTR,
    pwszIsFunctionNameFmt2: ?PWSTR,
    pwszGetCapFuncName: ?PWSTR,
};

pub const pCryptSIPGetCaps = fn(
    pSubjInfo: ?*SIP_SUBJECTINFO,
    pCaps: ?*SIP_CAP_SET_V3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const pCryptSIPGetSealedDigest = fn(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    pSig: ?[*:0]const u8,
    dwSig: u32,
    pbDigest: ?[*:0]u8,
    pcbDigest: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPTCATSTORE = extern struct {
    cbStruct: u32,
    dwPublicVersion: u32,
    pwszP7File: ?PWSTR,
    hProv: usize,
    dwEncodingType: u32,
    fdwStoreFlags: CRYPTCAT_OPEN_FLAGS,
    hReserved: ?HANDLE,
    hAttrs: ?HANDLE,
    hCryptMsg: ?*c_void,
    hSorted: ?HANDLE,
};

pub const CRYPTCATMEMBER = extern struct {
    cbStruct: u32,
    pwszReferenceTag: ?PWSTR,
    pwszFileName: ?PWSTR,
    gSubjectType: Guid,
    fdwMemberFlags: u32,
    pIndirectData: ?*SIP_INDIRECT_DATA,
    dwCertVersion: u32,
    dwReserved: u32,
    hReserved: ?HANDLE,
    sEncodedIndirectData: CRYPTOAPI_BLOB,
    sEncodedMemberInfo: CRYPTOAPI_BLOB,
};

pub const CRYPTCATATTRIBUTE = extern struct {
    cbStruct: u32,
    pwszReferenceTag: ?PWSTR,
    dwAttrTypeAndAction: u32,
    cbValue: u32,
    pbValue: ?*u8,
    dwReserved: u32,
};

pub const CRYPTCATCDF = extern struct {
    cbStruct: u32,
    hFile: ?HANDLE,
    dwCurFilePos: u32,
    dwLastMemberOffset: u32,
    fEOF: BOOL,
    pwszResultDir: ?PWSTR,
    hCATStore: ?HANDLE,
};

pub const CATALOG_INFO = extern struct {
    cbStruct: u32,
    wszCatalogFile: [260]u16,
};

pub const PFN_CDF_PARSE_ERROR_CALLBACK = fn(
    dwErrorArea: u32,
    dwLocalError: u32,
    pwszLine: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) void;

pub const WINTRUST_DATA = extern struct {
    cbStruct: u32,
    pPolicyCallbackData: ?*c_void,
    pSIPClientData: ?*c_void,
    dwUIChoice: WINTRUST_DATA_UICHOICE,
    fdwRevocationChecks: WINTRUST_DATA_REVOCATION_CHECKS,
    dwUnionChoice: WINTRUST_DATA_UNION_CHOICE,
    Anonymous: extern union {
        pFile: ?*WINTRUST_FILE_INFO,
        pCatalog: ?*WINTRUST_CATALOG_INFO,
        pBlob: ?*WINTRUST_BLOB_INFO,
        pSgnr: ?*WINTRUST_SGNR_INFO,
        pCert: ?*WINTRUST_CERT_INFO,
    },
    dwStateAction: WINTRUST_DATA_STATE_ACTION,
    hWVTStateData: ?HANDLE,
    pwszURLReference: ?PWSTR,
    dwProvFlags: u32,
    dwUIContext: WINTRUST_DATA_UICONTEXT,
    pSignatureSettings: ?*WINTRUST_SIGNATURE_SETTINGS,
};

pub const WINTRUST_SIGNATURE_SETTINGS = extern struct {
    cbStruct: u32,
    dwIndex: u32,
    dwFlags: WINTRUST_SIGNATURE_SETTINGS_FLAGS,
    cSecondarySigs: u32,
    dwVerifiedSigIndex: u32,
    pCryptoPolicy: ?*CERT_STRONG_SIGN_PARA,
};

pub const WINTRUST_FILE_INFO = extern struct {
    cbStruct: u32,
    pcwszFilePath: ?[*:0]const u16,
    hFile: ?HANDLE,
    pgKnownSubject: ?*Guid,
};

pub const WINTRUST_CATALOG_INFO = extern struct {
    cbStruct: u32,
    dwCatalogVersion: u32,
    pcwszCatalogFilePath: ?[*:0]const u16,
    pcwszMemberTag: ?[*:0]const u16,
    pcwszMemberFilePath: ?[*:0]const u16,
    hMemberFile: ?HANDLE,
    pbCalculatedFileHash: ?*u8,
    cbCalculatedFileHash: u32,
    pcCatalogContext: ?*CTL_CONTEXT,
    hCatAdmin: isize,
};

pub const WINTRUST_BLOB_INFO = extern struct {
    cbStruct: u32,
    gSubject: Guid,
    pcwszDisplayName: ?[*:0]const u16,
    cbMemObject: u32,
    pbMemObject: ?*u8,
    cbMemSignedMsg: u32,
    pbMemSignedMsg: ?*u8,
};

pub const WINTRUST_SGNR_INFO = extern struct {
    cbStruct: u32,
    pcwszDisplayName: ?[*:0]const u16,
    psSignerInfo: ?*CMSG_SIGNER_INFO,
    chStores: u32,
    pahStores: ?*?*c_void,
};

pub const WINTRUST_CERT_INFO = extern struct {
    cbStruct: u32,
    pcwszDisplayName: ?[*:0]const u16,
    psCertContext: ?*CERT_CONTEXT,
    chStores: u32,
    pahStores: ?*?*c_void,
    dwFlags: u32,
    psftVerifyAsOf: ?*FILETIME,
};

pub const PFN_CPD_MEM_ALLOC = fn(
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PFN_CPD_MEM_FREE = fn(
    pvMem2Free: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PFN_CPD_ADD_STORE = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
    hStore2Add: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CPD_ADD_SGNR = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
    fCounterSigner: BOOL,
    idxSigner: u32,
    pSgnr2Add: ?*CRYPT_PROVIDER_SGNR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CPD_ADD_CERT = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
    idxSigner: u32,
    fCounterSigner: BOOL,
    idxCounterSigner: u32,
    pCert2Add: ?*const CERT_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_CPD_ADD_PRIVDATA = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
    pPrivData2Add: ?*CRYPT_PROVIDER_PRIVDATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_PROVIDER_INIT_CALL = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_OBJTRUST_CALL = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_SIGTRUST_CALL = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_CERTTRUST_CALL = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_FINALPOLICY_CALL = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_TESTFINALPOLICY_CALL = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_CLEANUP_CALL = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFN_PROVIDER_CERTCHKPOLICY_CALL = fn(
    pProvData: ?*CRYPT_PROVIDER_DATA,
    idxSigner: u32,
    fCounterSignerChain: BOOL,
    idxCounterSigner: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PROVIDER_DATA = extern struct {
    cbStruct: u32,
    pWintrustData: ?*WINTRUST_DATA,
    fOpenedFile: BOOL,
    hWndParent: ?HWND,
    pgActionID: ?*Guid,
    hProv: usize,
    dwError: u32,
    dwRegSecuritySettings: u32,
    dwRegPolicySettings: u32,
    psPfns: ?*CRYPT_PROVIDER_FUNCTIONS,
    cdwTrustStepErrors: u32,
    padwTrustStepErrors: ?*u32,
    chStores: u32,
    pahStores: ?*?*c_void,
    dwEncoding: u32,
    hMsg: ?*c_void,
    csSigners: u32,
    pasSigners: ?*CRYPT_PROVIDER_SGNR,
    csProvPrivData: u32,
    pasProvPrivData: ?*CRYPT_PROVIDER_PRIVDATA,
    dwSubjectChoice: u32,
    Anonymous: extern union {
        pPDSip: ?*PROVDATA_SIP,
    },
    pszUsageOID: ?PSTR,
    fRecallWithState: BOOL,
    sftSystemTime: FILETIME,
    pszCTLSignerUsageOID: ?PSTR,
    dwProvFlags: u32,
    dwFinalError: u32,
    pRequestUsage: ?*CERT_USAGE_MATCH,
    dwTrustPubSettings: u32,
    dwUIStateFlags: u32,
    pSigState: ?*CRYPT_PROVIDER_SIGSTATE,
    pSigSettings: ?*WINTRUST_SIGNATURE_SETTINGS,
};

pub const CRYPT_PROVIDER_SIGSTATE = extern struct {
    cbStruct: u32,
    rhSecondarySigs: ?*?*c_void,
    hPrimarySig: ?*c_void,
    fFirstAttemptMade: BOOL,
    fNoMoreSigs: BOOL,
    cSecondarySigs: u32,
    dwCurrentIndex: u32,
    fSupportMultiSig: BOOL,
    dwCryptoPolicySupport: u32,
    iAttemptCount: u32,
    fCheckedSealing: BOOL,
    pSealingSignature: ?*SEALING_SIGNATURE_ATTRIBUTE,
};

pub const CRYPT_PROVIDER_FUNCTIONS = extern struct {
    cbStruct: u32,
    pfnAlloc: ?PFN_CPD_MEM_ALLOC,
    pfnFree: ?PFN_CPD_MEM_FREE,
    pfnAddStore2Chain: ?PFN_CPD_ADD_STORE,
    pfnAddSgnr2Chain: ?PFN_CPD_ADD_SGNR,
    pfnAddCert2Chain: ?PFN_CPD_ADD_CERT,
    pfnAddPrivData2Chain: ?PFN_CPD_ADD_PRIVDATA,
    pfnInitialize: ?PFN_PROVIDER_INIT_CALL,
    pfnObjectTrust: ?PFN_PROVIDER_OBJTRUST_CALL,
    pfnSignatureTrust: ?PFN_PROVIDER_SIGTRUST_CALL,
    pfnCertificateTrust: ?PFN_PROVIDER_CERTTRUST_CALL,
    pfnFinalPolicy: ?PFN_PROVIDER_FINALPOLICY_CALL,
    pfnCertCheckPolicy: ?PFN_PROVIDER_CERTCHKPOLICY_CALL,
    pfnTestFinalPolicy: ?PFN_PROVIDER_TESTFINALPOLICY_CALL,
    psUIpfns: ?*CRYPT_PROVUI_FUNCS,
    pfnCleanupPolicy: ?PFN_PROVIDER_CLEANUP_CALL,
};

pub const PFN_PROVUI_CALL = fn(
    hWndSecurityDialog: ?HWND,
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PROVUI_FUNCS = extern struct {
    cbStruct: u32,
    psUIData: ?*CRYPT_PROVUI_DATA,
    pfnOnMoreInfoClick: ?PFN_PROVUI_CALL,
    pfnOnMoreInfoClickDefault: ?PFN_PROVUI_CALL,
    pfnOnAdvancedClick: ?PFN_PROVUI_CALL,
    pfnOnAdvancedClickDefault: ?PFN_PROVUI_CALL,
};

pub const CRYPT_PROVUI_DATA = extern struct {
    cbStruct: u32,
    dwFinalError: u32,
    pYesButtonText: ?PWSTR,
    pNoButtonText: ?PWSTR,
    pMoreInfoButtonText: ?PWSTR,
    pAdvancedLinkText: ?PWSTR,
    pCopyActionText: ?PWSTR,
    pCopyActionTextNoTS: ?PWSTR,
    pCopyActionTextNotSigned: ?PWSTR,
};

pub const CRYPT_PROVIDER_SGNR = extern struct {
    cbStruct: u32,
    sftVerifyAsOf: FILETIME,
    csCertChain: u32,
    pasCertChain: ?*CRYPT_PROVIDER_CERT,
    dwSignerType: u32,
    psSigner: ?*CMSG_SIGNER_INFO,
    dwError: u32,
    csCounterSigners: u32,
    pasCounterSigners: ?*CRYPT_PROVIDER_SGNR,
    pChainContext: ?*CERT_CHAIN_CONTEXT,
};

pub const CRYPT_PROVIDER_CERT = extern struct {
    cbStruct: u32,
    pCert: ?*const CERT_CONTEXT,
    fCommercial: BOOL,
    fTrustedRoot: BOOL,
    fSelfSigned: BOOL,
    fTestCert: BOOL,
    dwRevokedReason: u32,
    dwConfidence: u32,
    dwError: u32,
    pTrustListContext: ?*CTL_CONTEXT,
    fTrustListSignerCert: BOOL,
    pCtlContext: ?*CTL_CONTEXT,
    dwCtlError: u32,
    fIsCyclic: BOOL,
    pChainElement: ?*CERT_CHAIN_ELEMENT,
};

pub const CRYPT_PROVIDER_PRIVDATA = extern struct {
    cbStruct: u32,
    gProviderID: Guid,
    cbProvData: u32,
    pvProvData: ?*c_void,
};

pub const PROVDATA_SIP = extern struct {
    cbStruct: u32,
    gSubject: Guid,
    pSip: ?*SIP_DISPATCH_INFO,
    pCATSip: ?*SIP_DISPATCH_INFO,
    psSipSubjectInfo: ?*SIP_SUBJECTINFO,
    psSipCATSubjectInfo: ?*SIP_SUBJECTINFO,
    psIndirectData: ?*SIP_INDIRECT_DATA,
};

pub const CRYPT_TRUST_REG_ENTRY = extern struct {
    cbStruct: u32,
    pwszDLLName: ?PWSTR,
    pwszFunctionName: ?PWSTR,
};

pub const CRYPT_REGISTER_ACTIONID = extern struct {
    cbStruct: u32,
    sInitProvider: CRYPT_TRUST_REG_ENTRY,
    sObjectProvider: CRYPT_TRUST_REG_ENTRY,
    sSignatureProvider: CRYPT_TRUST_REG_ENTRY,
    sCertificateProvider: CRYPT_TRUST_REG_ENTRY,
    sCertificatePolicyProvider: CRYPT_TRUST_REG_ENTRY,
    sFinalPolicyProvider: CRYPT_TRUST_REG_ENTRY,
    sTestPolicyProvider: CRYPT_TRUST_REG_ENTRY,
    sCleanupProvider: CRYPT_TRUST_REG_ENTRY,
};

pub const PFN_ALLOCANDFILLDEFUSAGE = fn(
    pszUsageOID: ?[*:0]const u8,
    psDefUsage: ?*CRYPT_PROVIDER_DEFUSAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFN_FREEDEFUSAGE = fn(
    pszUsageOID: ?[*:0]const u8,
    psDefUsage: ?*CRYPT_PROVIDER_DEFUSAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const CRYPT_PROVIDER_REGDEFUSAGE = extern struct {
    cbStruct: u32,
    pgActionID: ?*Guid,
    pwszDllName: ?PWSTR,
    pwszLoadCallbackDataFunctionName: ?PSTR,
    pwszFreeCallbackDataFunctionName: ?PSTR,
};

pub const CRYPT_PROVIDER_DEFUSAGE = extern struct {
    cbStruct: u32,
    gActionID: Guid,
    pDefPolicyCallbackData: ?*c_void,
    pDefSIPClientData: ?*c_void,
};

pub const SPC_SERIALIZED_OBJECT = extern struct {
    ClassId: [16]u8,
    SerializedData: CRYPTOAPI_BLOB,
};

pub const SPC_SIGINFO = extern struct {
    dwSipVersion: u32,
    gSIPGuid: Guid,
    dwReserved1: u32,
    dwReserved2: u32,
    dwReserved3: u32,
    dwReserved4: u32,
    dwReserved5: u32,
};

pub const SPC_LINK = extern struct {
    dwLinkChoice: u32,
    Anonymous: extern union {
        pwszUrl: ?PWSTR,
        Moniker: SPC_SERIALIZED_OBJECT,
        pwszFile: ?PWSTR,
    },
};

pub const SPC_PE_IMAGE_DATA = extern struct {
    Flags: CRYPT_BIT_BLOB,
    pFile: ?*SPC_LINK,
};

pub const SPC_INDIRECT_DATA_CONTENT = extern struct {
    Data: CRYPT_ATTRIBUTE_TYPE_VALUE,
    DigestAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    Digest: CRYPTOAPI_BLOB,
};

pub const SPC_FINANCIAL_CRITERIA = extern struct {
    fFinancialInfoAvailable: BOOL,
    fMeetsCriteria: BOOL,
};

pub const SPC_IMAGE = extern struct {
    pImageLink: ?*SPC_LINK,
    Bitmap: CRYPTOAPI_BLOB,
    Metafile: CRYPTOAPI_BLOB,
    EnhancedMetafile: CRYPTOAPI_BLOB,
    GifFile: CRYPTOAPI_BLOB,
};

pub const SPC_SP_AGENCY_INFO = extern struct {
    pPolicyInformation: ?*SPC_LINK,
    pwszPolicyDisplayText: ?PWSTR,
    pLogoImage: ?*SPC_IMAGE,
    pLogoLink: ?*SPC_LINK,
};

pub const SPC_STATEMENT_TYPE = extern struct {
    cKeyPurposeId: u32,
    rgpszKeyPurposeId: ?*?PSTR,
};

pub const SPC_SP_OPUS_INFO = extern struct {
    pwszProgramName: ?[*:0]const u16,
    pMoreInfo: ?*SPC_LINK,
    pPublisherInfo: ?*SPC_LINK,
};

pub const CAT_NAMEVALUE = extern struct {
    pwszTag: ?PWSTR,
    fdwFlags: u32,
    Value: CRYPTOAPI_BLOB,
};

pub const CAT_MEMBERINFO = extern struct {
    pwszSubjGuid: ?PWSTR,
    dwCertVersion: u32,
};

pub const CAT_MEMBERINFO2 = extern struct {
    SubjectGuid: Guid,
    dwCertVersion: u32,
};

pub const INTENT_TO_SEAL_ATTRIBUTE = extern struct {
    version: u32,
    seal: BOOLEAN,
};

pub const SEALING_SIGNATURE_ATTRIBUTE = extern struct {
    version: u32,
    signerIndex: u32,
    signatureAlgorithm: CRYPT_ALGORITHM_IDENTIFIER,
    encryptedDigest: CRYPTOAPI_BLOB,
};

pub const SEALING_TIMESTAMP_ATTRIBUTE = extern struct {
    version: u32,
    signerIndex: u32,
    sealTimeStampToken: CRYPTOAPI_BLOB,
};

pub const WIN_CERTIFICATE = extern struct {
    dwLength: u32,
    wRevision: u16,
    wCertificateType: u16,
    bCertificate: [1]u8,
};

pub const WIN_TRUST_ACTDATA_CONTEXT_WITH_SUBJECT = extern struct {
    hClientToken: ?HANDLE,
    SubjectType: ?*Guid,
    Subject: ?*c_void,
};

pub const WIN_TRUST_ACTDATA_SUBJECT_ONLY = extern struct {
    SubjectType: ?*Guid,
    Subject: ?*c_void,
};

pub const WIN_TRUST_SUBJECT_FILE = extern struct {
    hFile: ?HANDLE,
    lpPath: ?[*:0]const u16,
};

pub const WIN_TRUST_SUBJECT_FILE_AND_DISPLAY = extern struct {
    hFile: ?HANDLE,
    lpPath: ?[*:0]const u16,
    lpDisplayName: ?[*:0]const u16,
};

pub const WIN_SPUB_TRUSTED_PUBLISHER_DATA = extern struct {
    hClientToken: ?HANDLE,
    lpCertificate: ?*WIN_CERTIFICATE,
};

pub const SCESVC_CONFIGURATION_LINE = extern struct {
    Key: ?*i8,
    Value: ?*i8,
    ValueLen: u32,
};

pub const SCESVC_CONFIGURATION_INFO = extern struct {
    Count: u32,
    Lines: ?*SCESVC_CONFIGURATION_LINE,
};

pub const SCESVC_INFO_TYPE = enum(i32) {
    ConfigurationInfo = 0,
    MergedPolicyInfo = 1,
    AnalysisInfo = 2,
    InternalUse = 3,
};
pub const SceSvcConfigurationInfo = SCESVC_INFO_TYPE.ConfigurationInfo;
pub const SceSvcMergedPolicyInfo = SCESVC_INFO_TYPE.MergedPolicyInfo;
pub const SceSvcAnalysisInfo = SCESVC_INFO_TYPE.AnalysisInfo;
pub const SceSvcInternalUse = SCESVC_INFO_TYPE.InternalUse;

pub const SCESVC_ANALYSIS_LINE = extern struct {
    Key: ?*i8,
    Value: ?*u8,
    ValueLen: u32,
};

pub const SCESVC_ANALYSIS_INFO = extern struct {
    Count: u32,
    Lines: ?*SCESVC_ANALYSIS_LINE,
};

pub const PFSCE_QUERY_INFO = fn(
    sceHandle: ?*c_void,
    sceType: SCESVC_INFO_TYPE,
    lpPrefix: ?*i8,
    bExact: BOOL,
    ppvInfo: ?*?*c_void,
    psceEnumHandle: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFSCE_SET_INFO = fn(
    sceHandle: ?*c_void,
    sceType: SCESVC_INFO_TYPE,
    lpPrefix: ?*i8,
    bExact: BOOL,
    pvInfo: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFSCE_FREE_INFO = fn(
    pvServiceInfo: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PFSCE_LOG_INFO = fn(
    ErrLevel: SCE_LOG_ERR_LEVEL,
    Win32rc: u32,
    pErrFmt: ?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const SCESVC_CALLBACK_INFO = extern struct {
    sceHandle: ?*c_void,
    pfQueryInfo: ?PFSCE_QUERY_INFO,
    pfSetInfo: ?PFSCE_SET_INFO,
    pfFreeInfo: ?PFSCE_FREE_INFO,
    pfLogInfo: ?PFSCE_LOG_INFO,
};

pub const PF_ConfigAnalyzeService = fn(
    pSceCbInfo: ?*SCESVC_CALLBACK_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PF_UpdateService = fn(
    pSceCbInfo: ?*SCESVC_CALLBACK_INFO,
    ServiceInfo: ?*SCESVC_CONFIGURATION_INFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISceSvcAttachmentPersistInfo_Value = @import("zig.zig").Guid.initString("6d90e0d0-200d-11d1-affb-00c04fb984f9");
pub const IID_ISceSvcAttachmentPersistInfo = &IID_ISceSvcAttachmentPersistInfo_Value;
pub const ISceSvcAttachmentPersistInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Save: fn(
            self: *const ISceSvcAttachmentPersistInfo,
            lpTemplateName: ?*i8,
            scesvcHandle: ?*?*c_void,
            ppvData: ?*?*c_void,
            pbOverwriteAll: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsDirty: fn(
            self: *const ISceSvcAttachmentPersistInfo,
            lpTemplateName: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: fn(
            self: *const ISceSvcAttachmentPersistInfo,
            pvData: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_Save(self: *const T, lpTemplateName: ?*i8, scesvcHandle: ?*?*c_void, ppvData: ?*?*c_void, pbOverwriteAll: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).Save(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), lpTemplateName, scesvcHandle, ppvData, pbOverwriteAll);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_IsDirty(self: *const T, lpTemplateName: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).IsDirty(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), lpTemplateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentPersistInfo_FreeBuffer(self: *const T, pvData: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentPersistInfo.VTable, self.vtable).FreeBuffer(@ptrCast(*const ISceSvcAttachmentPersistInfo, self), pvData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows5.1.2600'
const IID_ISceSvcAttachmentData_Value = @import("zig.zig").Guid.initString("17c35fde-200d-11d1-affb-00c04fb984f9");
pub const IID_ISceSvcAttachmentData = &IID_ISceSvcAttachmentData_Value;
pub const ISceSvcAttachmentData = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetData: fn(
            self: *const ISceSvcAttachmentData,
            scesvcHandle: ?*c_void,
            sceType: SCESVC_INFO_TYPE,
            ppvData: ?*?*c_void,
            psceEnumHandle: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Initialize: fn(
            self: *const ISceSvcAttachmentData,
            lpServiceName: ?*i8,
            lpTemplateName: ?*i8,
            lpSceSvcPersistInfo: ?*ISceSvcAttachmentPersistInfo,
            pscesvcHandle: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeBuffer: fn(
            self: *const ISceSvcAttachmentData,
            pvData: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseHandle: fn(
            self: *const ISceSvcAttachmentData,
            scesvcHandle: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_GetData(self: *const T, scesvcHandle: ?*c_void, sceType: SCESVC_INFO_TYPE, ppvData: ?*?*c_void, psceEnumHandle: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).GetData(@ptrCast(*const ISceSvcAttachmentData, self), scesvcHandle, sceType, ppvData, psceEnumHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_Initialize(self: *const T, lpServiceName: ?*i8, lpTemplateName: ?*i8, lpSceSvcPersistInfo: ?*ISceSvcAttachmentPersistInfo, pscesvcHandle: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).Initialize(@ptrCast(*const ISceSvcAttachmentData, self), lpServiceName, lpTemplateName, lpSceSvcPersistInfo, pscesvcHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_FreeBuffer(self: *const T, pvData: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).FreeBuffer(@ptrCast(*const ISceSvcAttachmentData, self), pvData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISceSvcAttachmentData_CloseHandle(self: *const T, scesvcHandle: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISceSvcAttachmentData.VTable, self.vtable).CloseHandle(@ptrCast(*const ISceSvcAttachmentData, self), scesvcHandle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SAFER_CODE_PROPERTIES_V1 = extern struct {
    cbSize: u32,
    dwCheckFlags: u32,
    ImagePath: ?[*:0]const u16,
    hImageFileHandle: ?HANDLE,
    UrlZoneId: u32,
    ImageHash: [64]u8,
    dwImageHashSize: u32,
    ImageSize: LARGE_INTEGER,
    HashAlgorithm: u32,
    pByteBlock: ?*u8,
    hWndParent: ?HWND,
    dwWVTUIChoice: u32,
};

pub const SAFER_CODE_PROPERTIES_V2 = extern struct {
    cbSize: u32,
    dwCheckFlags: u32,
    ImagePath: ?[*:0]const u16,
    hImageFileHandle: ?HANDLE,
    UrlZoneId: u32,
    ImageHash: [64]u8,
    dwImageHashSize: u32,
    ImageSize: LARGE_INTEGER,
    HashAlgorithm: u32,
    pByteBlock: ?*u8,
    hWndParent: ?HWND,
    dwWVTUIChoice: u32,
    PackageMoniker: ?[*:0]const u16,
    PackagePublisher: ?[*:0]const u16,
    PackageName: ?[*:0]const u16,
    PackageVersion: u64,
    PackageIsFramework: BOOL,
};

pub const SAFER_POLICY_INFO_CLASS = enum(i32) {
    LevelList = 1,
    EnableTransparentEnforcement = 2,
    DefaultLevel = 3,
    EvaluateUserScope = 4,
    ScopeFlags = 5,
    DefaultLevelFlags = 6,
    AuthenticodeEnabled = 7,
};
pub const SaferPolicyLevelList = SAFER_POLICY_INFO_CLASS.LevelList;
pub const SaferPolicyEnableTransparentEnforcement = SAFER_POLICY_INFO_CLASS.EnableTransparentEnforcement;
pub const SaferPolicyDefaultLevel = SAFER_POLICY_INFO_CLASS.DefaultLevel;
pub const SaferPolicyEvaluateUserScope = SAFER_POLICY_INFO_CLASS.EvaluateUserScope;
pub const SaferPolicyScopeFlags = SAFER_POLICY_INFO_CLASS.ScopeFlags;
pub const SaferPolicyDefaultLevelFlags = SAFER_POLICY_INFO_CLASS.DefaultLevelFlags;
pub const SaferPolicyAuthenticodeEnabled = SAFER_POLICY_INFO_CLASS.AuthenticodeEnabled;

pub const SAFER_OBJECT_INFO_CLASS = enum(i32) {
    LevelId = 1,
    ScopeId = 2,
    FriendlyName = 3,
    Description = 4,
    Builtin = 5,
    Disallowed = 6,
    DisableMaxPrivilege = 7,
    InvertDeletedPrivileges = 8,
    DeletedPrivileges = 9,
    DefaultOwner = 10,
    SidsToDisable = 11,
    RestrictedSidsInverted = 12,
    RestrictedSidsAdded = 13,
    AllIdentificationGuids = 14,
    SingleIdentification = 15,
    ExtendedError = 16,
};
pub const SaferObjectLevelId = SAFER_OBJECT_INFO_CLASS.LevelId;
pub const SaferObjectScopeId = SAFER_OBJECT_INFO_CLASS.ScopeId;
pub const SaferObjectFriendlyName = SAFER_OBJECT_INFO_CLASS.FriendlyName;
pub const SaferObjectDescription = SAFER_OBJECT_INFO_CLASS.Description;
pub const SaferObjectBuiltin = SAFER_OBJECT_INFO_CLASS.Builtin;
pub const SaferObjectDisallowed = SAFER_OBJECT_INFO_CLASS.Disallowed;
pub const SaferObjectDisableMaxPrivilege = SAFER_OBJECT_INFO_CLASS.DisableMaxPrivilege;
pub const SaferObjectInvertDeletedPrivileges = SAFER_OBJECT_INFO_CLASS.InvertDeletedPrivileges;
pub const SaferObjectDeletedPrivileges = SAFER_OBJECT_INFO_CLASS.DeletedPrivileges;
pub const SaferObjectDefaultOwner = SAFER_OBJECT_INFO_CLASS.DefaultOwner;
pub const SaferObjectSidsToDisable = SAFER_OBJECT_INFO_CLASS.SidsToDisable;
pub const SaferObjectRestrictedSidsInverted = SAFER_OBJECT_INFO_CLASS.RestrictedSidsInverted;
pub const SaferObjectRestrictedSidsAdded = SAFER_OBJECT_INFO_CLASS.RestrictedSidsAdded;
pub const SaferObjectAllIdentificationGuids = SAFER_OBJECT_INFO_CLASS.AllIdentificationGuids;
pub const SaferObjectSingleIdentification = SAFER_OBJECT_INFO_CLASS.SingleIdentification;
pub const SaferObjectExtendedError = SAFER_OBJECT_INFO_CLASS.ExtendedError;

pub const SAFER_IDENTIFICATION_TYPES = enum(i32) {
    Default = 0,
    TypeImageName = 1,
    TypeImageHash = 2,
    TypeUrlZone = 3,
    TypeCertificate = 4,
};
pub const SaferIdentityDefault = SAFER_IDENTIFICATION_TYPES.Default;
pub const SaferIdentityTypeImageName = SAFER_IDENTIFICATION_TYPES.TypeImageName;
pub const SaferIdentityTypeImageHash = SAFER_IDENTIFICATION_TYPES.TypeImageHash;
pub const SaferIdentityTypeUrlZone = SAFER_IDENTIFICATION_TYPES.TypeUrlZone;
pub const SaferIdentityTypeCertificate = SAFER_IDENTIFICATION_TYPES.TypeCertificate;

pub const SAFER_IDENTIFICATION_HEADER = extern struct {
    dwIdentificationType: SAFER_IDENTIFICATION_TYPES,
    cbStructSize: u32,
    IdentificationGuid: Guid,
    lastModified: FILETIME,
};

pub const SAFER_PATHNAME_IDENTIFICATION = extern struct {
    header: SAFER_IDENTIFICATION_HEADER,
    Description: [256]u16,
    ImageName: ?[*]u16,
    dwSaferFlags: u32,
};

pub const SAFER_HASH_IDENTIFICATION = extern struct {
    header: SAFER_IDENTIFICATION_HEADER,
    Description: [256]u16,
    FriendlyName: [256]u16,
    HashSize: u32,
    ImageHash: [64]u8,
    HashAlgorithm: u32,
    ImageSize: LARGE_INTEGER,
    dwSaferFlags: u32,
};

pub const SAFER_HASH_IDENTIFICATION2 = extern struct {
    hashIdentification: SAFER_HASH_IDENTIFICATION,
    HashSize: u32,
    ImageHash: [64]u8,
    HashAlgorithm: u32,
};

pub const SAFER_URLZONE_IDENTIFICATION = extern struct {
    header: SAFER_IDENTIFICATION_HEADER,
    UrlZoneId: u32,
    dwSaferFlags: u32,
};

pub const DdqAccessLevel = enum(i32) {
    NoData = 0,
    CurrentUserData = 1,
    AllUserData = 2,
};
pub const NoData = DdqAccessLevel.NoData;
pub const CurrentUserData = DdqAccessLevel.CurrentUserData;
pub const AllUserData = DdqAccessLevel.AllUserData;

pub const DIAGNOSTIC_DATA_RECORD = extern struct {
    rowId: i64,
    timestamp: u64,
    eventKeywords: u64,
    fullEventName: ?PWSTR,
    providerGroupGuid: ?PWSTR,
    producerName: ?PWSTR,
    privacyTags: ?*i32,
    privacyTagCount: u32,
    categoryIds: ?*i32,
    categoryIdCount: u32,
    isCoreData: BOOL,
    extra1: ?PWSTR,
    extra2: ?PWSTR,
    extra3: ?PWSTR,
};

pub const DIAGNOSTIC_DATA_SEARCH_CRITERIA = extern struct {
    producerNames: ?*?PWSTR,
    producerNameCount: u32,
    textToMatch: ?[*:0]const u16,
    categoryIds: ?*const i32,
    categoryIdCount: u32,
    privacyTags: ?*const i32,
    privacyTagCount: u32,
    coreDataOnly: BOOL,
};

pub const DIAGNOSTIC_DATA_EVENT_TAG_DESCRIPTION = extern struct {
    privacyTag: i32,
    name: ?PWSTR,
    description: ?PWSTR,
};

pub const DIAGNOSTIC_DATA_EVENT_PRODUCER_DESCRIPTION = extern struct {
    name: ?PWSTR,
};

pub const DIAGNOSTIC_DATA_EVENT_CATEGORY_DESCRIPTION = extern struct {
    id: i32,
    name: ?PWSTR,
};

pub const DIAGNOSTIC_DATA_EVENT_TAG_STATS = extern struct {
    privacyTag: i32,
    eventCount: u32,
};

pub const DIAGNOSTIC_DATA_EVENT_BINARY_STATS = extern struct {
    moduleName: ?PWSTR,
    friendlyModuleName: ?PWSTR,
    eventCount: u32,
    uploadSizeBytes: u64,
};

pub const DIAGNOSTIC_DATA_GENERAL_STATS = extern struct {
    optInLevel: u32,
    transcriptSizeBytes: u64,
    oldestEventTimestamp: u64,
    totalEventCountLast24Hours: u32,
    averageDailyEvents: f32,
};

pub const DIAGNOSTIC_DATA_EVENT_TRANSCRIPT_CONFIGURATION = extern struct {
    hoursOfHistoryToKeep: u32,
    maxStoreMegabytes: u32,
    requestedMaxStoreMegabytes: u32,
};

pub const DIAGNOSTIC_REPORT_PARAMETER = extern struct {
    name: [129]u16,
    value: [260]u16,
};

pub const DIAGNOSTIC_REPORT_SIGNATURE = extern struct {
    eventName: [65]u16,
    parameters: [10]DIAGNOSTIC_REPORT_PARAMETER,
};

pub const DIAGNOSTIC_REPORT_DATA = extern struct {
    signature: DIAGNOSTIC_REPORT_SIGNATURE,
    bucketId: Guid,
    reportId: Guid,
    creationTime: FILETIME,
    sizeInBytes: u64,
    cabId: ?PWSTR,
    reportStatus: u32,
    reportIntegratorId: Guid,
    fileNames: ?*?PWSTR,
    fileCount: u32,
    friendlyEventName: ?PWSTR,
    applicationName: ?PWSTR,
    applicationPath: ?PWSTR,
    description: ?PWSTR,
    bucketIdString: ?PWSTR,
    legacyBucketId: u64,
    reportKey: ?PWSTR,
};


//--------------------------------------------------------------------------------
// Section: Functions (250)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn SetUserObjectSecurity(
    hObj: ?HANDLE,
    pSIRequested: ?*OBJECT_SECURITY_INFORMATION,
    pSID: ?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn GetUserObjectSecurity(
    hObj: ?HANDLE,
    pSIRequested: ?*u32,
    // TODO: what to do with BytesParamIndex 3?
    pSID: ?*SECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheck(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    ClientToken: ?HANDLE,
    DesiredAccess: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    // TODO: what to do with BytesParamIndex 5?
    PrivilegeSet: ?*PRIVILEGE_SET,
    PrivilegeSetLength: ?*u32,
    GrantedAccess: ?*u32,
    AccessStatus: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AccessCheckAndAuditAlarmW(
    SubsystemName: ?[*:0]const u16,
    HandleId: ?*c_void,
    ObjectTypeName: ?PWSTR,
    ObjectName: ?PWSTR,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    DesiredAccess: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: ?*u32,
    AccessStatus: ?*i32,
    pfGenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByType(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    PrincipalSelfSid: ?PSID,
    ClientToken: ?HANDLE,
    DesiredAccess: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    // TODO: what to do with BytesParamIndex 8?
    PrivilegeSet: ?*PRIVILEGE_SET,
    PrivilegeSetLength: ?*u32,
    GrantedAccess: ?*u32,
    AccessStatus: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByTypeResultList(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    PrincipalSelfSid: ?PSID,
    ClientToken: ?HANDLE,
    DesiredAccess: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    // TODO: what to do with BytesParamIndex 8?
    PrivilegeSet: ?*PRIVILEGE_SET,
    PrivilegeSetLength: ?*u32,
    GrantedAccessList: [*]u32,
    AccessStatusList: [*]u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AccessCheckByTypeAndAuditAlarmW(
    SubsystemName: ?[*:0]const u16,
    HandleId: ?*c_void,
    ObjectTypeName: ?[*:0]const u16,
    ObjectName: ?[*:0]const u16,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    PrincipalSelfSid: ?PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: ?*u32,
    AccessStatus: ?*i32,
    pfGenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AccessCheckByTypeResultListAndAuditAlarmW(
    SubsystemName: ?[*:0]const u16,
    HandleId: ?*c_void,
    ObjectTypeName: ?[*:0]const u16,
    ObjectName: ?[*:0]const u16,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    PrincipalSelfSid: ?PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccessList: [*]u32,
    AccessStatusList: [*]u32,
    pfGenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn AccessCheckByTypeResultListAndAuditAlarmByHandleW(
    SubsystemName: ?[*:0]const u16,
    HandleId: ?*c_void,
    ClientToken: ?HANDLE,
    ObjectTypeName: ?[*:0]const u16,
    ObjectName: ?[*:0]const u16,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    PrincipalSelfSid: ?PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccessList: [*]u32,
    AccessStatusList: [*]u32,
    pfGenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessAllowedAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AccessMask: u32,
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessAllowedAceEx(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessAllowedObjectAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    ObjectTypeGuid: ?*Guid,
    InheritedObjectTypeGuid: ?*Guid,
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessDeniedAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AccessMask: u32,
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessDeniedAceEx(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAccessDeniedObjectAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    ObjectTypeGuid: ?*Guid,
    InheritedObjectTypeGuid: ?*Guid,
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    dwStartingAceIndex: u32,
    // TODO: what to do with BytesParamIndex 4?
    pAceList: ?*c_void,
    nAceListLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAuditAccessAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    dwAccessMask: u32,
    pSid: ?PSID,
    bAuditSuccess: BOOL,
    bAuditFailure: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAuditAccessAceEx(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    dwAccessMask: u32,
    pSid: ?PSID,
    bAuditSuccess: BOOL,
    bAuditFailure: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AddAuditAccessObjectAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    ObjectTypeGuid: ?*Guid,
    InheritedObjectTypeGuid: ?*Guid,
    pSid: ?PSID,
    bAuditSuccess: BOOL,
    bAuditFailure: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn AddMandatoryAce(
    pAcl: ?*ACL,
    dwAceRevision: ACE_REVISION,
    AceFlags: ACE_FLAGS,
    MandatoryPolicy: u32,
    pLabelSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn AddResourceAttributeAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    pSid: ?PSID,
    pAttributeInfo: ?*CLAIM_SECURITY_ATTRIBUTES_INFORMATION,
    pReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn AddScopedPolicyIDAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AccessMask: u32,
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AdjustTokenGroups(
    TokenHandle: ?HANDLE,
    ResetToDefault: BOOL,
    NewState: ?*TOKEN_GROUPS,
    BufferLength: u32,
    // TODO: what to do with BytesParamIndex 3?
    PreviousState: ?*TOKEN_GROUPS,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AdjustTokenPrivileges(
    TokenHandle: ?HANDLE,
    DisableAllPrivileges: BOOL,
    NewState: ?*TOKEN_PRIVILEGES,
    BufferLength: u32,
    // TODO: what to do with BytesParamIndex 3?
    PreviousState: ?*TOKEN_PRIVILEGES,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AllocateAndInitializeSid(
    pIdentifierAuthority: ?*SID_IDENTIFIER_AUTHORITY,
    nSubAuthorityCount: u8,
    nSubAuthority0: u32,
    nSubAuthority1: u32,
    nSubAuthority2: u32,
    nSubAuthority3: u32,
    nSubAuthority4: u32,
    nSubAuthority5: u32,
    nSubAuthority6: u32,
    nSubAuthority7: u32,
    pSid: ?*?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AllocateLocallyUniqueId(
    Luid: ?*LUID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AreAllAccessesGranted(
    GrantedAccess: u32,
    DesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AreAnyAccessesGranted(
    GrantedAccess: u32,
    DesiredAccess: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CheckTokenMembership(
    TokenHandle: ?HANDLE,
    SidToCheck: ?PSID,
    IsMember: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CheckTokenCapability(
    TokenHandle: ?HANDLE,
    CapabilitySidToCheck: ?PSID,
    HasCapability: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetAppContainerAce(
    Acl: ?*ACL,
    StartingAceIndex: u32,
    AppContainerAce: ?*?*c_void,
    AppContainerAceIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "KERNEL32" fn CheckTokenMembershipEx(
    TokenHandle: ?HANDLE,
    SidToCheck: ?PSID,
    Flags: u32,
    IsMember: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ConvertToAutoInheritPrivateObjectSecurity(
    ParentDescriptor: ?*SECURITY_DESCRIPTOR,
    CurrentSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    NewSecurityDescriptor: ?*?*SECURITY_DESCRIPTOR,
    ObjectType: ?*Guid,
    IsDirectoryObject: BOOLEAN,
    GenericMapping: ?*GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CopySid(
    nDestinationSidLength: u32,
    // TODO: what to do with BytesParamIndex 0?
    pDestinationSid: ?PSID,
    pSourceSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreatePrivateObjectSecurity(
    ParentDescriptor: ?*SECURITY_DESCRIPTOR,
    CreatorDescriptor: ?*SECURITY_DESCRIPTOR,
    NewDescriptor: ?*?*SECURITY_DESCRIPTOR,
    IsDirectoryObject: BOOL,
    Token: ?HANDLE,
    GenericMapping: ?*GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreatePrivateObjectSecurityEx(
    ParentDescriptor: ?*SECURITY_DESCRIPTOR,
    CreatorDescriptor: ?*SECURITY_DESCRIPTOR,
    NewDescriptor: ?*?*SECURITY_DESCRIPTOR,
    ObjectType: ?*Guid,
    IsContainerObject: BOOL,
    AutoInheritFlags: SECURITY_AUTO_INHERIT_FLAGS,
    Token: ?HANDLE,
    GenericMapping: ?*GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreatePrivateObjectSecurityWithMultipleInheritance(
    ParentDescriptor: ?*SECURITY_DESCRIPTOR,
    CreatorDescriptor: ?*SECURITY_DESCRIPTOR,
    NewDescriptor: ?*?*SECURITY_DESCRIPTOR,
    ObjectTypes: ?[*]?*Guid,
    GuidCount: u32,
    IsContainerObject: BOOL,
    AutoInheritFlags: SECURITY_AUTO_INHERIT_FLAGS,
    Token: ?HANDLE,
    GenericMapping: ?*GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateRestrictedToken(
    ExistingTokenHandle: ?HANDLE,
    Flags: CREATE_RESTRICTED_TOKEN_FLAGS,
    DisableSidCount: u32,
    SidsToDisable: ?[*]SID_AND_ATTRIBUTES,
    DeletePrivilegeCount: u32,
    PrivilegesToDelete: ?[*]LUID_AND_ATTRIBUTES,
    RestrictedSidCount: u32,
    SidsToRestrict: ?[*]SID_AND_ATTRIBUTES,
    NewTokenHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn CreateWellKnownSid(
    WellKnownSidType: WELL_KNOWN_SID_TYPE,
    DomainSid: ?PSID,
    // TODO: what to do with BytesParamIndex 3?
    pSid: ?PSID,
    cbSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EqualDomainSid(
    pSid1: ?PSID,
    pSid2: ?PSID,
    pfEqual: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DeleteAce(
    pAcl: ?*ACL,
    dwAceIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DestroyPrivateObjectSecurity(
    ObjectDescriptor: ?*?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DuplicateToken(
    ExistingTokenHandle: ?HANDLE,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    DuplicateTokenHandle: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn DuplicateTokenEx(
    hExistingToken: ?HANDLE,
    dwDesiredAccess: TOKEN_ACCESS_MASK,
    lpTokenAttributes: ?*SECURITY_ATTRIBUTES,
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
    TokenType: TOKEN_TYPE,
    phNewToken: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EqualPrefixSid(
    pSid1: ?PSID,
    pSid2: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn EqualSid(
    pSid1: ?PSID,
    pSid2: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn FindFirstFreeAce(
    pAcl: ?*ACL,
    pAce: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn FreeSid(
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetAce(
    pAcl: ?*ACL,
    dwAceIndex: u32,
    pAce: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetAclInformation(
    pAcl: ?*ACL,
    // TODO: what to do with BytesParamIndex 2?
    pAclInformation: ?*c_void,
    nAclInformationLength: u32,
    dwAclInformationClass: ACL_INFORMATION_CLASS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn GetFileSecurityW(
    lpFileName: ?[*:0]const u16,
    RequestedInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetKernelObjectSecurity(
    Handle: ?HANDLE,
    RequestedInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetLengthSid(
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetPrivateObjectSecurity(
    ObjectDescriptor: ?*SECURITY_DESCRIPTOR,
    SecurityInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    ResultantDescriptor: ?*SECURITY_DESCRIPTOR,
    DescriptorLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorControl(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    pControl: ?*u16,
    lpdwRevision: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorDacl(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    lpbDaclPresent: ?*i32,
    pDacl: ?*?*ACL,
    lpbDaclDefaulted: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorGroup(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    pGroup: ?*?PSID,
    lpbGroupDefaulted: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorLength(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorOwner(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    pOwner: ?*?PSID,
    lpbOwnerDefaulted: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorRMControl(
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    RMControl: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSecurityDescriptorSacl(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    lpbSaclPresent: ?*i32,
    pSacl: ?*?*ACL,
    lpbSaclDefaulted: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSidIdentifierAuthority(
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) ?*SID_IDENTIFIER_AUTHORITY;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSidLengthRequired(
    nSubAuthorityCount: u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSidSubAuthority(
    pSid: ?PSID,
    nSubAuthority: u32,
) callconv(@import("std").os.windows.WINAPI) ?*u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetSidSubAuthorityCount(
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) ?*u8;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetTokenInformation(
    TokenHandle: ?HANDLE,
    TokenInformationClass: TOKEN_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    TokenInformation: ?*c_void,
    TokenInformationLength: u32,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetWindowsAccountDomainSid(
    pSid: ?PSID,
    // TODO: what to do with BytesParamIndex 2?
    pDomainSid: ?PSID,
    cbDomainSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ImpersonateAnonymousToken(
    ThreadHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ImpersonateLoggedOnUser(
    hToken: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ImpersonateSelf(
    ImpersonationLevel: SECURITY_IMPERSONATION_LEVEL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitializeAcl(
    // TODO: what to do with BytesParamIndex 1?
    pAcl: ?*ACL,
    nAclLength: u32,
    dwAclRevision: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitializeSecurityDescriptor(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    dwRevision: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn InitializeSid(
    Sid: ?PSID,
    pIdentifierAuthority: ?*SID_IDENTIFIER_AUTHORITY,
    nSubAuthorityCount: u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsTokenRestricted(
    TokenHandle: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsValidAcl(
    pAcl: ?*ACL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsValidSecurityDescriptor(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsValidSid(
    pSid: ?PSID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn IsWellKnownSid(
    pSid: ?PSID,
    WellKnownSidType: WELL_KNOWN_SID_TYPE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn MakeAbsoluteSD(
    pSelfRelativeSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    // TODO: what to do with BytesParamIndex 2?
    pAbsoluteSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    lpdwAbsoluteSecurityDescriptorSize: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    pDacl: ?*ACL,
    lpdwDaclSize: ?*u32,
    // TODO: what to do with BytesParamIndex 6?
    pSacl: ?*ACL,
    lpdwSaclSize: ?*u32,
    // TODO: what to do with BytesParamIndex 8?
    pOwner: ?PSID,
    lpdwOwnerSize: ?*u32,
    // TODO: what to do with BytesParamIndex 10?
    pPrimaryGroup: ?PSID,
    lpdwPrimaryGroupSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn MakeSelfRelativeSD(
    pAbsoluteSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    // TODO: what to do with BytesParamIndex 2?
    pSelfRelativeSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    lpdwBufferLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn MapGenericMask(
    AccessMask: ?*u32,
    GenericMapping: ?*GENERIC_MAPPING,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "ADVAPI32" fn ObjectCloseAuditAlarmW(
    SubsystemName: ?[*:0]const u16,
    HandleId: ?*c_void,
    GenerateOnClose: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ObjectDeleteAuditAlarmW(
    SubsystemName: ?[*:0]const u16,
    HandleId: ?*c_void,
    GenerateOnClose: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ObjectOpenAuditAlarmW(
    SubsystemName: ?[*:0]const u16,
    HandleId: ?*c_void,
    ObjectTypeName: ?PWSTR,
    ObjectName: ?PWSTR,
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    ClientToken: ?HANDLE,
    DesiredAccess: u32,
    GrantedAccess: u32,
    Privileges: ?*PRIVILEGE_SET,
    ObjectCreation: BOOL,
    AccessGranted: BOOL,
    GenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn ObjectPrivilegeAuditAlarmW(
    SubsystemName: ?[*:0]const u16,
    HandleId: ?*c_void,
    ClientToken: ?HANDLE,
    DesiredAccess: u32,
    Privileges: ?*PRIVILEGE_SET,
    AccessGranted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn PrivilegeCheck(
    ClientToken: ?HANDLE,
    RequiredPrivileges: ?*PRIVILEGE_SET,
    pfResult: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn PrivilegedServiceAuditAlarmW(
    SubsystemName: ?[*:0]const u16,
    ServiceName: ?[*:0]const u16,
    ClientToken: ?HANDLE,
    Privileges: ?*PRIVILEGE_SET,
    AccessGranted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn QuerySecurityAccessMask(
    SecurityInformation: u32,
    DesiredAccess: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn RevertToSelf(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetAclInformation(
    pAcl: ?*ACL,
    // TODO: what to do with BytesParamIndex 2?
    pAclInformation: ?*c_void,
    nAclInformationLength: u32,
    dwAclInformationClass: ACL_INFORMATION_CLASS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "ADVAPI32" fn SetFileSecurityW(
    lpFileName: ?[*:0]const u16,
    SecurityInformation: u32,
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetKernelObjectSecurity(
    Handle: ?HANDLE,
    SecurityInformation: u32,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetPrivateObjectSecurity(
    SecurityInformation: u32,
    ModificationDescriptor: ?*SECURITY_DESCRIPTOR,
    ObjectsSecurityDescriptor: ?*?*SECURITY_DESCRIPTOR,
    GenericMapping: ?*GENERIC_MAPPING,
    Token: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetPrivateObjectSecurityEx(
    SecurityInformation: u32,
    ModificationDescriptor: ?*SECURITY_DESCRIPTOR,
    ObjectsSecurityDescriptor: ?*?*SECURITY_DESCRIPTOR,
    AutoInheritFlags: SECURITY_AUTO_INHERIT_FLAGS,
    GenericMapping: ?*GENERIC_MAPPING,
    Token: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn SetSecurityAccessMask(
    SecurityInformation: u32,
    DesiredAccess: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorControl(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    ControlBitsOfInterest: u16,
    ControlBitsToSet: u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorDacl(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    bDaclPresent: BOOL,
    pDacl: ?*ACL,
    bDaclDefaulted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorGroup(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    pGroup: ?PSID,
    bGroupDefaulted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorOwner(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    pOwner: ?PSID,
    bOwnerDefaulted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorRMControl(
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    RMControl: ?*u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetSecurityDescriptorSacl(
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    bSaclPresent: BOOL,
    pSacl: ?*ACL,
    bSaclDefaulted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetTokenInformation(
    TokenHandle: ?HANDLE,
    TokenInformationClass: TOKEN_INFORMATION_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    TokenInformation: ?*c_void,
    TokenInformationLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn SetCachedSigningLevel(
    SourceFiles: [*]?HANDLE,
    SourceFileCount: u32,
    Flags: u32,
    TargetFile: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn GetCachedSigningLevel(
    File: ?HANDLE,
    Flags: ?*u32,
    SigningLevel: ?*u32,
    // TODO: what to do with BytesParamIndex 4?
    Thumbprint: ?*u8,
    ThumbprintSize: ?*u32,
    ThumbprintAlgorithm: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-security-base-l1-2-2" fn DeriveCapabilitySidsFromName(
    CapName: ?[*:0]const u16,
    CapabilityGroupSids: ?*?*?PSID,
    CapabilityGroupSidCount: ?*u32,
    CapabilitySids: ?*?*?PSID,
    CapabilitySidCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptProtectData(
    pDataIn: ?*CRYPTOAPI_BLOB,
    szDataDescr: ?[*:0]const u16,
    pOptionalEntropy: ?*CRYPTOAPI_BLOB,
    pvReserved: ?*c_void,
    pPromptStruct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dwFlags: u32,
    pDataOut: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptUnprotectData(
    pDataIn: ?*CRYPTOAPI_BLOB,
    ppszDataDescr: ?*?PWSTR,
    pOptionalEntropy: ?*CRYPTOAPI_BLOB,
    pvReserved: ?*c_void,
    pPromptStruct: ?*CRYPTPROTECT_PROMPTSTRUCT,
    dwFlags: u32,
    pDataOut: ?*CRYPTOAPI_BLOB,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptUpdateProtectedState(
    pOldSid: ?PSID,
    pwszOldPassword: ?[*:0]const u16,
    dwFlags: u32,
    pdwSuccessCount: ?*u32,
    pdwFailureCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptProtectMemory(
    pDataIn: ?*c_void,
    cbDataIn: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "CRYPT32" fn CryptUnprotectMemory(
    pDataIn: ?*c_void,
    cbDataIn: u32,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "DSSEC" fn DSCreateISecurityInfoObject(
    pwszObjectPath: ?[*:0]const u16,
    pwszObjectClass: ?[*:0]const u16,
    dwFlags: u32,
    ppSI: ?*?*ISecurityInformation,
    pfnReadSD: ?PFNREADOBJECTSECURITY,
    pfnWriteSD: ?PFNWRITEOBJECTSECURITY,
    lpContext: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "DSSEC" fn DSCreateISecurityInfoObjectEx(
    pwszObjectPath: ?[*:0]const u16,
    pwszObjectClass: ?[*:0]const u16,
    pwszServer: ?[*:0]const u16,
    pwszUserName: ?[*:0]const u16,
    pwszPassword: ?[*:0]const u16,
    dwFlags: u32,
    ppSI: ?*?*ISecurityInformation,
    pfnReadSD: ?PFNREADOBJECTSECURITY,
    pfnWriteSD: ?PFNWRITEOBJECTSECURITY,
    lpContext: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2003'
pub extern "DSSEC" fn DSCreateSecurityPage(
    pwszObjectPath: ?[*:0]const u16,
    pwszObjectClass: ?[*:0]const u16,
    dwFlags: u32,
    phPage: ?*?HPROPSHEETPAGE,
    pfnReadSD: ?PFNREADOBJECTSECURITY,
    pfnWriteSD: ?PFNWRITEOBJECTSECURITY,
    lpContext: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windowsServer2008'
pub extern "DSSEC" fn DSEditSecurity(
    hwndOwner: ?HWND,
    pwszObjectPath: ?[*:0]const u16,
    pwszObjectClass: ?[*:0]const u16,
    dwFlags: u32,
    pwszCaption: ?[*:0]const u16,
    pfnReadSD: ?PFNREADOBJECTSECURITY,
    pfnWriteSD: ?PFNWRITEOBJECTSECURITY,
    lpContext: LPARAM,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptSIPGetSignedDataMsg(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    pdwEncodingType: ?*CERT_QUERY_ENCODING_TYPE,
    dwIndex: u32,
    pcbSignedDataMsg: ?*u32,
    pbSignedDataMsg: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptSIPPutSignedDataMsg(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    dwEncodingType: CERT_QUERY_ENCODING_TYPE,
    pdwIndex: ?*u32,
    cbSignedDataMsg: u32,
    pbSignedDataMsg: ?*u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptSIPCreateIndirectData(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    pcbIndirectData: ?*u32,
    pIndirectData: ?*SIP_INDIRECT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptSIPVerifyIndirectData(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    pIndirectData: ?*SIP_INDIRECT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptSIPRemoveSignedDataMsg(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPLoad(
    pgSubject: ?*const Guid,
    dwFlags: u32,
    pSipDispatch: ?*SIP_DISPATCH_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPRetrieveSubjectGuid(
    FileName: ?[*:0]const u16,
    hFileIn: ?HANDLE,
    pgSubject: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPRetrieveSubjectGuidForCatalogFile(
    FileName: ?[*:0]const u16,
    hFileIn: ?HANDLE,
    pgSubject: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPAddProvider(
    psNewProv: ?*SIP_ADD_NEWPROVIDER,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "CRYPT32" fn CryptSIPRemoveProvider(
    pgProv: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINTRUST" fn CryptSIPGetCaps(
    pSubjInfo: ?*SIP_SUBJECTINFO,
    pCaps: ?*SIP_CAP_SET_V3,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINTRUST" fn CryptSIPGetSealedDigest(
    pSubjectInfo: ?*SIP_SUBJECTINFO,
    pSig: ?[*:0]const u8,
    dwSig: u32,
    pbDigest: ?[*:0]u8,
    pcbDigest: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATOpen(
    pwszFileName: ?PWSTR,
    fdwOpenFlags: CRYPTCAT_OPEN_FLAGS,
    hProv: usize,
    dwPublicVersion: CRYPTCAT_VERSION,
    dwEncodingType: u32,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATClose(
    hCatalog: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATStoreFromHandle(
    hCatalog: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATSTORE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATHandleFromStore(
    pCatStore: ?*CRYPTCATSTORE,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATPersistStore(
    hCatalog: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINTRUST" fn CryptCATGetCatAttrInfo(
    hCatalog: ?HANDLE,
    pwszReferenceTag: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATPutCatAttrInfo(
    hCatalog: ?HANDLE,
    pwszReferenceTag: ?PWSTR,
    dwAttrTypeAndAction: u32,
    cbData: u32,
    pbData: ?*u8,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATEnumerateCatAttr(
    hCatalog: ?HANDLE,
    pPrevAttr: ?*CRYPTCATATTRIBUTE,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATGetMemberInfo(
    hCatalog: ?HANDLE,
    pwszReferenceTag: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATMEMBER;

pub extern "WINTRUST" fn CryptCATAllocSortedMemberInfo(
    hCatalog: ?HANDLE,
    pwszReferenceTag: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATMEMBER;

pub extern "WINTRUST" fn CryptCATFreeSortedMemberInfo(
    hCatalog: ?HANDLE,
    pCatMember: ?*CRYPTCATMEMBER,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATGetAttrInfo(
    hCatalog: ?HANDLE,
    pCatMember: ?*CRYPTCATMEMBER,
    pwszReferenceTag: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATPutMemberInfo(
    hCatalog: ?HANDLE,
    pwszFileName: ?PWSTR,
    pwszReferenceTag: ?PWSTR,
    pgSubjectType: ?*Guid,
    dwCertVersion: u32,
    cbSIPIndirectData: u32,
    pbSIPIndirectData: ?*u8,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATMEMBER;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATPutAttrInfo(
    hCatalog: ?HANDLE,
    pCatMember: ?*CRYPTCATMEMBER,
    pwszReferenceTag: ?PWSTR,
    dwAttrTypeAndAction: u32,
    cbData: u32,
    pbData: ?*u8,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATEnumerateMember(
    hCatalog: ?HANDLE,
    pPrevMember: ?*CRYPTCATMEMBER,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATMEMBER;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATEnumerateAttr(
    hCatalog: ?HANDLE,
    pCatMember: ?*CRYPTCATMEMBER,
    pPrevAttr: ?*CRYPTCATATTRIBUTE,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATCDFOpen(
    pwszFilePath: ?PWSTR,
    pfnParseError: ?PFN_CDF_PARSE_ERROR_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATCDF;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATCDFClose(
    pCDF: ?*CRYPTCATCDF,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATCDFEnumCatAttributes(
    pCDF: ?*CRYPTCATCDF,
    pPrevAttr: ?*CRYPTCATATTRIBUTE,
    pfnParseError: ?PFN_CDF_PARSE_ERROR_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATATTRIBUTE;

pub extern "WINTRUST" fn CryptCATCDFEnumMembers(
    pCDF: ?*CRYPTCATCDF,
    pPrevMember: ?*CRYPTCATMEMBER,
    pfnParseError: ?PFN_CDF_PARSE_ERROR_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATMEMBER;

pub extern "WINTRUST" fn CryptCATCDFEnumAttributes(
    pCDF: ?*CRYPTCATCDF,
    pMember: ?*CRYPTCATMEMBER,
    pPrevAttr: ?*CRYPTCATATTRIBUTE,
    pfnParseError: ?PFN_CDF_PARSE_ERROR_CALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPTCATATTRIBUTE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn IsCatalogFile(
    hFile: ?HANDLE,
    pwszFileName: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminAcquireContext(
    phCatAdmin: ?*isize,
    pgSubsystem: ?*const Guid,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINTRUST" fn CryptCATAdminAcquireContext2(
    phCatAdmin: ?*isize,
    pgSubsystem: ?*const Guid,
    pwszHashAlgorithm: ?[*:0]const u16,
    pStrongHashPolicy: ?*CERT_STRONG_SIGN_PARA,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminReleaseContext(
    hCatAdmin: isize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminReleaseCatalogContext(
    hCatAdmin: isize,
    hCatInfo: isize,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminEnumCatalogFromHash(
    hCatAdmin: isize,
    // TODO: what to do with BytesParamIndex 2?
    pbHash: ?*u8,
    cbHash: u32,
    dwFlags: u32,
    phPrevCatInfo: ?*isize,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminCalcHashFromFileHandle(
    hFile: ?HANDLE,
    pcbHash: ?*u32,
    // TODO: what to do with BytesParamIndex 1?
    pbHash: ?*u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows8.0'
pub extern "WINTRUST" fn CryptCATAdminCalcHashFromFileHandle2(
    hCatAdmin: isize,
    hFile: ?HANDLE,
    pcbHash: ?*u32,
    // TODO: what to do with BytesParamIndex 2?
    pbHash: ?*u8,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminAddCatalog(
    hCatAdmin: isize,
    pwszCatalogFile: ?PWSTR,
    pwszSelectBaseName: ?PWSTR,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) isize;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminRemoveCatalog(
    hCatAdmin: isize,
    pwszCatalogFile: ?[*:0]const u16,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATCatalogInfoFromContext(
    hCatInfo: isize,
    psCatInfo: ?*CATALOG_INFO,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn CryptCATAdminResolveCatalogPath(
    hCatAdmin: isize,
    pwszCatalogFile: ?PWSTR,
    psCatInfo: ?*CATALOG_INFO,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "WINTRUST" fn CryptCATAdminPauseServiceForBackup(
    dwFlags: u32,
    fResume: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WinVerifyTrust(
    hwnd: ?HWND,
    pgActionID: ?*Guid,
    pWVTData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WinVerifyTrustEx(
    hwnd: ?HWND,
    pgActionID: ?*Guid,
    pWinTrustData: ?*WINTRUST_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustGetRegPolicyFlags(
    pdwPolicyFlags: ?*WINTRUST_POLICY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustSetRegPolicyFlags(
    dwPolicyFlags: WINTRUST_POLICY_FLAGS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustAddActionID(
    pgActionID: ?*Guid,
    fdwFlags: u32,
    psProvInfo: ?*CRYPT_REGISTER_ACTIONID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustRemoveActionID(
    pgActionID: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustLoadFunctionPointers(
    pgActionID: ?*Guid,
    pPfns: ?*CRYPT_PROVIDER_FUNCTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustAddDefaultForUsage(
    pszUsageOID: ?[*:0]const u8,
    psDefUsage: ?*CRYPT_PROVIDER_REGDEFUSAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WintrustGetDefaultForUsage(
    dwAction: WINTRUST_GET_DEFAULT_FOR_USAGE_ACTION,
    pszUsageOID: ?[*:0]const u8,
    psUsage: ?*CRYPT_PROVIDER_DEFUSAGE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperGetProvSignerFromChain(
    pProvData: ?*CRYPT_PROVIDER_DATA,
    idxSigner: u32,
    fCounterSigner: BOOL,
    idxCounterSigner: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_PROVIDER_SGNR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperGetProvCertFromChain(
    pSgnr: ?*CRYPT_PROVIDER_SGNR,
    idxCert: u32,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_PROVIDER_CERT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperProvDataFromStateData(
    hStateData: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_PROVIDER_DATA;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperGetProvPrivateDataFromChain(
    pProvData: ?*CRYPT_PROVIDER_DATA,
    pgProviderID: ?*Guid,
) callconv(@import("std").os.windows.WINAPI) ?*CRYPT_PROVIDER_PRIVDATA;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn WTHelperCertIsSelfSigned(
    dwEncoding: u32,
    pCert: ?*CERT_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WINTRUST" fn WTHelperCertCheckValidSignature(
    pProvData: ?*CRYPT_PROVIDER_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn OpenPersonalTrustDBDialogEx(
    hwndParent: ?HWND,
    dwFlags: u32,
    pvReserved: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "WINTRUST" fn OpenPersonalTrustDBDialog(
    hwndParent: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "WINTRUST" fn WintrustSetDefaultIncludePEPageHashes(
    fIncludePEPageHashes: BOOL,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferGetPolicyInformation(
    dwScopeId: u32,
    SaferPolicyInfoClass: SAFER_POLICY_INFO_CLASS,
    InfoBufferSize: u32,
    // TODO: what to do with BytesParamIndex 2?
    InfoBuffer: ?*c_void,
    InfoBufferRetSize: ?*u32,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferSetPolicyInformation(
    dwScopeId: u32,
    SaferPolicyInfoClass: SAFER_POLICY_INFO_CLASS,
    InfoBufferSize: u32,
    // TODO: what to do with BytesParamIndex 2?
    InfoBuffer: ?*c_void,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferCreateLevel(
    dwScopeId: u32,
    dwLevelId: u32,
    OpenFlags: u32,
    pLevelHandle: ?*SAFER_LEVEL_HANDLE,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferCloseLevel(
    hLevelHandle: SAFER_LEVEL_HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferIdentifyLevel(
    dwNumProperties: u32,
    pCodeProperties: ?[*]SAFER_CODE_PROPERTIES_V2,
    pLevelHandle: ?*SAFER_LEVEL_HANDLE,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferComputeTokenFromLevel(
    LevelHandle: SAFER_LEVEL_HANDLE,
    InAccessToken: ?HANDLE,
    OutAccessToken: ?*?HANDLE,
    dwFlags: SAFER_COMPUTE_TOKEN_FROM_LEVEL_FLAGS,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferGetLevelInformation(
    LevelHandle: SAFER_LEVEL_HANDLE,
    dwInfoType: SAFER_OBJECT_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    lpQueryBuffer: ?*c_void,
    dwInBufferSize: u32,
    lpdwOutBufferSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferSetLevelInformation(
    LevelHandle: SAFER_LEVEL_HANDLE,
    dwInfoType: SAFER_OBJECT_INFO_CLASS,
    // TODO: what to do with BytesParamIndex 3?
    lpQueryBuffer: ?*c_void,
    dwInBufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferRecordEventLogEntry(
    hLevel: SAFER_LEVEL_HANDLE,
    szTargetPath: ?[*:0]const u16,
    lpReserved: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SaferiIsExecutableFileType(
    szFullPathname: ?[*:0]const u16,
    bFromShellExecute: BOOLEAN,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqCreateSession(
    accessLevel: DdqAccessLevel,
    hSession: ?*HDIAGNOSTIC_DATA_QUERY_SESSION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqCloseSession(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetSessionAccessLevel(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    accessLevel: ?*DdqAccessLevel,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticDataAccessLevelAllowed(
    accessLevel: ?*DdqAccessLevel,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordStats(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    searchCriteria: ?*const DIAGNOSTIC_DATA_SEARCH_CRITERIA,
    recordCount: ?*u32,
    minRowId: ?*i64,
    maxRowId: ?*i64,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordPayload(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    rowId: i64,
    payload: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordLocaleTags(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    locale: ?[*:0]const u16,
    hTagDescription: ?*HDIAGNOSTIC_EVENT_TAG_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticRecordLocaleTags(
    hTagDescription: HDIAGNOSTIC_EVENT_TAG_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordLocaleTagAtIndex(
    hTagDescription: HDIAGNOSTIC_EVENT_TAG_DESCRIPTION,
    index: u32,
    tagDescription: ?*DIAGNOSTIC_DATA_EVENT_TAG_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordLocaleTagCount(
    hTagDescription: HDIAGNOSTIC_EVENT_TAG_DESCRIPTION,
    tagDescriptionCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordProducers(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    hProducerDescription: ?*HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticRecordProducers(
    hProducerDescription: HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordProducerAtIndex(
    hProducerDescription: HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION,
    index: u32,
    producerDescription: ?*DIAGNOSTIC_DATA_EVENT_PRODUCER_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordProducerCount(
    hProducerDescription: HDIAGNOSTIC_EVENT_PRODUCER_DESCRIPTION,
    producerDescriptionCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordProducerCategories(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    producerName: ?[*:0]const u16,
    hCategoryDescription: ?*HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticRecordProducerCategories(
    hCategoryDescription: HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordCategoryAtIndex(
    hCategoryDescription: HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION,
    index: u32,
    categoryDescription: ?*DIAGNOSTIC_DATA_EVENT_CATEGORY_DESCRIPTION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordCategoryCount(
    hCategoryDescription: HDIAGNOSTIC_EVENT_CATEGORY_DESCRIPTION,
    categoryDescriptionCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqIsDiagnosticRecordSampledIn(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    providerGroup: ?*const Guid,
    providerId: ?*const Guid,
    providerName: ?[*:0]const u16,
    eventId: ?*const u32,
    eventName: ?[*:0]const u16,
    eventVersion: ?*const u32,
    eventKeywords: ?*const u64,
    isSampledIn: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordPage(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    searchCriteria: ?*DIAGNOSTIC_DATA_SEARCH_CRITERIA,
    offset: u32,
    pageRecordCount: u32,
    baseRowId: i64,
    hRecord: ?*HDIAGNOSTIC_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticRecordPage(
    hRecord: HDIAGNOSTIC_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordAtIndex(
    hRecord: HDIAGNOSTIC_RECORD,
    index: u32,
    record: ?*DIAGNOSTIC_DATA_RECORD,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordCount(
    hRecord: HDIAGNOSTIC_RECORD,
    recordCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticReportStoreReportCount(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    reportStoreType: u32,
    reportCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqCancelDiagnosticRecordOperation(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticReport(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    reportStoreType: u32,
    hReport: ?*HDIAGNOSTIC_REPORT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqFreeDiagnosticReport(
    hReport: HDIAGNOSTIC_REPORT,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticReportAtIndex(
    hReport: HDIAGNOSTIC_REPORT,
    index: u32,
    report: ?*DIAGNOSTIC_REPORT_DATA,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticReportCount(
    hReport: HDIAGNOSTIC_REPORT,
    reportCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqExtractDiagnosticReport(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    reportStoreType: u32,
    reportKey: ?[*:0]const u16,
    destinationPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordTagDistribution(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    producerNames: [*]?PWSTR,
    producerNameCount: u32,
    tagStats: [*]?*DIAGNOSTIC_DATA_EVENT_TAG_STATS,
    statCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordBinaryDistribution(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    producerNames: [*]?PWSTR,
    producerNameCount: u32,
    topNBinaries: u32,
    binaryStats: [*]?*DIAGNOSTIC_DATA_EVENT_BINARY_STATS,
    statCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetDiagnosticRecordSummary(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    producerNames: [*]const ?[*:0]const u16,
    producerNameCount: u32,
    generalStats: ?*DIAGNOSTIC_DATA_GENERAL_STATS,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqSetTranscriptConfiguration(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    desiredConfig: ?*const DIAGNOSTIC_DATA_EVENT_TRANSCRIPT_CONFIGURATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows10.0.19041'
pub extern "DiagnosticDataQuery" fn DdqGetTranscriptConfiguration(
    hSession: HDIAGNOSTIC_DATA_QUERY_SESSION,
    currentConfig: ?*DIAGNOSTIC_DATA_EVENT_TRANSCRIPT_CONFIGURATION,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckAndAuditAlarmA(
    SubsystemName: ?[*:0]const u8,
    HandleId: ?*c_void,
    ObjectTypeName: ?PSTR,
    ObjectName: ?PSTR,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    DesiredAccess: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: ?*u32,
    AccessStatus: ?*i32,
    pfGenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByTypeAndAuditAlarmA(
    SubsystemName: ?[*:0]const u8,
    HandleId: ?*c_void,
    ObjectTypeName: ?[*:0]const u8,
    ObjectName: ?[*:0]const u8,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    PrincipalSelfSid: ?PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: ?*u32,
    AccessStatus: ?*i32,
    pfGenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByTypeResultListAndAuditAlarmA(
    SubsystemName: ?[*:0]const u8,
    HandleId: ?*c_void,
    ObjectTypeName: ?[*:0]const u8,
    ObjectName: ?[*:0]const u8,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    PrincipalSelfSid: ?PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: [*]u32,
    AccessStatusList: [*]u32,
    pfGenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn AccessCheckByTypeResultListAndAuditAlarmByHandleA(
    SubsystemName: ?[*:0]const u8,
    HandleId: ?*c_void,
    ClientToken: ?HANDLE,
    ObjectTypeName: ?[*:0]const u8,
    ObjectName: ?[*:0]const u8,
    SecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    PrincipalSelfSid: ?PSID,
    DesiredAccess: u32,
    AuditType: AUDIT_EVENT_TYPE,
    Flags: u32,
    ObjectTypeList: ?[*]OBJECT_TYPE_LIST,
    ObjectTypeListLength: u32,
    GenericMapping: ?*GENERIC_MAPPING,
    ObjectCreation: BOOL,
    GrantedAccess: [*]u32,
    AccessStatusList: [*]u32,
    pfGenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ObjectOpenAuditAlarmA(
    SubsystemName: ?[*:0]const u8,
    HandleId: ?*c_void,
    ObjectTypeName: ?PSTR,
    ObjectName: ?PSTR,
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    ClientToken: ?HANDLE,
    DesiredAccess: u32,
    GrantedAccess: u32,
    Privileges: ?*PRIVILEGE_SET,
    ObjectCreation: BOOL,
    AccessGranted: BOOL,
    GenerateOnClose: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ObjectPrivilegeAuditAlarmA(
    SubsystemName: ?[*:0]const u8,
    HandleId: ?*c_void,
    ClientToken: ?HANDLE,
    DesiredAccess: u32,
    Privileges: ?*PRIVILEGE_SET,
    AccessGranted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ObjectCloseAuditAlarmA(
    SubsystemName: ?[*:0]const u8,
    HandleId: ?*c_void,
    GenerateOnClose: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn ObjectDeleteAuditAlarmA(
    SubsystemName: ?[*:0]const u8,
    HandleId: ?*c_void,
    GenerateOnClose: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn PrivilegedServiceAuditAlarmA(
    SubsystemName: ?[*:0]const u8,
    ServiceName: ?[*:0]const u8,
    ClientToken: ?HANDLE,
    Privileges: ?*PRIVILEGE_SET,
    AccessGranted: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "ADVAPI32" fn AddConditionalAce(
    pAcl: ?*ACL,
    dwAceRevision: u32,
    AceFlags: ACE_FLAGS,
    AceType: u8,
    AccessMask: u32,
    pSid: ?PSID,
    ConditionStr: ?[*]u16,
    ReturnLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn SetFileSecurityA(
    lpFileName: ?[*:0]const u8,
    SecurityInformation: u32,
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn GetFileSecurityA(
    lpFileName: ?[*:0]const u8,
    RequestedInformation: u32,
    // TODO: what to do with BytesParamIndex 3?
    pSecurityDescriptor: ?*SECURITY_DESCRIPTOR,
    nLength: u32,
    lpnLengthNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupAccountSidA(
    lpSystemName: ?[*:0]const u8,
    Sid: ?PSID,
    Name: ?[*:0]u8,
    cchName: ?*u32,
    ReferencedDomainName: ?[*:0]u8,
    cchReferencedDomainName: ?*u32,
    peUse: ?*SID_NAME_USE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupAccountSidW(
    lpSystemName: ?[*:0]const u16,
    Sid: ?PSID,
    Name: ?[*:0]u16,
    cchName: ?*u32,
    ReferencedDomainName: ?[*:0]u16,
    cchReferencedDomainName: ?*u32,
    peUse: ?*SID_NAME_USE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupAccountNameA(
    lpSystemName: ?[*:0]const u8,
    lpAccountName: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 3?
    Sid: ?PSID,
    cbSid: ?*u32,
    ReferencedDomainName: ?[*:0]u8,
    cchReferencedDomainName: ?*u32,
    peUse: ?*SID_NAME_USE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupAccountNameW(
    lpSystemName: ?[*:0]const u16,
    lpAccountName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    Sid: ?PSID,
    cbSid: ?*u32,
    ReferencedDomainName: ?[*:0]u16,
    cchReferencedDomainName: ?*u32,
    peUse: ?*SID_NAME_USE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeValueA(
    lpSystemName: ?[*:0]const u8,
    lpName: ?[*:0]const u8,
    lpLuid: ?*LUID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeValueW(
    lpSystemName: ?[*:0]const u16,
    lpName: ?[*:0]const u16,
    lpLuid: ?*LUID,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeNameA(
    lpSystemName: ?[*:0]const u8,
    lpLuid: ?*LUID,
    lpName: ?[*:0]u8,
    cchName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeNameW(
    lpSystemName: ?[*:0]const u16,
    lpLuid: ?*LUID,
    lpName: ?[*:0]u16,
    cchName: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeDisplayNameA(
    lpSystemName: ?[*:0]const u8,
    lpName: ?[*:0]const u8,
    lpDisplayName: ?[*:0]u8,
    cchDisplayName: ?*u32,
    lpLanguageId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LookupPrivilegeDisplayNameW(
    lpSystemName: ?[*:0]const u16,
    lpName: ?[*:0]const u16,
    lpDisplayName: ?[*:0]u16,
    cchDisplayName: ?*u32,
    lpLanguageId: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LogonUserA(
    lpszUsername: ?[*:0]const u8,
    lpszDomain: ?[*:0]const u8,
    lpszPassword: ?[*:0]const u8,
    dwLogonType: LOGON32_LOGON,
    dwLogonProvider: LOGON32_PROVIDER,
    phToken: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LogonUserW(
    lpszUsername: ?[*:0]const u16,
    lpszDomain: ?[*:0]const u16,
    lpszPassword: ?[*:0]const u16,
    dwLogonType: LOGON32_LOGON,
    dwLogonProvider: LOGON32_PROVIDER,
    phToken: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LogonUserExA(
    lpszUsername: ?[*:0]const u8,
    lpszDomain: ?[*:0]const u8,
    lpszPassword: ?[*:0]const u8,
    dwLogonType: LOGON32_LOGON,
    dwLogonProvider: LOGON32_PROVIDER,
    phToken: ?*?HANDLE,
    ppLogonSid: ?*?PSID,
    // TODO: what to do with BytesParamIndex 8?
    ppProfileBuffer: ?*?*c_void,
    pdwProfileLength: ?*u32,
    pQuotaLimits: ?*QUOTA_LIMITS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ADVAPI32" fn LogonUserExW(
    lpszUsername: ?[*:0]const u16,
    lpszDomain: ?[*:0]const u16,
    lpszPassword: ?[*:0]const u16,
    dwLogonType: LOGON32_LOGON,
    dwLogonProvider: LOGON32_PROVIDER,
    phToken: ?*?HANDLE,
    ppLogonSid: ?*?PSID,
    // TODO: what to do with BytesParamIndex 8?
    ppProfileBuffer: ?*?*c_void,
    pdwProfileLength: ?*u32,
    pQuotaLimits: ?*QUOTA_LIMITS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "ntdll" fn RtlConvertSidToUnicodeString(
    UnicodeString: ?*UNICODE_STRING,
    Sid: ?PSID,
    AllocateDestinationString: BOOLEAN,
) callconv(@import("std").os.windows.WINAPI) NTSTATUS;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (18)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("zig.zig").unicode_mode) {
    .ansi => struct {
        pub const AccessCheckAndAuditAlarm = thismodule.AccessCheckAndAuditAlarmA;
        pub const AccessCheckByTypeAndAuditAlarm = thismodule.AccessCheckByTypeAndAuditAlarmA;
        pub const AccessCheckByTypeResultListAndAuditAlarm = thismodule.AccessCheckByTypeResultListAndAuditAlarmA;
        pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = thismodule.AccessCheckByTypeResultListAndAuditAlarmByHandleA;
        pub const GetFileSecurity = thismodule.GetFileSecurityA;
        pub const ObjectCloseAuditAlarm = thismodule.ObjectCloseAuditAlarmA;
        pub const ObjectDeleteAuditAlarm = thismodule.ObjectDeleteAuditAlarmA;
        pub const ObjectOpenAuditAlarm = thismodule.ObjectOpenAuditAlarmA;
        pub const ObjectPrivilegeAuditAlarm = thismodule.ObjectPrivilegeAuditAlarmA;
        pub const PrivilegedServiceAuditAlarm = thismodule.PrivilegedServiceAuditAlarmA;
        pub const SetFileSecurity = thismodule.SetFileSecurityA;
        pub const LookupAccountSid = thismodule.LookupAccountSidA;
        pub const LookupAccountName = thismodule.LookupAccountNameA;
        pub const LookupPrivilegeValue = thismodule.LookupPrivilegeValueA;
        pub const LookupPrivilegeName = thismodule.LookupPrivilegeNameA;
        pub const LookupPrivilegeDisplayName = thismodule.LookupPrivilegeDisplayNameA;
        pub const LogonUser = thismodule.LogonUserA;
        pub const LogonUserEx = thismodule.LogonUserExA;
    },
    .wide => struct {
        pub const AccessCheckAndAuditAlarm = thismodule.AccessCheckAndAuditAlarmW;
        pub const AccessCheckByTypeAndAuditAlarm = thismodule.AccessCheckByTypeAndAuditAlarmW;
        pub const AccessCheckByTypeResultListAndAuditAlarm = thismodule.AccessCheckByTypeResultListAndAuditAlarmW;
        pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = thismodule.AccessCheckByTypeResultListAndAuditAlarmByHandleW;
        pub const GetFileSecurity = thismodule.GetFileSecurityW;
        pub const ObjectCloseAuditAlarm = thismodule.ObjectCloseAuditAlarmW;
        pub const ObjectDeleteAuditAlarm = thismodule.ObjectDeleteAuditAlarmW;
        pub const ObjectOpenAuditAlarm = thismodule.ObjectOpenAuditAlarmW;
        pub const ObjectPrivilegeAuditAlarm = thismodule.ObjectPrivilegeAuditAlarmW;
        pub const PrivilegedServiceAuditAlarm = thismodule.PrivilegedServiceAuditAlarmW;
        pub const SetFileSecurity = thismodule.SetFileSecurityW;
        pub const LookupAccountSid = thismodule.LookupAccountSidW;
        pub const LookupAccountName = thismodule.LookupAccountNameW;
        pub const LookupPrivilegeValue = thismodule.LookupPrivilegeValueW;
        pub const LookupPrivilegeName = thismodule.LookupPrivilegeNameW;
        pub const LookupPrivilegeDisplayName = thismodule.LookupPrivilegeDisplayNameW;
        pub const LogonUser = thismodule.LogonUserW;
        pub const LogonUserEx = thismodule.LogonUserExW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const AccessCheckAndAuditAlarm = *opaque{};
        pub const AccessCheckByTypeAndAuditAlarm = *opaque{};
        pub const AccessCheckByTypeResultListAndAuditAlarm = *opaque{};
        pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = *opaque{};
        pub const GetFileSecurity = *opaque{};
        pub const ObjectCloseAuditAlarm = *opaque{};
        pub const ObjectDeleteAuditAlarm = *opaque{};
        pub const ObjectOpenAuditAlarm = *opaque{};
        pub const ObjectPrivilegeAuditAlarm = *opaque{};
        pub const PrivilegedServiceAuditAlarm = *opaque{};
        pub const SetFileSecurity = *opaque{};
        pub const LookupAccountSid = *opaque{};
        pub const LookupAccountName = *opaque{};
        pub const LookupPrivilegeValue = *opaque{};
        pub const LookupPrivilegeName = *opaque{};
        pub const LookupPrivilegeDisplayName = *opaque{};
        pub const LogonUser = *opaque{};
        pub const LogonUserEx = *opaque{};
    } else struct {
        pub const AccessCheckAndAuditAlarm = @compileError("'AccessCheckAndAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const AccessCheckByTypeAndAuditAlarm = @compileError("'AccessCheckByTypeAndAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const AccessCheckByTypeResultListAndAuditAlarm = @compileError("'AccessCheckByTypeResultListAndAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const AccessCheckByTypeResultListAndAuditAlarmByHandle = @compileError("'AccessCheckByTypeResultListAndAuditAlarmByHandle' requires that UNICODE be set to true or false in the root module");
        pub const GetFileSecurity = @compileError("'GetFileSecurity' requires that UNICODE be set to true or false in the root module");
        pub const ObjectCloseAuditAlarm = @compileError("'ObjectCloseAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const ObjectDeleteAuditAlarm = @compileError("'ObjectDeleteAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const ObjectOpenAuditAlarm = @compileError("'ObjectOpenAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const ObjectPrivilegeAuditAlarm = @compileError("'ObjectPrivilegeAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const PrivilegedServiceAuditAlarm = @compileError("'PrivilegedServiceAuditAlarm' requires that UNICODE be set to true or false in the root module");
        pub const SetFileSecurity = @compileError("'SetFileSecurity' requires that UNICODE be set to true or false in the root module");
        pub const LookupAccountSid = @compileError("'LookupAccountSid' requires that UNICODE be set to true or false in the root module");
        pub const LookupAccountName = @compileError("'LookupAccountName' requires that UNICODE be set to true or false in the root module");
        pub const LookupPrivilegeValue = @compileError("'LookupPrivilegeValue' requires that UNICODE be set to true or false in the root module");
        pub const LookupPrivilegeName = @compileError("'LookupPrivilegeName' requires that UNICODE be set to true or false in the root module");
        pub const LookupPrivilegeDisplayName = @compileError("'LookupPrivilegeDisplayName' requires that UNICODE be set to true or false in the root module");
        pub const LogonUser = @compileError("'LogonUser' requires that UNICODE be set to true or false in the root module");
        pub const LogonUserEx = @compileError("'LogonUserEx' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (39)
//--------------------------------------------------------------------------------
const Guid = @import("zig.zig").Guid;
const BOOL = @import("foundation.zig").BOOL;
const BOOLEAN = @import("foundation.zig").BOOLEAN;
const BSTR = @import("foundation.zig").BSTR;
const CERT_CHAIN_CONTEXT = @import("security/cryptography/core.zig").CERT_CHAIN_CONTEXT;
const CERT_CHAIN_ELEMENT = @import("security/cryptography/core.zig").CERT_CHAIN_ELEMENT;
const CERT_CONTEXT = @import("security/cryptography/core.zig").CERT_CONTEXT;
const CERT_INFO = @import("security/cryptography/core.zig").CERT_INFO;
const CERT_QUERY_ENCODING_TYPE = @import("security/cryptography/core.zig").CERT_QUERY_ENCODING_TYPE;
const CERT_STRONG_SIGN_PARA = @import("security/cryptography/core.zig").CERT_STRONG_SIGN_PARA;
const CERT_USAGE_MATCH = @import("security/cryptography/core.zig").CERT_USAGE_MATCH;
const CHAR = @import("system/system_services.zig").CHAR;
const CMSG_SIGNER_INFO = @import("security/cryptography/core.zig").CMSG_SIGNER_INFO;
const CRYPT_ALGORITHM_IDENTIFIER = @import("security/cryptography/core.zig").CRYPT_ALGORITHM_IDENTIFIER;
const CRYPT_ATTRIBUTE_TYPE_VALUE = @import("security/cryptography/core.zig").CRYPT_ATTRIBUTE_TYPE_VALUE;
const CRYPT_BIT_BLOB = @import("security/cryptography/core.zig").CRYPT_BIT_BLOB;
const CRYPTOAPI_BLOB = @import("security/cryptography/core.zig").CRYPTOAPI_BLOB;
const CTL_CONTEXT = @import("security/cryptography/core.zig").CTL_CONTEXT;
const DLGPROC = @import("ui/windows_and_messaging.zig").DLGPROC;
const DLGTEMPLATE = @import("ui/windows_and_messaging.zig").DLGTEMPLATE;
const FILETIME = @import("foundation.zig").FILETIME;
const HANDLE = @import("foundation.zig").HANDLE;
const HDESK = @import("system/stations_and_desktops.zig").HDESK;
const HPROPSHEETPAGE = @import("ui/controls.zig").HPROPSHEETPAGE;
const HRESULT = @import("foundation.zig").HRESULT;
const HWND = @import("foundation.zig").HWND;
const IDispatch = @import("system/ole_automation.zig").IDispatch;
const ISecurityInformation = @import("security/authorization.zig").ISecurityInformation;
const IUnknown = @import("system/com.zig").IUnknown;
const LARGE_INTEGER = @import("system/system_services.zig").LARGE_INTEGER;
const LPARAM = @import("foundation.zig").LPARAM;
const LUID = @import("system/system_services.zig").LUID;
const NTSTATUS = @import("foundation.zig").NTSTATUS;
const OBJECT_SECURITY_INFORMATION = @import("security/authorization.zig").OBJECT_SECURITY_INFORMATION;
const PSID = @import("foundation.zig").PSID;
const PSTR = @import("foundation.zig").PSTR;
const PWSTR = @import("foundation.zig").PWSTR;
const UNICODE_STRING = @import("system/kernel.zig").UNICODE_STRING;
const VARIANT = @import("system/ole_automation.zig").VARIANT;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PLSA_AP_CALL_PACKAGE_UNTRUSTED")) { _ = PLSA_AP_CALL_PACKAGE_UNTRUSTED; }
    if (@hasDecl(@This(), "SEC_THREAD_START")) { _ = SEC_THREAD_START; }
    if (@hasDecl(@This(), "PWLX_USE_CTRL_ALT_DEL")) { _ = PWLX_USE_CTRL_ALT_DEL; }
    if (@hasDecl(@This(), "PWLX_SET_CONTEXT_POINTER")) { _ = PWLX_SET_CONTEXT_POINTER; }
    if (@hasDecl(@This(), "PWLX_SAS_NOTIFY")) { _ = PWLX_SAS_NOTIFY; }
    if (@hasDecl(@This(), "PWLX_SET_TIMEOUT")) { _ = PWLX_SET_TIMEOUT; }
    if (@hasDecl(@This(), "PWLX_ASSIGN_SHELL_PROTECTION")) { _ = PWLX_ASSIGN_SHELL_PROTECTION; }
    if (@hasDecl(@This(), "PWLX_MESSAGE_BOX")) { _ = PWLX_MESSAGE_BOX; }
    if (@hasDecl(@This(), "PWLX_DIALOG_BOX")) { _ = PWLX_DIALOG_BOX; }
    if (@hasDecl(@This(), "PWLX_DIALOG_BOX_INDIRECT")) { _ = PWLX_DIALOG_BOX_INDIRECT; }
    if (@hasDecl(@This(), "PWLX_DIALOG_BOX_PARAM")) { _ = PWLX_DIALOG_BOX_PARAM; }
    if (@hasDecl(@This(), "PWLX_DIALOG_BOX_INDIRECT_PARAM")) { _ = PWLX_DIALOG_BOX_INDIRECT_PARAM; }
    if (@hasDecl(@This(), "PWLX_SWITCH_DESKTOP_TO_USER")) { _ = PWLX_SWITCH_DESKTOP_TO_USER; }
    if (@hasDecl(@This(), "PWLX_SWITCH_DESKTOP_TO_WINLOGON")) { _ = PWLX_SWITCH_DESKTOP_TO_WINLOGON; }
    if (@hasDecl(@This(), "PWLX_CHANGE_PASSWORD_NOTIFY")) { _ = PWLX_CHANGE_PASSWORD_NOTIFY; }
    if (@hasDecl(@This(), "PWLX_GET_SOURCE_DESKTOP")) { _ = PWLX_GET_SOURCE_DESKTOP; }
    if (@hasDecl(@This(), "PWLX_SET_RETURN_DESKTOP")) { _ = PWLX_SET_RETURN_DESKTOP; }
    if (@hasDecl(@This(), "PWLX_CREATE_USER_DESKTOP")) { _ = PWLX_CREATE_USER_DESKTOP; }
    if (@hasDecl(@This(), "PWLX_CHANGE_PASSWORD_NOTIFY_EX")) { _ = PWLX_CHANGE_PASSWORD_NOTIFY_EX; }
    if (@hasDecl(@This(), "PWLX_CLOSE_USER_DESKTOP")) { _ = PWLX_CLOSE_USER_DESKTOP; }
    if (@hasDecl(@This(), "PWLX_SET_OPTION")) { _ = PWLX_SET_OPTION; }
    if (@hasDecl(@This(), "PWLX_GET_OPTION")) { _ = PWLX_GET_OPTION; }
    if (@hasDecl(@This(), "PWLX_WIN31_MIGRATE")) { _ = PWLX_WIN31_MIGRATE; }
    if (@hasDecl(@This(), "PWLX_QUERY_CLIENT_CREDENTIALS")) { _ = PWLX_QUERY_CLIENT_CREDENTIALS; }
    if (@hasDecl(@This(), "PWLX_QUERY_IC_CREDENTIALS")) { _ = PWLX_QUERY_IC_CREDENTIALS; }
    if (@hasDecl(@This(), "PWLX_QUERY_TS_LOGON_CREDENTIALS")) { _ = PWLX_QUERY_TS_LOGON_CREDENTIALS; }
    if (@hasDecl(@This(), "PWLX_DISCONNECT")) { _ = PWLX_DISCONNECT; }
    if (@hasDecl(@This(), "PWLX_QUERY_TERMINAL_SERVICES_DATA")) { _ = PWLX_QUERY_TERMINAL_SERVICES_DATA; }
    if (@hasDecl(@This(), "PWLX_QUERY_CONSOLESWITCH_CREDENTIALS")) { _ = PWLX_QUERY_CONSOLESWITCH_CREDENTIALS; }
    if (@hasDecl(@This(), "PFNMSGECALLBACK")) { _ = PFNMSGECALLBACK; }
    if (@hasDecl(@This(), "PFNREADOBJECTSECURITY")) { _ = PFNREADOBJECTSECURITY; }
    if (@hasDecl(@This(), "PFNWRITEOBJECTSECURITY")) { _ = PFNWRITEOBJECTSECURITY; }
    if (@hasDecl(@This(), "PFNDSCREATEISECINFO")) { _ = PFNDSCREATEISECINFO; }
    if (@hasDecl(@This(), "PFNDSCREATEISECINFOEX")) { _ = PFNDSCREATEISECINFOEX; }
    if (@hasDecl(@This(), "PFNDSCREATESECPAGE")) { _ = PFNDSCREATESECPAGE; }
    if (@hasDecl(@This(), "PFNDSEDITSECURITY")) { _ = PFNDSEDITSECURITY; }
    if (@hasDecl(@This(), "pCryptSIPGetSignedDataMsg")) { _ = pCryptSIPGetSignedDataMsg; }
    if (@hasDecl(@This(), "pCryptSIPPutSignedDataMsg")) { _ = pCryptSIPPutSignedDataMsg; }
    if (@hasDecl(@This(), "pCryptSIPCreateIndirectData")) { _ = pCryptSIPCreateIndirectData; }
    if (@hasDecl(@This(), "pCryptSIPVerifyIndirectData")) { _ = pCryptSIPVerifyIndirectData; }
    if (@hasDecl(@This(), "pCryptSIPRemoveSignedDataMsg")) { _ = pCryptSIPRemoveSignedDataMsg; }
    if (@hasDecl(@This(), "pfnIsFileSupported")) { _ = pfnIsFileSupported; }
    if (@hasDecl(@This(), "pfnIsFileSupportedName")) { _ = pfnIsFileSupportedName; }
    if (@hasDecl(@This(), "pCryptSIPGetCaps")) { _ = pCryptSIPGetCaps; }
    if (@hasDecl(@This(), "pCryptSIPGetSealedDigest")) { _ = pCryptSIPGetSealedDigest; }
    if (@hasDecl(@This(), "PFN_CDF_PARSE_ERROR_CALLBACK")) { _ = PFN_CDF_PARSE_ERROR_CALLBACK; }
    if (@hasDecl(@This(), "PFN_CPD_MEM_ALLOC")) { _ = PFN_CPD_MEM_ALLOC; }
    if (@hasDecl(@This(), "PFN_CPD_MEM_FREE")) { _ = PFN_CPD_MEM_FREE; }
    if (@hasDecl(@This(), "PFN_CPD_ADD_STORE")) { _ = PFN_CPD_ADD_STORE; }
    if (@hasDecl(@This(), "PFN_CPD_ADD_SGNR")) { _ = PFN_CPD_ADD_SGNR; }
    if (@hasDecl(@This(), "PFN_CPD_ADD_CERT")) { _ = PFN_CPD_ADD_CERT; }
    if (@hasDecl(@This(), "PFN_CPD_ADD_PRIVDATA")) { _ = PFN_CPD_ADD_PRIVDATA; }
    if (@hasDecl(@This(), "PFN_PROVIDER_INIT_CALL")) { _ = PFN_PROVIDER_INIT_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_OBJTRUST_CALL")) { _ = PFN_PROVIDER_OBJTRUST_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_SIGTRUST_CALL")) { _ = PFN_PROVIDER_SIGTRUST_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_CERTTRUST_CALL")) { _ = PFN_PROVIDER_CERTTRUST_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_FINALPOLICY_CALL")) { _ = PFN_PROVIDER_FINALPOLICY_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_TESTFINALPOLICY_CALL")) { _ = PFN_PROVIDER_TESTFINALPOLICY_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_CLEANUP_CALL")) { _ = PFN_PROVIDER_CLEANUP_CALL; }
    if (@hasDecl(@This(), "PFN_PROVIDER_CERTCHKPOLICY_CALL")) { _ = PFN_PROVIDER_CERTCHKPOLICY_CALL; }
    if (@hasDecl(@This(), "PFN_PROVUI_CALL")) { _ = PFN_PROVUI_CALL; }
    if (@hasDecl(@This(), "PFN_ALLOCANDFILLDEFUSAGE")) { _ = PFN_ALLOCANDFILLDEFUSAGE; }
    if (@hasDecl(@This(), "PFN_FREEDEFUSAGE")) { _ = PFN_FREEDEFUSAGE; }
    if (@hasDecl(@This(), "PFSCE_QUERY_INFO")) { _ = PFSCE_QUERY_INFO; }
    if (@hasDecl(@This(), "PFSCE_SET_INFO")) { _ = PFSCE_SET_INFO; }
    if (@hasDecl(@This(), "PFSCE_FREE_INFO")) { _ = PFSCE_FREE_INFO; }
    if (@hasDecl(@This(), "PFSCE_LOG_INFO")) { _ = PFSCE_LOG_INFO; }
    if (@hasDecl(@This(), "PF_ConfigAnalyzeService")) { _ = PF_ConfigAnalyzeService; }
    if (@hasDecl(@This(), "PF_UpdateService")) { _ = PF_UpdateService; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
//--------------------------------------------------------------------------------
// Section: SubModules (7)
//--------------------------------------------------------------------------------
pub const authentication = @import("security/authentication.zig");
pub const authorization = @import("security/authorization.zig");
pub const credentials = @import("security/credentials.zig");
pub const cryptography = @import("security/cryptography.zig");
pub const enterprise_data = @import("security/enterprise_data.zig");
pub const extensible_authentication_protocol = @import("security/extensible_authentication_protocol.zig");
pub const isolation = @import("security/isolation.zig");
