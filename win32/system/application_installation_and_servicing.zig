//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (83)
//--------------------------------------------------------------------------------
pub const LOGTOKEN_TYPE_MASK = @as(u32, 3);
pub const LOGTOKEN_UNSPECIFIED = @as(u32, 0);
pub const LOGTOKEN_NO_LOG = @as(u32, 1);
pub const LOGTOKEN_SETUPAPI_APPLOG = @as(u32, 2);
pub const LOGTOKEN_SETUPAPI_DEVLOG = @as(u32, 3);
pub const TXTLOG_SETUPAPI_DEVLOG = @as(u32, 1);
pub const TXTLOG_SETUPAPI_CMDLINE = @as(u32, 2);
pub const TXTLOG_SETUPAPI_BITS = @as(u32, 3);
pub const TXTLOG_ERROR = @as(u32, 1);
pub const TXTLOG_WARNING = @as(u32, 2);
pub const TXTLOG_SYSTEM_STATE_CHANGE = @as(u32, 3);
pub const TXTLOG_SUMMARY = @as(u32, 4);
pub const TXTLOG_DETAILS = @as(u32, 5);
pub const TXTLOG_VERBOSE = @as(u32, 6);
pub const TXTLOG_VERY_VERBOSE = @as(u32, 7);
pub const TXTLOG_RESERVED_FLAGS = @as(u32, 65520);
pub const TXTLOG_TIMESTAMP = @as(u32, 65536);
pub const TXTLOG_DEPTH_INCR = @as(u32, 131072);
pub const TXTLOG_DEPTH_DECR = @as(u32, 262144);
pub const TXTLOG_TAB_1 = @as(u32, 524288);
pub const TXTLOG_FLUSH_FILE = @as(u32, 1048576);
pub const TXTLOG_DEVINST = @as(u32, 1);
pub const TXTLOG_INF = @as(u32, 2);
pub const TXTLOG_FILEQ = @as(u32, 4);
pub const TXTLOG_COPYFILES = @as(u32, 8);
pub const TXTLOG_SIGVERIF = @as(u32, 32);
pub const TXTLOG_BACKUP = @as(u32, 128);
pub const TXTLOG_UI = @as(u32, 256);
pub const TXTLOG_UTIL = @as(u32, 512);
pub const TXTLOG_INFDB = @as(u32, 1024);
pub const TXTLOG_DRVSETUP = @as(u32, 4194304);
pub const TXTLOG_POLICY = @as(u32, 8388608);
pub const TXTLOG_NEWDEV = @as(u32, 16777216);
pub const TXTLOG_UMPNPMGR = @as(u32, 33554432);
pub const TXTLOG_DRIVER_STORE = @as(u32, 67108864);
pub const TXTLOG_SETUP = @as(u32, 134217728);
pub const TXTLOG_CMI = @as(u32, 268435456);
pub const TXTLOG_DEVMGR = @as(u32, 536870912);
pub const TXTLOG_INSTALLER = @as(u32, 1073741824);
pub const TXTLOG_VENDOR = @as(u32, 2147483648);
pub const CLSID_EvalCom2 = Guid.initString("6e5e1910-8053-4660-b795-6b612e29bc58");
pub const _WIN32_MSM = @as(u32, 100);
pub const LIBID_MsmMergeTypeLib = Guid.initString("0adda82f-2c26-11d2-ad65-00a0c9af11a6");
pub const CLSID_MsmMerge2 = Guid.initString("f94985d5-29f9-4743-9805-99bc3f35b678");
pub const NTDDI_WIN2K = @as(u32, 83886080);
pub const NTDDI_WINXP = @as(u32, 83951616);
pub const NTDDI_WINXPSP2 = @as(u32, 83952128);
pub const NTDDI_WS03SP1 = @as(u32, 84017408);
pub const NTDDI_VISTA = @as(u32, 100663296);
pub const NTDDI_VISTASP1 = @as(u32, 100663552);
pub const NTDDI_WIN7 = @as(u32, 100728832);
pub const NTDDI_WIN8 = @as(u32, 100794368);
pub const NTDDI_WINBLUE = @as(u32, 100859904);
pub const NTDDI_WINTHRESHOLD = @as(u32, 100925440);
pub const MAX_GUID_CHARS = @as(u32, 38);
pub const MAX_FEATURE_CHARS = @as(u32, 38);
pub const MSI_INVALID_HASH_IS_FATAL = @as(u32, 1);
pub const ERROR_ROLLBACK_DISABLED = @as(u32, 1653);
pub const MSI_NULL_INTEGER = @as(u32, 2147483648);
pub const INSTALLMESSAGE_TYPEMASK = @as(i32, -16777216);
pub const STREAM_FORMAT_COMPLIB_MODULE = @as(u32, 0);
pub const STREAM_FORMAT_COMPLIB_MANIFEST = @as(u32, 1);
pub const STREAM_FORMAT_WIN32_MODULE = @as(u32, 2);
pub const STREAM_FORMAT_WIN32_MANIFEST = @as(u32, 4);
pub const IASSEMBLYCACHEITEM_COMMIT_FLAG_REFRESH = @as(u32, 1);
pub const ASSEMBLYINFO_FLAG_INSTALLED = @as(u32, 1);
pub const ASSEMBLYINFO_FLAG_PAYLOADRESIDENT = @as(u32, 2);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_INSTALLED = @as(u32, 1);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_REFRESHED = @as(u32, 2);
pub const IASSEMBLYCACHEITEM_COMMIT_DISPOSITION_ALREADY_INSTALLED = @as(u32, 3);
pub const FUSION_REFCOUNT_UNINSTALL_SUBKEY_GUID = Guid.initString("8cedc215-ac4b-488b-93c0-a50a49cb2fb8");
pub const FUSION_REFCOUNT_FILEPATH_GUID = Guid.initString("b02f9d65-fb77-4f7a-afa5-b391309f11c9");
pub const FUSION_REFCOUNT_OPAQUE_STRING_GUID = Guid.initString("2ec93463-b0c3-45e1-8364-327e96aea856");
pub const SFC_DISABLE_NORMAL = @as(u32, 0);
pub const SFC_DISABLE_ASK = @as(u32, 1);
pub const SFC_DISABLE_ONCE = @as(u32, 2);
pub const SFC_DISABLE_SETUP = @as(u32, 3);
pub const SFC_DISABLE_NOPOPUPS = @as(u32, 4);
pub const SFC_SCAN_NORMAL = @as(u32, 0);
pub const SFC_SCAN_ALWAYS = @as(u32, 1);
pub const SFC_SCAN_ONCE = @as(u32, 2);
pub const SFC_SCAN_IMMEDIATE = @as(u32, 3);
pub const SFC_QUOTA_DEFAULT = @as(u32, 50);

//--------------------------------------------------------------------------------
// Section: Types (83)
//--------------------------------------------------------------------------------
pub const MSIASSEMBLYINFO = enum(u32) {
    NETASSEMBLY = 0,
    WIN32ASSEMBLY = 1,
};
pub const MSIASSEMBLYINFO_NETASSEMBLY = MSIASSEMBLYINFO.NETASSEMBLY;
pub const MSIASSEMBLYINFO_WIN32ASSEMBLY = MSIASSEMBLYINFO.WIN32ASSEMBLY;

pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION = enum(u32) {
    UNINSTALLED = 1,
    STILL_IN_USE = 2,
    ALREADY_UNINSTALLED = 3,
    DELETE_PENDING = 4,
};
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_UNINSTALLED = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.UNINSTALLED;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_STILL_IN_USE = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.STILL_IN_USE;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_ALREADY_UNINSTALLED = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.ALREADY_UNINSTALLED;
pub const IASSEMBLYCACHE_UNINSTALL_DISPOSITION_DELETE_PENDING = IASSEMBLYCACHE_UNINSTALL_DISPOSITION.DELETE_PENDING;

pub const QUERYASMINFO_FLAGS = enum(u32) {
    E = 1,
    _,
    pub fn initFlags(o: struct {
        E: u1 = 0,
    }) QUERYASMINFO_FLAGS {
        return @intToEnum(QUERYASMINFO_FLAGS,
              (if (o.E == 1) @enumToInt(QUERYASMINFO_FLAGS.E) else 0)
        );
    }
};
pub const QUERYASMINFO_FLAG_VALIDATE = QUERYASMINFO_FLAGS.E;

// TODO: this type has a FreeFunc 'MsiCloseHandle', what can Zig do with this information?
pub const MSIHANDLE = u32;

pub const ACTIVATION_CONTEXT_QUERY_INDEX = extern struct {
    ulAssemblyIndex: u32,
    ulFileIndexInAssembly: u32,
};

pub const ASSEMBLY_FILE_DETAILED_INFORMATION = extern struct {
    ulFlags: u32,
    ulFilenameLength: u32,
    ulPathLength: u32,
    lpFileName: ?[*:0]const u16,
    lpFilePath: ?[*:0]const u16,
};

pub const ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION = extern struct {
    ulFlags: u32,
    ulEncodedAssemblyIdentityLength: u32,
    ulManifestPathType: u32,
    ulManifestPathLength: u32,
    liManifestLastWriteTime: LARGE_INTEGER,
    ulPolicyPathType: u32,
    ulPolicyPathLength: u32,
    liPolicyLastWriteTime: LARGE_INTEGER,
    ulMetadataSatelliteRosterIndex: u32,
    ulManifestVersionMajor: u32,
    ulManifestVersionMinor: u32,
    ulPolicyVersionMajor: u32,
    ulPolicyVersionMinor: u32,
    ulAssemblyDirectoryNameLength: u32,
    lpAssemblyEncodedAssemblyIdentity: ?[*:0]const u16,
    lpAssemblyManifestPath: ?[*:0]const u16,
    lpAssemblyPolicyPath: ?[*:0]const u16,
    lpAssemblyDirectoryName: ?[*:0]const u16,
    ulFileCount: u32,
};

pub const ACTCTX_REQUESTED_RUN_LEVEL = enum(i32) {
    UNSPECIFIED = 0,
    AS_INVOKER = 1,
    HIGHEST_AVAILABLE = 2,
    REQUIRE_ADMIN = 3,
    NUMBERS = 4,
};
pub const ACTCTX_RUN_LEVEL_UNSPECIFIED = ACTCTX_REQUESTED_RUN_LEVEL.UNSPECIFIED;
pub const ACTCTX_RUN_LEVEL_AS_INVOKER = ACTCTX_REQUESTED_RUN_LEVEL.AS_INVOKER;
pub const ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE = ACTCTX_REQUESTED_RUN_LEVEL.HIGHEST_AVAILABLE;
pub const ACTCTX_RUN_LEVEL_REQUIRE_ADMIN = ACTCTX_REQUESTED_RUN_LEVEL.REQUIRE_ADMIN;
pub const ACTCTX_RUN_LEVEL_NUMBERS = ACTCTX_REQUESTED_RUN_LEVEL.NUMBERS;

pub const ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION = extern struct {
    ulFlags: u32,
    RunLevel: ACTCTX_REQUESTED_RUN_LEVEL,
    UiAccess: u32,
};

pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE = enum(i32) {
    UNKNOWN = 0,
    OS = 1,
    MITIGATION = 2,
    MAXVERSIONTESTED = 3,
};
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.UNKNOWN;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.OS;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.MITIGATION;
pub const ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MAXVERSIONTESTED = ACTCTX_COMPATIBILITY_ELEMENT_TYPE.MAXVERSIONTESTED;

pub const COMPATIBILITY_CONTEXT_ELEMENT = extern struct {
    Id: Guid,
    Type: ACTCTX_COMPATIBILITY_ELEMENT_TYPE,
    MaxVersionTested: u64,
};

pub const ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION = extern struct {
    ElementCount: u32,
    Elements: [1]COMPATIBILITY_CONTEXT_ELEMENT,
};

pub const ACTIVATION_CONTEXT_DETAILED_INFORMATION = extern struct {
    dwFlags: u32,
    ulFormatVersion: u32,
    ulAssemblyCount: u32,
    ulRootManifestPathType: u32,
    ulRootManifestPathChars: u32,
    ulRootConfigurationPathType: u32,
    ulRootConfigurationPathChars: u32,
    ulAppDirPathType: u32,
    ulAppDirPathChars: u32,
    lpRootManifestPath: ?[*:0]const u16,
    lpRootConfigurationPath: ?[*:0]const u16,
    lpAppDirPath: ?[*:0]const u16,
};

pub const RESULTTYPES = enum(i32) {
    Unknown = 0,
    Error = 1,
    Warning = 2,
    Info = 3,
};
pub const ieUnknown = RESULTTYPES.Unknown;
pub const ieError = RESULTTYPES.Error;
pub const ieWarning = RESULTTYPES.Warning;
pub const ieInfo = RESULTTYPES.Info;

pub const STATUSTYPES = enum(i32) {
    GetCUB = 0,
    ICECount = 1,
    Merge = 2,
    SummaryInfo = 3,
    CreateEngine = 4,
    Starting = 5,
    RunICE = 6,
    Shutdown = 7,
    Success = 8,
    Fail = 9,
    Cancel = 10,
};
pub const ieStatusGetCUB = STATUSTYPES.GetCUB;
pub const ieStatusICECount = STATUSTYPES.ICECount;
pub const ieStatusMerge = STATUSTYPES.Merge;
pub const ieStatusSummaryInfo = STATUSTYPES.SummaryInfo;
pub const ieStatusCreateEngine = STATUSTYPES.CreateEngine;
pub const ieStatusStarting = STATUSTYPES.Starting;
pub const ieStatusRunICE = STATUSTYPES.RunICE;
pub const ieStatusShutdown = STATUSTYPES.Shutdown;
pub const ieStatusSuccess = STATUSTYPES.Success;
pub const ieStatusFail = STATUSTYPES.Fail;
pub const ieStatusCancel = STATUSTYPES.Cancel;

pub const LPDISPLAYVAL = fn(
    pContext: ?*c_void,
    uiType: RESULTTYPES,
    szwVal: ?[*:0]const u16,
    szwDescription: ?[*:0]const u16,
    szwLocation: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPEVALCOMCALLBACK = fn(
    iStatus: STATUSTYPES,
    szData: ?[*:0]const u16,
    pContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const IID_IValidate_Value = @import("../zig.zig").Guid.initString("e482e5c6-e31e-4143-a2e6-dbc3d8e4b8d3");
pub const IID_IValidate = &IID_IValidate_Value;
pub const IValidate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OpenDatabase: fn(
            self: *const IValidate,
            szDatabase: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenCUB: fn(
            self: *const IValidate,
            szCUBFile: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDatabase: fn(
            self: *const IValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseCUB: fn(
            self: *const IValidate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDisplay: fn(
            self: *const IValidate,
            pDisplayFunction: ?LPDISPLAYVAL,
            pContext: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStatus: fn(
            self: *const IValidate,
            pStatusFunction: ?LPEVALCOMCALLBACK,
            pContext: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Validate: fn(
            self: *const IValidate,
            wzICEs: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_OpenDatabase(self: *const T, szDatabase: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).OpenDatabase(@ptrCast(*const IValidate, self), szDatabase);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_OpenCUB(self: *const T, szCUBFile: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).OpenCUB(@ptrCast(*const IValidate, self), szCUBFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_CloseDatabase(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).CloseDatabase(@ptrCast(*const IValidate, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_CloseCUB(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).CloseCUB(@ptrCast(*const IValidate, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_SetDisplay(self: *const T, pDisplayFunction: ?LPDISPLAYVAL, pContext: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).SetDisplay(@ptrCast(*const IValidate, self), pDisplayFunction, pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_SetStatus(self: *const T, pStatusFunction: ?LPEVALCOMCALLBACK, pContext: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).SetStatus(@ptrCast(*const IValidate, self), pStatusFunction, pContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IValidate_Validate(self: *const T, wzICEs: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IValidate.VTable, self.vtable).Validate(@ptrCast(*const IValidate, self), wzICEs);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const CLSID_MsmMerge_Value = @import("../zig.zig").Guid.initString("0adda830-2c26-11d2-ad65-00a0c9af11a6");
pub const CLSID_MsmMerge = &CLSID_MsmMerge_Value;

pub const msmErrorType = enum(i32) {
    LanguageUnsupported = 1,
    LanguageFailed = 2,
    Exclusion = 3,
    TableMerge = 4,
    ResequenceMerge = 5,
    FileCreate = 6,
    DirCreate = 7,
    FeatureRequired = 8,
};
pub const msmErrorLanguageUnsupported = msmErrorType.LanguageUnsupported;
pub const msmErrorLanguageFailed = msmErrorType.LanguageFailed;
pub const msmErrorExclusion = msmErrorType.Exclusion;
pub const msmErrorTableMerge = msmErrorType.TableMerge;
pub const msmErrorResequenceMerge = msmErrorType.ResequenceMerge;
pub const msmErrorFileCreate = msmErrorType.FileCreate;
pub const msmErrorDirCreate = msmErrorType.DirCreate;
pub const msmErrorFeatureRequired = msmErrorType.FeatureRequired;

const IID_IEnumMsmString_Value = @import("../zig.zig").Guid.initString("0adda826-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmString = &IID_IEnumMsmString_Value;
pub const IEnumMsmString = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMsmString,
            cFetch: u32,
            rgbstrStrings: ?*?BSTR,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMsmString,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMsmString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMsmString,
            pemsmStrings: ?*?*IEnumMsmString,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmString_Next(self: *const T, cFetch: u32, rgbstrStrings: ?*?BSTR, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmString.VTable, self.vtable).Next(@ptrCast(*const IEnumMsmString, self), cFetch, rgbstrStrings, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmString_Skip(self: *const T, cSkip: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmString.VTable, self.vtable).Skip(@ptrCast(*const IEnumMsmString, self), cSkip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmString_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmString.VTable, self.vtable).Reset(@ptrCast(*const IEnumMsmString, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmString_Clone(self: *const T, pemsmStrings: ?*?*IEnumMsmString) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmString.VTable, self.vtable).Clone(@ptrCast(*const IEnumMsmString, self), pemsmStrings);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmStrings_Value = @import("../zig.zig").Guid.initString("0adda827-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmStrings = &IID_IMsmStrings_Value;
pub const IMsmStrings = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMsmStrings,
            Item: i32,
            Return: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMsmStrings,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMsmStrings,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmStrings_get_Item(self: *const T, Item: i32, Return: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmStrings.VTable, self.vtable).get_Item(@ptrCast(*const IMsmStrings, self), Item, Return);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmStrings_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmStrings.VTable, self.vtable).get_Count(@ptrCast(*const IMsmStrings, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmStrings_get__NewEnum(self: *const T, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmStrings.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMsmStrings, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmError_Value = @import("../zig.zig").Guid.initString("0adda828-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmError = &IID_IMsmError_Value;
pub const IMsmError = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Type: fn(
            self: *const IMsmError,
            ErrorType: ?*msmErrorType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Path: fn(
            self: *const IMsmError,
            ErrorPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: fn(
            self: *const IMsmError,
            ErrorLanguage: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DatabaseTable: fn(
            self: *const IMsmError,
            ErrorTable: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_DatabaseKeys: fn(
            self: *const IMsmError,
            ErrorKeys: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleTable: fn(
            self: *const IMsmError,
            ErrorTable: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleKeys: fn(
            self: *const IMsmError,
            ErrorKeys: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_Type(self: *const T, ErrorType: ?*msmErrorType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_Type(@ptrCast(*const IMsmError, self), ErrorType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_Path(self: *const T, ErrorPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_Path(@ptrCast(*const IMsmError, self), ErrorPath);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_Language(self: *const T, ErrorLanguage: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_Language(@ptrCast(*const IMsmError, self), ErrorLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_DatabaseTable(self: *const T, ErrorTable: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_DatabaseTable(@ptrCast(*const IMsmError, self), ErrorTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_DatabaseKeys(self: *const T, ErrorKeys: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_DatabaseKeys(@ptrCast(*const IMsmError, self), ErrorKeys);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_ModuleTable(self: *const T, ErrorTable: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_ModuleTable(@ptrCast(*const IMsmError, self), ErrorTable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmError_get_ModuleKeys(self: *const T, ErrorKeys: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmError.VTable, self.vtable).get_ModuleKeys(@ptrCast(*const IMsmError, self), ErrorKeys);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMsmError_Value = @import("../zig.zig").Guid.initString("0adda829-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmError = &IID_IEnumMsmError_Value;
pub const IEnumMsmError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMsmError,
            cFetch: u32,
            rgmsmErrors: ?*?*IMsmError,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMsmError,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMsmError,
            pemsmErrors: ?*?*IEnumMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmError_Next(self: *const T, cFetch: u32, rgmsmErrors: ?*?*IMsmError, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmError.VTable, self.vtable).Next(@ptrCast(*const IEnumMsmError, self), cFetch, rgmsmErrors, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmError_Skip(self: *const T, cSkip: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmError.VTable, self.vtable).Skip(@ptrCast(*const IEnumMsmError, self), cSkip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmError_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmError.VTable, self.vtable).Reset(@ptrCast(*const IEnumMsmError, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmError_Clone(self: *const T, pemsmErrors: ?*?*IEnumMsmError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmError.VTable, self.vtable).Clone(@ptrCast(*const IEnumMsmError, self), pemsmErrors);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmErrors_Value = @import("../zig.zig").Guid.initString("0adda82a-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmErrors = &IID_IMsmErrors_Value;
pub const IMsmErrors = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMsmErrors,
            Item: i32,
            Return: ?*?*IMsmError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMsmErrors,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMsmErrors,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmErrors_get_Item(self: *const T, Item: i32, Return: ?*?*IMsmError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmErrors.VTable, self.vtable).get_Item(@ptrCast(*const IMsmErrors, self), Item, Return);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmErrors_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmErrors.VTable, self.vtable).get_Count(@ptrCast(*const IMsmErrors, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmErrors_get__NewEnum(self: *const T, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmErrors.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMsmErrors, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmDependency_Value = @import("../zig.zig").Guid.initString("0adda82b-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmDependency = &IID_IMsmDependency_Value;
pub const IMsmDependency = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Module: fn(
            self: *const IMsmDependency,
            Module: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Language: fn(
            self: *const IMsmDependency,
            Language: ?*i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Version: fn(
            self: *const IMsmDependency,
            Version: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependency_get_Module(self: *const T, Module: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependency.VTable, self.vtable).get_Module(@ptrCast(*const IMsmDependency, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependency_get_Language(self: *const T, Language: ?*i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependency.VTable, self.vtable).get_Language(@ptrCast(*const IMsmDependency, self), Language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependency_get_Version(self: *const T, Version: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependency.VTable, self.vtable).get_Version(@ptrCast(*const IMsmDependency, self), Version);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumMsmDependency_Value = @import("../zig.zig").Guid.initString("0adda82c-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IEnumMsmDependency = &IID_IEnumMsmDependency_Value;
pub const IEnumMsmDependency = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumMsmDependency,
            cFetch: u32,
            rgmsmDependencies: ?*?*IMsmDependency,
            pcFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumMsmDependency,
            cSkip: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumMsmDependency,
            pemsmDependencies: ?*?*IEnumMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmDependency_Next(self: *const T, cFetch: u32, rgmsmDependencies: ?*?*IMsmDependency, pcFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmDependency.VTable, self.vtable).Next(@ptrCast(*const IEnumMsmDependency, self), cFetch, rgmsmDependencies, pcFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmDependency_Skip(self: *const T, cSkip: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmDependency.VTable, self.vtable).Skip(@ptrCast(*const IEnumMsmDependency, self), cSkip);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmDependency_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmDependency.VTable, self.vtable).Reset(@ptrCast(*const IEnumMsmDependency, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumMsmDependency_Clone(self: *const T, pemsmDependencies: ?*?*IEnumMsmDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumMsmDependency.VTable, self.vtable).Clone(@ptrCast(*const IEnumMsmDependency, self), pemsmDependencies);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmDependencies_Value = @import("../zig.zig").Guid.initString("0adda82d-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmDependencies = &IID_IMsmDependencies_Value;
pub const IMsmDependencies = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Item: fn(
            self: *const IMsmDependencies,
            Item: i32,
            Return: ?*?*IMsmDependency,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Count: fn(
            self: *const IMsmDependencies,
            Count: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get__NewEnum: fn(
            self: *const IMsmDependencies,
            NewEnum: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependencies_get_Item(self: *const T, Item: i32, Return: ?*?*IMsmDependency) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependencies.VTable, self.vtable).get_Item(@ptrCast(*const IMsmDependencies, self), Item, Return);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependencies_get_Count(self: *const T, Count: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependencies.VTable, self.vtable).get_Count(@ptrCast(*const IMsmDependencies, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmDependencies_get__NewEnum(self: *const T, NewEnum: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmDependencies.VTable, self.vtable).get__NewEnum(@ptrCast(*const IMsmDependencies, self), NewEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmMerge_Value = @import("../zig.zig").Guid.initString("0adda82e-2c26-11d2-ad65-00a0c9af11a6");
pub const IID_IMsmMerge = &IID_IMsmMerge_Value;
pub const IMsmMerge = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        OpenDatabase: fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenModule: fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
            Language: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseDatabase: fn(
            self: *const IMsmMerge,
            Commit: i16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseModule: fn(
            self: *const IMsmMerge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLog: fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLog: fn(
            self: *const IMsmMerge,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Log: fn(
            self: *const IMsmMerge,
            Message: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Errors: fn(
            self: *const IMsmMerge,
            Errors: ?*?*IMsmErrors,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Dependencies: fn(
            self: *const IMsmMerge,
            Dependencies: ?*?*IMsmDependencies,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Merge: fn(
            self: *const IMsmMerge,
            Feature: ?BSTR,
            RedirectDir: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Connect: fn(
            self: *const IMsmMerge,
            Feature: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtractCAB: fn(
            self: *const IMsmMerge,
            FileName: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExtractFiles: fn(
            self: *const IMsmMerge,
            Path: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_OpenDatabase(self: *const T, Path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).OpenDatabase(@ptrCast(*const IMsmMerge, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_OpenModule(self: *const T, Path: ?BSTR, Language: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).OpenModule(@ptrCast(*const IMsmMerge, self), Path, Language);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_CloseDatabase(self: *const T, Commit: i16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).CloseDatabase(@ptrCast(*const IMsmMerge, self), Commit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_CloseModule(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).CloseModule(@ptrCast(*const IMsmMerge, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_OpenLog(self: *const T, Path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).OpenLog(@ptrCast(*const IMsmMerge, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_CloseLog(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).CloseLog(@ptrCast(*const IMsmMerge, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_Log(self: *const T, Message: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).Log(@ptrCast(*const IMsmMerge, self), Message);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_get_Errors(self: *const T, Errors: ?*?*IMsmErrors) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).get_Errors(@ptrCast(*const IMsmMerge, self), Errors);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_get_Dependencies(self: *const T, Dependencies: ?*?*IMsmDependencies) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).get_Dependencies(@ptrCast(*const IMsmMerge, self), Dependencies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_Merge(self: *const T, Feature: ?BSTR, RedirectDir: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).Merge(@ptrCast(*const IMsmMerge, self), Feature, RedirectDir);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_Connect(self: *const T, Feature: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).Connect(@ptrCast(*const IMsmMerge, self), Feature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_ExtractCAB(self: *const T, FileName: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).ExtractCAB(@ptrCast(*const IMsmMerge, self), FileName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmMerge_ExtractFiles(self: *const T, Path: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmMerge.VTable, self.vtable).ExtractFiles(@ptrCast(*const IMsmMerge, self), Path);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMsmGetFiles_Value = @import("../zig.zig").Guid.initString("7041ae26-2d78-11d2-888a-00a0c981b015");
pub const IID_IMsmGetFiles = &IID_IMsmGetFiles_Value;
pub const IMsmGetFiles = extern struct {
    pub const VTable = extern struct {
        base: IDispatch.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_ModuleFiles: fn(
            self: *const IMsmGetFiles,
            Files: ?*?*IMsmStrings,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDispatch.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMsmGetFiles_get_ModuleFiles(self: *const T, Files: ?*?*IMsmStrings) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMsmGetFiles.VTable, self.vtable).get_ModuleFiles(@ptrCast(*const IMsmGetFiles, self), Files);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PMSIHANDLE = extern struct {
    m_h: MSIHANDLE,
};

pub const INSTALLMESSAGE = enum(i32) {
    FATALEXIT = 0,
    ERROR = 16777216,
    WARNING = 33554432,
    USER = 50331648,
    INFO = 67108864,
    FILESINUSE = 83886080,
    RESOLVESOURCE = 100663296,
    OUTOFDISKSPACE = 117440512,
    ACTIONSTART = 134217728,
    ACTIONDATA = 150994944,
    PROGRESS = 167772160,
    COMMONDATA = 184549376,
    INITIALIZE = 201326592,
    TERMINATE = 218103808,
    SHOWDIALOG = 234881024,
    PERFORMANCE = 251658240,
    RMFILESINUSE = 419430400,
    INSTALLSTART = 436207616,
    INSTALLEND = 452984832,
};
pub const INSTALLMESSAGE_FATALEXIT = INSTALLMESSAGE.FATALEXIT;
pub const INSTALLMESSAGE_ERROR = INSTALLMESSAGE.ERROR;
pub const INSTALLMESSAGE_WARNING = INSTALLMESSAGE.WARNING;
pub const INSTALLMESSAGE_USER = INSTALLMESSAGE.USER;
pub const INSTALLMESSAGE_INFO = INSTALLMESSAGE.INFO;
pub const INSTALLMESSAGE_FILESINUSE = INSTALLMESSAGE.FILESINUSE;
pub const INSTALLMESSAGE_RESOLVESOURCE = INSTALLMESSAGE.RESOLVESOURCE;
pub const INSTALLMESSAGE_OUTOFDISKSPACE = INSTALLMESSAGE.OUTOFDISKSPACE;
pub const INSTALLMESSAGE_ACTIONSTART = INSTALLMESSAGE.ACTIONSTART;
pub const INSTALLMESSAGE_ACTIONDATA = INSTALLMESSAGE.ACTIONDATA;
pub const INSTALLMESSAGE_PROGRESS = INSTALLMESSAGE.PROGRESS;
pub const INSTALLMESSAGE_COMMONDATA = INSTALLMESSAGE.COMMONDATA;
pub const INSTALLMESSAGE_INITIALIZE = INSTALLMESSAGE.INITIALIZE;
pub const INSTALLMESSAGE_TERMINATE = INSTALLMESSAGE.TERMINATE;
pub const INSTALLMESSAGE_SHOWDIALOG = INSTALLMESSAGE.SHOWDIALOG;
pub const INSTALLMESSAGE_PERFORMANCE = INSTALLMESSAGE.PERFORMANCE;
pub const INSTALLMESSAGE_RMFILESINUSE = INSTALLMESSAGE.RMFILESINUSE;
pub const INSTALLMESSAGE_INSTALLSTART = INSTALLMESSAGE.INSTALLSTART;
pub const INSTALLMESSAGE_INSTALLEND = INSTALLMESSAGE.INSTALLEND;

pub const INSTALLUI_HANDLERA = fn(
    pvContext: ?*c_void,
    iMessageType: u32,
    szMessage: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INSTALLUI_HANDLERW = fn(
    pvContext: ?*c_void,
    iMessageType: u32,
    szMessage: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const PINSTALLUI_HANDLER_RECORD = fn(
    pvContext: ?*c_void,
    iMessageType: u32,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const INSTALLUILEVEL = enum(i32) {
    NOCHANGE = 0,
    DEFAULT = 1,
    NONE = 2,
    BASIC = 3,
    REDUCED = 4,
    FULL = 5,
    ENDDIALOG = 128,
    PROGRESSONLY = 64,
    HIDECANCEL = 32,
    SOURCERESONLY = 256,
    UACONLY = 512,
};
pub const INSTALLUILEVEL_NOCHANGE = INSTALLUILEVEL.NOCHANGE;
pub const INSTALLUILEVEL_DEFAULT = INSTALLUILEVEL.DEFAULT;
pub const INSTALLUILEVEL_NONE = INSTALLUILEVEL.NONE;
pub const INSTALLUILEVEL_BASIC = INSTALLUILEVEL.BASIC;
pub const INSTALLUILEVEL_REDUCED = INSTALLUILEVEL.REDUCED;
pub const INSTALLUILEVEL_FULL = INSTALLUILEVEL.FULL;
pub const INSTALLUILEVEL_ENDDIALOG = INSTALLUILEVEL.ENDDIALOG;
pub const INSTALLUILEVEL_PROGRESSONLY = INSTALLUILEVEL.PROGRESSONLY;
pub const INSTALLUILEVEL_HIDECANCEL = INSTALLUILEVEL.HIDECANCEL;
pub const INSTALLUILEVEL_SOURCERESONLY = INSTALLUILEVEL.SOURCERESONLY;
pub const INSTALLUILEVEL_UACONLY = INSTALLUILEVEL.UACONLY;

pub const INSTALLSTATE = enum(i32) {
    NOTUSED = -7,
    BADCONFIG = -6,
    INCOMPLETE = -5,
    SOURCEABSENT = -4,
    MOREDATA = -3,
    INVALIDARG = -2,
    UNKNOWN = -1,
    BROKEN = 0,
    ADVERTISED = 1,
    // REMOVED = 1, this enum value conflicts with ADVERTISED
    ABSENT = 2,
    LOCAL = 3,
    SOURCE = 4,
    DEFAULT = 5,
};
pub const INSTALLSTATE_NOTUSED = INSTALLSTATE.NOTUSED;
pub const INSTALLSTATE_BADCONFIG = INSTALLSTATE.BADCONFIG;
pub const INSTALLSTATE_INCOMPLETE = INSTALLSTATE.INCOMPLETE;
pub const INSTALLSTATE_SOURCEABSENT = INSTALLSTATE.SOURCEABSENT;
pub const INSTALLSTATE_MOREDATA = INSTALLSTATE.MOREDATA;
pub const INSTALLSTATE_INVALIDARG = INSTALLSTATE.INVALIDARG;
pub const INSTALLSTATE_UNKNOWN = INSTALLSTATE.UNKNOWN;
pub const INSTALLSTATE_BROKEN = INSTALLSTATE.BROKEN;
pub const INSTALLSTATE_ADVERTISED = INSTALLSTATE.ADVERTISED;
pub const INSTALLSTATE_REMOVED = INSTALLSTATE.ADVERTISED;
pub const INSTALLSTATE_ABSENT = INSTALLSTATE.ABSENT;
pub const INSTALLSTATE_LOCAL = INSTALLSTATE.LOCAL;
pub const INSTALLSTATE_SOURCE = INSTALLSTATE.SOURCE;
pub const INSTALLSTATE_DEFAULT = INSTALLSTATE.DEFAULT;

pub const USERINFOSTATE = enum(i32) {
    MOREDATA = -3,
    INVALIDARG = -2,
    UNKNOWN = -1,
    ABSENT = 0,
    PRESENT = 1,
};
pub const USERINFOSTATE_MOREDATA = USERINFOSTATE.MOREDATA;
pub const USERINFOSTATE_INVALIDARG = USERINFOSTATE.INVALIDARG;
pub const USERINFOSTATE_UNKNOWN = USERINFOSTATE.UNKNOWN;
pub const USERINFOSTATE_ABSENT = USERINFOSTATE.ABSENT;
pub const USERINFOSTATE_PRESENT = USERINFOSTATE.PRESENT;

pub const INSTALLLEVEL = enum(i32) {
    DEFAULT = 0,
    MINIMUM = 1,
    MAXIMUM = 65535,
};
pub const INSTALLLEVEL_DEFAULT = INSTALLLEVEL.DEFAULT;
pub const INSTALLLEVEL_MINIMUM = INSTALLLEVEL.MINIMUM;
pub const INSTALLLEVEL_MAXIMUM = INSTALLLEVEL.MAXIMUM;

pub const REINSTALLMODE = enum(i32) {
    REPAIR = 1,
    FILEMISSING = 2,
    FILEOLDERVERSION = 4,
    FILEEQUALVERSION = 8,
    FILEEXACT = 16,
    FILEVERIFY = 32,
    FILEREPLACE = 64,
    MACHINEDATA = 128,
    USERDATA = 256,
    SHORTCUT = 512,
    PACKAGE = 1024,
};
pub const REINSTALLMODE_REPAIR = REINSTALLMODE.REPAIR;
pub const REINSTALLMODE_FILEMISSING = REINSTALLMODE.FILEMISSING;
pub const REINSTALLMODE_FILEOLDERVERSION = REINSTALLMODE.FILEOLDERVERSION;
pub const REINSTALLMODE_FILEEQUALVERSION = REINSTALLMODE.FILEEQUALVERSION;
pub const REINSTALLMODE_FILEEXACT = REINSTALLMODE.FILEEXACT;
pub const REINSTALLMODE_FILEVERIFY = REINSTALLMODE.FILEVERIFY;
pub const REINSTALLMODE_FILEREPLACE = REINSTALLMODE.FILEREPLACE;
pub const REINSTALLMODE_MACHINEDATA = REINSTALLMODE.MACHINEDATA;
pub const REINSTALLMODE_USERDATA = REINSTALLMODE.USERDATA;
pub const REINSTALLMODE_SHORTCUT = REINSTALLMODE.SHORTCUT;
pub const REINSTALLMODE_PACKAGE = REINSTALLMODE.PACKAGE;

pub const INSTALLOGMODE = enum(i32) {
    FATALEXIT = 1,
    ERROR = 2,
    WARNING = 4,
    USER = 8,
    INFO = 16,
    RESOLVESOURCE = 64,
    OUTOFDISKSPACE = 128,
    ACTIONSTART = 256,
    ACTIONDATA = 512,
    COMMONDATA = 2048,
    PROPERTYDUMP = 1024,
    VERBOSE = 4096,
    EXTRADEBUG = 8192,
    LOGONLYONERROR = 16384,
    LOGPERFORMANCE = 32768,
    // PROGRESS = 1024, this enum value conflicts with PROPERTYDUMP
    // INITIALIZE = 4096, this enum value conflicts with VERBOSE
    // TERMINATE = 8192, this enum value conflicts with EXTRADEBUG
    // SHOWDIALOG = 16384, this enum value conflicts with LOGONLYONERROR
    FILESINUSE = 32,
    RMFILESINUSE = 33554432,
    INSTALLSTART = 67108864,
    INSTALLEND = 134217728,
};
pub const INSTALLLOGMODE_FATALEXIT = INSTALLOGMODE.FATALEXIT;
pub const INSTALLLOGMODE_ERROR = INSTALLOGMODE.ERROR;
pub const INSTALLLOGMODE_WARNING = INSTALLOGMODE.WARNING;
pub const INSTALLLOGMODE_USER = INSTALLOGMODE.USER;
pub const INSTALLLOGMODE_INFO = INSTALLOGMODE.INFO;
pub const INSTALLLOGMODE_RESOLVESOURCE = INSTALLOGMODE.RESOLVESOURCE;
pub const INSTALLLOGMODE_OUTOFDISKSPACE = INSTALLOGMODE.OUTOFDISKSPACE;
pub const INSTALLLOGMODE_ACTIONSTART = INSTALLOGMODE.ACTIONSTART;
pub const INSTALLLOGMODE_ACTIONDATA = INSTALLOGMODE.ACTIONDATA;
pub const INSTALLLOGMODE_COMMONDATA = INSTALLOGMODE.COMMONDATA;
pub const INSTALLLOGMODE_PROPERTYDUMP = INSTALLOGMODE.PROPERTYDUMP;
pub const INSTALLLOGMODE_VERBOSE = INSTALLOGMODE.VERBOSE;
pub const INSTALLLOGMODE_EXTRADEBUG = INSTALLOGMODE.EXTRADEBUG;
pub const INSTALLLOGMODE_LOGONLYONERROR = INSTALLOGMODE.LOGONLYONERROR;
pub const INSTALLLOGMODE_LOGPERFORMANCE = INSTALLOGMODE.LOGPERFORMANCE;
pub const INSTALLLOGMODE_PROGRESS = INSTALLOGMODE.PROPERTYDUMP;
pub const INSTALLLOGMODE_INITIALIZE = INSTALLOGMODE.VERBOSE;
pub const INSTALLLOGMODE_TERMINATE = INSTALLOGMODE.EXTRADEBUG;
pub const INSTALLLOGMODE_SHOWDIALOG = INSTALLOGMODE.LOGONLYONERROR;
pub const INSTALLLOGMODE_FILESINUSE = INSTALLOGMODE.FILESINUSE;
pub const INSTALLLOGMODE_RMFILESINUSE = INSTALLOGMODE.RMFILESINUSE;
pub const INSTALLLOGMODE_INSTALLSTART = INSTALLOGMODE.INSTALLSTART;
pub const INSTALLLOGMODE_INSTALLEND = INSTALLOGMODE.INSTALLEND;

pub const INSTALLLOGATTRIBUTES = enum(i32) {
    APPEND = 1,
    FLUSHEACHLINE = 2,
};
pub const INSTALLLOGATTRIBUTES_APPEND = INSTALLLOGATTRIBUTES.APPEND;
pub const INSTALLLOGATTRIBUTES_FLUSHEACHLINE = INSTALLLOGATTRIBUTES.FLUSHEACHLINE;

pub const INSTALLFEATUREATTRIBUTE = enum(i32) {
    FAVORLOCAL = 1,
    FAVORSOURCE = 2,
    FOLLOWPARENT = 4,
    FAVORADVERTISE = 8,
    DISALLOWADVERTISE = 16,
    NOUNSUPPORTEDADVERTISE = 32,
};
pub const INSTALLFEATUREATTRIBUTE_FAVORLOCAL = INSTALLFEATUREATTRIBUTE.FAVORLOCAL;
pub const INSTALLFEATUREATTRIBUTE_FAVORSOURCE = INSTALLFEATUREATTRIBUTE.FAVORSOURCE;
pub const INSTALLFEATUREATTRIBUTE_FOLLOWPARENT = INSTALLFEATUREATTRIBUTE.FOLLOWPARENT;
pub const INSTALLFEATUREATTRIBUTE_FAVORADVERTISE = INSTALLFEATUREATTRIBUTE.FAVORADVERTISE;
pub const INSTALLFEATUREATTRIBUTE_DISALLOWADVERTISE = INSTALLFEATUREATTRIBUTE.DISALLOWADVERTISE;
pub const INSTALLFEATUREATTRIBUTE_NOUNSUPPORTEDADVERTISE = INSTALLFEATUREATTRIBUTE.NOUNSUPPORTEDADVERTISE;

pub const INSTALLMODE = enum(i32) {
    NODETECTION_ANY = -4,
    NOSOURCERESOLUTION = -3,
    NODETECTION = -2,
    EXISTING = -1,
    DEFAULT = 0,
};
pub const INSTALLMODE_NODETECTION_ANY = INSTALLMODE.NODETECTION_ANY;
pub const INSTALLMODE_NOSOURCERESOLUTION = INSTALLMODE.NOSOURCERESOLUTION;
pub const INSTALLMODE_NODETECTION = INSTALLMODE.NODETECTION;
pub const INSTALLMODE_EXISTING = INSTALLMODE.EXISTING;
pub const INSTALLMODE_DEFAULT = INSTALLMODE.DEFAULT;

pub const MSIPATCHSTATE = enum(i32) {
    INVALID = 0,
    APPLIED = 1,
    SUPERSEDED = 2,
    OBSOLETED = 4,
    REGISTERED = 8,
    ALL = 15,
};
pub const MSIPATCHSTATE_INVALID = MSIPATCHSTATE.INVALID;
pub const MSIPATCHSTATE_APPLIED = MSIPATCHSTATE.APPLIED;
pub const MSIPATCHSTATE_SUPERSEDED = MSIPATCHSTATE.SUPERSEDED;
pub const MSIPATCHSTATE_OBSOLETED = MSIPATCHSTATE.OBSOLETED;
pub const MSIPATCHSTATE_REGISTERED = MSIPATCHSTATE.REGISTERED;
pub const MSIPATCHSTATE_ALL = MSIPATCHSTATE.ALL;

pub const MSIINSTALLCONTEXT = enum(i32) {
    FIRSTVISIBLE = 0,
    // NONE = 0, this enum value conflicts with FIRSTVISIBLE
    USERMANAGED = 1,
    USERUNMANAGED = 2,
    MACHINE = 4,
    ALL = 7,
    ALLUSERMANAGED = 8,
};
pub const MSIINSTALLCONTEXT_FIRSTVISIBLE = MSIINSTALLCONTEXT.FIRSTVISIBLE;
pub const MSIINSTALLCONTEXT_NONE = MSIINSTALLCONTEXT.FIRSTVISIBLE;
pub const MSIINSTALLCONTEXT_USERMANAGED = MSIINSTALLCONTEXT.USERMANAGED;
pub const MSIINSTALLCONTEXT_USERUNMANAGED = MSIINSTALLCONTEXT.USERUNMANAGED;
pub const MSIINSTALLCONTEXT_MACHINE = MSIINSTALLCONTEXT.MACHINE;
pub const MSIINSTALLCONTEXT_ALL = MSIINSTALLCONTEXT.ALL;
pub const MSIINSTALLCONTEXT_ALLUSERMANAGED = MSIINSTALLCONTEXT.ALLUSERMANAGED;

pub const MSIPATCHDATATYPE = enum(i32) {
    PATCHFILE = 0,
    XMLPATH = 1,
    XMLBLOB = 2,
};
pub const MSIPATCH_DATATYPE_PATCHFILE = MSIPATCHDATATYPE.PATCHFILE;
pub const MSIPATCH_DATATYPE_XMLPATH = MSIPATCHDATATYPE.XMLPATH;
pub const MSIPATCH_DATATYPE_XMLBLOB = MSIPATCHDATATYPE.XMLBLOB;

pub const MSIPATCHSEQUENCEINFOA = extern struct {
    szPatchData: ?[*:0]const u8,
    ePatchDataType: MSIPATCHDATATYPE,
    dwOrder: u32,
    uStatus: u32,
};

pub const MSIPATCHSEQUENCEINFOW = extern struct {
    szPatchData: ?[*:0]const u16,
    ePatchDataType: MSIPATCHDATATYPE,
    dwOrder: u32,
    uStatus: u32,
};

pub const SCRIPTFLAGS = enum(i32) {
    CACHEINFO = 1,
    SHORTCUTS = 4,
    MACHINEASSIGN = 8,
    REGDATA_CNFGINFO = 32,
    VALIDATE_TRANSFORMS_LIST = 64,
    REGDATA_CLASSINFO = 128,
    REGDATA_EXTENSIONINFO = 256,
    REGDATA_APPINFO = 384,
    REGDATA = 416,
};
pub const SCRIPTFLAGS_CACHEINFO = SCRIPTFLAGS.CACHEINFO;
pub const SCRIPTFLAGS_SHORTCUTS = SCRIPTFLAGS.SHORTCUTS;
pub const SCRIPTFLAGS_MACHINEASSIGN = SCRIPTFLAGS.MACHINEASSIGN;
pub const SCRIPTFLAGS_REGDATA_CNFGINFO = SCRIPTFLAGS.REGDATA_CNFGINFO;
pub const SCRIPTFLAGS_VALIDATE_TRANSFORMS_LIST = SCRIPTFLAGS.VALIDATE_TRANSFORMS_LIST;
pub const SCRIPTFLAGS_REGDATA_CLASSINFO = SCRIPTFLAGS.REGDATA_CLASSINFO;
pub const SCRIPTFLAGS_REGDATA_EXTENSIONINFO = SCRIPTFLAGS.REGDATA_EXTENSIONINFO;
pub const SCRIPTFLAGS_REGDATA_APPINFO = SCRIPTFLAGS.REGDATA_APPINFO;
pub const SCRIPTFLAGS_REGDATA = SCRIPTFLAGS.REGDATA;

pub const ADVERTISEFLAGS = enum(i32) {
    MACHINEASSIGN = 0,
    USERASSIGN = 1,
};
pub const ADVERTISEFLAGS_MACHINEASSIGN = ADVERTISEFLAGS.MACHINEASSIGN;
pub const ADVERTISEFLAGS_USERASSIGN = ADVERTISEFLAGS.USERASSIGN;

pub const INSTALLTYPE = enum(i32) {
    DEFAULT = 0,
    NETWORK_IMAGE = 1,
    SINGLE_INSTANCE = 2,
};
pub const INSTALLTYPE_DEFAULT = INSTALLTYPE.DEFAULT;
pub const INSTALLTYPE_NETWORK_IMAGE = INSTALLTYPE.NETWORK_IMAGE;
pub const INSTALLTYPE_SINGLE_INSTANCE = INSTALLTYPE.SINGLE_INSTANCE;

pub const MSIFILEHASHINFO = extern struct {
    dwFileHashInfoSize: u32,
    dwData: [4]u32,
};

pub const MSIARCHITECTUREFLAGS = enum(i32) {
    X86 = 1,
    IA64 = 2,
    AMD64 = 4,
    ARM = 8,
};
pub const MSIARCHITECTUREFLAGS_X86 = MSIARCHITECTUREFLAGS.X86;
pub const MSIARCHITECTUREFLAGS_IA64 = MSIARCHITECTUREFLAGS.IA64;
pub const MSIARCHITECTUREFLAGS_AMD64 = MSIARCHITECTUREFLAGS.AMD64;
pub const MSIARCHITECTUREFLAGS_ARM = MSIARCHITECTUREFLAGS.ARM;

pub const MSIOPENPACKAGEFLAGS = enum(i32) {
    E = 1,
};
pub const MSIOPENPACKAGEFLAGS_IGNOREMACHINESTATE = MSIOPENPACKAGEFLAGS.E;

pub const MSIADVERTISEOPTIONFLAGS = enum(i32) {
    E = 1,
};
pub const MSIADVERTISEOPTIONFLAGS_INSTANCE = MSIADVERTISEOPTIONFLAGS.E;

pub const MSISOURCETYPE = enum(i32) {
    UNKNOWN = 0,
    NETWORK = 1,
    URL = 2,
    MEDIA = 4,
};
pub const MSISOURCETYPE_UNKNOWN = MSISOURCETYPE.UNKNOWN;
pub const MSISOURCETYPE_NETWORK = MSISOURCETYPE.NETWORK;
pub const MSISOURCETYPE_URL = MSISOURCETYPE.URL;
pub const MSISOURCETYPE_MEDIA = MSISOURCETYPE.MEDIA;

pub const MSICODE = enum(i32) {
    RODUCT = 0,
    ATCH = 1073741824,
};
pub const MSICODE_PRODUCT = MSICODE.RODUCT;
pub const MSICODE_PATCH = MSICODE.ATCH;

pub const MSITRANSACTION = enum(i32) {
    CHAIN_EMBEDDEDUI = 1,
    JOIN_EXISTING_EMBEDDEDUI = 2,
};
pub const MSITRANSACTION_CHAIN_EMBEDDEDUI = MSITRANSACTION.CHAIN_EMBEDDEDUI;
pub const MSITRANSACTION_JOIN_EXISTING_EMBEDDEDUI = MSITRANSACTION.JOIN_EXISTING_EMBEDDEDUI;

pub const MSITRANSACTIONSTATE = enum(u32) {
    ROLLBACK = 0,
    COMMIT = 1,
};
pub const MSITRANSACTIONSTATE_ROLLBACK = MSITRANSACTIONSTATE.ROLLBACK;
pub const MSITRANSACTIONSTATE_COMMIT = MSITRANSACTIONSTATE.COMMIT;

pub const MSIDBSTATE = enum(i32) {
    ERROR = -1,
    READ = 0,
    WRITE = 1,
};
pub const MSIDBSTATE_ERROR = MSIDBSTATE.ERROR;
pub const MSIDBSTATE_READ = MSIDBSTATE.READ;
pub const MSIDBSTATE_WRITE = MSIDBSTATE.WRITE;

pub const MSIMODIFY = enum(i32) {
    SEEK = -1,
    REFRESH = 0,
    INSERT = 1,
    UPDATE = 2,
    ASSIGN = 3,
    REPLACE = 4,
    MERGE = 5,
    DELETE = 6,
    INSERT_TEMPORARY = 7,
    VALIDATE = 8,
    VALIDATE_NEW = 9,
    VALIDATE_FIELD = 10,
    VALIDATE_DELETE = 11,
};
pub const MSIMODIFY_SEEK = MSIMODIFY.SEEK;
pub const MSIMODIFY_REFRESH = MSIMODIFY.REFRESH;
pub const MSIMODIFY_INSERT = MSIMODIFY.INSERT;
pub const MSIMODIFY_UPDATE = MSIMODIFY.UPDATE;
pub const MSIMODIFY_ASSIGN = MSIMODIFY.ASSIGN;
pub const MSIMODIFY_REPLACE = MSIMODIFY.REPLACE;
pub const MSIMODIFY_MERGE = MSIMODIFY.MERGE;
pub const MSIMODIFY_DELETE = MSIMODIFY.DELETE;
pub const MSIMODIFY_INSERT_TEMPORARY = MSIMODIFY.INSERT_TEMPORARY;
pub const MSIMODIFY_VALIDATE = MSIMODIFY.VALIDATE;
pub const MSIMODIFY_VALIDATE_NEW = MSIMODIFY.VALIDATE_NEW;
pub const MSIMODIFY_VALIDATE_FIELD = MSIMODIFY.VALIDATE_FIELD;
pub const MSIMODIFY_VALIDATE_DELETE = MSIMODIFY.VALIDATE_DELETE;

pub const MSICOLINFO = enum(i32) {
    NAMES = 0,
    TYPES = 1,
};
pub const MSICOLINFO_NAMES = MSICOLINFO.NAMES;
pub const MSICOLINFO_TYPES = MSICOLINFO.TYPES;

pub const MSICONDITION = enum(i32) {
    FALSE = 0,
    TRUE = 1,
    NONE = 2,
    ERROR = 3,
};
pub const MSICONDITION_FALSE = MSICONDITION.FALSE;
pub const MSICONDITION_TRUE = MSICONDITION.TRUE;
pub const MSICONDITION_NONE = MSICONDITION.NONE;
pub const MSICONDITION_ERROR = MSICONDITION.ERROR;

pub const MSICOSTTREE = enum(i32) {
    SELFONLY = 0,
    CHILDREN = 1,
    PARENTS = 2,
    RESERVED = 3,
};
pub const MSICOSTTREE_SELFONLY = MSICOSTTREE.SELFONLY;
pub const MSICOSTTREE_CHILDREN = MSICOSTTREE.CHILDREN;
pub const MSICOSTTREE_PARENTS = MSICOSTTREE.PARENTS;
pub const MSICOSTTREE_RESERVED = MSICOSTTREE.RESERVED;

pub const MSIDBERROR = enum(i32) {
    INVALIDARG = -3,
    MOREDATA = -2,
    FUNCTIONERROR = -1,
    NOERROR = 0,
    DUPLICATEKEY = 1,
    REQUIRED = 2,
    BADLINK = 3,
    OVERFLOW = 4,
    UNDERFLOW = 5,
    NOTINSET = 6,
    BADVERSION = 7,
    BADCASE = 8,
    BADGUID = 9,
    BADWILDCARD = 10,
    BADIDENTIFIER = 11,
    BADLANGUAGE = 12,
    BADFILENAME = 13,
    BADPATH = 14,
    BADCONDITION = 15,
    BADFORMATTED = 16,
    BADTEMPLATE = 17,
    BADDEFAULTDIR = 18,
    BADREGPATH = 19,
    BADCUSTOMSOURCE = 20,
    BADPROPERTY = 21,
    MISSINGDATA = 22,
    BADCATEGORY = 23,
    BADKEYTABLE = 24,
    BADMAXMINVALUES = 25,
    BADCABINET = 26,
    BADSHORTCUT = 27,
    STRINGOVERFLOW = 28,
    BADLOCALIZEATTRIB = 29,
};
pub const MSIDBERROR_INVALIDARG = MSIDBERROR.INVALIDARG;
pub const MSIDBERROR_MOREDATA = MSIDBERROR.MOREDATA;
pub const MSIDBERROR_FUNCTIONERROR = MSIDBERROR.FUNCTIONERROR;
pub const MSIDBERROR_NOERROR = MSIDBERROR.NOERROR;
pub const MSIDBERROR_DUPLICATEKEY = MSIDBERROR.DUPLICATEKEY;
pub const MSIDBERROR_REQUIRED = MSIDBERROR.REQUIRED;
pub const MSIDBERROR_BADLINK = MSIDBERROR.BADLINK;
pub const MSIDBERROR_OVERFLOW = MSIDBERROR.OVERFLOW;
pub const MSIDBERROR_UNDERFLOW = MSIDBERROR.UNDERFLOW;
pub const MSIDBERROR_NOTINSET = MSIDBERROR.NOTINSET;
pub const MSIDBERROR_BADVERSION = MSIDBERROR.BADVERSION;
pub const MSIDBERROR_BADCASE = MSIDBERROR.BADCASE;
pub const MSIDBERROR_BADGUID = MSIDBERROR.BADGUID;
pub const MSIDBERROR_BADWILDCARD = MSIDBERROR.BADWILDCARD;
pub const MSIDBERROR_BADIDENTIFIER = MSIDBERROR.BADIDENTIFIER;
pub const MSIDBERROR_BADLANGUAGE = MSIDBERROR.BADLANGUAGE;
pub const MSIDBERROR_BADFILENAME = MSIDBERROR.BADFILENAME;
pub const MSIDBERROR_BADPATH = MSIDBERROR.BADPATH;
pub const MSIDBERROR_BADCONDITION = MSIDBERROR.BADCONDITION;
pub const MSIDBERROR_BADFORMATTED = MSIDBERROR.BADFORMATTED;
pub const MSIDBERROR_BADTEMPLATE = MSIDBERROR.BADTEMPLATE;
pub const MSIDBERROR_BADDEFAULTDIR = MSIDBERROR.BADDEFAULTDIR;
pub const MSIDBERROR_BADREGPATH = MSIDBERROR.BADREGPATH;
pub const MSIDBERROR_BADCUSTOMSOURCE = MSIDBERROR.BADCUSTOMSOURCE;
pub const MSIDBERROR_BADPROPERTY = MSIDBERROR.BADPROPERTY;
pub const MSIDBERROR_MISSINGDATA = MSIDBERROR.MISSINGDATA;
pub const MSIDBERROR_BADCATEGORY = MSIDBERROR.BADCATEGORY;
pub const MSIDBERROR_BADKEYTABLE = MSIDBERROR.BADKEYTABLE;
pub const MSIDBERROR_BADMAXMINVALUES = MSIDBERROR.BADMAXMINVALUES;
pub const MSIDBERROR_BADCABINET = MSIDBERROR.BADCABINET;
pub const MSIDBERROR_BADSHORTCUT = MSIDBERROR.BADSHORTCUT;
pub const MSIDBERROR_STRINGOVERFLOW = MSIDBERROR.STRINGOVERFLOW;
pub const MSIDBERROR_BADLOCALIZEATTRIB = MSIDBERROR.BADLOCALIZEATTRIB;

pub const MSIRUNMODE = enum(i32) {
    ADMIN = 0,
    ADVERTISE = 1,
    MAINTENANCE = 2,
    ROLLBACKENABLED = 3,
    LOGENABLED = 4,
    OPERATIONS = 5,
    REBOOTATEND = 6,
    REBOOTNOW = 7,
    CABINET = 8,
    SOURCESHORTNAMES = 9,
    TARGETSHORTNAMES = 10,
    RESERVED11 = 11,
    WINDOWS9X = 12,
    ZAWENABLED = 13,
    RESERVED14 = 14,
    RESERVED15 = 15,
    SCHEDULED = 16,
    ROLLBACK = 17,
    COMMIT = 18,
};
pub const MSIRUNMODE_ADMIN = MSIRUNMODE.ADMIN;
pub const MSIRUNMODE_ADVERTISE = MSIRUNMODE.ADVERTISE;
pub const MSIRUNMODE_MAINTENANCE = MSIRUNMODE.MAINTENANCE;
pub const MSIRUNMODE_ROLLBACKENABLED = MSIRUNMODE.ROLLBACKENABLED;
pub const MSIRUNMODE_LOGENABLED = MSIRUNMODE.LOGENABLED;
pub const MSIRUNMODE_OPERATIONS = MSIRUNMODE.OPERATIONS;
pub const MSIRUNMODE_REBOOTATEND = MSIRUNMODE.REBOOTATEND;
pub const MSIRUNMODE_REBOOTNOW = MSIRUNMODE.REBOOTNOW;
pub const MSIRUNMODE_CABINET = MSIRUNMODE.CABINET;
pub const MSIRUNMODE_SOURCESHORTNAMES = MSIRUNMODE.SOURCESHORTNAMES;
pub const MSIRUNMODE_TARGETSHORTNAMES = MSIRUNMODE.TARGETSHORTNAMES;
pub const MSIRUNMODE_RESERVED11 = MSIRUNMODE.RESERVED11;
pub const MSIRUNMODE_WINDOWS9X = MSIRUNMODE.WINDOWS9X;
pub const MSIRUNMODE_ZAWENABLED = MSIRUNMODE.ZAWENABLED;
pub const MSIRUNMODE_RESERVED14 = MSIRUNMODE.RESERVED14;
pub const MSIRUNMODE_RESERVED15 = MSIRUNMODE.RESERVED15;
pub const MSIRUNMODE_SCHEDULED = MSIRUNMODE.SCHEDULED;
pub const MSIRUNMODE_ROLLBACK = MSIRUNMODE.ROLLBACK;
pub const MSIRUNMODE_COMMIT = MSIRUNMODE.COMMIT;

pub const MSITRANSFORM_ERROR = enum(i32) {
    ADDEXISTINGROW = 1,
    DELMISSINGROW = 2,
    ADDEXISTINGTABLE = 4,
    DELMISSINGTABLE = 8,
    UPDATEMISSINGROW = 16,
    CHANGECODEPAGE = 32,
    VIEWTRANSFORM = 256,
    NONE = 0,
};
pub const MSITRANSFORM_ERROR_ADDEXISTINGROW = MSITRANSFORM_ERROR.ADDEXISTINGROW;
pub const MSITRANSFORM_ERROR_DELMISSINGROW = MSITRANSFORM_ERROR.DELMISSINGROW;
pub const MSITRANSFORM_ERROR_ADDEXISTINGTABLE = MSITRANSFORM_ERROR.ADDEXISTINGTABLE;
pub const MSITRANSFORM_ERROR_DELMISSINGTABLE = MSITRANSFORM_ERROR.DELMISSINGTABLE;
pub const MSITRANSFORM_ERROR_UPDATEMISSINGROW = MSITRANSFORM_ERROR.UPDATEMISSINGROW;
pub const MSITRANSFORM_ERROR_CHANGECODEPAGE = MSITRANSFORM_ERROR.CHANGECODEPAGE;
pub const MSITRANSFORM_ERROR_VIEWTRANSFORM = MSITRANSFORM_ERROR.VIEWTRANSFORM;
pub const MSITRANSFORM_ERROR_NONE = MSITRANSFORM_ERROR.NONE;

pub const MSITRANSFORM_VALIDATE = enum(i32) {
    LANGUAGE = 1,
    PRODUCT = 2,
    PLATFORM = 4,
    MAJORVERSION = 8,
    MINORVERSION = 16,
    UPDATEVERSION = 32,
    NEWLESSBASEVERSION = 64,
    NEWLESSEQUALBASEVERSION = 128,
    NEWEQUALBASEVERSION = 256,
    NEWGREATEREQUALBASEVERSION = 512,
    NEWGREATERBASEVERSION = 1024,
    UPGRADECODE = 2048,
};
pub const MSITRANSFORM_VALIDATE_LANGUAGE = MSITRANSFORM_VALIDATE.LANGUAGE;
pub const MSITRANSFORM_VALIDATE_PRODUCT = MSITRANSFORM_VALIDATE.PRODUCT;
pub const MSITRANSFORM_VALIDATE_PLATFORM = MSITRANSFORM_VALIDATE.PLATFORM;
pub const MSITRANSFORM_VALIDATE_MAJORVERSION = MSITRANSFORM_VALIDATE.MAJORVERSION;
pub const MSITRANSFORM_VALIDATE_MINORVERSION = MSITRANSFORM_VALIDATE.MINORVERSION;
pub const MSITRANSFORM_VALIDATE_UPDATEVERSION = MSITRANSFORM_VALIDATE.UPDATEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWLESSBASEVERSION = MSITRANSFORM_VALIDATE.NEWLESSBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWLESSEQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWLESSEQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWEQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWEQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWGREATEREQUALBASEVERSION = MSITRANSFORM_VALIDATE.NEWGREATEREQUALBASEVERSION;
pub const MSITRANSFORM_VALIDATE_NEWGREATERBASEVERSION = MSITRANSFORM_VALIDATE.NEWGREATERBASEVERSION;
pub const MSITRANSFORM_VALIDATE_UPGRADECODE = MSITRANSFORM_VALIDATE.UPGRADECODE;

pub const ASSEMBLY_INFO = extern struct {
    cbAssemblyInfo: u32,
    dwAssemblyFlags: u32,
    uliAssemblySizeInKB: ULARGE_INTEGER,
    pszCurrentAssemblyPathBuf: ?PWSTR,
    cchBuf: u32,
};

pub const FUSION_INSTALL_REFERENCE = extern struct {
    cbSize: u32,
    dwFlags: u32,
    guidScheme: Guid,
    szIdentifier: ?[*:0]const u16,
    szNonCannonicalData: ?[*:0]const u16,
};

pub const ASM_NAME = enum(i32) {
    PUBLIC_KEY = 0,
    PUBLIC_KEY_TOKEN = 1,
    HASH_VALUE = 2,
    NAME = 3,
    MAJOR_VERSION = 4,
    MINOR_VERSION = 5,
    BUILD_NUMBER = 6,
    REVISION_NUMBER = 7,
    CULTURE = 8,
    PROCESSOR_ID_ARRAY = 9,
    OSINFO_ARRAY = 10,
    HASH_ALGID = 11,
    ALIAS = 12,
    CODEBASE_URL = 13,
    CODEBASE_LASTMOD = 14,
    NULL_PUBLIC_KEY = 15,
    NULL_PUBLIC_KEY_TOKEN = 16,
    CUSTOM = 17,
    NULL_CUSTOM = 18,
    MVID = 19,
    MAX_PARAMS = 20,
};
pub const ASM_NAME_PUBLIC_KEY = ASM_NAME.PUBLIC_KEY;
pub const ASM_NAME_PUBLIC_KEY_TOKEN = ASM_NAME.PUBLIC_KEY_TOKEN;
pub const ASM_NAME_HASH_VALUE = ASM_NAME.HASH_VALUE;
pub const ASM_NAME_NAME = ASM_NAME.NAME;
pub const ASM_NAME_MAJOR_VERSION = ASM_NAME.MAJOR_VERSION;
pub const ASM_NAME_MINOR_VERSION = ASM_NAME.MINOR_VERSION;
pub const ASM_NAME_BUILD_NUMBER = ASM_NAME.BUILD_NUMBER;
pub const ASM_NAME_REVISION_NUMBER = ASM_NAME.REVISION_NUMBER;
pub const ASM_NAME_CULTURE = ASM_NAME.CULTURE;
pub const ASM_NAME_PROCESSOR_ID_ARRAY = ASM_NAME.PROCESSOR_ID_ARRAY;
pub const ASM_NAME_OSINFO_ARRAY = ASM_NAME.OSINFO_ARRAY;
pub const ASM_NAME_HASH_ALGID = ASM_NAME.HASH_ALGID;
pub const ASM_NAME_ALIAS = ASM_NAME.ALIAS;
pub const ASM_NAME_CODEBASE_URL = ASM_NAME.CODEBASE_URL;
pub const ASM_NAME_CODEBASE_LASTMOD = ASM_NAME.CODEBASE_LASTMOD;
pub const ASM_NAME_NULL_PUBLIC_KEY = ASM_NAME.NULL_PUBLIC_KEY;
pub const ASM_NAME_NULL_PUBLIC_KEY_TOKEN = ASM_NAME.NULL_PUBLIC_KEY_TOKEN;
pub const ASM_NAME_CUSTOM = ASM_NAME.CUSTOM;
pub const ASM_NAME_NULL_CUSTOM = ASM_NAME.NULL_CUSTOM;
pub const ASM_NAME_MVID = ASM_NAME.MVID;
pub const ASM_NAME_MAX_PARAMS = ASM_NAME.MAX_PARAMS;

pub const ASM_BIND_FLAGS = enum(u32) {
    FORCE_CACHE_INSTALL = 1,
    RFS_INTEGRITY_CHECK = 2,
    RFS_MODULE_CHECK = 4,
    BINPATH_PROBE_ONLY = 8,
    SHARED_BINPATH_HINT = 16,
    PARENT_ASM_HINT = 32,
    _,
    pub fn initFlags(o: struct {
        FORCE_CACHE_INSTALL: u1 = 0,
        RFS_INTEGRITY_CHECK: u1 = 0,
        RFS_MODULE_CHECK: u1 = 0,
        BINPATH_PROBE_ONLY: u1 = 0,
        SHARED_BINPATH_HINT: u1 = 0,
        PARENT_ASM_HINT: u1 = 0,
    }) ASM_BIND_FLAGS {
        return @intToEnum(ASM_BIND_FLAGS,
              (if (o.FORCE_CACHE_INSTALL == 1) @enumToInt(ASM_BIND_FLAGS.FORCE_CACHE_INSTALL) else 0)
            | (if (o.RFS_INTEGRITY_CHECK == 1) @enumToInt(ASM_BIND_FLAGS.RFS_INTEGRITY_CHECK) else 0)
            | (if (o.RFS_MODULE_CHECK == 1) @enumToInt(ASM_BIND_FLAGS.RFS_MODULE_CHECK) else 0)
            | (if (o.BINPATH_PROBE_ONLY == 1) @enumToInt(ASM_BIND_FLAGS.BINPATH_PROBE_ONLY) else 0)
            | (if (o.SHARED_BINPATH_HINT == 1) @enumToInt(ASM_BIND_FLAGS.SHARED_BINPATH_HINT) else 0)
            | (if (o.PARENT_ASM_HINT == 1) @enumToInt(ASM_BIND_FLAGS.PARENT_ASM_HINT) else 0)
        );
    }
};
pub const ASM_BINDF_FORCE_CACHE_INSTALL = ASM_BIND_FLAGS.FORCE_CACHE_INSTALL;
pub const ASM_BINDF_RFS_INTEGRITY_CHECK = ASM_BIND_FLAGS.RFS_INTEGRITY_CHECK;
pub const ASM_BINDF_RFS_MODULE_CHECK = ASM_BIND_FLAGS.RFS_MODULE_CHECK;
pub const ASM_BINDF_BINPATH_PROBE_ONLY = ASM_BIND_FLAGS.BINPATH_PROBE_ONLY;
pub const ASM_BINDF_SHARED_BINPATH_HINT = ASM_BIND_FLAGS.SHARED_BINPATH_HINT;
pub const ASM_BINDF_PARENT_ASM_HINT = ASM_BIND_FLAGS.PARENT_ASM_HINT;

pub const ASM_DISPLAY_FLAGS = enum(i32) {
    VERSION = 1,
    CULTURE = 2,
    PUBLIC_KEY_TOKEN = 4,
    PUBLIC_KEY = 8,
    CUSTOM = 16,
    PROCESSORARCHITECTURE = 32,
    LANGUAGEID = 64,
};
pub const ASM_DISPLAYF_VERSION = ASM_DISPLAY_FLAGS.VERSION;
pub const ASM_DISPLAYF_CULTURE = ASM_DISPLAY_FLAGS.CULTURE;
pub const ASM_DISPLAYF_PUBLIC_KEY_TOKEN = ASM_DISPLAY_FLAGS.PUBLIC_KEY_TOKEN;
pub const ASM_DISPLAYF_PUBLIC_KEY = ASM_DISPLAY_FLAGS.PUBLIC_KEY;
pub const ASM_DISPLAYF_CUSTOM = ASM_DISPLAY_FLAGS.CUSTOM;
pub const ASM_DISPLAYF_PROCESSORARCHITECTURE = ASM_DISPLAY_FLAGS.PROCESSORARCHITECTURE;
pub const ASM_DISPLAYF_LANGUAGEID = ASM_DISPLAY_FLAGS.LANGUAGEID;

pub const ASM_CMP_FLAGS = enum(i32) {
    NAME = 1,
    MAJOR_VERSION = 2,
    MINOR_VERSION = 4,
    BUILD_NUMBER = 8,
    REVISION_NUMBER = 16,
    PUBLIC_KEY_TOKEN = 32,
    CULTURE = 64,
    CUSTOM = 128,
    ALL = 255,
    DEFAULT = 256,
};
pub const ASM_CMPF_NAME = ASM_CMP_FLAGS.NAME;
pub const ASM_CMPF_MAJOR_VERSION = ASM_CMP_FLAGS.MAJOR_VERSION;
pub const ASM_CMPF_MINOR_VERSION = ASM_CMP_FLAGS.MINOR_VERSION;
pub const ASM_CMPF_BUILD_NUMBER = ASM_CMP_FLAGS.BUILD_NUMBER;
pub const ASM_CMPF_REVISION_NUMBER = ASM_CMP_FLAGS.REVISION_NUMBER;
pub const ASM_CMPF_PUBLIC_KEY_TOKEN = ASM_CMP_FLAGS.PUBLIC_KEY_TOKEN;
pub const ASM_CMPF_CULTURE = ASM_CMP_FLAGS.CULTURE;
pub const ASM_CMPF_CUSTOM = ASM_CMP_FLAGS.CUSTOM;
pub const ASM_CMPF_ALL = ASM_CMP_FLAGS.ALL;
pub const ASM_CMPF_DEFAULT = ASM_CMP_FLAGS.DEFAULT;

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyName_Value = @import("../zig.zig").Guid.initString("cd193bc0-b4bc-11d2-9833-00c04fc31d2e");
pub const IID_IAssemblyName = &IID_IAssemblyName_Value;
pub const IAssemblyName = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetProperty: fn(
            self: *const IAssemblyName,
            PropertyId: u32,
            pvProperty: ?*c_void,
            cbProperty: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProperty: fn(
            self: *const IAssemblyName,
            PropertyId: u32,
            pvProperty: ?*c_void,
            pcbProperty: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finalize: fn(
            self: *const IAssemblyName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayName: fn(
            self: *const IAssemblyName,
            szDisplayName: ?[*:0]u16,
            pccDisplayName: ?*u32,
            dwDisplayFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reserved: fn(
            self: *const IAssemblyName,
            refIID: ?*const Guid,
            pUnkReserved1: ?*IUnknown,
            pUnkReserved2: ?*IUnknown,
            szReserved: ?[*:0]const u16,
            llReserved: i64,
            pvReserved: ?*c_void,
            cbReserved: u32,
            ppReserved: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IAssemblyName,
            lpcwBuffer: ?*u32,
            pwzName: ?[*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const IAssemblyName,
            pdwVersionHi: ?*u32,
            pdwVersionLow: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqual: fn(
            self: *const IAssemblyName,
            pName: ?*IAssemblyName,
            dwCmpFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IAssemblyName,
            pName: ?*?*IAssemblyName,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_SetProperty(self: *const T, PropertyId: u32, pvProperty: ?*c_void, cbProperty: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).SetProperty(@ptrCast(*const IAssemblyName, self), PropertyId, pvProperty, cbProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_GetProperty(self: *const T, PropertyId: u32, pvProperty: ?*c_void, pcbProperty: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).GetProperty(@ptrCast(*const IAssemblyName, self), PropertyId, pvProperty, pcbProperty);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_Finalize(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).Finalize(@ptrCast(*const IAssemblyName, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_GetDisplayName(self: *const T, szDisplayName: ?[*:0]u16, pccDisplayName: ?*u32, dwDisplayFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).GetDisplayName(@ptrCast(*const IAssemblyName, self), szDisplayName, pccDisplayName, dwDisplayFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_Reserved(self: *const T, refIID: ?*const Guid, pUnkReserved1: ?*IUnknown, pUnkReserved2: ?*IUnknown, szReserved: ?[*:0]const u16, llReserved: i64, pvReserved: ?*c_void, cbReserved: u32, ppReserved: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).Reserved(@ptrCast(*const IAssemblyName, self), refIID, pUnkReserved1, pUnkReserved2, szReserved, llReserved, pvReserved, cbReserved, ppReserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_GetName(self: *const T, lpcwBuffer: ?*u32, pwzName: ?[*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).GetName(@ptrCast(*const IAssemblyName, self), lpcwBuffer, pwzName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_GetVersion(self: *const T, pdwVersionHi: ?*u32, pdwVersionLow: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).GetVersion(@ptrCast(*const IAssemblyName, self), pdwVersionHi, pdwVersionLow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_IsEqual(self: *const T, pName: ?*IAssemblyName, dwCmpFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).IsEqual(@ptrCast(*const IAssemblyName, self), pName, dwCmpFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyName_Clone(self: *const T, pName: ?*?*IAssemblyName) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyName.VTable, self.vtable).Clone(@ptrCast(*const IAssemblyName, self), pName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyCacheItem_Value = @import("../zig.zig").Guid.initString("9e3aaeb4-d1cd-11d2-bab9-00c04f8eceae");
pub const IID_IAssemblyCacheItem = &IID_IAssemblyCacheItem_Value;
pub const IAssemblyCacheItem = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateStream: fn(
            self: *const IAssemblyCacheItem,
            dwFlags: u32,
            pszStreamName: ?[*:0]const u16,
            dwFormat: u32,
            dwFormatFlags: u32,
            ppIStream: ?*?*IStream,
            puliMaxSize: ?*ULARGE_INTEGER,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Commit: fn(
            self: *const IAssemblyCacheItem,
            dwFlags: u32,
            pulDisposition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbortItem: fn(
            self: *const IAssemblyCacheItem,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCacheItem_CreateStream(self: *const T, dwFlags: u32, pszStreamName: ?[*:0]const u16, dwFormat: u32, dwFormatFlags: u32, ppIStream: ?*?*IStream, puliMaxSize: ?*ULARGE_INTEGER) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCacheItem.VTable, self.vtable).CreateStream(@ptrCast(*const IAssemblyCacheItem, self), dwFlags, pszStreamName, dwFormat, dwFormatFlags, ppIStream, puliMaxSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCacheItem_Commit(self: *const T, dwFlags: u32, pulDisposition: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCacheItem.VTable, self.vtable).Commit(@ptrCast(*const IAssemblyCacheItem, self), dwFlags, pulDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCacheItem_AbortItem(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCacheItem.VTable, self.vtable).AbortItem(@ptrCast(*const IAssemblyCacheItem, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows6.0.6000'
const IID_IAssemblyCache_Value = @import("../zig.zig").Guid.initString("e707dcde-d1cd-11d2-bab9-00c04f8eceae");
pub const IID_IAssemblyCache = &IID_IAssemblyCache_Value;
pub const IAssemblyCache = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        UninstallAssembly: fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pszAssemblyName: ?[*:0]const u16,
            pRefData: ?*FUSION_INSTALL_REFERENCE,
            pulDisposition: ?*IASSEMBLYCACHE_UNINSTALL_DISPOSITION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAssemblyInfo: fn(
            self: *const IAssemblyCache,
            dwFlags: QUERYASMINFO_FLAGS,
            pszAssemblyName: ?[*:0]const u16,
            pAsmInfo: ?*ASSEMBLY_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAssemblyCacheItem: fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pvReserved: ?*c_void,
            ppAsmItem: ?*?*IAssemblyCacheItem,
            pszAssemblyName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reserved: fn(
            self: *const IAssemblyCache,
            ppUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InstallAssembly: fn(
            self: *const IAssemblyCache,
            dwFlags: u32,
            pszManifestFilePath: ?[*:0]const u16,
            pRefData: ?*FUSION_INSTALL_REFERENCE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_UninstallAssembly(self: *const T, dwFlags: u32, pszAssemblyName: ?[*:0]const u16, pRefData: ?*FUSION_INSTALL_REFERENCE, pulDisposition: ?*IASSEMBLYCACHE_UNINSTALL_DISPOSITION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).UninstallAssembly(@ptrCast(*const IAssemblyCache, self), dwFlags, pszAssemblyName, pRefData, pulDisposition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_QueryAssemblyInfo(self: *const T, dwFlags: QUERYASMINFO_FLAGS, pszAssemblyName: ?[*:0]const u16, pAsmInfo: ?*ASSEMBLY_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).QueryAssemblyInfo(@ptrCast(*const IAssemblyCache, self), dwFlags, pszAssemblyName, pAsmInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_CreateAssemblyCacheItem(self: *const T, dwFlags: u32, pvReserved: ?*c_void, ppAsmItem: ?*?*IAssemblyCacheItem, pszAssemblyName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).CreateAssemblyCacheItem(@ptrCast(*const IAssemblyCache, self), dwFlags, pvReserved, ppAsmItem, pszAssemblyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_Reserved(self: *const T, ppUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).Reserved(@ptrCast(*const IAssemblyCache, self), ppUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IAssemblyCache_InstallAssembly(self: *const T, dwFlags: u32, pszManifestFilePath: ?[*:0]const u16, pRefData: ?*FUSION_INSTALL_REFERENCE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IAssemblyCache.VTable, self.vtable).InstallAssembly(@ptrCast(*const IAssemblyCache, self), dwFlags, pszManifestFilePath, pRefData);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const CREATE_ASM_NAME_OBJ_FLAGS = enum(i32) {
    PARSE_DISPLAY_NAME = 1,
    SET_DEFAULT_VALUES = 2,
};
pub const CANOF_PARSE_DISPLAY_NAME = CREATE_ASM_NAME_OBJ_FLAGS.PARSE_DISPLAY_NAME;
pub const CANOF_SET_DEFAULT_VALUES = CREATE_ASM_NAME_OBJ_FLAGS.SET_DEFAULT_VALUES;

pub const PROTECTED_FILE_DATA = extern struct {
    FileName: [260]u16,
    FileNumber: u32,
};

pub const ACTCTXA = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpSource: ?[*:0]const u8,
    wProcessorArchitecture: u16,
    wLangId: u16,
    lpAssemblyDirectory: ?[*:0]const u8,
    lpResourceName: ?[*:0]const u8,
    lpApplicationName: ?[*:0]const u8,
    hModule: ?HINSTANCE,
};

pub const ACTCTXW = extern struct {
    cbSize: u32,
    dwFlags: u32,
    lpSource: ?[*:0]const u16,
    wProcessorArchitecture: u16,
    wLangId: u16,
    lpAssemblyDirectory: ?[*:0]const u16,
    lpResourceName: ?[*:0]const u16,
    lpApplicationName: ?[*:0]const u16,
    hModule: ?HINSTANCE,
};

pub const ACTCTX_SECTION_KEYED_DATA = extern struct {
    cbSize: u32,
    ulDataFormatVersion: u32,
    lpData: ?*c_void,
    ulLength: u32,
    lpSectionGlobalData: ?*c_void,
    ulSectionGlobalDataLength: u32,
    lpSectionBase: ?*c_void,
    ulSectionTotalLength: u32,
    hActCtx: ?HANDLE,
    ulAssemblyRosterIndex: u32,
    ulFlags: u32,
    AssemblyMetadata: ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA,
};


//--------------------------------------------------------------------------------
// Section: Functions (281)
//--------------------------------------------------------------------------------
// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCloseHandle(
    hAny: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCloseAllHandles(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetInternalUI(
    dwUILevel: INSTALLUILEVEL,
    phWnd: ?*?HWND,
) callconv(@import("std").os.windows.WINAPI) INSTALLUILEVEL;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetExternalUIA(
    puiHandler: ?INSTALLUI_HANDLERA,
    dwMessageFilter: u32,
    pvContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?INSTALLUI_HANDLERA;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetExternalUIW(
    puiHandler: ?INSTALLUI_HANDLERW,
    dwMessageFilter: u32,
    pvContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?INSTALLUI_HANDLERW;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetExternalUIRecord(
    puiHandler: ?PINSTALLUI_HANDLER_RECORD,
    dwMessageFilter: u32,
    pvContext: ?*c_void,
    ppuiPrevHandler: ?PINSTALLUI_HANDLER_RECORD,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnableLogA(
    dwLogMode: INSTALLOGMODE,
    szLogFile: ?[*:0]const u8,
    dwLogAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnableLogW(
    dwLogMode: INSTALLOGMODE,
    szLogFile: ?[*:0]const u16,
    dwLogAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryProductStateA(
    szProduct: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryProductStateW(
    szProduct: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoA(
    szProduct: ?[*:0]const u8,
    szAttribute: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoW(
    szProduct: ?[*:0]const u16,
    szAttribute: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallProductA(
    szPackagePath: ?[*:0]const u8,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallProductW(
    szPackagePath: ?[*:0]const u16,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureProductA(
    szProduct: ?[*:0]const u8,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureProductW(
    szProduct: ?[*:0]const u16,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureProductExA(
    szProduct: ?[*:0]const u8,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureProductExW(
    szProduct: ?[*:0]const u16,
    iInstallLevel: INSTALLLEVEL,
    eInstallState: INSTALLSTATE,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiReinstallProductA(
    szProduct: ?[*:0]const u8,
    szReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiReinstallProductW(
    szProduct: ?[*:0]const u16,
    szReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseProductExA(
    szPackagePath: ?[*:0]const u8,
    szScriptfilePath: ?[*:0]const u8,
    szTransforms: ?[*:0]const u8,
    lgidLanguage: u16,
    dwPlatform: u32,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseProductExW(
    szPackagePath: ?[*:0]const u16,
    szScriptfilePath: ?[*:0]const u16,
    szTransforms: ?[*:0]const u16,
    lgidLanguage: u16,
    dwPlatform: u32,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseProductA(
    szPackagePath: ?[*:0]const u8,
    szScriptfilePath: ?[*:0]const u8,
    szTransforms: ?[*:0]const u8,
    lgidLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseProductW(
    szPackagePath: ?[*:0]const u16,
    szScriptfilePath: ?[*:0]const u16,
    szTransforms: ?[*:0]const u16,
    lgidLanguage: u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProcessAdvertiseScriptA(
    szScriptFile: ?[*:0]const u8,
    szIconFolder: ?[*:0]const u8,
    hRegData: ?HKEY,
    fShortcuts: BOOL,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProcessAdvertiseScriptW(
    szScriptFile: ?[*:0]const u16,
    szIconFolder: ?[*:0]const u16,
    hRegData: ?HKEY,
    fShortcuts: BOOL,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseScriptA(
    szScriptFile: ?[*:0]const u8,
    dwFlags: u32,
    phRegData: ?*?HKEY,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiAdvertiseScriptW(
    szScriptFile: ?[*:0]const u16,
    dwFlags: u32,
    phRegData: ?*?HKEY,
    fRemoveItems: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoFromScriptA(
    szScriptFile: ?[*:0]const u8,
    lpProductBuf39: ?PSTR,
    plgidLanguage: ?*u16,
    pdwVersion: ?*u32,
    lpNameBuf: ?[*:0]u8,
    pcchNameBuf: ?*u32,
    lpPackageBuf: ?[*:0]u8,
    pcchPackageBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductInfoFromScriptW(
    szScriptFile: ?[*:0]const u16,
    lpProductBuf39: ?PWSTR,
    plgidLanguage: ?*u16,
    pdwVersion: ?*u32,
    lpNameBuf: ?[*:0]u16,
    pcchNameBuf: ?*u32,
    lpPackageBuf: ?[*:0]u16,
    pcchPackageBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductCodeA(
    szComponent: ?[*:0]const u8,
    lpBuf39: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductCodeW(
    szComponent: ?[*:0]const u16,
    lpBuf39: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetUserInfoA(
    szProduct: ?[*:0]const u8,
    lpUserNameBuf: ?[*:0]u8,
    pcchUserNameBuf: ?*u32,
    lpOrgNameBuf: ?[*:0]u8,
    pcchOrgNameBuf: ?*u32,
    lpSerialBuf: ?[*:0]u8,
    pcchSerialBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) USERINFOSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetUserInfoW(
    szProduct: ?[*:0]const u16,
    lpUserNameBuf: ?[*:0]u16,
    pcchUserNameBuf: ?*u32,
    lpOrgNameBuf: ?[*:0]u16,
    pcchOrgNameBuf: ?*u32,
    lpSerialBuf: ?[*:0]u16,
    pcchSerialBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) USERINFOSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCollectUserInfoA(
    szProduct: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCollectUserInfoW(
    szProduct: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiApplyPatchA(
    szPatchPackage: ?[*:0]const u8,
    szInstallPackage: ?[*:0]const u8,
    eInstallType: INSTALLTYPE,
    szCommandLine: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiApplyPatchW(
    szPatchPackage: ?[*:0]const u16,
    szInstallPackage: ?[*:0]const u16,
    eInstallType: INSTALLTYPE,
    szCommandLine: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchInfoA(
    szPatch: ?[*:0]const u8,
    szAttribute: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchInfoW(
    szPatch: ?[*:0]const u16,
    szAttribute: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumPatchesA(
    szProduct: ?[*:0]const u8,
    iPatchIndex: u32,
    lpPatchBuf: ?PSTR,
    lpTransformsBuf: [*:0]u8,
    pcchTransformsBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumPatchesW(
    szProduct: ?[*:0]const u16,
    iPatchIndex: u32,
    lpPatchBuf: ?PWSTR,
    lpTransformsBuf: [*:0]u16,
    pcchTransformsBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRemovePatchesA(
    szPatchList: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    eUninstallType: INSTALLTYPE,
    szPropertyList: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRemovePatchesW(
    szPatchList: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    eUninstallType: INSTALLTYPE,
    szPropertyList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows Vista'
pub extern "msi" fn MsiExtractPatchXMLDataA(
    szPatchPath: ?[*:0]const u8,
    dwReserved: u32,
    szXMLData: ?[*:0]u8,
    pcchXMLData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows Vista'
pub extern "msi" fn MsiExtractPatchXMLDataW(
    szPatchPath: ?[*:0]const u16,
    dwReserved: u32,
    szXMLData: ?[*:0]u16,
    pcchXMLData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchInfoExA(
    szPatchCode: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u8,
    lpValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchInfoExW(
    szPatchCode: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szProperty: ?[*:0]const u16,
    lpValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiApplyMultiplePatchesA(
    szPatchPackages: ?[*:0]const u8,
    szProductCode: ?[*:0]const u8,
    szPropertiesList: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiApplyMultiplePatchesW(
    szPatchPackages: ?[*:0]const u16,
    szProductCode: ?[*:0]const u16,
    szPropertiesList: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDeterminePatchSequenceA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDeterminePatchSequenceW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDetermineApplicablePatchesA(
    szProductPackagePath: ?[*:0]const u8,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOA,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDetermineApplicablePatchesW(
    szProductPackagePath: ?[*:0]const u16,
    cPatchInfo: u32,
    pPatchInfo: [*]MSIPATCHSEQUENCEINFOW,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumPatchesExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwFilter: u32,
    dwIndex: u32,
    szPatchCode: ?PSTR,
    szTargetProductCode: ?PSTR,
    pdwTargetProductContext: ?*MSIINSTALLCONTEXT,
    szTargetUserSid: ?[*:0]u8,
    pcchTargetUserSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumPatchesExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwFilter: u32,
    dwIndex: u32,
    szPatchCode: ?PWSTR,
    szTargetProductCode: ?PWSTR,
    pdwTargetProductContext: ?*MSIINSTALLCONTEXT,
    szTargetUserSid: ?[*:0]u16,
    pcchTargetUserSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryFeatureStateA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryFeatureStateW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryFeatureStateExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szFeature: ?[*:0]const u8,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryFeatureStateExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szFeature: ?[*:0]const u16,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiUseFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiUseFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiUseFeatureExA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    dwInstallMode: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiUseFeatureExW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    dwInstallMode: u32,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureUsageA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    pdwUseCount: ?*u32,
    pwDateUsed: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureUsageW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    pdwUseCount: ?*u32,
    pwDateUsed: ?*u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiConfigureFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiReinstallFeatureA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    dwReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiReinstallFeatureW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    dwReinstallMode: REINSTALLMODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideComponentA(
    szProduct: ?[*:0]const u8,
    szFeature: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideComponentW(
    szProduct: ?[*:0]const u16,
    szFeature: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideQualifiedComponentA(
    szCategory: ?[*:0]const u8,
    szQualifier: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideQualifiedComponentW(
    szCategory: ?[*:0]const u16,
    szQualifier: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideQualifiedComponentExA(
    szCategory: ?[*:0]const u8,
    szQualifier: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    szProduct: ?[*:0]const u8,
    dwUnused1: u32,
    dwUnused2: u32,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideQualifiedComponentExW(
    szCategory: ?[*:0]const u16,
    szQualifier: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    szProduct: ?[*:0]const u16,
    dwUnused1: u32,
    dwUnused2: u32,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetComponentPathA(
    szProduct: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    lpPathBuf: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetComponentPathW(
    szProduct: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    lpPathBuf: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
// This function from dll 'msi' is being skipped because it has some sort of issue
pub fn MsiGetComponentPathExA() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'Windows 8'
// This function from dll 'msi' is being skipped because it has some sort of issue
pub fn MsiGetComponentPathExW() void { @panic("this function is not working"); }

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideAssemblyA(
    szAssemblyName: ?[*:0]const u8,
    szAppContext: ?[*:0]const u8,
    dwInstallMode: INSTALLMODE,
    dwAssemblyInfo: MSIASSEMBLYINFO,
    lpPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProvideAssemblyW(
    szAssemblyName: ?[*:0]const u16,
    szAppContext: ?[*:0]const u16,
    dwInstallMode: INSTALLMODE,
    dwAssemblyInfo: MSIASSEMBLYINFO,
    lpPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryComponentStateA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    szComponentCode: ?[*:0]const u8,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiQueryComponentStateW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    szComponentCode: ?[*:0]const u16,
    pdwState: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumProductsA(
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumProductsW(
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumProductsExA(
    szProductCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwIndex: u32,
    szInstalledProductCode: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumProductsExW(
    szProductCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwIndex: u32,
    szInstalledProductCode: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumRelatedProductsA(
    lpUpgradeCode: ?[*:0]const u8,
    dwReserved: u32,
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumRelatedProductsW(
    lpUpgradeCode: ?[*:0]const u16,
    dwReserved: u32,
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumFeaturesA(
    szProduct: ?[*:0]const u8,
    iFeatureIndex: u32,
    lpFeatureBuf: ?PSTR,
    lpParentBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumFeaturesW(
    szProduct: ?[*:0]const u16,
    iFeatureIndex: u32,
    lpFeatureBuf: ?PWSTR,
    lpParentBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentsA(
    iComponentIndex: u32,
    lpComponentBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentsW(
    iComponentIndex: u32,
    lpComponentBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentsExA(
    szUserSid: ?[*:0]const u8,
    dwContext: u32,
    dwIndex: u32,
    szInstalledComponentCode: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentsExW(
    szUserSid: ?[*:0]const u16,
    dwContext: u32,
    dwIndex: u32,
    szInstalledComponentCode: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumClientsA(
    szComponent: ?[*:0]const u8,
    iProductIndex: u32,
    lpProductBuf: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumClientsW(
    szComponent: ?[*:0]const u16,
    iProductIndex: u32,
    lpProductBuf: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumClientsExA(
    szComponent: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwProductIndex: u32,
    szProductBuf: ?PSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u8,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumClientsExW(
    szComponent: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwProductIndex: u32,
    szProductBuf: ?PWSTR,
    pdwInstalledContext: ?*MSIINSTALLCONTEXT,
    szSid: ?[*:0]u16,
    pcchSid: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentQualifiersA(
    szComponent: ?[*:0]const u8,
    iIndex: u32,
    lpQualifierBuf: [*:0]u8,
    pcchQualifierBuf: ?*u32,
    lpApplicationDataBuf: ?[*:0]u8,
    pcchApplicationDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentQualifiersW(
    szComponent: ?[*:0]const u16,
    iIndex: u32,
    lpQualifierBuf: [*:0]u16,
    pcchQualifierBuf: ?*u32,
    lpApplicationDataBuf: ?[*:0]u16,
    pcchApplicationDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenProductA(
    szProduct: ?[*:0]const u8,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenProductW(
    szProduct: ?[*:0]const u16,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenPackageA(
    szPackagePath: ?[*:0]const u8,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenPackageW(
    szPackagePath: ?[*:0]const u16,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenPackageExA(
    szPackagePath: ?[*:0]const u8,
    dwOptions: u32,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenPackageExW(
    szPackagePath: ?[*:0]const u16,
    dwOptions: u32,
    hProduct: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchFileListA(
    szProductCode: ?[*:0]const u8,
    szPatchPackages: ?[*:0]const u8,
    pcFiles: ?*u32,
    pphFileRecords: ?*?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPatchFileListW(
    szProductCode: ?[*:0]const u16,
    szPatchPackages: ?[*:0]const u16,
    pcFiles: ?*u32,
    pphFileRecords: ?*?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductPropertyA(
    hProduct: MSIHANDLE,
    szProperty: ?[*:0]const u8,
    lpValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetProductPropertyW(
    hProduct: MSIHANDLE,
    szProperty: ?[*:0]const u16,
    lpValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiVerifyPackageA(
    szPackagePath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiVerifyPackageW(
    szPackagePath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureInfoA(
    hProduct: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    lpAttributes: ?*u32,
    lpTitleBuf: ?[*:0]u8,
    pcchTitleBuf: ?*u32,
    lpHelpBuf: ?[*:0]u8,
    pcchHelpBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureInfoW(
    hProduct: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    lpAttributes: ?*u32,
    lpTitleBuf: ?[*:0]u16,
    pcchTitleBuf: ?*u32,
    lpHelpBuf: ?[*:0]u16,
    pcchHelpBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallMissingComponentA(
    szProduct: ?[*:0]const u8,
    szComponent: ?[*:0]const u8,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallMissingComponentW(
    szProduct: ?[*:0]const u16,
    szComponent: ?[*:0]const u16,
    eInstallState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallMissingFileA(
    szProduct: ?[*:0]const u8,
    szFile: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiInstallMissingFileW(
    szProduct: ?[*:0]const u16,
    szFile: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiLocateComponentA(
    szComponent: ?[*:0]const u8,
    lpPathBuf: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiLocateComponentW(
    szComponent: ?[*:0]const u16,
    lpPathBuf: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) INSTALLSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearAllA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearAllW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddSourceA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
    szSource: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddSourceW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
    szSource: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListForceResolutionA(
    szProduct: ?[*:0]const u8,
    szUserName: ?[*:0]const u8,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListForceResolutionW(
    szProduct: ?[*:0]const u16,
    szUserName: ?[*:0]const u16,
    dwReserved: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddSourceExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u8,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddSourceExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u16,
    dwIndex: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddMediaDiskA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
    szVolumeLabel: ?[*:0]const u8,
    szDiskPrompt: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListAddMediaDiskW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
    szVolumeLabel: ?[*:0]const u16,
    szDiskPrompt: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearSourceA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearSourceW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szSource: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearMediaDiskA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearMediaDiskW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwDiskId: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearAllExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListClearAllExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListForceResolutionExA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListForceResolutionExW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListSetInfoA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListSetInfoW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListGetInfoA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u8,
    szValue: ?[*:0]u8,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListGetInfoW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    szProperty: ?[*:0]const u16,
    szValue: ?[*:0]u16,
    pcchValue: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListEnumSourcesA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    szSource: ?[*:0]u8,
    pcchSource: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListEnumSourcesW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    szSource: ?[*:0]u16,
    pcchSource: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListEnumMediaDisksA(
    szProductCodeOrPatchCode: ?[*:0]const u8,
    szUserSid: ?[*:0]const u8,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    pdwDiskId: ?*u32,
    szVolumeLabel: ?[*:0]u8,
    pcchVolumeLabel: ?*u32,
    szDiskPrompt: ?[*:0]u8,
    pcchDiskPrompt: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSourceListEnumMediaDisksW(
    szProductCodeOrPatchCode: ?[*:0]const u16,
    szUserSid: ?[*:0]const u16,
    dwContext: MSIINSTALLCONTEXT,
    dwOptions: u32,
    dwIndex: u32,
    pdwDiskId: ?*u32,
    szVolumeLabel: ?[*:0]u16,
    pcchVolumeLabel: ?*u32,
    szDiskPrompt: ?[*:0]u16,
    pcchDiskPrompt: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileVersionA(
    szFilePath: ?[*:0]const u8,
    lpVersionBuf: ?[*:0]u8,
    pcchVersionBuf: ?*u32,
    lpLangBuf: ?[*:0]u8,
    pcchLangBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileVersionW(
    szFilePath: ?[*:0]const u16,
    lpVersionBuf: ?[*:0]u16,
    pcchVersionBuf: ?*u32,
    lpLangBuf: ?[*:0]u16,
    pcchLangBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileHashA(
    szFilePath: ?[*:0]const u8,
    dwOptions: u32,
    pHash: ?*MSIFILEHASHINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileHashW(
    szFilePath: ?[*:0]const u16,
    dwOptions: u32,
    pHash: ?*MSIFILEHASHINFO,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileSignatureInformationA(
    szSignedObjectPath: ?[*:0]const u8,
    dwFlags: u32,
    ppcCertContext: ?*?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbHashData: ?*u8,
    pcbHashData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFileSignatureInformationW(
    szSignedObjectPath: ?[*:0]const u16,
    dwFlags: u32,
    ppcCertContext: ?*?*CERT_CONTEXT,
    // TODO: what to do with BytesParamIndex 4?
    pbHashData: ?*u8,
    pcbHashData: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetShortcutTargetA(
    szShortcutPath: ?[*:0]const u8,
    szProductCode: ?PSTR,
    szFeatureId: ?PSTR,
    szComponentCode: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetShortcutTargetW(
    szShortcutPath: ?[*:0]const u16,
    szProductCode: ?PWSTR,
    szFeatureId: ?PWSTR,
    szComponentCode: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiIsProductElevatedA(
    szProduct: ?[*:0]const u8,
    pfElevated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiIsProductElevatedW(
    szProduct: ?[*:0]const u16,
    pfElevated: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiNotifySidChangeA(
    pOldSid: ?[*:0]const u8,
    pNewSid: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiNotifySidChangeW(
    pOldSid: ?[*:0]const u16,
    pNewSid: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiBeginTransactionA(
    szName: ?[*:0]const u8,
    dwTransactionAttributes: u32,
    phTransactionHandle: ?*MSIHANDLE,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiBeginTransactionW(
    szName: ?[*:0]const u16,
    dwTransactionAttributes: u32,
    phTransactionHandle: ?*MSIHANDLE,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEndTransaction(
    dwTransactionState: MSITRANSACTIONSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiJoinTransaction(
    hTransactionHandle: MSIHANDLE,
    dwTransactionAttributes: u32,
    phChangeOfOwnerEvent: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseOpenViewA(
    hDatabase: MSIHANDLE,
    szQuery: ?[*:0]const u8,
    phView: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseOpenViewW(
    hDatabase: MSIHANDLE,
    szQuery: ?[*:0]const u16,
    phView: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewGetErrorA(
    hView: MSIHANDLE,
    szColumnNameBuffer: ?[*:0]u8,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) MSIDBERROR;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewGetErrorW(
    hView: MSIHANDLE,
    szColumnNameBuffer: ?[*:0]u16,
    pcchBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) MSIDBERROR;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewExecute(
    hView: MSIHANDLE,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewFetch(
    hView: MSIHANDLE,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewModify(
    hView: MSIHANDLE,
    eModifyMode: MSIMODIFY,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewGetColumnInfo(
    hView: MSIHANDLE,
    eColumnInfo: MSICOLINFO,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiViewClose(
    hView: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseGetPrimaryKeysA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseGetPrimaryKeysW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
    phRecord: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseIsTablePersistentA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseIsTablePersistentW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetSummaryInformationA(
    hDatabase: MSIHANDLE,
    szDatabasePath: ?[*:0]const u8,
    uiUpdateCount: u32,
    phSummaryInfo: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetSummaryInformationW(
    hDatabase: MSIHANDLE,
    szDatabasePath: ?[*:0]const u16,
    uiUpdateCount: u32,
    phSummaryInfo: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoGetPropertyCount(
    hSummaryInfo: MSIHANDLE,
    puiPropertyCount: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoSetPropertyA(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    uiDataType: u32,
    iValue: i32,
    pftValue: ?*FILETIME,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoSetPropertyW(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    uiDataType: u32,
    iValue: i32,
    pftValue: ?*FILETIME,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoGetPropertyA(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    puiDataType: ?*u32,
    piValue: ?*i32,
    pftValue: ?*FILETIME,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoGetPropertyW(
    hSummaryInfo: MSIHANDLE,
    uiProperty: u32,
    puiDataType: ?*u32,
    piValue: ?*i32,
    pftValue: ?*FILETIME,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSummaryInfoPersist(
    hSummaryInfo: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenDatabaseA(
    szDatabasePath: ?[*:0]const u8,
    szPersist: ?[*:0]const u8,
    phDatabase: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiOpenDatabaseW(
    szDatabasePath: ?[*:0]const u16,
    szPersist: ?[*:0]const u16,
    phDatabase: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseImportA(
    hDatabase: MSIHANDLE,
    szFolderPath: ?[*:0]const u8,
    szFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseImportW(
    hDatabase: MSIHANDLE,
    szFolderPath: ?[*:0]const u16,
    szFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseExportA(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u8,
    szFolderPath: ?[*:0]const u8,
    szFileName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseExportW(
    hDatabase: MSIHANDLE,
    szTableName: ?[*:0]const u16,
    szFolderPath: ?[*:0]const u16,
    szFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseMergeA(
    hDatabase: MSIHANDLE,
    hDatabaseMerge: MSIHANDLE,
    szTableName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseMergeW(
    hDatabase: MSIHANDLE,
    hDatabaseMerge: MSIHANDLE,
    szTableName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseGenerateTransformA(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iReserved1: i32,
    iReserved2: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseGenerateTransformW(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iReserved1: i32,
    iReserved2: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseApplyTransformA(
    hDatabase: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iErrorConditions: MSITRANSFORM_ERROR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseApplyTransformW(
    hDatabase: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iErrorConditions: MSITRANSFORM_ERROR,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCreateTransformSummaryInfoA(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u8,
    iErrorConditions: MSITRANSFORM_ERROR,
    iValidation: MSITRANSFORM_VALIDATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCreateTransformSummaryInfoW(
    hDatabase: MSIHANDLE,
    hDatabaseReference: MSIHANDLE,
    szTransformFile: ?[*:0]const u16,
    iErrorConditions: MSITRANSFORM_ERROR,
    iValidation: MSITRANSFORM_VALIDATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDatabaseCommit(
    hDatabase: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetDatabaseState(
    hDatabase: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) MSIDBSTATE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiCreateRecord(
    cParams: u32,
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordIsNull(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordDataSize(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetInteger(
    hRecord: MSIHANDLE,
    iField: u32,
    iValue: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetStringA(
    hRecord: MSIHANDLE,
    iField: u32,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetStringW(
    hRecord: MSIHANDLE,
    iField: u32,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordGetInteger(
    hRecord: MSIHANDLE,
    iField: u32,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordGetStringA(
    hRecord: MSIHANDLE,
    iField: u32,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordGetStringW(
    hRecord: MSIHANDLE,
    iField: u32,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordGetFieldCount(
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetStreamA(
    hRecord: MSIHANDLE,
    iField: u32,
    szFilePath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordSetStreamW(
    hRecord: MSIHANDLE,
    iField: u32,
    szFilePath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordReadStream(
    hRecord: MSIHANDLE,
    iField: u32,
    // TODO: what to do with BytesParamIndex 3?
    szDataBuf: ?PSTR,
    pcbDataBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiRecordClearData(
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetActiveDatabase(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetPropertyA(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u8,
    szValue: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetPropertyW(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u16,
    szValue: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPropertyA(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u8,
    szValueBuf: ?[*:0]u8,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetPropertyW(
    hInstall: MSIHANDLE,
    szName: ?[*:0]const u16,
    szValueBuf: ?[*:0]u16,
    pcchValueBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetLanguage(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetMode(
    hInstall: MSIHANDLE,
    eRunMode: MSIRUNMODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetMode(
    hInstall: MSIHANDLE,
    eRunMode: MSIRUNMODE,
    fState: BOOL,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiFormatRecordA(
    hInstall: MSIHANDLE,
    hRecord: MSIHANDLE,
    szResultBuf: ?[*:0]u8,
    pcchResultBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiFormatRecordW(
    hInstall: MSIHANDLE,
    hRecord: MSIHANDLE,
    szResultBuf: ?[*:0]u16,
    pcchResultBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDoActionA(
    hInstall: MSIHANDLE,
    szAction: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiDoActionW(
    hInstall: MSIHANDLE,
    szAction: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSequenceA(
    hInstall: MSIHANDLE,
    szTable: ?[*:0]const u8,
    iSequenceMode: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSequenceW(
    hInstall: MSIHANDLE,
    szTable: ?[*:0]const u16,
    iSequenceMode: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiProcessMessage(
    hInstall: MSIHANDLE,
    eMessageType: INSTALLMESSAGE,
    hRecord: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEvaluateConditionA(
    hInstall: MSIHANDLE,
    szCondition: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEvaluateConditionW(
    hInstall: MSIHANDLE,
    szCondition: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) MSICONDITION;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureStateA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureStateW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetFeatureStateA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetFeatureStateW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetFeatureAttributesA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetFeatureAttributesW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    dwAttributes: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetComponentStateA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetComponentStateW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    piInstalled: ?*INSTALLSTATE,
    piAction: ?*INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetComponentStateA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetComponentStateW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    iState: INSTALLSTATE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureCostA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    iCostTree: MSICOSTTREE,
    iState: INSTALLSTATE,
    piCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureCostW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    iCostTree: MSICOSTTREE,
    iState: INSTALLSTATE,
    piCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentCostsA(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u8,
    dwIndex: u32,
    iState: INSTALLSTATE,
    szDriveBuf: [*:0]u8,
    pcchDriveBuf: ?*u32,
    piCost: ?*i32,
    piTempCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnumComponentCostsW(
    hInstall: MSIHANDLE,
    szComponent: ?[*:0]const u16,
    dwIndex: u32,
    iState: INSTALLSTATE,
    szDriveBuf: [*:0]u16,
    pcchDriveBuf: ?*u32,
    piCost: ?*i32,
    piTempCost: ?*i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetInstallLevel(
    hInstall: MSIHANDLE,
    iInstallLevel: i32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureValidStatesA(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u8,
    lpInstallStates: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetFeatureValidStatesW(
    hInstall: MSIHANDLE,
    szFeature: ?[*:0]const u16,
    lpInstallStates: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetSourcePathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetSourcePathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetTargetPathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szPathBuf: ?[*:0]u8,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetTargetPathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szPathBuf: ?[*:0]u16,
    pcchPathBuf: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetTargetPathA(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u8,
    szFolderPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiSetTargetPathW(
    hInstall: MSIHANDLE,
    szFolder: ?[*:0]const u16,
    szFolderPath: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiVerifyDiskSpace(
    hInstall: MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiEnableUIPreview(
    hDatabase: MSIHANDLE,
    phPreview: ?*MSIHANDLE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiPreviewDialogA(
    hPreview: MSIHANDLE,
    szDialogName: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiPreviewDialogW(
    hPreview: MSIHANDLE,
    szDialogName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiPreviewBillboardA(
    hPreview: MSIHANDLE,
    szControlName: ?[*:0]const u8,
    szBillboard: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiPreviewBillboardW(
    hPreview: MSIHANDLE,
    szControlName: ?[*:0]const u16,
    szBillboard: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'Windows 8'
pub extern "msi" fn MsiGetLastErrorRecord(
) callconv(@import("std").os.windows.WINAPI) MSIHANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sfc" fn SfcGetNextProtectedFile(
    RpcHandle: ?HANDLE,
    ProtFileData: ?*PROTECTED_FILE_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "sfc" fn SfcIsFileProtected(
    RpcHandle: ?HANDLE,
    ProtFileName: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "sfc" fn SfcIsKeyProtected(
    KeyHandle: ?HKEY,
    SubKeyName: ?[*:0]const u16,
    KeySam: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "sfc" fn SfpVerifyFile(
    pszFileName: ?[*:0]const u8,
    pszError: [*:0]u8,
    dwErrSize: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateActCtxA(
    pActCtx: ?*ACTCTXA,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn CreateActCtxW(
    pActCtx: ?*ACTCTXW,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn AddRefActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReleaseActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ZombifyActCtx(
    hActCtx: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ActivateActCtx(
    hActCtx: ?HANDLE,
    lpCookie: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DeactivateActCtx(
    dwFlags: u32,
    ulCookie: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetCurrentActCtx(
    lphActCtx: ?*?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindActCtxSectionStringA(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpStringToFind: ?[*:0]const u8,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindActCtxSectionStringW(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpStringToFind: ?[*:0]const u16,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FindActCtxSectionGuid(
    dwFlags: u32,
    lpExtensionGuid: ?*const Guid,
    ulSectionId: u32,
    lpGuidToFind: ?*const Guid,
    ReturnedData: ?*ACTCTX_SECTION_KEYED_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn QueryActCtxW(
    dwFlags: u32,
    hActCtx: ?HANDLE,
    pvSubInstance: ?*c_void,
    ulInfoClass: u32,
    // TODO: what to do with BytesParamIndex 5?
    pvBuffer: ?*c_void,
    cbBuffer: usize,
    pcbWrittenOrRequired: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn QueryActCtxSettingsW(
    dwFlags: u32,
    hActCtx: ?HANDLE,
    settingsNameSpace: ?[*:0]const u16,
    settingName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 5?
    pvBuffer: ?PWSTR,
    dwBuffer: usize,
    pdwWrittenOrRequired: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (121)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const INSTALLUI_HANDLER = thismodule.INSTALLUI_HANDLERA;
        pub const MSIPATCHSEQUENCEINFO = thismodule.MSIPATCHSEQUENCEINFOA;
        pub const ACTCTX = thismodule.ACTCTXA;
        pub const MsiSetExternalUI = thismodule.MsiSetExternalUIA;
        pub const MsiEnableLog = thismodule.MsiEnableLogA;
        pub const MsiQueryProductState = thismodule.MsiQueryProductStateA;
        pub const MsiGetProductInfo = thismodule.MsiGetProductInfoA;
        pub const MsiGetProductInfoEx = thismodule.MsiGetProductInfoExA;
        pub const MsiInstallProduct = thismodule.MsiInstallProductA;
        pub const MsiConfigureProduct = thismodule.MsiConfigureProductA;
        pub const MsiConfigureProductEx = thismodule.MsiConfigureProductExA;
        pub const MsiReinstallProduct = thismodule.MsiReinstallProductA;
        pub const MsiAdvertiseProductEx = thismodule.MsiAdvertiseProductExA;
        pub const MsiAdvertiseProduct = thismodule.MsiAdvertiseProductA;
        pub const MsiProcessAdvertiseScript = thismodule.MsiProcessAdvertiseScriptA;
        pub const MsiAdvertiseScript = thismodule.MsiAdvertiseScriptA;
        pub const MsiGetProductInfoFromScript = thismodule.MsiGetProductInfoFromScriptA;
        pub const MsiGetProductCode = thismodule.MsiGetProductCodeA;
        pub const MsiGetUserInfo = thismodule.MsiGetUserInfoA;
        pub const MsiCollectUserInfo = thismodule.MsiCollectUserInfoA;
        pub const MsiApplyPatch = thismodule.MsiApplyPatchA;
        pub const MsiGetPatchInfo = thismodule.MsiGetPatchInfoA;
        pub const MsiEnumPatches = thismodule.MsiEnumPatchesA;
        pub const MsiRemovePatches = thismodule.MsiRemovePatchesA;
        pub const MsiExtractPatchXMLData = thismodule.MsiExtractPatchXMLDataA;
        pub const MsiGetPatchInfoEx = thismodule.MsiGetPatchInfoExA;
        pub const MsiApplyMultiplePatches = thismodule.MsiApplyMultiplePatchesA;
        pub const MsiDeterminePatchSequence = thismodule.MsiDeterminePatchSequenceA;
        pub const MsiDetermineApplicablePatches = thismodule.MsiDetermineApplicablePatchesA;
        pub const MsiEnumPatchesEx = thismodule.MsiEnumPatchesExA;
        pub const MsiQueryFeatureState = thismodule.MsiQueryFeatureStateA;
        pub const MsiQueryFeatureStateEx = thismodule.MsiQueryFeatureStateExA;
        pub const MsiUseFeature = thismodule.MsiUseFeatureA;
        pub const MsiUseFeatureEx = thismodule.MsiUseFeatureExA;
        pub const MsiGetFeatureUsage = thismodule.MsiGetFeatureUsageA;
        pub const MsiConfigureFeature = thismodule.MsiConfigureFeatureA;
        pub const MsiReinstallFeature = thismodule.MsiReinstallFeatureA;
        pub const MsiProvideComponent = thismodule.MsiProvideComponentA;
        pub const MsiProvideQualifiedComponent = thismodule.MsiProvideQualifiedComponentA;
        pub const MsiProvideQualifiedComponentEx = thismodule.MsiProvideQualifiedComponentExA;
        pub const MsiGetComponentPath = thismodule.MsiGetComponentPathA;
        pub const MsiGetComponentPathEx = thismodule.MsiGetComponentPathExA;
        pub const MsiProvideAssembly = thismodule.MsiProvideAssemblyA;
        pub const MsiQueryComponentState = thismodule.MsiQueryComponentStateA;
        pub const MsiEnumProducts = thismodule.MsiEnumProductsA;
        pub const MsiEnumProductsEx = thismodule.MsiEnumProductsExA;
        pub const MsiEnumRelatedProducts = thismodule.MsiEnumRelatedProductsA;
        pub const MsiEnumFeatures = thismodule.MsiEnumFeaturesA;
        pub const MsiEnumComponents = thismodule.MsiEnumComponentsA;
        pub const MsiEnumComponentsEx = thismodule.MsiEnumComponentsExA;
        pub const MsiEnumClients = thismodule.MsiEnumClientsA;
        pub const MsiEnumClientsEx = thismodule.MsiEnumClientsExA;
        pub const MsiEnumComponentQualifiers = thismodule.MsiEnumComponentQualifiersA;
        pub const MsiOpenProduct = thismodule.MsiOpenProductA;
        pub const MsiOpenPackage = thismodule.MsiOpenPackageA;
        pub const MsiOpenPackageEx = thismodule.MsiOpenPackageExA;
        pub const MsiGetPatchFileList = thismodule.MsiGetPatchFileListA;
        pub const MsiGetProductProperty = thismodule.MsiGetProductPropertyA;
        pub const MsiVerifyPackage = thismodule.MsiVerifyPackageA;
        pub const MsiGetFeatureInfo = thismodule.MsiGetFeatureInfoA;
        pub const MsiInstallMissingComponent = thismodule.MsiInstallMissingComponentA;
        pub const MsiInstallMissingFile = thismodule.MsiInstallMissingFileA;
        pub const MsiLocateComponent = thismodule.MsiLocateComponentA;
        pub const MsiSourceListClearAll = thismodule.MsiSourceListClearAllA;
        pub const MsiSourceListAddSource = thismodule.MsiSourceListAddSourceA;
        pub const MsiSourceListForceResolution = thismodule.MsiSourceListForceResolutionA;
        pub const MsiSourceListAddSourceEx = thismodule.MsiSourceListAddSourceExA;
        pub const MsiSourceListAddMediaDisk = thismodule.MsiSourceListAddMediaDiskA;
        pub const MsiSourceListClearSource = thismodule.MsiSourceListClearSourceA;
        pub const MsiSourceListClearMediaDisk = thismodule.MsiSourceListClearMediaDiskA;
        pub const MsiSourceListClearAllEx = thismodule.MsiSourceListClearAllExA;
        pub const MsiSourceListForceResolutionEx = thismodule.MsiSourceListForceResolutionExA;
        pub const MsiSourceListSetInfo = thismodule.MsiSourceListSetInfoA;
        pub const MsiSourceListGetInfo = thismodule.MsiSourceListGetInfoA;
        pub const MsiSourceListEnumSources = thismodule.MsiSourceListEnumSourcesA;
        pub const MsiSourceListEnumMediaDisks = thismodule.MsiSourceListEnumMediaDisksA;
        pub const MsiGetFileVersion = thismodule.MsiGetFileVersionA;
        pub const MsiGetFileHash = thismodule.MsiGetFileHashA;
        pub const MsiGetFileSignatureInformation = thismodule.MsiGetFileSignatureInformationA;
        pub const MsiGetShortcutTarget = thismodule.MsiGetShortcutTargetA;
        pub const MsiIsProductElevated = thismodule.MsiIsProductElevatedA;
        pub const MsiNotifySidChange = thismodule.MsiNotifySidChangeA;
        pub const MsiBeginTransaction = thismodule.MsiBeginTransactionA;
        pub const MsiDatabaseOpenView = thismodule.MsiDatabaseOpenViewA;
        pub const MsiViewGetError = thismodule.MsiViewGetErrorA;
        pub const MsiDatabaseGetPrimaryKeys = thismodule.MsiDatabaseGetPrimaryKeysA;
        pub const MsiDatabaseIsTablePersistent = thismodule.MsiDatabaseIsTablePersistentA;
        pub const MsiGetSummaryInformation = thismodule.MsiGetSummaryInformationA;
        pub const MsiSummaryInfoSetProperty = thismodule.MsiSummaryInfoSetPropertyA;
        pub const MsiSummaryInfoGetProperty = thismodule.MsiSummaryInfoGetPropertyA;
        pub const MsiOpenDatabase = thismodule.MsiOpenDatabaseA;
        pub const MsiDatabaseImport = thismodule.MsiDatabaseImportA;
        pub const MsiDatabaseExport = thismodule.MsiDatabaseExportA;
        pub const MsiDatabaseMerge = thismodule.MsiDatabaseMergeA;
        pub const MsiDatabaseGenerateTransform = thismodule.MsiDatabaseGenerateTransformA;
        pub const MsiDatabaseApplyTransform = thismodule.MsiDatabaseApplyTransformA;
        pub const MsiCreateTransformSummaryInfo = thismodule.MsiCreateTransformSummaryInfoA;
        pub const MsiRecordSetString = thismodule.MsiRecordSetStringA;
        pub const MsiRecordGetString = thismodule.MsiRecordGetStringA;
        pub const MsiRecordSetStream = thismodule.MsiRecordSetStreamA;
        pub const MsiSetProperty = thismodule.MsiSetPropertyA;
        pub const MsiGetProperty = thismodule.MsiGetPropertyA;
        pub const MsiFormatRecord = thismodule.MsiFormatRecordA;
        pub const MsiDoAction = thismodule.MsiDoActionA;
        pub const MsiSequence = thismodule.MsiSequenceA;
        pub const MsiEvaluateCondition = thismodule.MsiEvaluateConditionA;
        pub const MsiGetFeatureState = thismodule.MsiGetFeatureStateA;
        pub const MsiSetFeatureState = thismodule.MsiSetFeatureStateA;
        pub const MsiSetFeatureAttributes = thismodule.MsiSetFeatureAttributesA;
        pub const MsiGetComponentState = thismodule.MsiGetComponentStateA;
        pub const MsiSetComponentState = thismodule.MsiSetComponentStateA;
        pub const MsiGetFeatureCost = thismodule.MsiGetFeatureCostA;
        pub const MsiEnumComponentCosts = thismodule.MsiEnumComponentCostsA;
        pub const MsiGetFeatureValidStates = thismodule.MsiGetFeatureValidStatesA;
        pub const MsiGetSourcePath = thismodule.MsiGetSourcePathA;
        pub const MsiGetTargetPath = thismodule.MsiGetTargetPathA;
        pub const MsiSetTargetPath = thismodule.MsiSetTargetPathA;
        pub const MsiPreviewDialog = thismodule.MsiPreviewDialogA;
        pub const MsiPreviewBillboard = thismodule.MsiPreviewBillboardA;
        pub const CreateActCtx = thismodule.CreateActCtxA;
        pub const FindActCtxSectionString = thismodule.FindActCtxSectionStringA;
    },
    .wide => struct {
        pub const INSTALLUI_HANDLER = thismodule.INSTALLUI_HANDLERW;
        pub const MSIPATCHSEQUENCEINFO = thismodule.MSIPATCHSEQUENCEINFOW;
        pub const ACTCTX = thismodule.ACTCTXW;
        pub const MsiSetExternalUI = thismodule.MsiSetExternalUIW;
        pub const MsiEnableLog = thismodule.MsiEnableLogW;
        pub const MsiQueryProductState = thismodule.MsiQueryProductStateW;
        pub const MsiGetProductInfo = thismodule.MsiGetProductInfoW;
        pub const MsiGetProductInfoEx = thismodule.MsiGetProductInfoExW;
        pub const MsiInstallProduct = thismodule.MsiInstallProductW;
        pub const MsiConfigureProduct = thismodule.MsiConfigureProductW;
        pub const MsiConfigureProductEx = thismodule.MsiConfigureProductExW;
        pub const MsiReinstallProduct = thismodule.MsiReinstallProductW;
        pub const MsiAdvertiseProductEx = thismodule.MsiAdvertiseProductExW;
        pub const MsiAdvertiseProduct = thismodule.MsiAdvertiseProductW;
        pub const MsiProcessAdvertiseScript = thismodule.MsiProcessAdvertiseScriptW;
        pub const MsiAdvertiseScript = thismodule.MsiAdvertiseScriptW;
        pub const MsiGetProductInfoFromScript = thismodule.MsiGetProductInfoFromScriptW;
        pub const MsiGetProductCode = thismodule.MsiGetProductCodeW;
        pub const MsiGetUserInfo = thismodule.MsiGetUserInfoW;
        pub const MsiCollectUserInfo = thismodule.MsiCollectUserInfoW;
        pub const MsiApplyPatch = thismodule.MsiApplyPatchW;
        pub const MsiGetPatchInfo = thismodule.MsiGetPatchInfoW;
        pub const MsiEnumPatches = thismodule.MsiEnumPatchesW;
        pub const MsiRemovePatches = thismodule.MsiRemovePatchesW;
        pub const MsiExtractPatchXMLData = thismodule.MsiExtractPatchXMLDataW;
        pub const MsiGetPatchInfoEx = thismodule.MsiGetPatchInfoExW;
        pub const MsiApplyMultiplePatches = thismodule.MsiApplyMultiplePatchesW;
        pub const MsiDeterminePatchSequence = thismodule.MsiDeterminePatchSequenceW;
        pub const MsiDetermineApplicablePatches = thismodule.MsiDetermineApplicablePatchesW;
        pub const MsiEnumPatchesEx = thismodule.MsiEnumPatchesExW;
        pub const MsiQueryFeatureState = thismodule.MsiQueryFeatureStateW;
        pub const MsiQueryFeatureStateEx = thismodule.MsiQueryFeatureStateExW;
        pub const MsiUseFeature = thismodule.MsiUseFeatureW;
        pub const MsiUseFeatureEx = thismodule.MsiUseFeatureExW;
        pub const MsiGetFeatureUsage = thismodule.MsiGetFeatureUsageW;
        pub const MsiConfigureFeature = thismodule.MsiConfigureFeatureW;
        pub const MsiReinstallFeature = thismodule.MsiReinstallFeatureW;
        pub const MsiProvideComponent = thismodule.MsiProvideComponentW;
        pub const MsiProvideQualifiedComponent = thismodule.MsiProvideQualifiedComponentW;
        pub const MsiProvideQualifiedComponentEx = thismodule.MsiProvideQualifiedComponentExW;
        pub const MsiGetComponentPath = thismodule.MsiGetComponentPathW;
        pub const MsiGetComponentPathEx = thismodule.MsiGetComponentPathExW;
        pub const MsiProvideAssembly = thismodule.MsiProvideAssemblyW;
        pub const MsiQueryComponentState = thismodule.MsiQueryComponentStateW;
        pub const MsiEnumProducts = thismodule.MsiEnumProductsW;
        pub const MsiEnumProductsEx = thismodule.MsiEnumProductsExW;
        pub const MsiEnumRelatedProducts = thismodule.MsiEnumRelatedProductsW;
        pub const MsiEnumFeatures = thismodule.MsiEnumFeaturesW;
        pub const MsiEnumComponents = thismodule.MsiEnumComponentsW;
        pub const MsiEnumComponentsEx = thismodule.MsiEnumComponentsExW;
        pub const MsiEnumClients = thismodule.MsiEnumClientsW;
        pub const MsiEnumClientsEx = thismodule.MsiEnumClientsExW;
        pub const MsiEnumComponentQualifiers = thismodule.MsiEnumComponentQualifiersW;
        pub const MsiOpenProduct = thismodule.MsiOpenProductW;
        pub const MsiOpenPackage = thismodule.MsiOpenPackageW;
        pub const MsiOpenPackageEx = thismodule.MsiOpenPackageExW;
        pub const MsiGetPatchFileList = thismodule.MsiGetPatchFileListW;
        pub const MsiGetProductProperty = thismodule.MsiGetProductPropertyW;
        pub const MsiVerifyPackage = thismodule.MsiVerifyPackageW;
        pub const MsiGetFeatureInfo = thismodule.MsiGetFeatureInfoW;
        pub const MsiInstallMissingComponent = thismodule.MsiInstallMissingComponentW;
        pub const MsiInstallMissingFile = thismodule.MsiInstallMissingFileW;
        pub const MsiLocateComponent = thismodule.MsiLocateComponentW;
        pub const MsiSourceListClearAll = thismodule.MsiSourceListClearAllW;
        pub const MsiSourceListAddSource = thismodule.MsiSourceListAddSourceW;
        pub const MsiSourceListForceResolution = thismodule.MsiSourceListForceResolutionW;
        pub const MsiSourceListAddSourceEx = thismodule.MsiSourceListAddSourceExW;
        pub const MsiSourceListAddMediaDisk = thismodule.MsiSourceListAddMediaDiskW;
        pub const MsiSourceListClearSource = thismodule.MsiSourceListClearSourceW;
        pub const MsiSourceListClearMediaDisk = thismodule.MsiSourceListClearMediaDiskW;
        pub const MsiSourceListClearAllEx = thismodule.MsiSourceListClearAllExW;
        pub const MsiSourceListForceResolutionEx = thismodule.MsiSourceListForceResolutionExW;
        pub const MsiSourceListSetInfo = thismodule.MsiSourceListSetInfoW;
        pub const MsiSourceListGetInfo = thismodule.MsiSourceListGetInfoW;
        pub const MsiSourceListEnumSources = thismodule.MsiSourceListEnumSourcesW;
        pub const MsiSourceListEnumMediaDisks = thismodule.MsiSourceListEnumMediaDisksW;
        pub const MsiGetFileVersion = thismodule.MsiGetFileVersionW;
        pub const MsiGetFileHash = thismodule.MsiGetFileHashW;
        pub const MsiGetFileSignatureInformation = thismodule.MsiGetFileSignatureInformationW;
        pub const MsiGetShortcutTarget = thismodule.MsiGetShortcutTargetW;
        pub const MsiIsProductElevated = thismodule.MsiIsProductElevatedW;
        pub const MsiNotifySidChange = thismodule.MsiNotifySidChangeW;
        pub const MsiBeginTransaction = thismodule.MsiBeginTransactionW;
        pub const MsiDatabaseOpenView = thismodule.MsiDatabaseOpenViewW;
        pub const MsiViewGetError = thismodule.MsiViewGetErrorW;
        pub const MsiDatabaseGetPrimaryKeys = thismodule.MsiDatabaseGetPrimaryKeysW;
        pub const MsiDatabaseIsTablePersistent = thismodule.MsiDatabaseIsTablePersistentW;
        pub const MsiGetSummaryInformation = thismodule.MsiGetSummaryInformationW;
        pub const MsiSummaryInfoSetProperty = thismodule.MsiSummaryInfoSetPropertyW;
        pub const MsiSummaryInfoGetProperty = thismodule.MsiSummaryInfoGetPropertyW;
        pub const MsiOpenDatabase = thismodule.MsiOpenDatabaseW;
        pub const MsiDatabaseImport = thismodule.MsiDatabaseImportW;
        pub const MsiDatabaseExport = thismodule.MsiDatabaseExportW;
        pub const MsiDatabaseMerge = thismodule.MsiDatabaseMergeW;
        pub const MsiDatabaseGenerateTransform = thismodule.MsiDatabaseGenerateTransformW;
        pub const MsiDatabaseApplyTransform = thismodule.MsiDatabaseApplyTransformW;
        pub const MsiCreateTransformSummaryInfo = thismodule.MsiCreateTransformSummaryInfoW;
        pub const MsiRecordSetString = thismodule.MsiRecordSetStringW;
        pub const MsiRecordGetString = thismodule.MsiRecordGetStringW;
        pub const MsiRecordSetStream = thismodule.MsiRecordSetStreamW;
        pub const MsiSetProperty = thismodule.MsiSetPropertyW;
        pub const MsiGetProperty = thismodule.MsiGetPropertyW;
        pub const MsiFormatRecord = thismodule.MsiFormatRecordW;
        pub const MsiDoAction = thismodule.MsiDoActionW;
        pub const MsiSequence = thismodule.MsiSequenceW;
        pub const MsiEvaluateCondition = thismodule.MsiEvaluateConditionW;
        pub const MsiGetFeatureState = thismodule.MsiGetFeatureStateW;
        pub const MsiSetFeatureState = thismodule.MsiSetFeatureStateW;
        pub const MsiSetFeatureAttributes = thismodule.MsiSetFeatureAttributesW;
        pub const MsiGetComponentState = thismodule.MsiGetComponentStateW;
        pub const MsiSetComponentState = thismodule.MsiSetComponentStateW;
        pub const MsiGetFeatureCost = thismodule.MsiGetFeatureCostW;
        pub const MsiEnumComponentCosts = thismodule.MsiEnumComponentCostsW;
        pub const MsiGetFeatureValidStates = thismodule.MsiGetFeatureValidStatesW;
        pub const MsiGetSourcePath = thismodule.MsiGetSourcePathW;
        pub const MsiGetTargetPath = thismodule.MsiGetTargetPathW;
        pub const MsiSetTargetPath = thismodule.MsiSetTargetPathW;
        pub const MsiPreviewDialog = thismodule.MsiPreviewDialogW;
        pub const MsiPreviewBillboard = thismodule.MsiPreviewBillboardW;
        pub const CreateActCtx = thismodule.CreateActCtxW;
        pub const FindActCtxSectionString = thismodule.FindActCtxSectionStringW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const INSTALLUI_HANDLER = *opaque{};
        pub const MSIPATCHSEQUENCEINFO = *opaque{};
        pub const ACTCTX = *opaque{};
        pub const MsiSetExternalUI = *opaque{};
        pub const MsiEnableLog = *opaque{};
        pub const MsiQueryProductState = *opaque{};
        pub const MsiGetProductInfo = *opaque{};
        pub const MsiGetProductInfoEx = *opaque{};
        pub const MsiInstallProduct = *opaque{};
        pub const MsiConfigureProduct = *opaque{};
        pub const MsiConfigureProductEx = *opaque{};
        pub const MsiReinstallProduct = *opaque{};
        pub const MsiAdvertiseProductEx = *opaque{};
        pub const MsiAdvertiseProduct = *opaque{};
        pub const MsiProcessAdvertiseScript = *opaque{};
        pub const MsiAdvertiseScript = *opaque{};
        pub const MsiGetProductInfoFromScript = *opaque{};
        pub const MsiGetProductCode = *opaque{};
        pub const MsiGetUserInfo = *opaque{};
        pub const MsiCollectUserInfo = *opaque{};
        pub const MsiApplyPatch = *opaque{};
        pub const MsiGetPatchInfo = *opaque{};
        pub const MsiEnumPatches = *opaque{};
        pub const MsiRemovePatches = *opaque{};
        pub const MsiExtractPatchXMLData = *opaque{};
        pub const MsiGetPatchInfoEx = *opaque{};
        pub const MsiApplyMultiplePatches = *opaque{};
        pub const MsiDeterminePatchSequence = *opaque{};
        pub const MsiDetermineApplicablePatches = *opaque{};
        pub const MsiEnumPatchesEx = *opaque{};
        pub const MsiQueryFeatureState = *opaque{};
        pub const MsiQueryFeatureStateEx = *opaque{};
        pub const MsiUseFeature = *opaque{};
        pub const MsiUseFeatureEx = *opaque{};
        pub const MsiGetFeatureUsage = *opaque{};
        pub const MsiConfigureFeature = *opaque{};
        pub const MsiReinstallFeature = *opaque{};
        pub const MsiProvideComponent = *opaque{};
        pub const MsiProvideQualifiedComponent = *opaque{};
        pub const MsiProvideQualifiedComponentEx = *opaque{};
        pub const MsiGetComponentPath = *opaque{};
        pub const MsiGetComponentPathEx = *opaque{};
        pub const MsiProvideAssembly = *opaque{};
        pub const MsiQueryComponentState = *opaque{};
        pub const MsiEnumProducts = *opaque{};
        pub const MsiEnumProductsEx = *opaque{};
        pub const MsiEnumRelatedProducts = *opaque{};
        pub const MsiEnumFeatures = *opaque{};
        pub const MsiEnumComponents = *opaque{};
        pub const MsiEnumComponentsEx = *opaque{};
        pub const MsiEnumClients = *opaque{};
        pub const MsiEnumClientsEx = *opaque{};
        pub const MsiEnumComponentQualifiers = *opaque{};
        pub const MsiOpenProduct = *opaque{};
        pub const MsiOpenPackage = *opaque{};
        pub const MsiOpenPackageEx = *opaque{};
        pub const MsiGetPatchFileList = *opaque{};
        pub const MsiGetProductProperty = *opaque{};
        pub const MsiVerifyPackage = *opaque{};
        pub const MsiGetFeatureInfo = *opaque{};
        pub const MsiInstallMissingComponent = *opaque{};
        pub const MsiInstallMissingFile = *opaque{};
        pub const MsiLocateComponent = *opaque{};
        pub const MsiSourceListClearAll = *opaque{};
        pub const MsiSourceListAddSource = *opaque{};
        pub const MsiSourceListForceResolution = *opaque{};
        pub const MsiSourceListAddSourceEx = *opaque{};
        pub const MsiSourceListAddMediaDisk = *opaque{};
        pub const MsiSourceListClearSource = *opaque{};
        pub const MsiSourceListClearMediaDisk = *opaque{};
        pub const MsiSourceListClearAllEx = *opaque{};
        pub const MsiSourceListForceResolutionEx = *opaque{};
        pub const MsiSourceListSetInfo = *opaque{};
        pub const MsiSourceListGetInfo = *opaque{};
        pub const MsiSourceListEnumSources = *opaque{};
        pub const MsiSourceListEnumMediaDisks = *opaque{};
        pub const MsiGetFileVersion = *opaque{};
        pub const MsiGetFileHash = *opaque{};
        pub const MsiGetFileSignatureInformation = *opaque{};
        pub const MsiGetShortcutTarget = *opaque{};
        pub const MsiIsProductElevated = *opaque{};
        pub const MsiNotifySidChange = *opaque{};
        pub const MsiBeginTransaction = *opaque{};
        pub const MsiDatabaseOpenView = *opaque{};
        pub const MsiViewGetError = *opaque{};
        pub const MsiDatabaseGetPrimaryKeys = *opaque{};
        pub const MsiDatabaseIsTablePersistent = *opaque{};
        pub const MsiGetSummaryInformation = *opaque{};
        pub const MsiSummaryInfoSetProperty = *opaque{};
        pub const MsiSummaryInfoGetProperty = *opaque{};
        pub const MsiOpenDatabase = *opaque{};
        pub const MsiDatabaseImport = *opaque{};
        pub const MsiDatabaseExport = *opaque{};
        pub const MsiDatabaseMerge = *opaque{};
        pub const MsiDatabaseGenerateTransform = *opaque{};
        pub const MsiDatabaseApplyTransform = *opaque{};
        pub const MsiCreateTransformSummaryInfo = *opaque{};
        pub const MsiRecordSetString = *opaque{};
        pub const MsiRecordGetString = *opaque{};
        pub const MsiRecordSetStream = *opaque{};
        pub const MsiSetProperty = *opaque{};
        pub const MsiGetProperty = *opaque{};
        pub const MsiFormatRecord = *opaque{};
        pub const MsiDoAction = *opaque{};
        pub const MsiSequence = *opaque{};
        pub const MsiEvaluateCondition = *opaque{};
        pub const MsiGetFeatureState = *opaque{};
        pub const MsiSetFeatureState = *opaque{};
        pub const MsiSetFeatureAttributes = *opaque{};
        pub const MsiGetComponentState = *opaque{};
        pub const MsiSetComponentState = *opaque{};
        pub const MsiGetFeatureCost = *opaque{};
        pub const MsiEnumComponentCosts = *opaque{};
        pub const MsiGetFeatureValidStates = *opaque{};
        pub const MsiGetSourcePath = *opaque{};
        pub const MsiGetTargetPath = *opaque{};
        pub const MsiSetTargetPath = *opaque{};
        pub const MsiPreviewDialog = *opaque{};
        pub const MsiPreviewBillboard = *opaque{};
        pub const CreateActCtx = *opaque{};
        pub const FindActCtxSectionString = *opaque{};
    } else struct {
        pub const INSTALLUI_HANDLER = @compileError("'INSTALLUI_HANDLER' requires that UNICODE be set to true or false in the root module");
        pub const MSIPATCHSEQUENCEINFO = @compileError("'MSIPATCHSEQUENCEINFO' requires that UNICODE be set to true or false in the root module");
        pub const ACTCTX = @compileError("'ACTCTX' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetExternalUI = @compileError("'MsiSetExternalUI' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnableLog = @compileError("'MsiEnableLog' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryProductState = @compileError("'MsiQueryProductState' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfo = @compileError("'MsiGetProductInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfoEx = @compileError("'MsiGetProductInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallProduct = @compileError("'MsiInstallProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureProduct = @compileError("'MsiConfigureProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureProductEx = @compileError("'MsiConfigureProductEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiReinstallProduct = @compileError("'MsiReinstallProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseProductEx = @compileError("'MsiAdvertiseProductEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseProduct = @compileError("'MsiAdvertiseProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiProcessAdvertiseScript = @compileError("'MsiProcessAdvertiseScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiAdvertiseScript = @compileError("'MsiAdvertiseScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductInfoFromScript = @compileError("'MsiGetProductInfoFromScript' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductCode = @compileError("'MsiGetProductCode' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetUserInfo = @compileError("'MsiGetUserInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiCollectUserInfo = @compileError("'MsiCollectUserInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiApplyPatch = @compileError("'MsiApplyPatch' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchInfo = @compileError("'MsiGetPatchInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumPatches = @compileError("'MsiEnumPatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiRemovePatches = @compileError("'MsiRemovePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiExtractPatchXMLData = @compileError("'MsiExtractPatchXMLData' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchInfoEx = @compileError("'MsiGetPatchInfoEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiApplyMultiplePatches = @compileError("'MsiApplyMultiplePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiDeterminePatchSequence = @compileError("'MsiDeterminePatchSequence' requires that UNICODE be set to true or false in the root module");
        pub const MsiDetermineApplicablePatches = @compileError("'MsiDetermineApplicablePatches' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumPatchesEx = @compileError("'MsiEnumPatchesEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryFeatureState = @compileError("'MsiQueryFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryFeatureStateEx = @compileError("'MsiQueryFeatureStateEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiUseFeature = @compileError("'MsiUseFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiUseFeatureEx = @compileError("'MsiUseFeatureEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureUsage = @compileError("'MsiGetFeatureUsage' requires that UNICODE be set to true or false in the root module");
        pub const MsiConfigureFeature = @compileError("'MsiConfigureFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiReinstallFeature = @compileError("'MsiReinstallFeature' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideComponent = @compileError("'MsiProvideComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideQualifiedComponent = @compileError("'MsiProvideQualifiedComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideQualifiedComponentEx = @compileError("'MsiProvideQualifiedComponentEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentPath = @compileError("'MsiGetComponentPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentPathEx = @compileError("'MsiGetComponentPathEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiProvideAssembly = @compileError("'MsiProvideAssembly' requires that UNICODE be set to true or false in the root module");
        pub const MsiQueryComponentState = @compileError("'MsiQueryComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumProducts = @compileError("'MsiEnumProducts' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumProductsEx = @compileError("'MsiEnumProductsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumRelatedProducts = @compileError("'MsiEnumRelatedProducts' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumFeatures = @compileError("'MsiEnumFeatures' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponents = @compileError("'MsiEnumComponents' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentsEx = @compileError("'MsiEnumComponentsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumClients = @compileError("'MsiEnumClients' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumClientsEx = @compileError("'MsiEnumClientsEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentQualifiers = @compileError("'MsiEnumComponentQualifiers' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenProduct = @compileError("'MsiOpenProduct' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenPackage = @compileError("'MsiOpenPackage' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenPackageEx = @compileError("'MsiOpenPackageEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetPatchFileList = @compileError("'MsiGetPatchFileList' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProductProperty = @compileError("'MsiGetProductProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiVerifyPackage = @compileError("'MsiVerifyPackage' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureInfo = @compileError("'MsiGetFeatureInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallMissingComponent = @compileError("'MsiInstallMissingComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiInstallMissingFile = @compileError("'MsiInstallMissingFile' requires that UNICODE be set to true or false in the root module");
        pub const MsiLocateComponent = @compileError("'MsiLocateComponent' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearAll = @compileError("'MsiSourceListClearAll' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddSource = @compileError("'MsiSourceListAddSource' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListForceResolution = @compileError("'MsiSourceListForceResolution' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddSourceEx = @compileError("'MsiSourceListAddSourceEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListAddMediaDisk = @compileError("'MsiSourceListAddMediaDisk' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearSource = @compileError("'MsiSourceListClearSource' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearMediaDisk = @compileError("'MsiSourceListClearMediaDisk' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListClearAllEx = @compileError("'MsiSourceListClearAllEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListForceResolutionEx = @compileError("'MsiSourceListForceResolutionEx' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListSetInfo = @compileError("'MsiSourceListSetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListGetInfo = @compileError("'MsiSourceListGetInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListEnumSources = @compileError("'MsiSourceListEnumSources' requires that UNICODE be set to true or false in the root module");
        pub const MsiSourceListEnumMediaDisks = @compileError("'MsiSourceListEnumMediaDisks' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileVersion = @compileError("'MsiGetFileVersion' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileHash = @compileError("'MsiGetFileHash' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFileSignatureInformation = @compileError("'MsiGetFileSignatureInformation' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetShortcutTarget = @compileError("'MsiGetShortcutTarget' requires that UNICODE be set to true or false in the root module");
        pub const MsiIsProductElevated = @compileError("'MsiIsProductElevated' requires that UNICODE be set to true or false in the root module");
        pub const MsiNotifySidChange = @compileError("'MsiNotifySidChange' requires that UNICODE be set to true or false in the root module");
        pub const MsiBeginTransaction = @compileError("'MsiBeginTransaction' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseOpenView = @compileError("'MsiDatabaseOpenView' requires that UNICODE be set to true or false in the root module");
        pub const MsiViewGetError = @compileError("'MsiViewGetError' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseGetPrimaryKeys = @compileError("'MsiDatabaseGetPrimaryKeys' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseIsTablePersistent = @compileError("'MsiDatabaseIsTablePersistent' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetSummaryInformation = @compileError("'MsiGetSummaryInformation' requires that UNICODE be set to true or false in the root module");
        pub const MsiSummaryInfoSetProperty = @compileError("'MsiSummaryInfoSetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiSummaryInfoGetProperty = @compileError("'MsiSummaryInfoGetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiOpenDatabase = @compileError("'MsiOpenDatabase' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseImport = @compileError("'MsiDatabaseImport' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseExport = @compileError("'MsiDatabaseExport' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseMerge = @compileError("'MsiDatabaseMerge' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseGenerateTransform = @compileError("'MsiDatabaseGenerateTransform' requires that UNICODE be set to true or false in the root module");
        pub const MsiDatabaseApplyTransform = @compileError("'MsiDatabaseApplyTransform' requires that UNICODE be set to true or false in the root module");
        pub const MsiCreateTransformSummaryInfo = @compileError("'MsiCreateTransformSummaryInfo' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordSetString = @compileError("'MsiRecordSetString' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordGetString = @compileError("'MsiRecordGetString' requires that UNICODE be set to true or false in the root module");
        pub const MsiRecordSetStream = @compileError("'MsiRecordSetStream' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetProperty = @compileError("'MsiSetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetProperty = @compileError("'MsiGetProperty' requires that UNICODE be set to true or false in the root module");
        pub const MsiFormatRecord = @compileError("'MsiFormatRecord' requires that UNICODE be set to true or false in the root module");
        pub const MsiDoAction = @compileError("'MsiDoAction' requires that UNICODE be set to true or false in the root module");
        pub const MsiSequence = @compileError("'MsiSequence' requires that UNICODE be set to true or false in the root module");
        pub const MsiEvaluateCondition = @compileError("'MsiEvaluateCondition' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureState = @compileError("'MsiGetFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetFeatureState = @compileError("'MsiSetFeatureState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetFeatureAttributes = @compileError("'MsiSetFeatureAttributes' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetComponentState = @compileError("'MsiGetComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetComponentState = @compileError("'MsiSetComponentState' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureCost = @compileError("'MsiGetFeatureCost' requires that UNICODE be set to true or false in the root module");
        pub const MsiEnumComponentCosts = @compileError("'MsiEnumComponentCosts' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetFeatureValidStates = @compileError("'MsiGetFeatureValidStates' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetSourcePath = @compileError("'MsiGetSourcePath' requires that UNICODE be set to true or false in the root module");
        pub const MsiGetTargetPath = @compileError("'MsiGetTargetPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiSetTargetPath = @compileError("'MsiSetTargetPath' requires that UNICODE be set to true or false in the root module");
        pub const MsiPreviewDialog = @compileError("'MsiPreviewDialog' requires that UNICODE be set to true or false in the root module");
        pub const MsiPreviewBillboard = @compileError("'MsiPreviewBillboard' requires that UNICODE be set to true or false in the root module");
        pub const CreateActCtx = @compileError("'CreateActCtx' requires that UNICODE be set to true or false in the root module");
        pub const FindActCtxSectionString = @compileError("'FindActCtxSectionString' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (18)
//--------------------------------------------------------------------------------
const Guid = @import("../zig.zig").Guid;
const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA = @import("../system/windows_programming.zig").ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
const BOOL = @import("../foundation.zig").BOOL;
const BSTR = @import("../foundation.zig").BSTR;
const CERT_CONTEXT = @import("../security/cryptography/core.zig").CERT_CONTEXT;
const FILETIME = @import("../foundation.zig").FILETIME;
const HANDLE = @import("../foundation.zig").HANDLE;
const HINSTANCE = @import("../foundation.zig").HINSTANCE;
const HKEY = @import("../system/registry.zig").HKEY;
const HRESULT = @import("../foundation.zig").HRESULT;
const HWND = @import("../foundation.zig").HWND;
const IDispatch = @import("../system/ole_automation.zig").IDispatch;
const IStream = @import("../storage/structured_storage.zig").IStream;
const IUnknown = @import("../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../system/system_services.zig").LARGE_INTEGER;
const PSTR = @import("../foundation.zig").PSTR;
const PWSTR = @import("../foundation.zig").PWSTR;
const ULARGE_INTEGER = @import("../system/system_services.zig").ULARGE_INTEGER;

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "LPDISPLAYVAL")) { _ = LPDISPLAYVAL; }
    if (@hasDecl(@This(), "LPEVALCOMCALLBACK")) { _ = LPEVALCOMCALLBACK; }
    if (@hasDecl(@This(), "INSTALLUI_HANDLERA")) { _ = INSTALLUI_HANDLERA; }
    if (@hasDecl(@This(), "INSTALLUI_HANDLERW")) { _ = INSTALLUI_HANDLERW; }
    if (@hasDecl(@This(), "PINSTALLUI_HANDLER_RECORD")) { _ = PINSTALLUI_HANDLER_RECORD; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
