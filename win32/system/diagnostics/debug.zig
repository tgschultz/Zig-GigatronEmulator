//! NOTE: this file is autogenerated, DO NOT MODIFY
//--------------------------------------------------------------------------------
// Section: Constants (1109)
//--------------------------------------------------------------------------------
pub const WOW64_CONTEXT_i386 = @as(u32, 65536);
pub const WOW64_CONTEXT_i486 = @as(u32, 65536);
pub const WOW64_CONTEXT_EXCEPTION_ACTIVE = @as(u32, 134217728);
pub const WOW64_CONTEXT_SERVICE_ACTIVE = @as(u32, 268435456);
pub const WOW64_CONTEXT_EXCEPTION_REQUEST = @as(u32, 1073741824);
pub const WOW64_CONTEXT_EXCEPTION_REPORTING = @as(u32, 2147483648);
pub const WOW64_SIZE_OF_80387_REGISTERS = @as(u32, 80);
pub const WOW64_MAXIMUM_SUPPORTED_EXTENSION = @as(u32, 512);
pub const ERROR_DBG_CANCELLED = @as(u32, 3221226695);
pub const ERROR_DBG_TIMEOUT = @as(u32, 3221226932);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_DOT_COMMANDS = @as(u32, 1);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_EXTENSION_COMMANDS = @as(u32, 2);
pub const DEBUG_GET_TEXT_COMPLETIONS_NO_SYMBOLS = @as(u32, 4);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_DOT_COMMAND = @as(u32, 1);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_EXTENSION_COMMAND = @as(u32, 2);
pub const DEBUG_GET_TEXT_COMPLETIONS_IS_SYMBOL = @as(u32, 4);
pub const DEBUG_REQUEST_SOURCE_PATH_HAS_SOURCE_SERVER = @as(u32, 0);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_CONTEXT = @as(u32, 1);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_THREAD = @as(u32, 2);
pub const DEBUG_REQUEST_TARGET_EXCEPTION_RECORD = @as(u32, 3);
pub const DEBUG_REQUEST_GET_ADDITIONAL_CREATE_OPTIONS = @as(u32, 4);
pub const DEBUG_REQUEST_SET_ADDITIONAL_CREATE_OPTIONS = @as(u32, 5);
pub const DEBUG_REQUEST_GET_WIN32_MAJOR_MINOR_VERSIONS = @as(u32, 6);
pub const DEBUG_REQUEST_READ_USER_MINIDUMP_STREAM = @as(u32, 7);
pub const DEBUG_REQUEST_TARGET_CAN_DETACH = @as(u32, 8);
pub const DEBUG_REQUEST_SET_LOCAL_IMPLICIT_COMMAND_LINE = @as(u32, 9);
pub const DEBUG_REQUEST_GET_CAPTURED_EVENT_CODE_OFFSET = @as(u32, 10);
pub const DEBUG_REQUEST_READ_CAPTURED_EVENT_CODE_STREAM = @as(u32, 11);
pub const DEBUG_REQUEST_EXT_TYPED_DATA_ANSI = @as(u32, 12);
pub const DEBUG_REQUEST_GET_EXTENSION_SEARCH_PATH_WIDE = @as(u32, 13);
pub const DEBUG_REQUEST_GET_TEXT_COMPLETIONS_WIDE = @as(u32, 14);
pub const DEBUG_REQUEST_GET_CACHED_SYMBOL_INFO = @as(u32, 15);
pub const DEBUG_REQUEST_ADD_CACHED_SYMBOL_INFO = @as(u32, 16);
pub const DEBUG_REQUEST_REMOVE_CACHED_SYMBOL_INFO = @as(u32, 17);
pub const DEBUG_REQUEST_GET_TEXT_COMPLETIONS_ANSI = @as(u32, 18);
pub const DEBUG_REQUEST_CURRENT_OUTPUT_CALLBACKS_ARE_DML_AWARE = @as(u32, 19);
pub const DEBUG_REQUEST_GET_OFFSET_UNWIND_INFORMATION = @as(u32, 20);
pub const DEBUG_REQUEST_GET_DUMP_HEADER = @as(u32, 21);
pub const DEBUG_REQUEST_SET_DUMP_HEADER = @as(u32, 22);
pub const DEBUG_REQUEST_MIDORI = @as(u32, 23);
pub const DEBUG_REQUEST_PROCESS_DESCRIPTORS = @as(u32, 24);
pub const DEBUG_REQUEST_MISC_INFORMATION = @as(u32, 25);
pub const DEBUG_REQUEST_OPEN_PROCESS_TOKEN = @as(u32, 26);
pub const DEBUG_REQUEST_OPEN_THREAD_TOKEN = @as(u32, 27);
pub const DEBUG_REQUEST_DUPLICATE_TOKEN = @as(u32, 28);
pub const DEBUG_REQUEST_QUERY_INFO_TOKEN = @as(u32, 29);
pub const DEBUG_REQUEST_CLOSE_TOKEN = @as(u32, 30);
pub const DEBUG_REQUEST_WOW_PROCESS = @as(u32, 31);
pub const DEBUG_REQUEST_WOW_MODULE = @as(u32, 32);
pub const DEBUG_LIVE_USER_NON_INVASIVE = @as(u32, 33);
pub const DEBUG_REQUEST_RESUME_THREAD = @as(u32, 34);
pub const DEBUG_REQUEST_INLINE_QUERY = @as(u32, 35);
pub const DEBUG_REQUEST_TL_INSTRUMENTATION_AWARE = @as(u32, 36);
pub const DEBUG_REQUEST_GET_INSTRUMENTATION_VERSION = @as(u32, 37);
pub const DEBUG_REQUEST_GET_MODULE_ARCHITECTURE = @as(u32, 38);
pub const DEBUG_SRCFILE_SYMBOL_TOKEN = @as(u32, 0);
pub const DEBUG_SRCFILE_SYMBOL_TOKEN_SOURCE_COMMAND_WIDE = @as(u32, 1);
pub const DEBUG_SRCFILE_SYMBOL_CHECKSUMINFO = @as(u32, 2);
pub const DEBUG_SYMINFO_BREAKPOINT_SOURCE_LINE = @as(u32, 0);
pub const DEBUG_SYMINFO_IMAGEHLP_MODULEW64 = @as(u32, 1);
pub const DEBUG_SYMINFO_GET_SYMBOL_NAME_BY_OFFSET_AND_TAG_WIDE = @as(u32, 2);
pub const DEBUG_SYMINFO_GET_MODULE_SYMBOL_NAMES_AND_OFFSETS = @as(u32, 3);
pub const DEBUG_SYSOBJINFO_THREAD_BASIC_INFORMATION = @as(u32, 0);
pub const DEBUG_SYSOBJINFO_THREAD_NAME_WIDE = @as(u32, 1);
pub const DEBUG_SYSOBJINFO_CURRENT_PROCESS_COOKIE = @as(u32, 2);
pub const DEBUG_TBINFO_EXIT_STATUS = @as(u32, 1);
pub const DEBUG_TBINFO_PRIORITY_CLASS = @as(u32, 2);
pub const DEBUG_TBINFO_PRIORITY = @as(u32, 4);
pub const DEBUG_TBINFO_TIMES = @as(u32, 8);
pub const DEBUG_TBINFO_START_OFFSET = @as(u32, 16);
pub const DEBUG_TBINFO_AFFINITY = @as(u32, 32);
pub const DEBUG_TBINFO_ALL = @as(u32, 63);
pub const DEBUG_BREAKPOINT_CODE = @as(u32, 0);
pub const DEBUG_BREAKPOINT_DATA = @as(u32, 1);
pub const DEBUG_BREAKPOINT_TIME = @as(u32, 2);
pub const DEBUG_BREAKPOINT_INLINE = @as(u32, 3);
pub const DEBUG_BREAKPOINT_GO_ONLY = @as(u32, 1);
pub const DEBUG_BREAKPOINT_DEFERRED = @as(u32, 2);
pub const DEBUG_BREAKPOINT_ENABLED = @as(u32, 4);
pub const DEBUG_BREAKPOINT_ADDER_ONLY = @as(u32, 8);
pub const DEBUG_BREAKPOINT_ONE_SHOT = @as(u32, 16);
pub const DEBUG_BREAK_READ = @as(u32, 1);
pub const DEBUG_BREAK_WRITE = @as(u32, 2);
pub const DEBUG_BREAK_EXECUTE = @as(u32, 4);
pub const DEBUG_BREAK_IO = @as(u32, 8);
pub const DEBUG_ATTACH_KERNEL_CONNECTION = @as(u32, 0);
pub const DEBUG_ATTACH_LOCAL_KERNEL = @as(u32, 1);
pub const DEBUG_ATTACH_EXDI_DRIVER = @as(u32, 2);
pub const DEBUG_ATTACH_INSTALL_DRIVER = @as(u32, 4);
pub const DEBUG_GET_PROC_DEFAULT = @as(u32, 0);
pub const DEBUG_GET_PROC_FULL_MATCH = @as(u32, 1);
pub const DEBUG_GET_PROC_ONLY_MATCH = @as(u32, 2);
pub const DEBUG_GET_PROC_SERVICE_NAME = @as(u32, 4);
pub const DEBUG_PROC_DESC_DEFAULT = @as(u32, 0);
pub const DEBUG_PROC_DESC_NO_PATHS = @as(u32, 1);
pub const DEBUG_PROC_DESC_NO_SERVICES = @as(u32, 2);
pub const DEBUG_PROC_DESC_NO_MTS_PACKAGES = @as(u32, 4);
pub const DEBUG_PROC_DESC_NO_COMMAND_LINE = @as(u32, 8);
pub const DEBUG_PROC_DESC_NO_SESSION_ID = @as(u32, 16);
pub const DEBUG_PROC_DESC_NO_USER_NAME = @as(u32, 32);
pub const DEBUG_ATTACH_DEFAULT = @as(u32, 0);
pub const DEBUG_ATTACH_NONINVASIVE = @as(u32, 1);
pub const DEBUG_ATTACH_EXISTING = @as(u32, 2);
pub const DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND = @as(u32, 4);
pub const DEBUG_ATTACH_INVASIVE_NO_INITIAL_BREAK = @as(u32, 8);
pub const DEBUG_ATTACH_INVASIVE_RESUME_PROCESS = @as(u32, 16);
pub const DEBUG_ATTACH_NONINVASIVE_ALLOW_PARTIAL = @as(u32, 32);
pub const DEBUG_ECREATE_PROCESS_DEFAULT = @as(u32, 0);
pub const DEBUG_ECREATE_PROCESS_INHERIT_HANDLES = @as(u32, 1);
pub const DEBUG_ECREATE_PROCESS_USE_VERIFIER_FLAGS = @as(u32, 2);
pub const DEBUG_ECREATE_PROCESS_USE_IMPLICIT_COMMAND_LINE = @as(u32, 4);
pub const DEBUG_PROCESS_DETACH_ON_EXIT = @as(u32, 1);
pub const DEBUG_PROCESS_ONLY_THIS_PROCESS = @as(u32, 2);
pub const DEBUG_CONNECT_SESSION_DEFAULT = @as(u32, 0);
pub const DEBUG_CONNECT_SESSION_NO_VERSION = @as(u32, 1);
pub const DEBUG_CONNECT_SESSION_NO_ANNOUNCE = @as(u32, 2);
pub const DEBUG_SERVERS_DEBUGGER = @as(u32, 1);
pub const DEBUG_SERVERS_PROCESS = @as(u32, 2);
pub const DEBUG_SERVERS_ALL = @as(u32, 3);
pub const DEBUG_END_PASSIVE = @as(u32, 0);
pub const DEBUG_END_ACTIVE_TERMINATE = @as(u32, 1);
pub const DEBUG_END_ACTIVE_DETACH = @as(u32, 2);
pub const DEBUG_END_REENTRANT = @as(u32, 3);
pub const DEBUG_END_DISCONNECT = @as(u32, 4);
pub const DEBUG_OUTPUT_NORMAL = @as(u32, 1);
pub const DEBUG_OUTPUT_ERROR = @as(u32, 2);
pub const DEBUG_OUTPUT_WARNING = @as(u32, 4);
pub const DEBUG_OUTPUT_VERBOSE = @as(u32, 8);
pub const DEBUG_OUTPUT_PROMPT = @as(u32, 16);
pub const DEBUG_OUTPUT_PROMPT_REGISTERS = @as(u32, 32);
pub const DEBUG_OUTPUT_EXTENSION_WARNING = @as(u32, 64);
pub const DEBUG_OUTPUT_DEBUGGEE = @as(u32, 128);
pub const DEBUG_OUTPUT_DEBUGGEE_PROMPT = @as(u32, 256);
pub const DEBUG_OUTPUT_SYMBOLS = @as(u32, 512);
pub const DEBUG_OUTPUT_STATUS = @as(u32, 1024);
pub const DEBUG_OUTPUT_XML = @as(u32, 2048);
pub const DEBUG_IOUTPUT_KD_PROTOCOL = @as(u32, 2147483648);
pub const DEBUG_IOUTPUT_REMOTING = @as(u32, 1073741824);
pub const DEBUG_IOUTPUT_BREAKPOINT = @as(u32, 536870912);
pub const DEBUG_IOUTPUT_EVENT = @as(u32, 268435456);
pub const DEBUG_IOUTPUT_ADDR_TRANSLATE = @as(u32, 134217728);
pub const DEBUG_OUTPUT_IDENTITY_DEFAULT = @as(u32, 0);
pub const DEBUG_CLIENT_UNKNOWN = @as(u32, 0);
pub const DEBUG_CLIENT_VSINT = @as(u32, 1);
pub const DEBUG_CLIENT_NTSD = @as(u32, 2);
pub const DEBUG_CLIENT_NTKD = @as(u32, 3);
pub const DEBUG_CLIENT_CDB = @as(u32, 4);
pub const DEBUG_CLIENT_KD = @as(u32, 5);
pub const DEBUG_CLIENT_WINDBG = @as(u32, 6);
pub const DEBUG_CLIENT_WINIDE = @as(u32, 7);
pub const DEBUG_FORMAT_DEFAULT = @as(u32, 0);
pub const DEBUG_FORMAT_CAB_SECONDARY_ALL_IMAGES = @as(u32, 268435456);
pub const DEBUG_FORMAT_WRITE_CAB = @as(u32, 536870912);
pub const DEBUG_FORMAT_CAB_SECONDARY_FILES = @as(u32, 1073741824);
pub const DEBUG_FORMAT_NO_OVERWRITE = @as(u32, 2147483648);
pub const DEBUG_FORMAT_USER_SMALL_FULL_MEMORY = @as(u32, 1);
pub const DEBUG_FORMAT_USER_SMALL_HANDLE_DATA = @as(u32, 2);
pub const DEBUG_FORMAT_USER_SMALL_UNLOADED_MODULES = @as(u32, 4);
pub const DEBUG_FORMAT_USER_SMALL_INDIRECT_MEMORY = @as(u32, 8);
pub const DEBUG_FORMAT_USER_SMALL_DATA_SEGMENTS = @as(u32, 16);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_MEMORY = @as(u32, 32);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_PATHS = @as(u32, 64);
pub const DEBUG_FORMAT_USER_SMALL_PROCESS_THREAD_DATA = @as(u32, 128);
pub const DEBUG_FORMAT_USER_SMALL_PRIVATE_READ_WRITE_MEMORY = @as(u32, 256);
pub const DEBUG_FORMAT_USER_SMALL_NO_OPTIONAL_DATA = @as(u32, 512);
pub const DEBUG_FORMAT_USER_SMALL_FULL_MEMORY_INFO = @as(u32, 1024);
pub const DEBUG_FORMAT_USER_SMALL_THREAD_INFO = @as(u32, 2048);
pub const DEBUG_FORMAT_USER_SMALL_CODE_SEGMENTS = @as(u32, 4096);
pub const DEBUG_FORMAT_USER_SMALL_NO_AUXILIARY_STATE = @as(u32, 8192);
pub const DEBUG_FORMAT_USER_SMALL_FULL_AUXILIARY_STATE = @as(u32, 16384);
pub const DEBUG_FORMAT_USER_SMALL_MODULE_HEADERS = @as(u32, 32768);
pub const DEBUG_FORMAT_USER_SMALL_FILTER_TRIAGE = @as(u32, 65536);
pub const DEBUG_FORMAT_USER_SMALL_ADD_AVX_XSTATE_CONTEXT = @as(u32, 131072);
pub const DEBUG_FORMAT_USER_SMALL_IPT_TRACE = @as(u32, 262144);
pub const DEBUG_FORMAT_USER_SMALL_IGNORE_INACCESSIBLE_MEM = @as(u32, 134217728);
pub const DEBUG_FORMAT_USER_SMALL_SCAN_PARTIAL_PAGES = @as(u32, 268435456);
pub const DEBUG_DUMP_FILE_BASE = @as(u32, 4294967295);
pub const DEBUG_DUMP_FILE_PAGE_FILE_DUMP = @as(u32, 0);
pub const DEBUG_DUMP_FILE_LOAD_FAILED_INDEX = @as(u32, 4294967295);
pub const DEBUG_DUMP_FILE_ORIGINAL_CAB_INDEX = @as(u32, 4294967294);
pub const DEBUG_STATUS_NO_CHANGE = @as(u32, 0);
pub const DEBUG_STATUS_GO = @as(u32, 1);
pub const DEBUG_STATUS_GO_HANDLED = @as(u32, 2);
pub const DEBUG_STATUS_GO_NOT_HANDLED = @as(u32, 3);
pub const DEBUG_STATUS_STEP_OVER = @as(u32, 4);
pub const DEBUG_STATUS_STEP_INTO = @as(u32, 5);
pub const DEBUG_STATUS_BREAK = @as(u32, 6);
pub const DEBUG_STATUS_NO_DEBUGGEE = @as(u32, 7);
pub const DEBUG_STATUS_STEP_BRANCH = @as(u32, 8);
pub const DEBUG_STATUS_IGNORE_EVENT = @as(u32, 9);
pub const DEBUG_STATUS_RESTART_REQUESTED = @as(u32, 10);
pub const DEBUG_STATUS_REVERSE_GO = @as(u32, 11);
pub const DEBUG_STATUS_REVERSE_STEP_BRANCH = @as(u32, 12);
pub const DEBUG_STATUS_REVERSE_STEP_OVER = @as(u32, 13);
pub const DEBUG_STATUS_REVERSE_STEP_INTO = @as(u32, 14);
pub const DEBUG_STATUS_OUT_OF_SYNC = @as(u32, 15);
pub const DEBUG_STATUS_WAIT_INPUT = @as(u32, 16);
pub const DEBUG_STATUS_TIMEOUT = @as(u32, 17);
pub const DEBUG_STATUS_MASK = @as(u32, 31);
pub const DEBUG_STATUS_INSIDE_WAIT = @as(u64, 4294967296);
pub const DEBUG_STATUS_WAIT_TIMEOUT = @as(u64, 8589934592);
pub const DEBUG_OUTCTL_THIS_CLIENT = @as(u32, 0);
pub const DEBUG_OUTCTL_ALL_CLIENTS = @as(u32, 1);
pub const DEBUG_OUTCTL_ALL_OTHER_CLIENTS = @as(u32, 2);
pub const DEBUG_OUTCTL_IGNORE = @as(u32, 3);
pub const DEBUG_OUTCTL_LOG_ONLY = @as(u32, 4);
pub const DEBUG_OUTCTL_SEND_MASK = @as(u32, 7);
pub const DEBUG_OUTCTL_NOT_LOGGED = @as(u32, 8);
pub const DEBUG_OUTCTL_OVERRIDE_MASK = @as(u32, 16);
pub const DEBUG_OUTCTL_DML = @as(u32, 32);
pub const DEBUG_OUTCTL_AMBIENT_DML = @as(u32, 4294967294);
pub const DEBUG_OUTCTL_AMBIENT_TEXT = @as(u32, 4294967295);
pub const DEBUG_INTERRUPT_ACTIVE = @as(u32, 0);
pub const DEBUG_INTERRUPT_PASSIVE = @as(u32, 1);
pub const DEBUG_INTERRUPT_EXIT = @as(u32, 2);
pub const DEBUG_CURRENT_DEFAULT = @as(u32, 15);
pub const DEBUG_CURRENT_SYMBOL = @as(u32, 1);
pub const DEBUG_CURRENT_DISASM = @as(u32, 2);
pub const DEBUG_CURRENT_REGISTERS = @as(u32, 4);
pub const DEBUG_CURRENT_SOURCE_LINE = @as(u32, 8);
pub const DEBUG_DISASM_EFFECTIVE_ADDRESS = @as(u32, 1);
pub const DEBUG_DISASM_MATCHING_SYMBOLS = @as(u32, 2);
pub const DEBUG_DISASM_SOURCE_LINE_NUMBER = @as(u32, 4);
pub const DEBUG_DISASM_SOURCE_FILE_NAME = @as(u32, 8);
pub const DEBUG_LEVEL_SOURCE = @as(u32, 0);
pub const DEBUG_LEVEL_ASSEMBLY = @as(u32, 1);
pub const DEBUG_ENGOPT_IGNORE_DBGHELP_VERSION = @as(u32, 1);
pub const DEBUG_ENGOPT_IGNORE_EXTENSION_VERSIONS = @as(u32, 2);
pub const DEBUG_ENGOPT_ALLOW_NETWORK_PATHS = @as(u32, 4);
pub const DEBUG_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 8);
pub const DEBUG_ENGOPT_IGNORE_LOADER_EXCEPTIONS = @as(u32, 16);
pub const DEBUG_ENGOPT_INITIAL_BREAK = @as(u32, 32);
pub const DEBUG_ENGOPT_INITIAL_MODULE_BREAK = @as(u32, 64);
pub const DEBUG_ENGOPT_FINAL_BREAK = @as(u32, 128);
pub const DEBUG_ENGOPT_NO_EXECUTE_REPEAT = @as(u32, 256);
pub const DEBUG_ENGOPT_FAIL_INCOMPLETE_INFORMATION = @as(u32, 512);
pub const DEBUG_ENGOPT_ALLOW_READ_ONLY_BREAKPOINTS = @as(u32, 1024);
pub const DEBUG_ENGOPT_SYNCHRONIZE_BREAKPOINTS = @as(u32, 2048);
pub const DEBUG_ENGOPT_DISALLOW_SHELL_COMMANDS = @as(u32, 4096);
pub const DEBUG_ENGOPT_KD_QUIET_MODE = @as(u32, 8192);
pub const DEBUG_ENGOPT_DISABLE_MANAGED_SUPPORT = @as(u32, 16384);
pub const DEBUG_ENGOPT_DISABLE_MODULE_SYMBOL_LOAD = @as(u32, 32768);
pub const DEBUG_ENGOPT_DISABLE_EXECUTION_COMMANDS = @as(u32, 65536);
pub const DEBUG_ENGOPT_DISALLOW_IMAGE_FILE_MAPPING = @as(u32, 131072);
pub const DEBUG_ENGOPT_PREFER_DML = @as(u32, 262144);
pub const DEBUG_ENGOPT_DISABLESQM = @as(u32, 524288);
pub const DEBUG_ENGOPT_DISABLE_STEPLINES_OPTIONS = @as(u32, 2097152);
pub const DEBUG_ENGOPT_DEBUGGING_SENSITIVE_DATA = @as(u32, 4194304);
pub const DEBUG_ENGOPT_PREFER_TRACE_FILES = @as(u32, 8388608);
pub const DEBUG_ENGOPT_ALL = @as(u32, 15728639);
pub const DEBUG_ANY_ID = @as(u32, 4294967295);
pub const DBG_FRAME_DEFAULT = @as(u32, 0);
pub const DBG_FRAME_IGNORE_INLINE = @as(u32, 4294967295);
pub const STACK_FRAME_TYPE_INIT = @as(u32, 0);
pub const STACK_FRAME_TYPE_STACK = @as(u32, 1);
pub const STACK_FRAME_TYPE_INLINE = @as(u32, 2);
pub const STACK_FRAME_TYPE_RA = @as(u32, 128);
pub const STACK_FRAME_TYPE_IGNORE = @as(u32, 255);
pub const DEBUG_STACK_ARGUMENTS = @as(u32, 1);
pub const DEBUG_STACK_FUNCTION_INFO = @as(u32, 2);
pub const DEBUG_STACK_SOURCE_LINE = @as(u32, 4);
pub const DEBUG_STACK_FRAME_ADDRESSES = @as(u32, 8);
pub const DEBUG_STACK_COLUMN_NAMES = @as(u32, 16);
pub const DEBUG_STACK_NONVOLATILE_REGISTERS = @as(u32, 32);
pub const DEBUG_STACK_FRAME_NUMBERS = @as(u32, 64);
pub const DEBUG_STACK_PARAMETERS = @as(u32, 128);
pub const DEBUG_STACK_FRAME_ADDRESSES_RA_ONLY = @as(u32, 256);
pub const DEBUG_STACK_FRAME_MEMORY_USAGE = @as(u32, 512);
pub const DEBUG_STACK_PARAMETERS_NEWLINE = @as(u32, 1024);
pub const DEBUG_STACK_DML = @as(u32, 2048);
pub const DEBUG_STACK_FRAME_OFFSETS = @as(u32, 4096);
pub const DEBUG_STACK_PROVIDER = @as(u32, 8192);
pub const DEBUG_STACK_FRAME_ARCH = @as(u32, 16384);
pub const DEBUG_CLASS_UNINITIALIZED = @as(u32, 0);
pub const DEBUG_CLASS_KERNEL = @as(u32, 1);
pub const DEBUG_CLASS_USER_WINDOWS = @as(u32, 2);
pub const DEBUG_CLASS_IMAGE_FILE = @as(u32, 3);
pub const DEBUG_DUMP_SMALL = @as(u32, 1024);
pub const DEBUG_DUMP_DEFAULT = @as(u32, 1025);
pub const DEBUG_DUMP_FULL = @as(u32, 1026);
pub const DEBUG_DUMP_IMAGE_FILE = @as(u32, 1027);
pub const DEBUG_DUMP_TRACE_LOG = @as(u32, 1028);
pub const DEBUG_DUMP_WINDOWS_CE = @as(u32, 1029);
pub const DEBUG_DUMP_ACTIVE = @as(u32, 1030);
pub const DEBUG_KERNEL_CONNECTION = @as(u32, 0);
pub const DEBUG_KERNEL_LOCAL = @as(u32, 1);
pub const DEBUG_KERNEL_EXDI_DRIVER = @as(u32, 2);
pub const DEBUG_KERNEL_IDNA = @as(u32, 3);
pub const DEBUG_KERNEL_INSTALL_DRIVER = @as(u32, 4);
pub const DEBUG_KERNEL_REPT = @as(u32, 5);
pub const DEBUG_USER_WINDOWS_PROCESS = @as(u32, 0);
pub const DEBUG_USER_WINDOWS_PROCESS_SERVER = @as(u32, 1);
pub const DEBUG_USER_WINDOWS_IDNA = @as(u32, 2);
pub const DEBUG_USER_WINDOWS_REPT = @as(u32, 3);
pub const DEBUG_EXTENSION_AT_ENGINE = @as(u32, 0);
pub const DEBUG_EXECUTE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXECUTE_ECHO = @as(u32, 1);
pub const DEBUG_EXECUTE_NOT_LOGGED = @as(u32, 2);
pub const DEBUG_EXECUTE_NO_REPEAT = @as(u32, 4);
pub const DEBUG_EXECUTE_USER_TYPED = @as(u32, 8);
pub const DEBUG_EXECUTE_USER_CLICKED = @as(u32, 16);
pub const DEBUG_EXECUTE_EXTENSION = @as(u32, 32);
pub const DEBUG_EXECUTE_INTERNAL = @as(u32, 64);
pub const DEBUG_EXECUTE_SCRIPT = @as(u32, 128);
pub const DEBUG_EXECUTE_TOOLBAR = @as(u32, 256);
pub const DEBUG_EXECUTE_MENU = @as(u32, 512);
pub const DEBUG_EXECUTE_HOTKEY = @as(u32, 1024);
pub const DEBUG_EXECUTE_EVENT = @as(u32, 2048);
pub const DEBUG_FILTER_CREATE_THREAD = @as(u32, 0);
pub const DEBUG_FILTER_EXIT_THREAD = @as(u32, 1);
pub const DEBUG_FILTER_CREATE_PROCESS = @as(u32, 2);
pub const DEBUG_FILTER_EXIT_PROCESS = @as(u32, 3);
pub const DEBUG_FILTER_LOAD_MODULE = @as(u32, 4);
pub const DEBUG_FILTER_UNLOAD_MODULE = @as(u32, 5);
pub const DEBUG_FILTER_SYSTEM_ERROR = @as(u32, 6);
pub const DEBUG_FILTER_INITIAL_BREAKPOINT = @as(u32, 7);
pub const DEBUG_FILTER_INITIAL_MODULE_LOAD = @as(u32, 8);
pub const DEBUG_FILTER_DEBUGGEE_OUTPUT = @as(u32, 9);
pub const DEBUG_FILTER_BREAK = @as(u32, 0);
pub const DEBUG_FILTER_SECOND_CHANCE_BREAK = @as(u32, 1);
pub const DEBUG_FILTER_OUTPUT = @as(u32, 2);
pub const DEBUG_FILTER_IGNORE = @as(u32, 3);
pub const DEBUG_FILTER_REMOVE = @as(u32, 4);
pub const DEBUG_FILTER_GO_HANDLED = @as(u32, 0);
pub const DEBUG_FILTER_GO_NOT_HANDLED = @as(u32, 1);
pub const DEBUG_WAIT_DEFAULT = @as(u32, 0);
pub const DEBUG_VALUE_INVALID = @as(u32, 0);
pub const DEBUG_VALUE_INT8 = @as(u32, 1);
pub const DEBUG_VALUE_INT16 = @as(u32, 2);
pub const DEBUG_VALUE_INT32 = @as(u32, 3);
pub const DEBUG_VALUE_INT64 = @as(u32, 4);
pub const DEBUG_VALUE_FLOAT32 = @as(u32, 5);
pub const DEBUG_VALUE_FLOAT64 = @as(u32, 6);
pub const DEBUG_VALUE_FLOAT80 = @as(u32, 7);
pub const DEBUG_VALUE_FLOAT82 = @as(u32, 8);
pub const DEBUG_VALUE_FLOAT128 = @as(u32, 9);
pub const DEBUG_VALUE_VECTOR64 = @as(u32, 10);
pub const DEBUG_VALUE_VECTOR128 = @as(u32, 11);
pub const DEBUG_VALUE_TYPES = @as(u32, 12);
pub const DEBUG_OUT_TEXT_REPL_DEFAULT = @as(u32, 0);
pub const DEBUG_ASMOPT_DEFAULT = @as(u32, 0);
pub const DEBUG_ASMOPT_VERBOSE = @as(u32, 1);
pub const DEBUG_ASMOPT_NO_CODE_BYTES = @as(u32, 2);
pub const DEBUG_ASMOPT_IGNORE_OUTPUT_WIDTH = @as(u32, 4);
pub const DEBUG_ASMOPT_SOURCE_LINE_NUMBER = @as(u32, 8);
pub const DEBUG_EXPR_MASM = @as(u32, 0);
pub const DEBUG_EXPR_CPLUSPLUS = @as(u32, 1);
pub const DEBUG_EINDEX_NAME = @as(u32, 0);
pub const DEBUG_EINDEX_FROM_START = @as(u32, 0);
pub const DEBUG_EINDEX_FROM_END = @as(u32, 1);
pub const DEBUG_EINDEX_FROM_CURRENT = @as(u32, 2);
pub const DEBUG_LOG_DEFAULT = @as(u32, 0);
pub const DEBUG_LOG_APPEND = @as(u32, 1);
pub const DEBUG_LOG_UNICODE = @as(u32, 2);
pub const DEBUG_LOG_DML = @as(u32, 4);
pub const DEBUG_SYSVERSTR_SERVICE_PACK = @as(u32, 0);
pub const DEBUG_SYSVERSTR_BUILD = @as(u32, 1);
pub const DEBUG_MANAGED_DISABLED = @as(u32, 0);
pub const DEBUG_MANAGED_ALLOWED = @as(u32, 1);
pub const DEBUG_MANAGED_DLL_LOADED = @as(u32, 2);
pub const DEBUG_MANSTR_NONE = @as(u32, 0);
pub const DEBUG_MANSTR_LOADED_SUPPORT_DLL = @as(u32, 1);
pub const DEBUG_MANSTR_LOAD_STATUS = @as(u32, 2);
pub const DEBUG_MANRESET_DEFAULT = @as(u32, 0);
pub const DEBUG_MANRESET_LOAD_DLL = @as(u32, 1);
pub const DEBUG_EXEC_FLAGS_NONBLOCK = @as(u32, 1);
pub const DEBUG_DATA_SPACE_VIRTUAL = @as(u32, 0);
pub const DEBUG_DATA_SPACE_PHYSICAL = @as(u32, 1);
pub const DEBUG_DATA_SPACE_CONTROL = @as(u32, 2);
pub const DEBUG_DATA_SPACE_IO = @as(u32, 3);
pub const DEBUG_DATA_SPACE_MSR = @as(u32, 4);
pub const DEBUG_DATA_SPACE_BUS_DATA = @as(u32, 5);
pub const DEBUG_DATA_SPACE_DEBUGGER_DATA = @as(u32, 6);
pub const DEBUG_DATA_SPACE_COUNT = @as(u32, 7);
pub const DEBUG_DATA_KernBase = @as(u32, 24);
pub const DEBUG_DATA_BreakpointWithStatusAddr = @as(u32, 32);
pub const DEBUG_DATA_SavedContextAddr = @as(u32, 40);
pub const DEBUG_DATA_KiCallUserModeAddr = @as(u32, 56);
pub const DEBUG_DATA_KeUserCallbackDispatcherAddr = @as(u32, 64);
pub const DEBUG_DATA_PsLoadedModuleListAddr = @as(u32, 72);
pub const DEBUG_DATA_PsActiveProcessHeadAddr = @as(u32, 80);
pub const DEBUG_DATA_PspCidTableAddr = @as(u32, 88);
pub const DEBUG_DATA_ExpSystemResourcesListAddr = @as(u32, 96);
pub const DEBUG_DATA_ExpPagedPoolDescriptorAddr = @as(u32, 104);
pub const DEBUG_DATA_ExpNumberOfPagedPoolsAddr = @as(u32, 112);
pub const DEBUG_DATA_KeTimeIncrementAddr = @as(u32, 120);
pub const DEBUG_DATA_KeBugCheckCallbackListHeadAddr = @as(u32, 128);
pub const DEBUG_DATA_KiBugcheckDataAddr = @as(u32, 136);
pub const DEBUG_DATA_IopErrorLogListHeadAddr = @as(u32, 144);
pub const DEBUG_DATA_ObpRootDirectoryObjectAddr = @as(u32, 152);
pub const DEBUG_DATA_ObpTypeObjectTypeAddr = @as(u32, 160);
pub const DEBUG_DATA_MmSystemCacheStartAddr = @as(u32, 168);
pub const DEBUG_DATA_MmSystemCacheEndAddr = @as(u32, 176);
pub const DEBUG_DATA_MmSystemCacheWsAddr = @as(u32, 184);
pub const DEBUG_DATA_MmPfnDatabaseAddr = @as(u32, 192);
pub const DEBUG_DATA_MmSystemPtesStartAddr = @as(u32, 200);
pub const DEBUG_DATA_MmSystemPtesEndAddr = @as(u32, 208);
pub const DEBUG_DATA_MmSubsectionBaseAddr = @as(u32, 216);
pub const DEBUG_DATA_MmNumberOfPagingFilesAddr = @as(u32, 224);
pub const DEBUG_DATA_MmLowestPhysicalPageAddr = @as(u32, 232);
pub const DEBUG_DATA_MmHighestPhysicalPageAddr = @as(u32, 240);
pub const DEBUG_DATA_MmNumberOfPhysicalPagesAddr = @as(u32, 248);
pub const DEBUG_DATA_MmMaximumNonPagedPoolInBytesAddr = @as(u32, 256);
pub const DEBUG_DATA_MmNonPagedSystemStartAddr = @as(u32, 264);
pub const DEBUG_DATA_MmNonPagedPoolStartAddr = @as(u32, 272);
pub const DEBUG_DATA_MmNonPagedPoolEndAddr = @as(u32, 280);
pub const DEBUG_DATA_MmPagedPoolStartAddr = @as(u32, 288);
pub const DEBUG_DATA_MmPagedPoolEndAddr = @as(u32, 296);
pub const DEBUG_DATA_MmPagedPoolInformationAddr = @as(u32, 304);
pub const DEBUG_DATA_MmPageSize = @as(u32, 312);
pub const DEBUG_DATA_MmSizeOfPagedPoolInBytesAddr = @as(u32, 320);
pub const DEBUG_DATA_MmTotalCommitLimitAddr = @as(u32, 328);
pub const DEBUG_DATA_MmTotalCommittedPagesAddr = @as(u32, 336);
pub const DEBUG_DATA_MmSharedCommitAddr = @as(u32, 344);
pub const DEBUG_DATA_MmDriverCommitAddr = @as(u32, 352);
pub const DEBUG_DATA_MmProcessCommitAddr = @as(u32, 360);
pub const DEBUG_DATA_MmPagedPoolCommitAddr = @as(u32, 368);
pub const DEBUG_DATA_MmExtendedCommitAddr = @as(u32, 376);
pub const DEBUG_DATA_MmZeroedPageListHeadAddr = @as(u32, 384);
pub const DEBUG_DATA_MmFreePageListHeadAddr = @as(u32, 392);
pub const DEBUG_DATA_MmStandbyPageListHeadAddr = @as(u32, 400);
pub const DEBUG_DATA_MmModifiedPageListHeadAddr = @as(u32, 408);
pub const DEBUG_DATA_MmModifiedNoWritePageListHeadAddr = @as(u32, 416);
pub const DEBUG_DATA_MmAvailablePagesAddr = @as(u32, 424);
pub const DEBUG_DATA_MmResidentAvailablePagesAddr = @as(u32, 432);
pub const DEBUG_DATA_PoolTrackTableAddr = @as(u32, 440);
pub const DEBUG_DATA_NonPagedPoolDescriptorAddr = @as(u32, 448);
pub const DEBUG_DATA_MmHighestUserAddressAddr = @as(u32, 456);
pub const DEBUG_DATA_MmSystemRangeStartAddr = @as(u32, 464);
pub const DEBUG_DATA_MmUserProbeAddressAddr = @as(u32, 472);
pub const DEBUG_DATA_KdPrintCircularBufferAddr = @as(u32, 480);
pub const DEBUG_DATA_KdPrintCircularBufferEndAddr = @as(u32, 488);
pub const DEBUG_DATA_KdPrintWritePointerAddr = @as(u32, 496);
pub const DEBUG_DATA_KdPrintRolloverCountAddr = @as(u32, 504);
pub const DEBUG_DATA_MmLoadedUserImageListAddr = @as(u32, 512);
pub const DEBUG_DATA_NtBuildLabAddr = @as(u32, 520);
pub const DEBUG_DATA_KiNormalSystemCall = @as(u32, 528);
pub const DEBUG_DATA_KiProcessorBlockAddr = @as(u32, 536);
pub const DEBUG_DATA_MmUnloadedDriversAddr = @as(u32, 544);
pub const DEBUG_DATA_MmLastUnloadedDriverAddr = @as(u32, 552);
pub const DEBUG_DATA_MmTriageActionTakenAddr = @as(u32, 560);
pub const DEBUG_DATA_MmSpecialPoolTagAddr = @as(u32, 568);
pub const DEBUG_DATA_KernelVerifierAddr = @as(u32, 576);
pub const DEBUG_DATA_MmVerifierDataAddr = @as(u32, 584);
pub const DEBUG_DATA_MmAllocatedNonPagedPoolAddr = @as(u32, 592);
pub const DEBUG_DATA_MmPeakCommitmentAddr = @as(u32, 600);
pub const DEBUG_DATA_MmTotalCommitLimitMaximumAddr = @as(u32, 608);
pub const DEBUG_DATA_CmNtCSDVersionAddr = @as(u32, 616);
pub const DEBUG_DATA_MmPhysicalMemoryBlockAddr = @as(u32, 624);
pub const DEBUG_DATA_MmSessionBase = @as(u32, 632);
pub const DEBUG_DATA_MmSessionSize = @as(u32, 640);
pub const DEBUG_DATA_MmSystemParentTablePage = @as(u32, 648);
pub const DEBUG_DATA_MmVirtualTranslationBase = @as(u32, 656);
pub const DEBUG_DATA_OffsetKThreadNextProcessor = @as(u32, 664);
pub const DEBUG_DATA_OffsetKThreadTeb = @as(u32, 666);
pub const DEBUG_DATA_OffsetKThreadKernelStack = @as(u32, 668);
pub const DEBUG_DATA_OffsetKThreadInitialStack = @as(u32, 670);
pub const DEBUG_DATA_OffsetKThreadApcProcess = @as(u32, 672);
pub const DEBUG_DATA_OffsetKThreadState = @as(u32, 674);
pub const DEBUG_DATA_OffsetKThreadBStore = @as(u32, 676);
pub const DEBUG_DATA_OffsetKThreadBStoreLimit = @as(u32, 678);
pub const DEBUG_DATA_SizeEProcess = @as(u32, 680);
pub const DEBUG_DATA_OffsetEprocessPeb = @as(u32, 682);
pub const DEBUG_DATA_OffsetEprocessParentCID = @as(u32, 684);
pub const DEBUG_DATA_OffsetEprocessDirectoryTableBase = @as(u32, 686);
pub const DEBUG_DATA_SizePrcb = @as(u32, 688);
pub const DEBUG_DATA_OffsetPrcbDpcRoutine = @as(u32, 690);
pub const DEBUG_DATA_OffsetPrcbCurrentThread = @as(u32, 692);
pub const DEBUG_DATA_OffsetPrcbMhz = @as(u32, 694);
pub const DEBUG_DATA_OffsetPrcbCpuType = @as(u32, 696);
pub const DEBUG_DATA_OffsetPrcbVendorString = @as(u32, 698);
pub const DEBUG_DATA_OffsetPrcbProcessorState = @as(u32, 700);
pub const DEBUG_DATA_OffsetPrcbNumber = @as(u32, 702);
pub const DEBUG_DATA_SizeEThread = @as(u32, 704);
pub const DEBUG_DATA_KdPrintCircularBufferPtrAddr = @as(u32, 712);
pub const DEBUG_DATA_KdPrintBufferSizeAddr = @as(u32, 720);
pub const DEBUG_DATA_MmBadPagesDetected = @as(u32, 800);
pub const DEBUG_DATA_EtwpDebuggerData = @as(u32, 816);
pub const DEBUG_DATA_PteBase = @as(u32, 864);
pub const DEBUG_DATA_PaeEnabled = @as(u32, 100000);
pub const DEBUG_DATA_SharedUserData = @as(u32, 100008);
pub const DEBUG_DATA_ProductType = @as(u32, 100016);
pub const DEBUG_DATA_SuiteMask = @as(u32, 100024);
pub const DEBUG_DATA_DumpWriterStatus = @as(u32, 100032);
pub const DEBUG_DATA_DumpFormatVersion = @as(u32, 100040);
pub const DEBUG_DATA_DumpWriterVersion = @as(u32, 100048);
pub const DEBUG_DATA_DumpPowerState = @as(u32, 100056);
pub const DEBUG_DATA_DumpMmStorage = @as(u32, 100064);
pub const DEBUG_DATA_DumpAttributes = @as(u32, 100072);
pub const DEBUG_DATA_KPCR_OFFSET = @as(u32, 0);
pub const DEBUG_DATA_KPRCB_OFFSET = @as(u32, 1);
pub const DEBUG_DATA_KTHREAD_OFFSET = @as(u32, 2);
pub const DEBUG_DATA_BASE_TRANSLATION_VIRTUAL_OFFSET = @as(u32, 3);
pub const DEBUG_DATA_PROCESSOR_IDENTIFICATION = @as(u32, 4);
pub const DEBUG_DATA_PROCESSOR_SPEED = @as(u32, 5);
pub const DEBUG_HANDLE_DATA_TYPE_BASIC = @as(u32, 0);
pub const DEBUG_HANDLE_DATA_TYPE_TYPE_NAME = @as(u32, 1);
pub const DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME = @as(u32, 2);
pub const DEBUG_HANDLE_DATA_TYPE_HANDLE_COUNT = @as(u32, 3);
pub const DEBUG_HANDLE_DATA_TYPE_TYPE_NAME_WIDE = @as(u32, 4);
pub const DEBUG_HANDLE_DATA_TYPE_OBJECT_NAME_WIDE = @as(u32, 5);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_THREAD_1 = @as(u32, 6);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_1 = @as(u32, 7);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_MUTANT_2 = @as(u32, 8);
pub const DEBUG_HANDLE_DATA_TYPE_PER_HANDLE_OPERATIONS = @as(u32, 9);
pub const DEBUG_HANDLE_DATA_TYPE_ALL_HANDLE_OPERATIONS = @as(u32, 10);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_1 = @as(u32, 11);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_PROCESS_2 = @as(u32, 12);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_EVENT_1 = @as(u32, 13);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_SECTION_1 = @as(u32, 14);
pub const DEBUG_HANDLE_DATA_TYPE_MINI_SEMAPHORE_1 = @as(u32, 15);
pub const DEBUG_OFFSINFO_VIRTUAL_SOURCE = @as(u32, 1);
pub const DEBUG_VSOURCE_INVALID = @as(u32, 0);
pub const DEBUG_VSOURCE_DEBUGGEE = @as(u32, 1);
pub const DEBUG_VSOURCE_MAPPED_IMAGE = @as(u32, 2);
pub const DEBUG_VSOURCE_DUMP_WITHOUT_MEMINFO = @as(u32, 3);
pub const DEBUG_VSEARCH_DEFAULT = @as(u32, 0);
pub const DEBUG_VSEARCH_WRITABLE_ONLY = @as(u32, 1);
pub const DEBUG_PHYSICAL_DEFAULT = @as(u32, 0);
pub const DEBUG_PHYSICAL_CACHED = @as(u32, 1);
pub const DEBUG_PHYSICAL_UNCACHED = @as(u32, 2);
pub const DEBUG_PHYSICAL_WRITE_COMBINED = @as(u32, 3);
pub const DEBUG_EVENT_BREAKPOINT = @as(u32, 1);
pub const DEBUG_EVENT_EXCEPTION = @as(u32, 2);
pub const DEBUG_EVENT_CREATE_THREAD = @as(u32, 4);
pub const DEBUG_EVENT_EXIT_THREAD = @as(u32, 8);
pub const DEBUG_EVENT_CREATE_PROCESS = @as(u32, 16);
pub const DEBUG_EVENT_EXIT_PROCESS = @as(u32, 32);
pub const DEBUG_EVENT_LOAD_MODULE = @as(u32, 64);
pub const DEBUG_EVENT_UNLOAD_MODULE = @as(u32, 128);
pub const DEBUG_EVENT_SYSTEM_ERROR = @as(u32, 256);
pub const DEBUG_EVENT_SESSION_STATUS = @as(u32, 512);
pub const DEBUG_EVENT_CHANGE_DEBUGGEE_STATE = @as(u32, 1024);
pub const DEBUG_EVENT_CHANGE_ENGINE_STATE = @as(u32, 2048);
pub const DEBUG_EVENT_CHANGE_SYMBOL_STATE = @as(u32, 4096);
pub const DEBUG_EVENT_SERVICE_EXCEPTION = @as(u32, 8192);
pub const DEBUG_SESSION_ACTIVE = @as(u32, 0);
pub const DEBUG_SESSION_END_SESSION_ACTIVE_TERMINATE = @as(u32, 1);
pub const DEBUG_SESSION_END_SESSION_ACTIVE_DETACH = @as(u32, 2);
pub const DEBUG_SESSION_END_SESSION_PASSIVE = @as(u32, 3);
pub const DEBUG_SESSION_END = @as(u32, 4);
pub const DEBUG_SESSION_REBOOT = @as(u32, 5);
pub const DEBUG_SESSION_HIBERNATE = @as(u32, 6);
pub const DEBUG_SESSION_FAILURE = @as(u32, 7);
pub const DEBUG_CDS_ALL = @as(u32, 4294967295);
pub const DEBUG_CDS_REGISTERS = @as(u32, 1);
pub const DEBUG_CDS_DATA = @as(u32, 2);
pub const DEBUG_CDS_REFRESH = @as(u32, 4);
pub const DEBUG_CDS_REFRESH_EVALUATE = @as(u32, 1);
pub const DEBUG_CDS_REFRESH_EXECUTE = @as(u32, 2);
pub const DEBUG_CDS_REFRESH_EXECUTECOMMANDFILE = @as(u32, 3);
pub const DEBUG_CDS_REFRESH_ADDBREAKPOINT = @as(u32, 4);
pub const DEBUG_CDS_REFRESH_REMOVEBREAKPOINT = @as(u32, 5);
pub const DEBUG_CDS_REFRESH_WRITEVIRTUAL = @as(u32, 6);
pub const DEBUG_CDS_REFRESH_WRITEVIRTUALUNCACHED = @as(u32, 7);
pub const DEBUG_CDS_REFRESH_WRITEPHYSICAL = @as(u32, 8);
pub const DEBUG_CDS_REFRESH_WRITEPHYSICAL2 = @as(u32, 9);
pub const DEBUG_CDS_REFRESH_SETVALUE = @as(u32, 10);
pub const DEBUG_CDS_REFRESH_SETVALUE2 = @as(u32, 11);
pub const DEBUG_CDS_REFRESH_SETSCOPE = @as(u32, 12);
pub const DEBUG_CDS_REFRESH_SETSCOPEFRAMEBYINDEX = @as(u32, 13);
pub const DEBUG_CDS_REFRESH_SETSCOPEFROMJITDEBUGINFO = @as(u32, 14);
pub const DEBUG_CDS_REFRESH_SETSCOPEFROMSTOREDEVENT = @as(u32, 15);
pub const DEBUG_CDS_REFRESH_INLINESTEP = @as(u32, 16);
pub const DEBUG_CDS_REFRESH_INLINESTEP_PSEUDO = @as(u32, 17);
pub const DEBUG_CES_ALL = @as(u32, 4294967295);
pub const DEBUG_CES_CURRENT_THREAD = @as(u32, 1);
pub const DEBUG_CES_EFFECTIVE_PROCESSOR = @as(u32, 2);
pub const DEBUG_CES_BREAKPOINTS = @as(u32, 4);
pub const DEBUG_CES_CODE_LEVEL = @as(u32, 8);
pub const DEBUG_CES_EXECUTION_STATUS = @as(u32, 16);
pub const DEBUG_CES_ENGINE_OPTIONS = @as(u32, 32);
pub const DEBUG_CES_LOG_FILE = @as(u32, 64);
pub const DEBUG_CES_RADIX = @as(u32, 128);
pub const DEBUG_CES_EVENT_FILTERS = @as(u32, 256);
pub const DEBUG_CES_PROCESS_OPTIONS = @as(u32, 512);
pub const DEBUG_CES_EXTENSIONS = @as(u32, 1024);
pub const DEBUG_CES_SYSTEMS = @as(u32, 2048);
pub const DEBUG_CES_ASSEMBLY_OPTIONS = @as(u32, 4096);
pub const DEBUG_CES_EXPRESSION_SYNTAX = @as(u32, 8192);
pub const DEBUG_CES_TEXT_REPLACEMENTS = @as(u32, 16384);
pub const DEBUG_CSS_ALL = @as(u32, 4294967295);
pub const DEBUG_CSS_LOADS = @as(u32, 1);
pub const DEBUG_CSS_UNLOADS = @as(u32, 2);
pub const DEBUG_CSS_SCOPE = @as(u32, 4);
pub const DEBUG_CSS_PATHS = @as(u32, 8);
pub const DEBUG_CSS_SYMBOL_OPTIONS = @as(u32, 16);
pub const DEBUG_CSS_TYPE_OPTIONS = @as(u32, 32);
pub const DEBUG_CSS_COLLAPSE_CHILDREN = @as(u32, 64);
pub const DEBUG_OUTCBI_EXPLICIT_FLUSH = @as(u32, 1);
pub const DEBUG_OUTCBI_TEXT = @as(u32, 2);
pub const DEBUG_OUTCBI_DML = @as(u32, 4);
pub const DEBUG_OUTCBI_ANY_FORMAT = @as(u32, 6);
pub const DEBUG_OUTCB_TEXT = @as(u32, 0);
pub const DEBUG_OUTCB_DML = @as(u32, 1);
pub const DEBUG_OUTCB_EXPLICIT_FLUSH = @as(u32, 2);
pub const DEBUG_OUTCBF_COMBINED_EXPLICIT_FLUSH = @as(u32, 1);
pub const DEBUG_OUTCBF_DML_HAS_TAGS = @as(u32, 2);
pub const DEBUG_OUTCBF_DML_HAS_SPECIAL_CHARACTERS = @as(u32, 4);
pub const DEBUG_REGISTERS_DEFAULT = @as(u32, 0);
pub const DEBUG_REGISTERS_INT32 = @as(u32, 1);
pub const DEBUG_REGISTERS_INT64 = @as(u32, 2);
pub const DEBUG_REGISTERS_FLOAT = @as(u32, 4);
pub const DEBUG_REGISTERS_ALL = @as(u32, 7);
pub const DEBUG_REGISTER_SUB_REGISTER = @as(u32, 1);
pub const DEBUG_REGSRC_DEBUGGEE = @as(u32, 0);
pub const DEBUG_REGSRC_EXPLICIT = @as(u32, 1);
pub const DEBUG_REGSRC_FRAME = @as(u32, 2);
pub const DEBUG_OUTPUT_SYMBOLS_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTPUT_SYMBOLS_NO_NAMES = @as(u32, 1);
pub const DEBUG_OUTPUT_SYMBOLS_NO_OFFSETS = @as(u32, 2);
pub const DEBUG_OUTPUT_SYMBOLS_NO_VALUES = @as(u32, 4);
pub const DEBUG_OUTPUT_SYMBOLS_NO_TYPES = @as(u32, 16);
pub const DEBUG_SYMBOL_EXPANSION_LEVEL_MASK = @as(u32, 15);
pub const DEBUG_SYMBOL_EXPANDED = @as(u32, 16);
pub const DEBUG_SYMBOL_READ_ONLY = @as(u32, 32);
pub const DEBUG_SYMBOL_IS_ARRAY = @as(u32, 64);
pub const DEBUG_SYMBOL_IS_FLOAT = @as(u32, 128);
pub const DEBUG_SYMBOL_IS_ARGUMENT = @as(u32, 256);
pub const DEBUG_SYMBOL_IS_LOCAL = @as(u32, 512);
pub const DEBUG_SYMENT_IS_CODE = @as(u32, 1);
pub const DEBUG_SYMENT_IS_DATA = @as(u32, 2);
pub const DEBUG_SYMENT_IS_PARAMETER = @as(u32, 4);
pub const DEBUG_SYMENT_IS_LOCAL = @as(u32, 8);
pub const DEBUG_SYMENT_IS_MANAGED = @as(u32, 16);
pub const DEBUG_SYMENT_IS_SYNTHETIC = @as(u32, 32);
pub const DEBUG_MODULE_LOADED = @as(u32, 0);
pub const DEBUG_MODULE_UNLOADED = @as(u32, 1);
pub const DEBUG_MODULE_USER_MODE = @as(u32, 2);
pub const DEBUG_MODULE_EXE_MODULE = @as(u32, 4);
pub const DEBUG_MODULE_EXPLICIT = @as(u32, 8);
pub const DEBUG_MODULE_SECONDARY = @as(u32, 16);
pub const DEBUG_MODULE_SYNTHETIC = @as(u32, 32);
pub const DEBUG_MODULE_SYM_BAD_CHECKSUM = @as(u32, 65536);
pub const DEBUG_SYMTYPE_NONE = @as(u32, 0);
pub const DEBUG_SYMTYPE_COFF = @as(u32, 1);
pub const DEBUG_SYMTYPE_CODEVIEW = @as(u32, 2);
pub const DEBUG_SYMTYPE_PDB = @as(u32, 3);
pub const DEBUG_SYMTYPE_EXPORT = @as(u32, 4);
pub const DEBUG_SYMTYPE_DEFERRED = @as(u32, 5);
pub const DEBUG_SYMTYPE_SYM = @as(u32, 6);
pub const DEBUG_SYMTYPE_DIA = @as(u32, 7);
pub const DEBUG_SCOPE_GROUP_ARGUMENTS = @as(u32, 1);
pub const DEBUG_SCOPE_GROUP_LOCALS = @as(u32, 2);
pub const DEBUG_SCOPE_GROUP_ALL = @as(u32, 3);
pub const DEBUG_SCOPE_GROUP_BY_DATAMODEL = @as(u32, 4);
pub const DEBUG_OUTTYPE_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTTYPE_NO_INDENT = @as(u32, 1);
pub const DEBUG_OUTTYPE_NO_OFFSET = @as(u32, 2);
pub const DEBUG_OUTTYPE_VERBOSE = @as(u32, 4);
pub const DEBUG_OUTTYPE_COMPACT_OUTPUT = @as(u32, 8);
pub const DEBUG_OUTTYPE_ADDRESS_OF_FIELD = @as(u32, 65536);
pub const DEBUG_OUTTYPE_ADDRESS_AT_END = @as(u32, 131072);
pub const DEBUG_OUTTYPE_BLOCK_RECURSE = @as(u32, 2097152);
pub const DEBUG_FIND_SOURCE_DEFAULT = @as(u32, 0);
pub const DEBUG_FIND_SOURCE_FULL_PATH = @as(u32, 1);
pub const DEBUG_FIND_SOURCE_BEST_MATCH = @as(u32, 2);
pub const DEBUG_FIND_SOURCE_NO_SRCSRV = @as(u32, 4);
pub const DEBUG_FIND_SOURCE_TOKEN_LOOKUP = @as(u32, 8);
pub const DEBUG_FIND_SOURCE_WITH_CHECKSUM = @as(u32, 16);
pub const MODULE_ORDERS_MASK = @as(u32, 4026531840);
pub const MODULE_ORDERS_LOADTIME = @as(u32, 268435456);
pub const MODULE_ORDERS_MODULENAME = @as(u32, 536870912);
pub const DEBUG_MODNAME_IMAGE = @as(u32, 0);
pub const DEBUG_MODNAME_MODULE = @as(u32, 1);
pub const DEBUG_MODNAME_LOADED_IMAGE = @as(u32, 2);
pub const DEBUG_MODNAME_SYMBOL_FILE = @as(u32, 3);
pub const DEBUG_MODNAME_MAPPED_IMAGE = @as(u32, 4);
pub const DEBUG_TYPEOPTS_UNICODE_DISPLAY = @as(u32, 1);
pub const DEBUG_TYPEOPTS_LONGSTATUS_DISPLAY = @as(u32, 2);
pub const DEBUG_TYPEOPTS_FORCERADIX_OUTPUT = @as(u32, 4);
pub const DEBUG_TYPEOPTS_MATCH_MAXSIZE = @as(u32, 8);
pub const DEBUG_GETMOD_DEFAULT = @as(u32, 0);
pub const DEBUG_GETMOD_NO_LOADED_MODULES = @as(u32, 1);
pub const DEBUG_GETMOD_NO_UNLOADED_MODULES = @as(u32, 2);
pub const DEBUG_ADDSYNTHMOD_DEFAULT = @as(u32, 0);
pub const DEBUG_ADDSYNTHMOD_ZEROBASE = @as(u32, 1);
pub const DEBUG_ADDSYNTHSYM_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTSYM_DEFAULT = @as(u32, 0);
pub const DEBUG_OUTSYM_FORCE_OFFSET = @as(u32, 1);
pub const DEBUG_OUTSYM_SOURCE_LINE = @as(u32, 2);
pub const DEBUG_OUTSYM_ALLOW_DISPLACEMENT = @as(u32, 4);
pub const DEBUG_GETFNENT_DEFAULT = @as(u32, 0);
pub const DEBUG_GETFNENT_RAW_ENTRY_ONLY = @as(u32, 1);
pub const DEBUG_SOURCE_IS_STATEMENT = @as(u32, 1);
pub const DEBUG_GSEL_DEFAULT = @as(u32, 0);
pub const DEBUG_GSEL_NO_SYMBOL_LOADS = @as(u32, 1);
pub const DEBUG_GSEL_ALLOW_LOWER = @as(u32, 2);
pub const DEBUG_GSEL_ALLOW_HIGHER = @as(u32, 4);
pub const DEBUG_GSEL_NEAREST_ONLY = @as(u32, 8);
pub const DEBUG_GSEL_INLINE_CALLSITE = @as(u32, 16);
pub const DEBUG_FRAME_DEFAULT = @as(u32, 0);
pub const DEBUG_FRAME_IGNORE_INLINE = @as(u32, 1);
pub const DEBUG_COMMAND_EXCEPTION_ID = @as(u32, 3688893886);
pub const DEBUG_CMDEX_INVALID = @as(u32, 0);
pub const DEBUG_CMDEX_ADD_EVENT_STRING = @as(u32, 1);
pub const DEBUG_CMDEX_RESET_EVENT_STRINGS = @as(u32, 2);
pub const DEBUG_EXTINIT_HAS_COMMAND_HELP = @as(u32, 1);
pub const DEBUG_NOTIFY_SESSION_ACTIVE = @as(u32, 0);
pub const DEBUG_NOTIFY_SESSION_INACTIVE = @as(u32, 1);
pub const DEBUG_NOTIFY_SESSION_ACCESSIBLE = @as(u32, 2);
pub const DEBUG_NOTIFY_SESSION_INACCESSIBLE = @as(u32, 3);
pub const DEBUG_KNOWN_STRUCT_GET_NAMES = @as(u32, 1);
pub const DEBUG_KNOWN_STRUCT_GET_SINGLE_LINE_OUTPUT = @as(u32, 2);
pub const DEBUG_KNOWN_STRUCT_SUPPRESS_TYPE_NAME = @as(u32, 3);
pub const DEBUG_EXT_QVALUE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXT_PVALUE_DEFAULT = @as(u32, 0);
pub const DEBUG_EXT_PVTYPE_IS_VALUE = @as(u32, 0);
pub const DEBUG_EXT_PVTYPE_IS_POINTER = @as(u32, 1);
pub const CROSS_PLATFORM_MAXIMUM_PROCESSORS = @as(u32, 2048);
pub const EXT_API_VERSION_NUMBER = @as(u32, 5);
pub const EXT_API_VERSION_NUMBER32 = @as(u32, 5);
pub const EXT_API_VERSION_NUMBER64 = @as(u32, 6);
pub const IG_KD_CONTEXT = @as(u32, 1);
pub const IG_READ_CONTROL_SPACE = @as(u32, 2);
pub const IG_WRITE_CONTROL_SPACE = @as(u32, 3);
pub const IG_READ_IO_SPACE = @as(u32, 4);
pub const IG_WRITE_IO_SPACE = @as(u32, 5);
pub const IG_READ_PHYSICAL = @as(u32, 6);
pub const IG_WRITE_PHYSICAL = @as(u32, 7);
pub const IG_READ_IO_SPACE_EX = @as(u32, 8);
pub const IG_WRITE_IO_SPACE_EX = @as(u32, 9);
pub const IG_KSTACK_HELP = @as(u32, 10);
pub const IG_SET_THREAD = @as(u32, 11);
pub const IG_READ_MSR = @as(u32, 12);
pub const IG_WRITE_MSR = @as(u32, 13);
pub const IG_GET_DEBUGGER_DATA = @as(u32, 14);
pub const IG_GET_KERNEL_VERSION = @as(u32, 15);
pub const IG_RELOAD_SYMBOLS = @as(u32, 16);
pub const IG_GET_SET_SYMPATH = @as(u32, 17);
pub const IG_GET_EXCEPTION_RECORD = @as(u32, 18);
pub const IG_IS_PTR64 = @as(u32, 19);
pub const IG_GET_BUS_DATA = @as(u32, 20);
pub const IG_SET_BUS_DATA = @as(u32, 21);
pub const IG_DUMP_SYMBOL_INFO = @as(u32, 22);
pub const IG_LOWMEM_CHECK = @as(u32, 23);
pub const IG_SEARCH_MEMORY = @as(u32, 24);
pub const IG_GET_CURRENT_THREAD = @as(u32, 25);
pub const IG_GET_CURRENT_PROCESS = @as(u32, 26);
pub const IG_GET_TYPE_SIZE = @as(u32, 27);
pub const IG_GET_CURRENT_PROCESS_HANDLE = @as(u32, 28);
pub const IG_GET_INPUT_LINE = @as(u32, 29);
pub const IG_GET_EXPRESSION_EX = @as(u32, 30);
pub const IG_TRANSLATE_VIRTUAL_TO_PHYSICAL = @as(u32, 31);
pub const IG_GET_CACHE_SIZE = @as(u32, 32);
pub const IG_READ_PHYSICAL_WITH_FLAGS = @as(u32, 33);
pub const IG_WRITE_PHYSICAL_WITH_FLAGS = @as(u32, 34);
pub const IG_POINTER_SEARCH_PHYSICAL = @as(u32, 35);
pub const IG_OBSOLETE_PLACEHOLDER_36 = @as(u32, 36);
pub const IG_GET_THREAD_OS_INFO = @as(u32, 37);
pub const IG_GET_CLR_DATA_INTERFACE = @as(u32, 38);
pub const IG_MATCH_PATTERN_A = @as(u32, 39);
pub const IG_FIND_FILE = @as(u32, 40);
pub const IG_TYPED_DATA_OBSOLETE = @as(u32, 41);
pub const IG_QUERY_TARGET_INTERFACE = @as(u32, 42);
pub const IG_TYPED_DATA = @as(u32, 43);
pub const IG_DISASSEMBLE_BUFFER = @as(u32, 44);
pub const IG_GET_ANY_MODULE_IN_RANGE = @as(u32, 45);
pub const IG_VIRTUAL_TO_PHYSICAL = @as(u32, 46);
pub const IG_PHYSICAL_TO_VIRTUAL = @as(u32, 47);
pub const IG_GET_CONTEXT_EX = @as(u32, 48);
pub const IG_GET_TEB_ADDRESS = @as(u32, 128);
pub const IG_GET_PEB_ADDRESS = @as(u32, 129);
pub const PHYS_FLAG_DEFAULT = @as(u32, 0);
pub const PHYS_FLAG_CACHED = @as(u32, 1);
pub const PHYS_FLAG_UNCACHED = @as(u32, 2);
pub const PHYS_FLAG_WRITE_COMBINED = @as(u32, 3);
pub const PTR_SEARCH_PHYS_ALL_HITS = @as(u32, 1);
pub const PTR_SEARCH_PHYS_PTE = @as(u32, 2);
pub const PTR_SEARCH_PHYS_RANGE_CHECK_ONLY = @as(u32, 4);
pub const PTR_SEARCH_PHYS_SIZE_SHIFT = @as(u32, 3);
pub const PTR_SEARCH_NO_SYMBOL_CHECK = @as(u32, 2147483648);
pub const EXT_FIND_FILE_ALLOW_GIVEN_PATH = @as(u32, 1);
pub const DEBUG_TYPED_DATA_IS_IN_MEMORY = @as(u32, 1);
pub const DEBUG_TYPED_DATA_PHYSICAL_DEFAULT = @as(u32, 2);
pub const DEBUG_TYPED_DATA_PHYSICAL_CACHED = @as(u32, 4);
pub const DEBUG_TYPED_DATA_PHYSICAL_UNCACHED = @as(u32, 6);
pub const DEBUG_TYPED_DATA_PHYSICAL_WRITE_COMBINED = @as(u32, 8);
pub const DEBUG_TYPED_DATA_PHYSICAL_MEMORY = @as(u32, 14);
pub const EXT_TDF_PHYSICAL_DEFAULT = @as(u32, 2);
pub const EXT_TDF_PHYSICAL_CACHED = @as(u32, 4);
pub const EXT_TDF_PHYSICAL_UNCACHED = @as(u32, 6);
pub const EXT_TDF_PHYSICAL_WRITE_COMBINED = @as(u32, 8);
pub const EXT_TDF_PHYSICAL_MEMORY = @as(u32, 14);
pub const WDBGEXTS_ADDRESS_DEFAULT = @as(u32, 0);
pub const WDBGEXTS_ADDRESS_SEG16 = @as(u32, 1);
pub const WDBGEXTS_ADDRESS_SEG32 = @as(u32, 2);
pub const WDBGEXTS_ADDRESS_RESERVED0 = @as(u32, 2147483648);
pub const DBGKD_VERS_FLAG_MP = @as(u32, 1);
pub const DBGKD_VERS_FLAG_DATA = @as(u32, 2);
pub const DBGKD_VERS_FLAG_PTR64 = @as(u32, 4);
pub const DBGKD_VERS_FLAG_NOMM = @as(u32, 8);
pub const DBGKD_VERS_FLAG_HSS = @as(u32, 16);
pub const DBGKD_VERS_FLAG_PARTITIONS = @as(u32, 32);
pub const DBGKD_VERS_FLAG_HAL_IN_NTOS = @as(u32, 64);
pub const KD_SECONDARY_VERSION_DEFAULT = @as(u32, 0);
pub const KD_SECONDARY_VERSION_AMD64_OBSOLETE_CONTEXT_1 = @as(u32, 0);
pub const KD_SECONDARY_VERSION_AMD64_OBSOLETE_CONTEXT_2 = @as(u32, 1);
pub const KD_SECONDARY_VERSION_AMD64_CONTEXT = @as(u32, 2);
pub const DBG_DUMP_NO_INDENT = @as(u32, 1);
pub const DBG_DUMP_NO_OFFSET = @as(u32, 2);
pub const DBG_DUMP_VERBOSE = @as(u32, 4);
pub const DBG_DUMP_CALL_FOR_EACH = @as(u32, 8);
pub const DBG_DUMP_LIST = @as(u32, 32);
pub const DBG_DUMP_NO_PRINT = @as(u32, 64);
pub const DBG_DUMP_GET_SIZE_ONLY = @as(u32, 128);
pub const DBG_DUMP_COMPACT_OUT = @as(u32, 8192);
pub const DBG_DUMP_ARRAY = @as(u32, 32768);
pub const DBG_DUMP_ADDRESS_OF_FIELD = @as(u32, 65536);
pub const DBG_DUMP_ADDRESS_AT_END = @as(u32, 131072);
pub const DBG_DUMP_COPY_TYPE_DATA = @as(u32, 262144);
pub const DBG_DUMP_READ_PHYSICAL = @as(u32, 524288);
pub const DBG_DUMP_FUNCTION_FORMAT = @as(u32, 1048576);
pub const DBG_DUMP_BLOCK_RECURSE = @as(u32, 2097152);
pub const DBG_DUMP_MATCH_SIZE = @as(u32, 4194304);
pub const DBG_RETURN_TYPE = @as(u32, 0);
pub const DBG_RETURN_SUBTYPES = @as(u32, 0);
pub const DBG_RETURN_TYPE_VALUES = @as(u32, 0);
pub const DBG_DUMP_FIELD_CALL_BEFORE_PRINT = @as(u32, 1);
pub const DBG_DUMP_FIELD_NO_CALLBACK_REQ = @as(u32, 2);
pub const DBG_DUMP_FIELD_RECUR_ON_THIS = @as(u32, 4);
pub const DBG_DUMP_FIELD_FULL_NAME = @as(u32, 8);
pub const DBG_DUMP_FIELD_ARRAY = @as(u32, 16);
pub const DBG_DUMP_FIELD_COPY_FIELD_DATA = @as(u32, 32);
pub const DBG_DUMP_FIELD_RETURN_ADDRESS = @as(u32, 4096);
pub const DBG_DUMP_FIELD_SIZE_IN_BITS = @as(u32, 8192);
pub const DBG_DUMP_FIELD_NO_PRINT = @as(u32, 16384);
pub const DBG_DUMP_FIELD_DEFAULT_STRING = @as(u32, 65536);
pub const DBG_DUMP_FIELD_WCHAR_STRING = @as(u32, 131072);
pub const DBG_DUMP_FIELD_MULTI_STRING = @as(u32, 262144);
pub const DBG_DUMP_FIELD_GUID_STRING = @as(u32, 524288);
pub const DBG_DUMP_FIELD_UTF32_STRING = @as(u32, 1048576);
pub const MEMORY_READ_ERROR = @as(u32, 1);
pub const SYMBOL_TYPE_INDEX_NOT_FOUND = @as(u32, 2);
pub const SYMBOL_TYPE_INFO_NOT_FOUND = @as(u32, 3);
pub const FIELDS_DID_NOT_MATCH = @as(u32, 4);
pub const NULL_SYM_DUMP_PARAM = @as(u32, 5);
pub const NULL_FIELD_NAME = @as(u32, 6);
pub const INCORRECT_VERSION_INFO = @as(u32, 7);
pub const EXIT_ON_CONTROLC = @as(u32, 8);
pub const CANNOT_ALLOCATE_MEMORY = @as(u32, 9);
pub const INSUFFICIENT_SPACE_TO_COPY = @as(u32, 10);
pub const ADDRESS_TYPE_INDEX_NOT_FOUND = @as(u32, 11);
pub const UNAVAILABLE_ERROR = @as(u32, 12);
pub const CATID_ActiveScript = Guid.initString("f0b7a1a1-9847-11cf-8f20-00805f2cd064");
pub const CATID_ActiveScriptParse = Guid.initString("f0b7a1a2-9847-11cf-8f20-00805f2cd064");
pub const CATID_ActiveScriptEncode = Guid.initString("f0b7a1a3-9847-11cf-8f20-00805f2cd064");
pub const OID_VBSSIP = Guid.initString("1629f04e-2799-4db5-8fe5-ace10f17ebab");
pub const OID_JSSIP = Guid.initString("06c9e010-38ce-11d4-a2a3-00104bd35090");
pub const OID_WSFSIP = Guid.initString("1a610570-38ce-11d4-a2a3-00104bd35090");
pub const SCRIPTITEM_ISVISIBLE = @as(u32, 2);
pub const SCRIPTITEM_ISSOURCE = @as(u32, 4);
pub const SCRIPTITEM_GLOBALMEMBERS = @as(u32, 8);
pub const SCRIPTITEM_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTITEM_CODEONLY = @as(u32, 512);
pub const SCRIPTITEM_NOCODE = @as(u32, 1024);
pub const SCRIPTTYPELIB_ISCONTROL = @as(u32, 16);
pub const SCRIPTTYPELIB_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTTEXT_DELAYEXECUTION = @as(u32, 1);
pub const SCRIPTTEXT_ISVISIBLE = @as(u32, 2);
pub const SCRIPTTEXT_ISEXPRESSION = @as(u32, 32);
pub const SCRIPTTEXT_ISPERSISTENT = @as(u32, 64);
pub const SCRIPTTEXT_HOSTMANAGESSOURCE = @as(u32, 128);
pub const SCRIPTTEXT_ISXDOMAIN = @as(u32, 256);
pub const SCRIPTTEXT_ISNONUSERCODE = @as(u32, 512);
pub const SCRIPTPROC_ISEXPRESSION = @as(u32, 32);
pub const SCRIPTPROC_HOSTMANAGESSOURCE = @as(u32, 128);
pub const SCRIPTPROC_IMPLICIT_THIS = @as(u32, 256);
pub const SCRIPTPROC_IMPLICIT_PARENTS = @as(u32, 512);
pub const SCRIPTPROC_ISXDOMAIN = @as(u32, 1024);
pub const SCRIPTINFO_IUNKNOWN = @as(u32, 1);
pub const SCRIPTINFO_ITYPEINFO = @as(u32, 2);
pub const SCRIPTINTERRUPT_DEBUG = @as(u32, 1);
pub const SCRIPTINTERRUPT_RAISEEXCEPTION = @as(u32, 2);
pub const SCRIPTSTAT_STATEMENT_COUNT = @as(u32, 1);
pub const SCRIPTSTAT_INSTRUCTION_COUNT = @as(u32, 2);
pub const SCRIPTSTAT_INTSTRUCTION_TIME = @as(u32, 3);
pub const SCRIPTSTAT_TOTAL_TIME = @as(u32, 4);
pub const SCRIPT_ENCODE_SECTION = @as(u32, 1);
pub const SCRIPT_ENCODE_DEFAULT_LANGUAGE = @as(u32, 1);
pub const SCRIPT_ENCODE_NO_ASP_LANGUAGE = @as(u32, 2);
pub const SCRIPTPROP_NAME = @as(u32, 0);
pub const SCRIPTPROP_MAJORVERSION = @as(u32, 1);
pub const SCRIPTPROP_MINORVERSION = @as(u32, 2);
pub const SCRIPTPROP_BUILDNUMBER = @as(u32, 3);
pub const SCRIPTPROP_DELAYEDEVENTSINKING = @as(u32, 4096);
pub const SCRIPTPROP_CATCHEXCEPTION = @as(u32, 4097);
pub const SCRIPTPROP_CONVERSIONLCID = @as(u32, 4098);
pub const SCRIPTPROP_HOSTSTACKREQUIRED = @as(u32, 4099);
pub const SCRIPTPROP_SCRIPTSAREFULLYTRUSTED = @as(u32, 4100);
pub const SCRIPTPROP_DEBUGGER = @as(u32, 4352);
pub const SCRIPTPROP_JITDEBUG = @as(u32, 4353);
pub const SCRIPTPROP_GCCONTROLSOFTCLOSE = @as(u32, 8192);
pub const SCRIPTPROP_INTEGERMODE = @as(u32, 12288);
pub const SCRIPTPROP_STRINGCOMPAREINSTANCE = @as(u32, 12289);
pub const SCRIPTPROP_INVOKEVERSIONING = @as(u32, 16384);
pub const SCRIPTPROP_HACK_FIBERSUPPORT = @as(u32, 1879048192);
pub const SCRIPTPROP_HACK_TRIDENTEVENTSINK = @as(u32, 1879048193);
pub const SCRIPTPROP_ABBREVIATE_GLOBALNAME_RESOLUTION = @as(u32, 1879048194);
pub const SCRIPTPROP_HOSTKEEPALIVE = @as(u32, 1879048196);
pub const SCRIPT_E_RECORDED = @as(i32, -2040119292);
pub const SCRIPT_E_REPORTED = @as(i32, -2147352319);
pub const SCRIPT_E_PROPAGATE = @as(i32, -2147352318);
pub const MINIDUMP_VERSION = @as(u32, 42899);
pub const MINIDUMP_MISC1_PROCESSOR_POWER_INFO = @as(u32, 4);
pub const MINIDUMP_MISC3_PROCESS_INTEGRITY = @as(u32, 16);
pub const MINIDUMP_MISC3_PROCESS_EXECUTE_FLAGS = @as(u32, 32);
pub const MINIDUMP_MISC3_TIMEZONE = @as(u32, 64);
pub const MINIDUMP_MISC3_PROTECTED_PROCESS = @as(u32, 128);
pub const MINIDUMP_MISC4_BUILDSTRING = @as(u32, 256);
pub const MINIDUMP_MISC5_PROCESS_COOKIE = @as(u32, 512);
pub const MINIDUMP_SYSMEMINFO1_FILECACHE_TRANSITIONREPURPOSECOUNT_FLAGS = @as(u32, 1);
pub const MINIDUMP_SYSMEMINFO1_BASICPERF = @as(u32, 2);
pub const MINIDUMP_SYSMEMINFO1_PERF_CCTOTALDIRTYPAGES_CCDIRTYPAGETHRESHOLD = @as(u32, 4);
pub const MINIDUMP_SYSMEMINFO1_PERF_RESIDENTAVAILABLEPAGES_SHAREDCOMMITPAGES = @as(u32, 8);
pub const MINIDUMP_PROCESS_VM_COUNTERS = @as(u32, 1);
pub const MINIDUMP_PROCESS_VM_COUNTERS_VIRTUALSIZE = @as(u32, 2);
pub const MINIDUMP_PROCESS_VM_COUNTERS_EX = @as(u32, 4);
pub const MINIDUMP_PROCESS_VM_COUNTERS_EX2 = @as(u32, 8);
pub const MINIDUMP_PROCESS_VM_COUNTERS_JOB = @as(u32, 16);
pub const MAX_SYM_NAME = @as(u32, 2000);
pub const ERROR_IMAGE_NOT_STRIPPED = @as(u32, 34816);
pub const ERROR_NO_DBG_POINTER = @as(u32, 34817);
pub const ERROR_NO_PDB_POINTER = @as(u32, 34818);
pub const UNDNAME_COMPLETE = @as(u32, 0);
pub const UNDNAME_NO_LEADING_UNDERSCORES = @as(u32, 1);
pub const UNDNAME_NO_MS_KEYWORDS = @as(u32, 2);
pub const UNDNAME_NO_FUNCTION_RETURNS = @as(u32, 4);
pub const UNDNAME_NO_ALLOCATION_MODEL = @as(u32, 8);
pub const UNDNAME_NO_ALLOCATION_LANGUAGE = @as(u32, 16);
pub const UNDNAME_NO_MS_THISTYPE = @as(u32, 32);
pub const UNDNAME_NO_CV_THISTYPE = @as(u32, 64);
pub const UNDNAME_NO_THISTYPE = @as(u32, 96);
pub const UNDNAME_NO_ACCESS_SPECIFIERS = @as(u32, 128);
pub const UNDNAME_NO_THROW_SIGNATURES = @as(u32, 256);
pub const UNDNAME_NO_MEMBER_TYPE = @as(u32, 512);
pub const UNDNAME_NO_RETURN_UDT_MODEL = @as(u32, 1024);
pub const UNDNAME_32_BIT_DECODE = @as(u32, 2048);
pub const UNDNAME_NAME_ONLY = @as(u32, 4096);
pub const UNDNAME_NO_ARGUMENTS = @as(u32, 8192);
pub const UNDNAME_NO_SPECIAL_SYMS = @as(u32, 16384);
pub const DBHHEADER_PDBGUID = @as(u32, 3);
pub const INLINE_FRAME_CONTEXT_INIT = @as(u32, 0);
pub const INLINE_FRAME_CONTEXT_IGNORE = @as(u32, 4294967295);
pub const SYM_STKWALK_DEFAULT = @as(u32, 0);
pub const SYM_STKWALK_FORCE_FRAMEPTR = @as(u32, 1);
pub const API_VERSION_NUMBER = @as(u32, 12);
pub const SYMFLAG_NULL = @as(u32, 524288);
pub const SYMFLAG_FUNC_NO_RETURN = @as(u32, 1048576);
pub const SYMFLAG_SYNTHETIC_ZEROBASE = @as(u32, 2097152);
pub const SYMFLAG_PUBLIC_CODE = @as(u32, 4194304);
pub const SYMFLAG_REGREL_ALIASINDIR = @as(u32, 8388608);
pub const SYMFLAG_RESET = @as(u32, 2147483648);
pub const CBA_DEFERRED_SYMBOL_LOAD_START = @as(u32, 1);
pub const CBA_DEFERRED_SYMBOL_LOAD_COMPLETE = @as(u32, 2);
pub const CBA_DEFERRED_SYMBOL_LOAD_FAILURE = @as(u32, 3);
pub const CBA_SYMBOLS_UNLOADED = @as(u32, 4);
pub const CBA_DUPLICATE_SYMBOL = @as(u32, 5);
pub const CBA_READ_MEMORY = @as(u32, 6);
pub const CBA_DEFERRED_SYMBOL_LOAD_CANCEL = @as(u32, 7);
pub const CBA_SET_OPTIONS = @as(u32, 8);
pub const CBA_EVENT = @as(u32, 16);
pub const CBA_DEFERRED_SYMBOL_LOAD_PARTIAL = @as(u32, 32);
pub const CBA_DEBUG_INFO = @as(u32, 268435456);
pub const CBA_SRCSRV_INFO = @as(u32, 536870912);
pub const CBA_SRCSRV_EVENT = @as(u32, 1073741824);
pub const CBA_UPDATE_STATUS_BAR = @as(u32, 1342177280);
pub const CBA_ENGINE_PRESENT = @as(u32, 1610612736);
pub const CBA_CHECK_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 1879048192);
pub const CBA_CHECK_ARM_MACHINE_THUMB_TYPE_OVERRIDE = @as(u32, 2147483648);
pub const CBA_XML_LOG = @as(u32, 2415919104);
pub const EVENT_SRCSPEW_START = @as(u32, 100);
pub const EVENT_SRCSPEW = @as(u32, 100);
pub const EVENT_SRCSPEW_END = @as(u32, 199);
pub const DSLFLAG_MISMATCHED_PDB = @as(u32, 1);
pub const DSLFLAG_MISMATCHED_DBG = @as(u32, 2);
pub const FLAG_ENGINE_PRESENT = @as(u32, 4);
pub const FLAG_ENGOPT_DISALLOW_NETWORK_PATHS = @as(u32, 8);
pub const FLAG_OVERRIDE_ARM_MACHINE_TYPE = @as(u32, 16);
pub const SYM_INLINE_COMP_ERROR = @as(u32, 0);
pub const SYM_INLINE_COMP_IDENTICAL = @as(u32, 1);
pub const SYM_INLINE_COMP_STEPIN = @as(u32, 2);
pub const SYM_INLINE_COMP_STEPOUT = @as(u32, 3);
pub const SYM_INLINE_COMP_STEPOVER = @as(u32, 4);
pub const SYM_INLINE_COMP_DIFFERENT = @as(u32, 5);
pub const ESLFLAG_FULLPATH = @as(u32, 1);
pub const ESLFLAG_NEAREST = @as(u32, 2);
pub const ESLFLAG_PREV = @as(u32, 4);
pub const ESLFLAG_NEXT = @as(u32, 8);
pub const ESLFLAG_INLINE_SITE = @as(u32, 16);
pub const SYMENUM_OPTIONS_DEFAULT = @as(u32, 1);
pub const SYMENUM_OPTIONS_INLINE = @as(u32, 2);
pub const SYMSEARCH_MASKOBJS = @as(u32, 1);
pub const SYMSEARCH_RECURSE = @as(u32, 2);
pub const SYMSEARCH_GLOBALSONLY = @as(u32, 4);
pub const SYMSEARCH_ALLITEMS = @as(u32, 8);
pub const EXT_OUTPUT_VER = @as(u32, 1);
pub const SYMSRV_VERSION = @as(u32, 2);
pub const SSRVOPT_CALLBACK = @as(u32, 1);
pub const SSRVOPT_OLDGUIDPTR = @as(u32, 16);
pub const SSRVOPT_UNATTENDED = @as(u32, 32);
pub const SSRVOPT_NOCOPY = @as(u32, 64);
pub const SSRVOPT_GETPATH = @as(u32, 64);
pub const SSRVOPT_PARENTWIN = @as(u32, 128);
pub const SSRVOPT_PARAMTYPE = @as(u32, 256);
pub const SSRVOPT_SECURE = @as(u32, 512);
pub const SSRVOPT_TRACE = @as(u32, 1024);
pub const SSRVOPT_SETCONTEXT = @as(u32, 2048);
pub const SSRVOPT_PROXY = @as(u32, 4096);
pub const SSRVOPT_DOWNSTREAM_STORE = @as(u32, 8192);
pub const SSRVOPT_OVERWRITE = @as(u32, 16384);
pub const SSRVOPT_RESETTOU = @as(u32, 32768);
pub const SSRVOPT_CALLBACKW = @as(u32, 65536);
pub const SSRVOPT_FLAT_DEFAULT_STORE = @as(u32, 131072);
pub const SSRVOPT_PROXYW = @as(u32, 262144);
pub const SSRVOPT_MESSAGE = @as(u32, 524288);
pub const SSRVOPT_SERVICE = @as(u32, 1048576);
pub const SSRVOPT_FAVOR_COMPRESSED = @as(u32, 2097152);
pub const SSRVOPT_STRING = @as(u32, 4194304);
pub const SSRVOPT_WINHTTP = @as(u32, 8388608);
pub const SSRVOPT_WININET = @as(u32, 16777216);
pub const SSRVOPT_DONT_UNCOMPRESS = @as(u32, 33554432);
pub const SSRVOPT_DISABLE_PING_HOST = @as(u32, 67108864);
pub const SSRVOPT_DISABLE_TIMEOUT = @as(u32, 134217728);
pub const SSRVOPT_ENABLE_COMM_MSG = @as(u32, 268435456);
pub const SSRVOPT_URI_FILTER = @as(u32, 536870912);
pub const SSRVOPT_URI_TIERS = @as(u32, 1073741824);
pub const SSRVOPT_RETRY_APP_HANG = @as(u32, 2147483648);
pub const SSRVOPT_MAX = @as(u32, 2147483648);
pub const NUM_SSRVOPTS = @as(u32, 32);
pub const SSRVURI_HTTP_NORMAL = @as(u32, 1);
pub const SSRVURI_HTTP_COMPRESSED = @as(u32, 2);
pub const SSRVURI_HTTP_FILEPTR = @as(u32, 4);
pub const SSRVURI_UNC_NORMAL = @as(u32, 16);
pub const SSRVURI_UNC_COMPRESSED = @as(u32, 32);
pub const SSRVURI_UNC_FILEPTR = @as(u32, 64);
pub const SSRVURI_HTTP_MASK = @as(u32, 15);
pub const SSRVURI_UNC_MASK = @as(u32, 240);
pub const SSRVURI_ALL = @as(u32, 255);
pub const SSRVACTION_TRACE = @as(u32, 1);
pub const SSRVACTION_QUERYCANCEL = @as(u32, 2);
pub const SSRVACTION_EVENT = @as(u32, 3);
pub const SSRVACTION_EVENTW = @as(u32, 4);
pub const SSRVACTION_SIZE = @as(u32, 5);
pub const SSRVACTION_HTTPSTATUS = @as(u32, 6);
pub const SSRVACTION_XMLOUTPUT = @as(u32, 7);
pub const SSRVACTION_CHECKSUMSTATUS = @as(u32, 8);
pub const SYMF_OMAP_GENERATED = @as(u32, 1);
pub const SYMF_OMAP_MODIFIED = @as(u32, 2);
pub const SYMF_REGISTER = @as(u32, 8);
pub const SYMF_REGREL = @as(u32, 16);
pub const SYMF_FRAMEREL = @as(u32, 32);
pub const SYMF_PARAMETER = @as(u32, 64);
pub const SYMF_LOCAL = @as(u32, 128);
pub const SYMF_CONSTANT = @as(u32, 256);
pub const SYMF_EXPORT = @as(u32, 512);
pub const SYMF_FORWARDER = @as(u32, 1024);
pub const SYMF_FUNCTION = @as(u32, 2048);
pub const SYMF_VIRTUAL = @as(u32, 4096);
pub const SYMF_THUNK = @as(u32, 8192);
pub const SYMF_TLSREL = @as(u32, 16384);
pub const IMAGEHLP_SYMBOL_INFO_VALUEPRESENT = @as(u32, 1);
pub const IMAGEHLP_RMAP_MAPPED_FLAT = @as(u32, 1);
pub const IMAGEHLP_RMAP_BIG_ENDIAN = @as(u32, 2);
pub const IMAGEHLP_RMAP_IGNORE_MISCOMPARE = @as(u32, 4);
pub const IMAGEHLP_RMAP_LOAD_RW_DATA_SECTIONS = @as(u32, 536870912);
pub const IMAGEHLP_RMAP_OMIT_SHARED_RW_DATA_SECTIONS = @as(u32, 1073741824);
pub const IMAGEHLP_RMAP_FIXUP_IMAGEBASE = @as(u32, 2147483648);
pub const WCT_MAX_NODE_COUNT = @as(u32, 16);
pub const WCT_OBJNAME_LENGTH = @as(u32, 128);
pub const WCT_NETWORK_IO_FLAG = @as(u32, 8);
pub const APPBREAKFLAG_DEBUGGER_BLOCK = @as(u32, 1);
pub const APPBREAKFLAG_DEBUGGER_HALT = @as(u32, 2);
pub const APPBREAKFLAG_STEP = @as(u32, 65536);
pub const APPBREAKFLAG_NESTED = @as(u32, 131072);
pub const APPBREAKFLAG_STEPTYPE_SOURCE = @as(u32, 0);
pub const APPBREAKFLAG_STEPTYPE_BYTECODE = @as(u32, 1048576);
pub const APPBREAKFLAG_STEPTYPE_MACHINE = @as(u32, 2097152);
pub const APPBREAKFLAG_STEPTYPE_MASK = @as(u32, 15728640);
pub const APPBREAKFLAG_IN_BREAKPOINT = @as(u32, 2147483648);
pub const SOURCETEXT_ATTR_KEYWORD = @as(u32, 1);
pub const SOURCETEXT_ATTR_COMMENT = @as(u32, 2);
pub const SOURCETEXT_ATTR_NONSOURCE = @as(u32, 4);
pub const SOURCETEXT_ATTR_OPERATOR = @as(u32, 8);
pub const SOURCETEXT_ATTR_NUMBER = @as(u32, 16);
pub const SOURCETEXT_ATTR_STRING = @as(u32, 32);
pub const SOURCETEXT_ATTR_FUNCTION_START = @as(u32, 64);
pub const TEXT_DOC_ATTR_READONLY = @as(u32, 1);
pub const TEXT_DOC_ATTR_TYPE_PRIMARY = @as(u32, 2);
pub const TEXT_DOC_ATTR_TYPE_WORKER = @as(u32, 4);
pub const TEXT_DOC_ATTR_TYPE_SCRIPT = @as(u32, 8);
pub const DEBUG_TEXT_ISEXPRESSION = @as(u32, 1);
pub const DEBUG_TEXT_RETURNVALUE = @as(u32, 2);
pub const DEBUG_TEXT_NOSIDEEFFECTS = @as(u32, 4);
pub const DEBUG_TEXT_ALLOWBREAKPOINTS = @as(u32, 8);
pub const DEBUG_TEXT_ALLOWERRORREPORT = @as(u32, 16);
pub const DEBUG_TEXT_EVALUATETOCODECONTEXT = @as(u32, 32);
pub const DEBUG_TEXT_ISNONUSERCODE = @as(u32, 64);
pub const THREAD_STATE_RUNNING = @as(u32, 1);
pub const THREAD_STATE_SUSPENDED = @as(u32, 2);
pub const THREAD_BLOCKED = @as(u32, 4);
pub const THREAD_OUT_OF_CONTEXT = @as(u32, 8);
pub const ACTIVPROF_E_PROFILER_PRESENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220992));
pub const ACTIVPROF_E_PROFILER_ABSENT = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220991));
pub const ACTIVPROF_E_UNABLE_TO_APPLY_ACTION = @import("../../zig.zig").typedConst(HRESULT, @as(i32, -2147220990));
pub const PROFILER_HEAP_OBJECT_NAME_ID_UNAVAILABLE = @as(u32, 4294967295);
pub const sevMax = @as(i32, 4);
pub const DBGKD_SIMULATION_NONE = @as(i32, 0);
pub const DBGKD_SIMULATION_EXDI = @as(i32, 1);

//--------------------------------------------------------------------------------
// Section: Types (733)
//--------------------------------------------------------------------------------
pub const SYM_LOAD_FLAGS = enum(u32) {
    NONE = 0,
    VIRTUAL = 1,
    ALT_INDEX = 2,
    NO_SYMBOLS = 4,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        VIRTUAL: u1 = 0,
        ALT_INDEX: u1 = 0,
        NO_SYMBOLS: u1 = 0,
    }) SYM_LOAD_FLAGS {
        return @intToEnum(SYM_LOAD_FLAGS,
              (if (o.NONE == 1) @enumToInt(SYM_LOAD_FLAGS.NONE) else 0)
            | (if (o.VIRTUAL == 1) @enumToInt(SYM_LOAD_FLAGS.VIRTUAL) else 0)
            | (if (o.ALT_INDEX == 1) @enumToInt(SYM_LOAD_FLAGS.ALT_INDEX) else 0)
            | (if (o.NO_SYMBOLS == 1) @enumToInt(SYM_LOAD_FLAGS.NO_SYMBOLS) else 0)
        );
    }
};
pub const SLMFLAG_NONE = SYM_LOAD_FLAGS.NONE;
pub const SLMFLAG_VIRTUAL = SYM_LOAD_FLAGS.VIRTUAL;
pub const SLMFLAG_ALT_INDEX = SYM_LOAD_FLAGS.ALT_INDEX;
pub const SLMFLAG_NO_SYMBOLS = SYM_LOAD_FLAGS.NO_SYMBOLS;

pub const IMAGE_SECTION_CHARACTERISTICS = enum(u32) {
    TYPE_NO_PAD = 8,
    CNT_CODE = 32,
    CNT_INITIALIZED_DATA = 64,
    CNT_UNINITIALIZED_DATA = 128,
    LNK_OTHER = 256,
    LNK_INFO = 512,
    LNK_REMOVE = 2048,
    LNK_COMDAT = 4096,
    NO_DEFER_SPEC_EXC = 16384,
    GPREL = 32768,
    // MEM_FARDATA = 32768, this enum value conflicts with GPREL
    MEM_PURGEABLE = 131072,
    // MEM_16BIT = 131072, this enum value conflicts with MEM_PURGEABLE
    MEM_LOCKED = 262144,
    MEM_PRELOAD = 524288,
    ALIGN_1BYTES = 1048576,
    ALIGN_2BYTES = 2097152,
    ALIGN_4BYTES = 3145728,
    ALIGN_8BYTES = 4194304,
    ALIGN_16BYTES = 5242880,
    ALIGN_32BYTES = 6291456,
    ALIGN_64BYTES = 7340032,
    ALIGN_128BYTES = 8388608,
    ALIGN_256BYTES = 9437184,
    ALIGN_512BYTES = 10485760,
    ALIGN_1024BYTES = 11534336,
    ALIGN_2048BYTES = 12582912,
    ALIGN_4096BYTES = 13631488,
    ALIGN_8192BYTES = 14680064,
    ALIGN_MASK = 15728640,
    LNK_NRELOC_OVFL = 16777216,
    MEM_DISCARDABLE = 33554432,
    MEM_NOT_CACHED = 67108864,
    MEM_NOT_PAGED = 134217728,
    MEM_SHARED = 268435456,
    MEM_EXECUTE = 536870912,
    MEM_READ = 1073741824,
    MEM_WRITE = 2147483648,
    SCALE_INDEX = 1,
    _,
    pub fn initFlags(o: struct {
        TYPE_NO_PAD: u1 = 0,
        CNT_CODE: u1 = 0,
        CNT_INITIALIZED_DATA: u1 = 0,
        CNT_UNINITIALIZED_DATA: u1 = 0,
        LNK_OTHER: u1 = 0,
        LNK_INFO: u1 = 0,
        LNK_REMOVE: u1 = 0,
        LNK_COMDAT: u1 = 0,
        NO_DEFER_SPEC_EXC: u1 = 0,
        GPREL: u1 = 0,
        MEM_PURGEABLE: u1 = 0,
        MEM_LOCKED: u1 = 0,
        MEM_PRELOAD: u1 = 0,
        ALIGN_1BYTES: u1 = 0,
        ALIGN_2BYTES: u1 = 0,
        ALIGN_4BYTES: u1 = 0,
        ALIGN_8BYTES: u1 = 0,
        ALIGN_16BYTES: u1 = 0,
        ALIGN_32BYTES: u1 = 0,
        ALIGN_64BYTES: u1 = 0,
        ALIGN_128BYTES: u1 = 0,
        ALIGN_256BYTES: u1 = 0,
        ALIGN_512BYTES: u1 = 0,
        ALIGN_1024BYTES: u1 = 0,
        ALIGN_2048BYTES: u1 = 0,
        ALIGN_4096BYTES: u1 = 0,
        ALIGN_8192BYTES: u1 = 0,
        ALIGN_MASK: u1 = 0,
        LNK_NRELOC_OVFL: u1 = 0,
        MEM_DISCARDABLE: u1 = 0,
        MEM_NOT_CACHED: u1 = 0,
        MEM_NOT_PAGED: u1 = 0,
        MEM_SHARED: u1 = 0,
        MEM_EXECUTE: u1 = 0,
        MEM_READ: u1 = 0,
        MEM_WRITE: u1 = 0,
        SCALE_INDEX: u1 = 0,
    }) IMAGE_SECTION_CHARACTERISTICS {
        return @intToEnum(IMAGE_SECTION_CHARACTERISTICS,
              (if (o.TYPE_NO_PAD == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.TYPE_NO_PAD) else 0)
            | (if (o.CNT_CODE == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.CNT_CODE) else 0)
            | (if (o.CNT_INITIALIZED_DATA == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA) else 0)
            | (if (o.CNT_UNINITIALIZED_DATA == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.CNT_UNINITIALIZED_DATA) else 0)
            | (if (o.LNK_OTHER == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.LNK_OTHER) else 0)
            | (if (o.LNK_INFO == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.LNK_INFO) else 0)
            | (if (o.LNK_REMOVE == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.LNK_REMOVE) else 0)
            | (if (o.LNK_COMDAT == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.LNK_COMDAT) else 0)
            | (if (o.NO_DEFER_SPEC_EXC == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.NO_DEFER_SPEC_EXC) else 0)
            | (if (o.GPREL == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.GPREL) else 0)
            | (if (o.MEM_PURGEABLE == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE) else 0)
            | (if (o.MEM_LOCKED == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_LOCKED) else 0)
            | (if (o.MEM_PRELOAD == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_PRELOAD) else 0)
            | (if (o.ALIGN_1BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_1BYTES) else 0)
            | (if (o.ALIGN_2BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_2BYTES) else 0)
            | (if (o.ALIGN_4BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_4BYTES) else 0)
            | (if (o.ALIGN_8BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_8BYTES) else 0)
            | (if (o.ALIGN_16BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_16BYTES) else 0)
            | (if (o.ALIGN_32BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_32BYTES) else 0)
            | (if (o.ALIGN_64BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_64BYTES) else 0)
            | (if (o.ALIGN_128BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_128BYTES) else 0)
            | (if (o.ALIGN_256BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_256BYTES) else 0)
            | (if (o.ALIGN_512BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_512BYTES) else 0)
            | (if (o.ALIGN_1024BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_1024BYTES) else 0)
            | (if (o.ALIGN_2048BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_2048BYTES) else 0)
            | (if (o.ALIGN_4096BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_4096BYTES) else 0)
            | (if (o.ALIGN_8192BYTES == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_8192BYTES) else 0)
            | (if (o.ALIGN_MASK == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.ALIGN_MASK) else 0)
            | (if (o.LNK_NRELOC_OVFL == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.LNK_NRELOC_OVFL) else 0)
            | (if (o.MEM_DISCARDABLE == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_DISCARDABLE) else 0)
            | (if (o.MEM_NOT_CACHED == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_CACHED) else 0)
            | (if (o.MEM_NOT_PAGED == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_PAGED) else 0)
            | (if (o.MEM_SHARED == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_SHARED) else 0)
            | (if (o.MEM_EXECUTE == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_EXECUTE) else 0)
            | (if (o.MEM_READ == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_READ) else 0)
            | (if (o.MEM_WRITE == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.MEM_WRITE) else 0)
            | (if (o.SCALE_INDEX == 1) @enumToInt(IMAGE_SECTION_CHARACTERISTICS.SCALE_INDEX) else 0)
        );
    }
};
pub const IMAGE_SCN_TYPE_NO_PAD = IMAGE_SECTION_CHARACTERISTICS.TYPE_NO_PAD;
pub const IMAGE_SCN_CNT_CODE = IMAGE_SECTION_CHARACTERISTICS.CNT_CODE;
pub const IMAGE_SCN_CNT_INITIALIZED_DATA = IMAGE_SECTION_CHARACTERISTICS.CNT_INITIALIZED_DATA;
pub const IMAGE_SCN_CNT_UNINITIALIZED_DATA = IMAGE_SECTION_CHARACTERISTICS.CNT_UNINITIALIZED_DATA;
pub const IMAGE_SCN_LNK_OTHER = IMAGE_SECTION_CHARACTERISTICS.LNK_OTHER;
pub const IMAGE_SCN_LNK_INFO = IMAGE_SECTION_CHARACTERISTICS.LNK_INFO;
pub const IMAGE_SCN_LNK_REMOVE = IMAGE_SECTION_CHARACTERISTICS.LNK_REMOVE;
pub const IMAGE_SCN_LNK_COMDAT = IMAGE_SECTION_CHARACTERISTICS.LNK_COMDAT;
pub const IMAGE_SCN_NO_DEFER_SPEC_EXC = IMAGE_SECTION_CHARACTERISTICS.NO_DEFER_SPEC_EXC;
pub const IMAGE_SCN_GPREL = IMAGE_SECTION_CHARACTERISTICS.GPREL;
pub const IMAGE_SCN_MEM_FARDATA = IMAGE_SECTION_CHARACTERISTICS.GPREL;
pub const IMAGE_SCN_MEM_PURGEABLE = IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE;
pub const IMAGE_SCN_MEM_16BIT = IMAGE_SECTION_CHARACTERISTICS.MEM_PURGEABLE;
pub const IMAGE_SCN_MEM_LOCKED = IMAGE_SECTION_CHARACTERISTICS.MEM_LOCKED;
pub const IMAGE_SCN_MEM_PRELOAD = IMAGE_SECTION_CHARACTERISTICS.MEM_PRELOAD;
pub const IMAGE_SCN_ALIGN_1BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_1BYTES;
pub const IMAGE_SCN_ALIGN_2BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_2BYTES;
pub const IMAGE_SCN_ALIGN_4BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_4BYTES;
pub const IMAGE_SCN_ALIGN_8BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_8BYTES;
pub const IMAGE_SCN_ALIGN_16BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_16BYTES;
pub const IMAGE_SCN_ALIGN_32BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_32BYTES;
pub const IMAGE_SCN_ALIGN_64BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_64BYTES;
pub const IMAGE_SCN_ALIGN_128BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_128BYTES;
pub const IMAGE_SCN_ALIGN_256BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_256BYTES;
pub const IMAGE_SCN_ALIGN_512BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_512BYTES;
pub const IMAGE_SCN_ALIGN_1024BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_1024BYTES;
pub const IMAGE_SCN_ALIGN_2048BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_2048BYTES;
pub const IMAGE_SCN_ALIGN_4096BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_4096BYTES;
pub const IMAGE_SCN_ALIGN_8192BYTES = IMAGE_SECTION_CHARACTERISTICS.ALIGN_8192BYTES;
pub const IMAGE_SCN_ALIGN_MASK = IMAGE_SECTION_CHARACTERISTICS.ALIGN_MASK;
pub const IMAGE_SCN_LNK_NRELOC_OVFL = IMAGE_SECTION_CHARACTERISTICS.LNK_NRELOC_OVFL;
pub const IMAGE_SCN_MEM_DISCARDABLE = IMAGE_SECTION_CHARACTERISTICS.MEM_DISCARDABLE;
pub const IMAGE_SCN_MEM_NOT_CACHED = IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_CACHED;
pub const IMAGE_SCN_MEM_NOT_PAGED = IMAGE_SECTION_CHARACTERISTICS.MEM_NOT_PAGED;
pub const IMAGE_SCN_MEM_SHARED = IMAGE_SECTION_CHARACTERISTICS.MEM_SHARED;
pub const IMAGE_SCN_MEM_EXECUTE = IMAGE_SECTION_CHARACTERISTICS.MEM_EXECUTE;
pub const IMAGE_SCN_MEM_READ = IMAGE_SECTION_CHARACTERISTICS.MEM_READ;
pub const IMAGE_SCN_MEM_WRITE = IMAGE_SECTION_CHARACTERISTICS.MEM_WRITE;
pub const IMAGE_SCN_SCALE_INDEX = IMAGE_SECTION_CHARACTERISTICS.SCALE_INDEX;

pub const IMAGE_FILE_MACHINE = enum(u16) {
    AXP64 = 644,
    I386 = 332,
    IA64 = 512,
    AMD64 = 34404,
    UNKNOWN = 0,
    TARGET_HOST = 1,
    R3000 = 354,
    R4000 = 358,
    R10000 = 360,
    WCEMIPSV2 = 361,
    ALPHA = 388,
    SH3 = 418,
    SH3DSP = 419,
    SH3E = 420,
    SH4 = 422,
    SH5 = 424,
    ARM = 448,
    THUMB = 450,
    ARMNT = 452,
    AM33 = 467,
    POWERPC = 496,
    POWERPCFP = 497,
    MIPS16 = 614,
    // ALPHA64 = 644, this enum value conflicts with AXP64
    MIPSFPU = 870,
    MIPSFPU16 = 1126,
    TRICORE = 1312,
    CEF = 3311,
    EBC = 3772,
    M32R = 36929,
    ARM64 = 43620,
    CEE = 49390,
};
pub const IMAGE_FILE_MACHINE_AXP64 = IMAGE_FILE_MACHINE.AXP64;
pub const IMAGE_FILE_MACHINE_I386 = IMAGE_FILE_MACHINE.I386;
pub const IMAGE_FILE_MACHINE_IA64 = IMAGE_FILE_MACHINE.IA64;
pub const IMAGE_FILE_MACHINE_AMD64 = IMAGE_FILE_MACHINE.AMD64;
pub const IMAGE_FILE_MACHINE_UNKNOWN = IMAGE_FILE_MACHINE.UNKNOWN;
pub const IMAGE_FILE_MACHINE_TARGET_HOST = IMAGE_FILE_MACHINE.TARGET_HOST;
pub const IMAGE_FILE_MACHINE_R3000 = IMAGE_FILE_MACHINE.R3000;
pub const IMAGE_FILE_MACHINE_R4000 = IMAGE_FILE_MACHINE.R4000;
pub const IMAGE_FILE_MACHINE_R10000 = IMAGE_FILE_MACHINE.R10000;
pub const IMAGE_FILE_MACHINE_WCEMIPSV2 = IMAGE_FILE_MACHINE.WCEMIPSV2;
pub const IMAGE_FILE_MACHINE_ALPHA = IMAGE_FILE_MACHINE.ALPHA;
pub const IMAGE_FILE_MACHINE_SH3 = IMAGE_FILE_MACHINE.SH3;
pub const IMAGE_FILE_MACHINE_SH3DSP = IMAGE_FILE_MACHINE.SH3DSP;
pub const IMAGE_FILE_MACHINE_SH3E = IMAGE_FILE_MACHINE.SH3E;
pub const IMAGE_FILE_MACHINE_SH4 = IMAGE_FILE_MACHINE.SH4;
pub const IMAGE_FILE_MACHINE_SH5 = IMAGE_FILE_MACHINE.SH5;
pub const IMAGE_FILE_MACHINE_ARM = IMAGE_FILE_MACHINE.ARM;
pub const IMAGE_FILE_MACHINE_THUMB = IMAGE_FILE_MACHINE.THUMB;
pub const IMAGE_FILE_MACHINE_ARMNT = IMAGE_FILE_MACHINE.ARMNT;
pub const IMAGE_FILE_MACHINE_AM33 = IMAGE_FILE_MACHINE.AM33;
pub const IMAGE_FILE_MACHINE_POWERPC = IMAGE_FILE_MACHINE.POWERPC;
pub const IMAGE_FILE_MACHINE_POWERPCFP = IMAGE_FILE_MACHINE.POWERPCFP;
pub const IMAGE_FILE_MACHINE_MIPS16 = IMAGE_FILE_MACHINE.MIPS16;
pub const IMAGE_FILE_MACHINE_ALPHA64 = IMAGE_FILE_MACHINE.AXP64;
pub const IMAGE_FILE_MACHINE_MIPSFPU = IMAGE_FILE_MACHINE.MIPSFPU;
pub const IMAGE_FILE_MACHINE_MIPSFPU16 = IMAGE_FILE_MACHINE.MIPSFPU16;
pub const IMAGE_FILE_MACHINE_TRICORE = IMAGE_FILE_MACHINE.TRICORE;
pub const IMAGE_FILE_MACHINE_CEF = IMAGE_FILE_MACHINE.CEF;
pub const IMAGE_FILE_MACHINE_EBC = IMAGE_FILE_MACHINE.EBC;
pub const IMAGE_FILE_MACHINE_M32R = IMAGE_FILE_MACHINE.M32R;
pub const IMAGE_FILE_MACHINE_ARM64 = IMAGE_FILE_MACHINE.ARM64;
pub const IMAGE_FILE_MACHINE_CEE = IMAGE_FILE_MACHINE.CEE;

pub const IMAGE_SUBSYSTEM = enum(u16) {
    UNKNOWN = 0,
    NATIVE = 1,
    WINDOWS_GUI = 2,
    WINDOWS_CUI = 3,
    OS2_CUI = 5,
    POSIX_CUI = 7,
    NATIVE_WINDOWS = 8,
    WINDOWS_CE_GUI = 9,
    EFI_APPLICATION = 10,
    EFI_BOOT_SERVICE_DRIVER = 11,
    EFI_RUNTIME_DRIVER = 12,
    EFI_ROM = 13,
    XBOX = 14,
    WINDOWS_BOOT_APPLICATION = 16,
    XBOX_CODE_CATALOG = 17,
};
pub const IMAGE_SUBSYSTEM_UNKNOWN = IMAGE_SUBSYSTEM.UNKNOWN;
pub const IMAGE_SUBSYSTEM_NATIVE = IMAGE_SUBSYSTEM.NATIVE;
pub const IMAGE_SUBSYSTEM_WINDOWS_GUI = IMAGE_SUBSYSTEM.WINDOWS_GUI;
pub const IMAGE_SUBSYSTEM_WINDOWS_CUI = IMAGE_SUBSYSTEM.WINDOWS_CUI;
pub const IMAGE_SUBSYSTEM_OS2_CUI = IMAGE_SUBSYSTEM.OS2_CUI;
pub const IMAGE_SUBSYSTEM_POSIX_CUI = IMAGE_SUBSYSTEM.POSIX_CUI;
pub const IMAGE_SUBSYSTEM_NATIVE_WINDOWS = IMAGE_SUBSYSTEM.NATIVE_WINDOWS;
pub const IMAGE_SUBSYSTEM_WINDOWS_CE_GUI = IMAGE_SUBSYSTEM.WINDOWS_CE_GUI;
pub const IMAGE_SUBSYSTEM_EFI_APPLICATION = IMAGE_SUBSYSTEM.EFI_APPLICATION;
pub const IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER = IMAGE_SUBSYSTEM.EFI_BOOT_SERVICE_DRIVER;
pub const IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER = IMAGE_SUBSYSTEM.EFI_RUNTIME_DRIVER;
pub const IMAGE_SUBSYSTEM_EFI_ROM = IMAGE_SUBSYSTEM.EFI_ROM;
pub const IMAGE_SUBSYSTEM_XBOX = IMAGE_SUBSYSTEM.XBOX;
pub const IMAGE_SUBSYSTEM_WINDOWS_BOOT_APPLICATION = IMAGE_SUBSYSTEM.WINDOWS_BOOT_APPLICATION;
pub const IMAGE_SUBSYSTEM_XBOX_CODE_CATALOG = IMAGE_SUBSYSTEM.XBOX_CODE_CATALOG;

pub const IMAGE_DLL_CHARACTERISTICS = enum(u16) {
    HIGH_ENTROPY_VA = 32,
    DYNAMIC_BASE = 64,
    FORCE_INTEGRITY = 128,
    NX_COMPAT = 256,
    NO_ISOLATION = 512,
    NO_SEH = 1024,
    NO_BIND = 2048,
    APPCONTAINER = 4096,
    WDM_DRIVER = 8192,
    GUARD_CF = 16384,
    TERMINAL_SERVER_AWARE = 32768,
    EX_CET_COMPAT = 1,
    _,
    pub fn initFlags(o: struct {
        HIGH_ENTROPY_VA: u1 = 0,
        DYNAMIC_BASE: u1 = 0,
        FORCE_INTEGRITY: u1 = 0,
        NX_COMPAT: u1 = 0,
        NO_ISOLATION: u1 = 0,
        NO_SEH: u1 = 0,
        NO_BIND: u1 = 0,
        APPCONTAINER: u1 = 0,
        WDM_DRIVER: u1 = 0,
        GUARD_CF: u1 = 0,
        TERMINAL_SERVER_AWARE: u1 = 0,
        EX_CET_COMPAT: u1 = 0,
    }) IMAGE_DLL_CHARACTERISTICS {
        return @intToEnum(IMAGE_DLL_CHARACTERISTICS,
              (if (o.HIGH_ENTROPY_VA == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.HIGH_ENTROPY_VA) else 0)
            | (if (o.DYNAMIC_BASE == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.DYNAMIC_BASE) else 0)
            | (if (o.FORCE_INTEGRITY == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.FORCE_INTEGRITY) else 0)
            | (if (o.NX_COMPAT == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.NX_COMPAT) else 0)
            | (if (o.NO_ISOLATION == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.NO_ISOLATION) else 0)
            | (if (o.NO_SEH == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.NO_SEH) else 0)
            | (if (o.NO_BIND == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.NO_BIND) else 0)
            | (if (o.APPCONTAINER == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.APPCONTAINER) else 0)
            | (if (o.WDM_DRIVER == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.WDM_DRIVER) else 0)
            | (if (o.GUARD_CF == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.GUARD_CF) else 0)
            | (if (o.TERMINAL_SERVER_AWARE == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.TERMINAL_SERVER_AWARE) else 0)
            | (if (o.EX_CET_COMPAT == 1) @enumToInt(IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT) else 0)
        );
    }
};
pub const IMAGE_DLLCHARACTERISTICS_HIGH_ENTROPY_VA = IMAGE_DLL_CHARACTERISTICS.HIGH_ENTROPY_VA;
pub const IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE = IMAGE_DLL_CHARACTERISTICS.DYNAMIC_BASE;
pub const IMAGE_DLLCHARACTERISTICS_FORCE_INTEGRITY = IMAGE_DLL_CHARACTERISTICS.FORCE_INTEGRITY;
pub const IMAGE_DLLCHARACTERISTICS_NX_COMPAT = IMAGE_DLL_CHARACTERISTICS.NX_COMPAT;
pub const IMAGE_DLLCHARACTERISTICS_NO_ISOLATION = IMAGE_DLL_CHARACTERISTICS.NO_ISOLATION;
pub const IMAGE_DLLCHARACTERISTICS_NO_SEH = IMAGE_DLL_CHARACTERISTICS.NO_SEH;
pub const IMAGE_DLLCHARACTERISTICS_NO_BIND = IMAGE_DLL_CHARACTERISTICS.NO_BIND;
pub const IMAGE_DLLCHARACTERISTICS_APPCONTAINER = IMAGE_DLL_CHARACTERISTICS.APPCONTAINER;
pub const IMAGE_DLLCHARACTERISTICS_WDM_DRIVER = IMAGE_DLL_CHARACTERISTICS.WDM_DRIVER;
pub const IMAGE_DLLCHARACTERISTICS_GUARD_CF = IMAGE_DLL_CHARACTERISTICS.GUARD_CF;
pub const IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE = IMAGE_DLL_CHARACTERISTICS.TERMINAL_SERVER_AWARE;
pub const IMAGE_DLLCHARACTERISTICS_EX_CET_COMPAT = IMAGE_DLL_CHARACTERISTICS.EX_CET_COMPAT;

pub const IMAGE_OPTIONAL_HEADER_MAGIC = enum(u16) {
    NT_OPTIONAL_HDR_MAGIC = 523,
    NT_OPTIONAL_HDR32_MAGIC = 267,
    // NT_OPTIONAL_HDR64_MAGIC = 523, this enum value conflicts with NT_OPTIONAL_HDR_MAGIC
    ROM_OPTIONAL_HDR_MAGIC = 263,
};
pub const IMAGE_NT_OPTIONAL_HDR_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR_MAGIC;
pub const IMAGE_NT_OPTIONAL_HDR32_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR32_MAGIC;
pub const IMAGE_NT_OPTIONAL_HDR64_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.NT_OPTIONAL_HDR_MAGIC;
pub const IMAGE_ROM_OPTIONAL_HDR_MAGIC = IMAGE_OPTIONAL_HEADER_MAGIC.ROM_OPTIONAL_HDR_MAGIC;

pub const WIN32_ERROR = enum(u32) {
    NO_ERROR = 0,
    // ERROR_SUCCESS = 0, this enum value conflicts with NO_ERROR
    ERROR_INVALID_FUNCTION = 1,
    ERROR_FILE_NOT_FOUND = 2,
    ERROR_PATH_NOT_FOUND = 3,
    ERROR_TOO_MANY_OPEN_FILES = 4,
    ERROR_ACCESS_DENIED = 5,
    ERROR_INVALID_HANDLE = 6,
    ERROR_ARENA_TRASHED = 7,
    ERROR_NOT_ENOUGH_MEMORY = 8,
    ERROR_INVALID_BLOCK = 9,
    ERROR_BAD_ENVIRONMENT = 10,
    ERROR_BAD_FORMAT = 11,
    ERROR_INVALID_ACCESS = 12,
    ERROR_INVALID_DATA = 13,
    ERROR_OUTOFMEMORY = 14,
    ERROR_INVALID_DRIVE = 15,
    ERROR_CURRENT_DIRECTORY = 16,
    ERROR_NOT_SAME_DEVICE = 17,
    ERROR_NO_MORE_FILES = 18,
    ERROR_WRITE_PROTECT = 19,
    ERROR_BAD_UNIT = 20,
    ERROR_NOT_READY = 21,
    ERROR_BAD_COMMAND = 22,
    ERROR_CRC = 23,
    ERROR_BAD_LENGTH = 24,
    ERROR_SEEK = 25,
    ERROR_NOT_DOS_DISK = 26,
    ERROR_SECTOR_NOT_FOUND = 27,
    ERROR_OUT_OF_PAPER = 28,
    ERROR_WRITE_FAULT = 29,
    ERROR_READ_FAULT = 30,
    ERROR_GEN_FAILURE = 31,
    ERROR_SHARING_VIOLATION = 32,
    ERROR_LOCK_VIOLATION = 33,
    ERROR_WRONG_DISK = 34,
    ERROR_SHARING_BUFFER_EXCEEDED = 36,
    ERROR_HANDLE_EOF = 38,
    ERROR_HANDLE_DISK_FULL = 39,
    ERROR_NOT_SUPPORTED = 50,
    ERROR_REM_NOT_LIST = 51,
    ERROR_DUP_NAME = 52,
    ERROR_BAD_NETPATH = 53,
    ERROR_NETWORK_BUSY = 54,
    ERROR_DEV_NOT_EXIST = 55,
    ERROR_TOO_MANY_CMDS = 56,
    ERROR_ADAP_HDW_ERR = 57,
    ERROR_BAD_NET_RESP = 58,
    ERROR_UNEXP_NET_ERR = 59,
    ERROR_BAD_REM_ADAP = 60,
    ERROR_PRINTQ_FULL = 61,
    ERROR_NO_SPOOL_SPACE = 62,
    ERROR_PRINT_CANCELLED = 63,
    ERROR_NETNAME_DELETED = 64,
    ERROR_NETWORK_ACCESS_DENIED = 65,
    ERROR_BAD_DEV_TYPE = 66,
    ERROR_BAD_NET_NAME = 67,
    ERROR_TOO_MANY_NAMES = 68,
    ERROR_TOO_MANY_SESS = 69,
    ERROR_SHARING_PAUSED = 70,
    ERROR_REQ_NOT_ACCEP = 71,
    ERROR_REDIR_PAUSED = 72,
    ERROR_FILE_EXISTS = 80,
    ERROR_CANNOT_MAKE = 82,
    ERROR_FAIL_I24 = 83,
    ERROR_OUT_OF_STRUCTURES = 84,
    ERROR_ALREADY_ASSIGNED = 85,
    ERROR_INVALID_PASSWORD = 86,
    ERROR_INVALID_PARAMETER = 87,
    ERROR_NET_WRITE_FAULT = 88,
    ERROR_NO_PROC_SLOTS = 89,
    ERROR_TOO_MANY_SEMAPHORES = 100,
    ERROR_EXCL_SEM_ALREADY_OWNED = 101,
    ERROR_SEM_IS_SET = 102,
    ERROR_TOO_MANY_SEM_REQUESTS = 103,
    ERROR_INVALID_AT_INTERRUPT_TIME = 104,
    ERROR_SEM_OWNER_DIED = 105,
    ERROR_SEM_USER_LIMIT = 106,
    ERROR_DISK_CHANGE = 107,
    ERROR_DRIVE_LOCKED = 108,
    ERROR_BROKEN_PIPE = 109,
    ERROR_OPEN_FAILED = 110,
    ERROR_BUFFER_OVERFLOW = 111,
    ERROR_DISK_FULL = 112,
    ERROR_NO_MORE_SEARCH_HANDLES = 113,
    ERROR_INVALID_TARGET_HANDLE = 114,
    ERROR_INVALID_CATEGORY = 117,
    ERROR_INVALID_VERIFY_SWITCH = 118,
    ERROR_BAD_DRIVER_LEVEL = 119,
    ERROR_CALL_NOT_IMPLEMENTED = 120,
    ERROR_SEM_TIMEOUT = 121,
    ERROR_INSUFFICIENT_BUFFER = 122,
    ERROR_INVALID_NAME = 123,
    ERROR_INVALID_LEVEL = 124,
    ERROR_NO_VOLUME_LABEL = 125,
    ERROR_MOD_NOT_FOUND = 126,
    ERROR_PROC_NOT_FOUND = 127,
    ERROR_WAIT_NO_CHILDREN = 128,
    ERROR_CHILD_NOT_COMPLETE = 129,
    ERROR_DIRECT_ACCESS_HANDLE = 130,
    ERROR_NEGATIVE_SEEK = 131,
    ERROR_SEEK_ON_DEVICE = 132,
    ERROR_IS_JOIN_TARGET = 133,
    ERROR_IS_JOINED = 134,
    ERROR_IS_SUBSTED = 135,
    ERROR_NOT_JOINED = 136,
    ERROR_NOT_SUBSTED = 137,
    ERROR_JOIN_TO_JOIN = 138,
    ERROR_SUBST_TO_SUBST = 139,
    ERROR_JOIN_TO_SUBST = 140,
    ERROR_SUBST_TO_JOIN = 141,
    ERROR_BUSY_DRIVE = 142,
    ERROR_SAME_DRIVE = 143,
    ERROR_DIR_NOT_ROOT = 144,
    ERROR_DIR_NOT_EMPTY = 145,
    ERROR_IS_SUBST_PATH = 146,
    ERROR_IS_JOIN_PATH = 147,
    ERROR_PATH_BUSY = 148,
    ERROR_IS_SUBST_TARGET = 149,
    ERROR_SYSTEM_TRACE = 150,
    ERROR_INVALID_EVENT_COUNT = 151,
    ERROR_TOO_MANY_MUXWAITERS = 152,
    ERROR_INVALID_LIST_FORMAT = 153,
    ERROR_LABEL_TOO_LONG = 154,
    ERROR_TOO_MANY_TCBS = 155,
    ERROR_SIGNAL_REFUSED = 156,
    ERROR_DISCARDED = 157,
    ERROR_NOT_LOCKED = 158,
    ERROR_BAD_THREADID_ADDR = 159,
    ERROR_BAD_ARGUMENTS = 160,
    ERROR_BAD_PATHNAME = 161,
    ERROR_SIGNAL_PENDING = 162,
    ERROR_MAX_THRDS_REACHED = 164,
    ERROR_LOCK_FAILED = 167,
    ERROR_BUSY = 170,
    ERROR_DEVICE_SUPPORT_IN_PROGRESS = 171,
    ERROR_CANCEL_VIOLATION = 173,
    ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = 174,
    ERROR_INVALID_SEGMENT_NUMBER = 180,
    ERROR_INVALID_ORDINAL = 182,
    ERROR_ALREADY_EXISTS = 183,
    ERROR_INVALID_FLAG_NUMBER = 186,
    ERROR_SEM_NOT_FOUND = 187,
    ERROR_INVALID_STARTING_CODESEG = 188,
    ERROR_INVALID_STACKSEG = 189,
    ERROR_INVALID_MODULETYPE = 190,
    ERROR_INVALID_EXE_SIGNATURE = 191,
    ERROR_EXE_MARKED_INVALID = 192,
    ERROR_BAD_EXE_FORMAT = 193,
    ERROR_ITERATED_DATA_EXCEEDS_64k = 194,
    ERROR_INVALID_MINALLOCSIZE = 195,
    ERROR_DYNLINK_FROM_INVALID_RING = 196,
    ERROR_IOPL_NOT_ENABLED = 197,
    ERROR_INVALID_SEGDPL = 198,
    ERROR_AUTODATASEG_EXCEEDS_64k = 199,
    ERROR_RING2SEG_MUST_BE_MOVABLE = 200,
    ERROR_RELOC_CHAIN_XEEDS_SEGLIM = 201,
    ERROR_INFLOOP_IN_RELOC_CHAIN = 202,
    ERROR_ENVVAR_NOT_FOUND = 203,
    ERROR_NO_SIGNAL_SENT = 205,
    ERROR_FILENAME_EXCED_RANGE = 206,
    ERROR_RING2_STACK_IN_USE = 207,
    ERROR_META_EXPANSION_TOO_LONG = 208,
    ERROR_INVALID_SIGNAL_NUMBER = 209,
    ERROR_THREAD_1_INACTIVE = 210,
    ERROR_LOCKED = 212,
    ERROR_TOO_MANY_MODULES = 214,
    ERROR_NESTING_NOT_ALLOWED = 215,
    ERROR_EXE_MACHINE_TYPE_MISMATCH = 216,
    ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = 217,
    ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = 218,
    ERROR_FILE_CHECKED_OUT = 220,
    ERROR_CHECKOUT_REQUIRED = 221,
    ERROR_BAD_FILE_TYPE = 222,
    ERROR_FILE_TOO_LARGE = 223,
    ERROR_FORMS_AUTH_REQUIRED = 224,
    ERROR_VIRUS_INFECTED = 225,
    ERROR_VIRUS_DELETED = 226,
    ERROR_PIPE_LOCAL = 229,
    ERROR_BAD_PIPE = 230,
    ERROR_PIPE_BUSY = 231,
    ERROR_NO_DATA = 232,
    ERROR_PIPE_NOT_CONNECTED = 233,
    ERROR_MORE_DATA = 234,
    ERROR_NO_WORK_DONE = 235,
    ERROR_VC_DISCONNECTED = 240,
    ERROR_INVALID_EA_NAME = 254,
    ERROR_EA_LIST_INCONSISTENT = 255,
    ERROR_NO_MORE_ITEMS = 259,
    ERROR_CANNOT_COPY = 266,
    ERROR_DIRECTORY = 267,
    ERROR_EAS_DIDNT_FIT = 275,
    ERROR_EA_FILE_CORRUPT = 276,
    ERROR_EA_TABLE_FULL = 277,
    ERROR_INVALID_EA_HANDLE = 278,
    ERROR_EAS_NOT_SUPPORTED = 282,
    ERROR_NOT_OWNER = 288,
    ERROR_TOO_MANY_POSTS = 298,
    ERROR_PARTIAL_COPY = 299,
    ERROR_OPLOCK_NOT_GRANTED = 300,
    ERROR_INVALID_OPLOCK_PROTOCOL = 301,
    ERROR_DISK_TOO_FRAGMENTED = 302,
    ERROR_DELETE_PENDING = 303,
    ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = 304,
    ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = 305,
    ERROR_SECURITY_STREAM_IS_INCONSISTENT = 306,
    ERROR_INVALID_LOCK_RANGE = 307,
    ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = 308,
    ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = 309,
    ERROR_INVALID_EXCEPTION_HANDLER = 310,
    ERROR_DUPLICATE_PRIVILEGES = 311,
    ERROR_NO_RANGES_PROCESSED = 312,
    ERROR_NOT_ALLOWED_ON_SYSTEM_FILE = 313,
    ERROR_DISK_RESOURCES_EXHAUSTED = 314,
    ERROR_INVALID_TOKEN = 315,
    ERROR_DEVICE_FEATURE_NOT_SUPPORTED = 316,
    ERROR_MR_MID_NOT_FOUND = 317,
    ERROR_SCOPE_NOT_FOUND = 318,
    ERROR_UNDEFINED_SCOPE = 319,
    ERROR_INVALID_CAP = 320,
    ERROR_DEVICE_UNREACHABLE = 321,
    ERROR_DEVICE_NO_RESOURCES = 322,
    ERROR_DATA_CHECKSUM_ERROR = 323,
    ERROR_INTERMIXED_KERNEL_EA_OPERATION = 324,
    ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED = 326,
    ERROR_OFFSET_ALIGNMENT_VIOLATION = 327,
    ERROR_INVALID_FIELD_IN_PARAMETER_LIST = 328,
    ERROR_OPERATION_IN_PROGRESS = 329,
    ERROR_BAD_DEVICE_PATH = 330,
    ERROR_TOO_MANY_DESCRIPTORS = 331,
    ERROR_SCRUB_DATA_DISABLED = 332,
    ERROR_NOT_REDUNDANT_STORAGE = 333,
    ERROR_RESIDENT_FILE_NOT_SUPPORTED = 334,
    ERROR_COMPRESSED_FILE_NOT_SUPPORTED = 335,
    ERROR_DIRECTORY_NOT_SUPPORTED = 336,
    ERROR_NOT_READ_FROM_COPY = 337,
    ERROR_FT_WRITE_FAILURE = 338,
    ERROR_FT_DI_SCAN_REQUIRED = 339,
    ERROR_INVALID_KERNEL_INFO_VERSION = 340,
    ERROR_INVALID_PEP_INFO_VERSION = 341,
    ERROR_OBJECT_NOT_EXTERNALLY_BACKED = 342,
    ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN = 343,
    ERROR_COMPRESSION_NOT_BENEFICIAL = 344,
    ERROR_STORAGE_TOPOLOGY_ID_MISMATCH = 345,
    ERROR_BLOCKED_BY_PARENTAL_CONTROLS = 346,
    ERROR_BLOCK_TOO_MANY_REFERENCES = 347,
    ERROR_MARKED_TO_DISALLOW_WRITES = 348,
    ERROR_ENCLAVE_FAILURE = 349,
    ERROR_FAIL_NOACTION_REBOOT = 350,
    ERROR_FAIL_SHUTDOWN = 351,
    ERROR_FAIL_RESTART = 352,
    ERROR_MAX_SESSIONS_REACHED = 353,
    ERROR_NETWORK_ACCESS_DENIED_EDP = 354,
    ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL = 355,
    ERROR_EDP_POLICY_DENIES_OPERATION = 356,
    ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED = 357,
    ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT = 358,
    ERROR_DEVICE_IN_MAINTENANCE = 359,
    ERROR_NOT_SUPPORTED_ON_DAX = 360,
    ERROR_DAX_MAPPING_EXISTS = 361,
    ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING = 362,
    ERROR_CLOUD_FILE_METADATA_CORRUPT = 363,
    ERROR_CLOUD_FILE_METADATA_TOO_LARGE = 364,
    ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE = 365,
    ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH = 366,
    ERROR_CHILD_PROCESS_BLOCKED = 367,
    ERROR_STORAGE_LOST_DATA_PERSISTENCE = 368,
    ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE = 369,
    ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT = 370,
    ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY = 371,
    ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN = 372,
    ERROR_GDI_HANDLE_LEAK = 373,
    ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS = 374,
    ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED = 375,
    ERROR_NOT_A_CLOUD_FILE = 376,
    ERROR_CLOUD_FILE_NOT_IN_SYNC = 377,
    ERROR_CLOUD_FILE_ALREADY_CONNECTED = 378,
    ERROR_CLOUD_FILE_NOT_SUPPORTED = 379,
    ERROR_CLOUD_FILE_INVALID_REQUEST = 380,
    ERROR_CLOUD_FILE_READ_ONLY_VOLUME = 381,
    ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY = 382,
    ERROR_CLOUD_FILE_VALIDATION_FAILED = 383,
    ERROR_SMB1_NOT_AVAILABLE = 384,
    ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION = 385,
    ERROR_CLOUD_FILE_AUTHENTICATION_FAILED = 386,
    ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES = 387,
    ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE = 388,
    ERROR_CLOUD_FILE_UNSUCCESSFUL = 389,
    ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT = 390,
    ERROR_CLOUD_FILE_IN_USE = 391,
    ERROR_CLOUD_FILE_PINNED = 392,
    ERROR_CLOUD_FILE_REQUEST_ABORTED = 393,
    ERROR_CLOUD_FILE_PROPERTY_CORRUPT = 394,
    ERROR_CLOUD_FILE_ACCESS_DENIED = 395,
    ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS = 396,
    ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT = 397,
    ERROR_CLOUD_FILE_REQUEST_CANCELED = 398,
    ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED = 399,
    ERROR_THREAD_MODE_ALREADY_BACKGROUND = 400,
    ERROR_THREAD_MODE_NOT_BACKGROUND = 401,
    ERROR_PROCESS_MODE_ALREADY_BACKGROUND = 402,
    ERROR_PROCESS_MODE_NOT_BACKGROUND = 403,
    ERROR_CLOUD_FILE_PROVIDER_TERMINATED = 404,
    ERROR_NOT_A_CLOUD_SYNC_ROOT = 405,
    ERROR_FILE_PROTECTED_UNDER_DPL = 406,
    ERROR_VOLUME_NOT_CLUSTER_ALIGNED = 407,
    ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND = 408,
    ERROR_APPX_FILE_NOT_ENCRYPTED = 409,
    ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED = 410,
    ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET = 411,
    ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE = 412,
    ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER = 413,
    ERROR_LINUX_SUBSYSTEM_NOT_PRESENT = 414,
    ERROR_FT_READ_FAILURE = 415,
    ERROR_STORAGE_RESERVE_ID_INVALID = 416,
    ERROR_STORAGE_RESERVE_DOES_NOT_EXIST = 417,
    ERROR_STORAGE_RESERVE_ALREADY_EXISTS = 418,
    ERROR_STORAGE_RESERVE_NOT_EMPTY = 419,
    ERROR_NOT_A_DAX_VOLUME = 420,
    ERROR_NOT_DAX_MAPPABLE = 421,
    ERROR_TIME_SENSITIVE_THREAD = 422,
    ERROR_DPL_NOT_SUPPORTED_FOR_USER = 423,
    ERROR_CASE_DIFFERING_NAMES_IN_DIR = 424,
    ERROR_FILE_NOT_SUPPORTED = 425,
    ERROR_CLOUD_FILE_REQUEST_TIMEOUT = 426,
    ERROR_NO_TASK_QUEUE = 427,
    ERROR_SRC_SRV_DLL_LOAD_FAILED = 428,
    ERROR_NOT_SUPPORTED_WITH_BTT = 429,
    ERROR_ENCRYPTION_DISABLED = 430,
    ERROR_ENCRYPTING_METADATA_DISALLOWED = 431,
    ERROR_CANT_CLEAR_ENCRYPTION_FLAG = 432,
    ERROR_NO_SUCH_DEVICE = 433,
    ERROR_CLOUD_FILE_DEHYDRATION_DISALLOWED = 434,
    ERROR_FILE_SNAP_IN_PROGRESS = 435,
    ERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED = 436,
    ERROR_FILE_SNAP_MODIFY_NOT_SUPPORTED = 437,
    ERROR_FILE_SNAP_IO_NOT_COORDINATED = 438,
    ERROR_FILE_SNAP_UNEXPECTED_ERROR = 439,
    ERROR_FILE_SNAP_INVALID_PARAMETER = 440,
    ERROR_UNSATISFIED_DEPENDENCIES = 441,
    ERROR_CASE_SENSITIVE_PATH = 442,
    ERROR_UNEXPECTED_NTCACHEMANAGER_ERROR = 443,
    ERROR_CAPAUTHZ_NOT_DEVUNLOCKED = 450,
    ERROR_CAPAUTHZ_CHANGE_TYPE = 451,
    ERROR_CAPAUTHZ_NOT_PROVISIONED = 452,
    ERROR_CAPAUTHZ_NOT_AUTHORIZED = 453,
    ERROR_CAPAUTHZ_NO_POLICY = 454,
    ERROR_CAPAUTHZ_DB_CORRUPTED = 455,
    ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG = 456,
    ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY = 457,
    ERROR_CAPAUTHZ_SCCD_PARSE_ERROR = 458,
    ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED = 459,
    ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH = 460,
    ERROR_CIMFS_IMAGE_CORRUPT = 470,
    ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT = 480,
    ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT = 481,
    ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT = 482,
    ERROR_DEVICE_HARDWARE_ERROR = 483,
    ERROR_INVALID_ADDRESS = 487,
    ERROR_VRF_CFG_AND_IO_ENABLED = 1183,
    ERROR_PARTITION_TERMINATING = 1184,
    ERROR_USER_PROFILE_LOAD = 500,
    ERROR_ARITHMETIC_OVERFLOW = 534,
    ERROR_PIPE_CONNECTED = 535,
    ERROR_PIPE_LISTENING = 536,
    ERROR_VERIFIER_STOP = 537,
    ERROR_ABIOS_ERROR = 538,
    ERROR_WX86_WARNING = 539,
    ERROR_WX86_ERROR = 540,
    ERROR_TIMER_NOT_CANCELED = 541,
    ERROR_UNWIND = 542,
    ERROR_BAD_STACK = 543,
    ERROR_INVALID_UNWIND_TARGET = 544,
    ERROR_INVALID_PORT_ATTRIBUTES = 545,
    ERROR_PORT_MESSAGE_TOO_LONG = 546,
    ERROR_INVALID_QUOTA_LOWER = 547,
    ERROR_DEVICE_ALREADY_ATTACHED = 548,
    ERROR_INSTRUCTION_MISALIGNMENT = 549,
    ERROR_PROFILING_NOT_STARTED = 550,
    ERROR_PROFILING_NOT_STOPPED = 551,
    ERROR_COULD_NOT_INTERPRET = 552,
    ERROR_PROFILING_AT_LIMIT = 553,
    ERROR_CANT_WAIT = 554,
    ERROR_CANT_TERMINATE_SELF = 555,
    ERROR_UNEXPECTED_MM_CREATE_ERR = 556,
    ERROR_UNEXPECTED_MM_MAP_ERROR = 557,
    ERROR_UNEXPECTED_MM_EXTEND_ERR = 558,
    ERROR_BAD_FUNCTION_TABLE = 559,
    ERROR_NO_GUID_TRANSLATION = 560,
    ERROR_INVALID_LDT_SIZE = 561,
    ERROR_INVALID_LDT_OFFSET = 563,
    ERROR_INVALID_LDT_DESCRIPTOR = 564,
    ERROR_TOO_MANY_THREADS = 565,
    ERROR_THREAD_NOT_IN_PROCESS = 566,
    ERROR_PAGEFILE_QUOTA_EXCEEDED = 567,
    ERROR_LOGON_SERVER_CONFLICT = 568,
    ERROR_SYNCHRONIZATION_REQUIRED = 569,
    ERROR_NET_OPEN_FAILED = 570,
    ERROR_IO_PRIVILEGE_FAILED = 571,
    ERROR_CONTROL_C_EXIT = 572,
    ERROR_MISSING_SYSTEMFILE = 573,
    ERROR_UNHANDLED_EXCEPTION = 574,
    ERROR_APP_INIT_FAILURE = 575,
    ERROR_PAGEFILE_CREATE_FAILED = 576,
    ERROR_INVALID_IMAGE_HASH = 577,
    ERROR_NO_PAGEFILE = 578,
    ERROR_ILLEGAL_FLOAT_CONTEXT = 579,
    ERROR_NO_EVENT_PAIR = 580,
    ERROR_DOMAIN_CTRLR_CONFIG_ERROR = 581,
    ERROR_ILLEGAL_CHARACTER = 582,
    ERROR_UNDEFINED_CHARACTER = 583,
    ERROR_FLOPPY_VOLUME = 584,
    ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT = 585,
    ERROR_BACKUP_CONTROLLER = 586,
    ERROR_MUTANT_LIMIT_EXCEEDED = 587,
    ERROR_FS_DRIVER_REQUIRED = 588,
    ERROR_CANNOT_LOAD_REGISTRY_FILE = 589,
    ERROR_DEBUG_ATTACH_FAILED = 590,
    ERROR_SYSTEM_PROCESS_TERMINATED = 591,
    ERROR_DATA_NOT_ACCEPTED = 592,
    ERROR_VDM_HARD_ERROR = 593,
    ERROR_DRIVER_CANCEL_TIMEOUT = 594,
    ERROR_REPLY_MESSAGE_MISMATCH = 595,
    ERROR_LOST_WRITEBEHIND_DATA = 596,
    ERROR_CLIENT_SERVER_PARAMETERS_INVALID = 597,
    ERROR_NOT_TINY_STREAM = 598,
    ERROR_STACK_OVERFLOW_READ = 599,
    ERROR_CONVERT_TO_LARGE = 600,
    ERROR_FOUND_OUT_OF_SCOPE = 601,
    ERROR_ALLOCATE_BUCKET = 602,
    ERROR_MARSHALL_OVERFLOW = 603,
    ERROR_INVALID_VARIANT = 604,
    ERROR_BAD_COMPRESSION_BUFFER = 605,
    ERROR_AUDIT_FAILED = 606,
    ERROR_TIMER_RESOLUTION_NOT_SET = 607,
    ERROR_INSUFFICIENT_LOGON_INFO = 608,
    ERROR_BAD_DLL_ENTRYPOINT = 609,
    ERROR_BAD_SERVICE_ENTRYPOINT = 610,
    ERROR_IP_ADDRESS_CONFLICT1 = 611,
    ERROR_IP_ADDRESS_CONFLICT2 = 612,
    ERROR_REGISTRY_QUOTA_LIMIT = 613,
    ERROR_NO_CALLBACK_ACTIVE = 614,
    ERROR_PWD_TOO_SHORT = 615,
    ERROR_PWD_TOO_RECENT = 616,
    ERROR_PWD_HISTORY_CONFLICT = 617,
    ERROR_UNSUPPORTED_COMPRESSION = 618,
    ERROR_INVALID_HW_PROFILE = 619,
    ERROR_INVALID_PLUGPLAY_DEVICE_PATH = 620,
    ERROR_QUOTA_LIST_INCONSISTENT = 621,
    ERROR_EVALUATION_EXPIRATION = 622,
    ERROR_ILLEGAL_DLL_RELOCATION = 623,
    ERROR_DLL_INIT_FAILED_LOGOFF = 624,
    ERROR_VALIDATE_CONTINUE = 625,
    ERROR_NO_MORE_MATCHES = 626,
    ERROR_RANGE_LIST_CONFLICT = 627,
    ERROR_SERVER_SID_MISMATCH = 628,
    ERROR_CANT_ENABLE_DENY_ONLY = 629,
    ERROR_FLOAT_MULTIPLE_FAULTS = 630,
    ERROR_FLOAT_MULTIPLE_TRAPS = 631,
    ERROR_NOINTERFACE = 632,
    ERROR_DRIVER_FAILED_SLEEP = 633,
    ERROR_CORRUPT_SYSTEM_FILE = 634,
    ERROR_COMMITMENT_MINIMUM = 635,
    ERROR_PNP_RESTART_ENUMERATION = 636,
    ERROR_SYSTEM_IMAGE_BAD_SIGNATURE = 637,
    ERROR_PNP_REBOOT_REQUIRED = 638,
    ERROR_INSUFFICIENT_POWER = 639,
    ERROR_MULTIPLE_FAULT_VIOLATION = 640,
    ERROR_SYSTEM_SHUTDOWN = 641,
    ERROR_PORT_NOT_SET = 642,
    ERROR_DS_VERSION_CHECK_FAILURE = 643,
    ERROR_RANGE_NOT_FOUND = 644,
    ERROR_NOT_SAFE_MODE_DRIVER = 646,
    ERROR_FAILED_DRIVER_ENTRY = 647,
    ERROR_DEVICE_ENUMERATION_ERROR = 648,
    ERROR_MOUNT_POINT_NOT_RESOLVED = 649,
    ERROR_INVALID_DEVICE_OBJECT_PARAMETER = 650,
    ERROR_MCA_OCCURED = 651,
    ERROR_DRIVER_DATABASE_ERROR = 652,
    ERROR_SYSTEM_HIVE_TOO_LARGE = 653,
    ERROR_DRIVER_FAILED_PRIOR_UNLOAD = 654,
    ERROR_VOLSNAP_PREPARE_HIBERNATE = 655,
    ERROR_HIBERNATION_FAILURE = 656,
    ERROR_PWD_TOO_LONG = 657,
    ERROR_FILE_SYSTEM_LIMITATION = 665,
    ERROR_ASSERTION_FAILURE = 668,
    ERROR_ACPI_ERROR = 669,
    ERROR_WOW_ASSERTION = 670,
    ERROR_PNP_BAD_MPS_TABLE = 671,
    ERROR_PNP_TRANSLATION_FAILED = 672,
    ERROR_PNP_IRQ_TRANSLATION_FAILED = 673,
    ERROR_PNP_INVALID_ID = 674,
    ERROR_WAKE_SYSTEM_DEBUGGER = 675,
    ERROR_HANDLES_CLOSED = 676,
    ERROR_EXTRANEOUS_INFORMATION = 677,
    ERROR_RXACT_COMMIT_NECESSARY = 678,
    ERROR_MEDIA_CHECK = 679,
    ERROR_GUID_SUBSTITUTION_MADE = 680,
    ERROR_STOPPED_ON_SYMLINK = 681,
    ERROR_LONGJUMP = 682,
    ERROR_PLUGPLAY_QUERY_VETOED = 683,
    ERROR_UNWIND_CONSOLIDATE = 684,
    ERROR_REGISTRY_HIVE_RECOVERED = 685,
    ERROR_DLL_MIGHT_BE_INSECURE = 686,
    ERROR_DLL_MIGHT_BE_INCOMPATIBLE = 687,
    ERROR_DBG_EXCEPTION_NOT_HANDLED = 688,
    ERROR_DBG_REPLY_LATER = 689,
    ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE = 690,
    ERROR_DBG_TERMINATE_THREAD = 691,
    ERROR_DBG_TERMINATE_PROCESS = 692,
    ERROR_DBG_CONTROL_C = 693,
    ERROR_DBG_PRINTEXCEPTION_C = 694,
    ERROR_DBG_RIPEXCEPTION = 695,
    ERROR_DBG_CONTROL_BREAK = 696,
    ERROR_DBG_COMMAND_EXCEPTION = 697,
    ERROR_OBJECT_NAME_EXISTS = 698,
    ERROR_THREAD_WAS_SUSPENDED = 699,
    ERROR_IMAGE_NOT_AT_BASE = 700,
    ERROR_RXACT_STATE_CREATED = 701,
    ERROR_SEGMENT_NOTIFICATION = 702,
    ERROR_BAD_CURRENT_DIRECTORY = 703,
    ERROR_FT_READ_RECOVERY_FROM_BACKUP = 704,
    ERROR_FT_WRITE_RECOVERY = 705,
    ERROR_IMAGE_MACHINE_TYPE_MISMATCH = 706,
    ERROR_RECEIVE_PARTIAL = 707,
    ERROR_RECEIVE_EXPEDITED = 708,
    ERROR_RECEIVE_PARTIAL_EXPEDITED = 709,
    ERROR_EVENT_DONE = 710,
    ERROR_EVENT_PENDING = 711,
    ERROR_CHECKING_FILE_SYSTEM = 712,
    ERROR_FATAL_APP_EXIT = 713,
    ERROR_PREDEFINED_HANDLE = 714,
    ERROR_WAS_UNLOCKED = 715,
    ERROR_SERVICE_NOTIFICATION = 716,
    ERROR_WAS_LOCKED = 717,
    ERROR_LOG_HARD_ERROR = 718,
    ERROR_ALREADY_WIN32 = 719,
    ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE = 720,
    ERROR_NO_YIELD_PERFORMED = 721,
    ERROR_TIMER_RESUME_IGNORED = 722,
    ERROR_ARBITRATION_UNHANDLED = 723,
    ERROR_CARDBUS_NOT_SUPPORTED = 724,
    ERROR_MP_PROCESSOR_MISMATCH = 725,
    ERROR_HIBERNATED = 726,
    ERROR_RESUME_HIBERNATION = 727,
    ERROR_FIRMWARE_UPDATED = 728,
    ERROR_DRIVERS_LEAKING_LOCKED_PAGES = 729,
    ERROR_WAKE_SYSTEM = 730,
    ERROR_WAIT_1 = 731,
    ERROR_WAIT_2 = 732,
    ERROR_WAIT_3 = 733,
    ERROR_WAIT_63 = 734,
    ERROR_ABANDONED_WAIT_0 = 735,
    ERROR_ABANDONED_WAIT_63 = 736,
    ERROR_USER_APC = 737,
    ERROR_KERNEL_APC = 738,
    ERROR_ALERTED = 739,
    ERROR_ELEVATION_REQUIRED = 740,
    ERROR_REPARSE = 741,
    ERROR_OPLOCK_BREAK_IN_PROGRESS = 742,
    ERROR_VOLUME_MOUNTED = 743,
    ERROR_RXACT_COMMITTED = 744,
    ERROR_NOTIFY_CLEANUP = 745,
    ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED = 746,
    ERROR_PAGE_FAULT_TRANSITION = 747,
    ERROR_PAGE_FAULT_DEMAND_ZERO = 748,
    ERROR_PAGE_FAULT_COPY_ON_WRITE = 749,
    ERROR_PAGE_FAULT_GUARD_PAGE = 750,
    ERROR_PAGE_FAULT_PAGING_FILE = 751,
    ERROR_CACHE_PAGE_LOCKED = 752,
    ERROR_CRASH_DUMP = 753,
    ERROR_BUFFER_ALL_ZEROS = 754,
    ERROR_REPARSE_OBJECT = 755,
    ERROR_RESOURCE_REQUIREMENTS_CHANGED = 756,
    ERROR_TRANSLATION_COMPLETE = 757,
    ERROR_NOTHING_TO_TERMINATE = 758,
    ERROR_PROCESS_NOT_IN_JOB = 759,
    ERROR_PROCESS_IN_JOB = 760,
    ERROR_VOLSNAP_HIBERNATE_READY = 761,
    ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY = 762,
    ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED = 763,
    ERROR_INTERRUPT_STILL_CONNECTED = 764,
    ERROR_WAIT_FOR_OPLOCK = 765,
    ERROR_DBG_EXCEPTION_HANDLED = 766,
    ERROR_DBG_CONTINUE = 767,
    ERROR_CALLBACK_POP_STACK = 768,
    ERROR_COMPRESSION_DISABLED = 769,
    ERROR_CANTFETCHBACKWARDS = 770,
    ERROR_CANTSCROLLBACKWARDS = 771,
    ERROR_ROWSNOTRELEASED = 772,
    ERROR_BAD_ACCESSOR_FLAGS = 773,
    ERROR_ERRORS_ENCOUNTERED = 774,
    ERROR_NOT_CAPABLE = 775,
    ERROR_REQUEST_OUT_OF_SEQUENCE = 776,
    ERROR_VERSION_PARSE_ERROR = 777,
    ERROR_BADSTARTPOSITION = 778,
    ERROR_MEMORY_HARDWARE = 779,
    ERROR_DISK_REPAIR_DISABLED = 780,
    ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = 781,
    ERROR_SYSTEM_POWERSTATE_TRANSITION = 782,
    ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = 783,
    ERROR_MCA_EXCEPTION = 784,
    ERROR_ACCESS_AUDIT_BY_POLICY = 785,
    ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = 786,
    ERROR_ABANDON_HIBERFILE = 787,
    ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = 788,
    ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = 789,
    ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = 790,
    ERROR_BAD_MCFG_TABLE = 791,
    ERROR_DISK_REPAIR_REDIRECTED = 792,
    ERROR_DISK_REPAIR_UNSUCCESSFUL = 793,
    ERROR_CORRUPT_LOG_OVERFULL = 794,
    ERROR_CORRUPT_LOG_CORRUPTED = 795,
    ERROR_CORRUPT_LOG_UNAVAILABLE = 796,
    ERROR_CORRUPT_LOG_DELETED_FULL = 797,
    ERROR_CORRUPT_LOG_CLEARED = 798,
    ERROR_ORPHAN_NAME_EXHAUSTED = 799,
    ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE = 800,
    ERROR_CANNOT_GRANT_REQUESTED_OPLOCK = 801,
    ERROR_CANNOT_BREAK_OPLOCK = 802,
    ERROR_OPLOCK_HANDLE_CLOSED = 803,
    ERROR_NO_ACE_CONDITION = 804,
    ERROR_INVALID_ACE_CONDITION = 805,
    ERROR_FILE_HANDLE_REVOKED = 806,
    ERROR_IMAGE_AT_DIFFERENT_BASE = 807,
    ERROR_ENCRYPTED_IO_NOT_POSSIBLE = 808,
    ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS = 809,
    ERROR_QUOTA_ACTIVITY = 810,
    ERROR_HANDLE_REVOKED = 811,
    ERROR_CALLBACK_INVOKE_INLINE = 812,
    ERROR_CPU_SET_INVALID = 813,
    ERROR_ENCLAVE_NOT_TERMINATED = 814,
    ERROR_ENCLAVE_VIOLATION = 815,
    ERROR_EA_ACCESS_DENIED = 994,
    ERROR_OPERATION_ABORTED = 995,
    ERROR_IO_INCOMPLETE = 996,
    ERROR_IO_PENDING = 997,
    ERROR_NOACCESS = 998,
    ERROR_SWAPERROR = 999,
    ERROR_STACK_OVERFLOW = 1001,
    ERROR_INVALID_MESSAGE = 1002,
    ERROR_CAN_NOT_COMPLETE = 1003,
    ERROR_INVALID_FLAGS = 1004,
    ERROR_UNRECOGNIZED_VOLUME = 1005,
    ERROR_FILE_INVALID = 1006,
    ERROR_FULLSCREEN_MODE = 1007,
    ERROR_NO_TOKEN = 1008,
    ERROR_BADDB = 1009,
    ERROR_BADKEY = 1010,
    ERROR_CANTOPEN = 1011,
    ERROR_CANTREAD = 1012,
    ERROR_CANTWRITE = 1013,
    ERROR_REGISTRY_RECOVERED = 1014,
    ERROR_REGISTRY_CORRUPT = 1015,
    ERROR_REGISTRY_IO_FAILED = 1016,
    ERROR_NOT_REGISTRY_FILE = 1017,
    ERROR_KEY_DELETED = 1018,
    ERROR_NO_LOG_SPACE = 1019,
    ERROR_KEY_HAS_CHILDREN = 1020,
    ERROR_CHILD_MUST_BE_VOLATILE = 1021,
    ERROR_NOTIFY_ENUM_DIR = 1022,
    ERROR_DEPENDENT_SERVICES_RUNNING = 1051,
    ERROR_INVALID_SERVICE_CONTROL = 1052,
    ERROR_SERVICE_REQUEST_TIMEOUT = 1053,
    ERROR_SERVICE_NO_THREAD = 1054,
    ERROR_SERVICE_DATABASE_LOCKED = 1055,
    ERROR_SERVICE_ALREADY_RUNNING = 1056,
    ERROR_INVALID_SERVICE_ACCOUNT = 1057,
    ERROR_SERVICE_DISABLED = 1058,
    ERROR_CIRCULAR_DEPENDENCY = 1059,
    ERROR_SERVICE_DOES_NOT_EXIST = 1060,
    ERROR_SERVICE_CANNOT_ACCEPT_CTRL = 1061,
    ERROR_SERVICE_NOT_ACTIVE = 1062,
    ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = 1063,
    ERROR_EXCEPTION_IN_SERVICE = 1064,
    ERROR_DATABASE_DOES_NOT_EXIST = 1065,
    ERROR_SERVICE_SPECIFIC_ERROR = 1066,
    ERROR_PROCESS_ABORTED = 1067,
    ERROR_SERVICE_DEPENDENCY_FAIL = 1068,
    ERROR_SERVICE_LOGON_FAILED = 1069,
    ERROR_SERVICE_START_HANG = 1070,
    ERROR_INVALID_SERVICE_LOCK = 1071,
    ERROR_SERVICE_MARKED_FOR_DELETE = 1072,
    ERROR_SERVICE_EXISTS = 1073,
    ERROR_ALREADY_RUNNING_LKG = 1074,
    ERROR_SERVICE_DEPENDENCY_DELETED = 1075,
    ERROR_BOOT_ALREADY_ACCEPTED = 1076,
    ERROR_SERVICE_NEVER_STARTED = 1077,
    ERROR_DUPLICATE_SERVICE_NAME = 1078,
    ERROR_DIFFERENT_SERVICE_ACCOUNT = 1079,
    ERROR_CANNOT_DETECT_DRIVER_FAILURE = 1080,
    ERROR_CANNOT_DETECT_PROCESS_ABORT = 1081,
    ERROR_NO_RECOVERY_PROGRAM = 1082,
    ERROR_SERVICE_NOT_IN_EXE = 1083,
    ERROR_NOT_SAFEBOOT_SERVICE = 1084,
    ERROR_END_OF_MEDIA = 1100,
    ERROR_FILEMARK_DETECTED = 1101,
    ERROR_BEGINNING_OF_MEDIA = 1102,
    ERROR_SETMARK_DETECTED = 1103,
    ERROR_NO_DATA_DETECTED = 1104,
    ERROR_PARTITION_FAILURE = 1105,
    ERROR_INVALID_BLOCK_LENGTH = 1106,
    ERROR_DEVICE_NOT_PARTITIONED = 1107,
    ERROR_UNABLE_TO_LOCK_MEDIA = 1108,
    ERROR_UNABLE_TO_UNLOAD_MEDIA = 1109,
    ERROR_MEDIA_CHANGED = 1110,
    ERROR_BUS_RESET = 1111,
    ERROR_NO_MEDIA_IN_DRIVE = 1112,
    ERROR_NO_UNICODE_TRANSLATION = 1113,
    ERROR_DLL_INIT_FAILED = 1114,
    ERROR_SHUTDOWN_IN_PROGRESS = 1115,
    ERROR_NO_SHUTDOWN_IN_PROGRESS = 1116,
    ERROR_IO_DEVICE = 1117,
    ERROR_SERIAL_NO_DEVICE = 1118,
    ERROR_IRQ_BUSY = 1119,
    ERROR_MORE_WRITES = 1120,
    ERROR_COUNTER_TIMEOUT = 1121,
    ERROR_FLOPPY_ID_MARK_NOT_FOUND = 1122,
    ERROR_FLOPPY_WRONG_CYLINDER = 1123,
    ERROR_FLOPPY_UNKNOWN_ERROR = 1124,
    ERROR_FLOPPY_BAD_REGISTERS = 1125,
    ERROR_DISK_RECALIBRATE_FAILED = 1126,
    ERROR_DISK_OPERATION_FAILED = 1127,
    ERROR_DISK_RESET_FAILED = 1128,
    ERROR_EOM_OVERFLOW = 1129,
    ERROR_NOT_ENOUGH_SERVER_MEMORY = 1130,
    ERROR_POSSIBLE_DEADLOCK = 1131,
    ERROR_MAPPED_ALIGNMENT = 1132,
    ERROR_SET_POWER_STATE_VETOED = 1140,
    ERROR_SET_POWER_STATE_FAILED = 1141,
    ERROR_TOO_MANY_LINKS = 1142,
    ERROR_OLD_WIN_VERSION = 1150,
    ERROR_APP_WRONG_OS = 1151,
    ERROR_SINGLE_INSTANCE_APP = 1152,
    ERROR_RMODE_APP = 1153,
    ERROR_INVALID_DLL = 1154,
    ERROR_NO_ASSOCIATION = 1155,
    ERROR_DDE_FAIL = 1156,
    ERROR_DLL_NOT_FOUND = 1157,
    ERROR_NO_MORE_USER_HANDLES = 1158,
    ERROR_MESSAGE_SYNC_ONLY = 1159,
    ERROR_SOURCE_ELEMENT_EMPTY = 1160,
    ERROR_DESTINATION_ELEMENT_FULL = 1161,
    ERROR_ILLEGAL_ELEMENT_ADDRESS = 1162,
    ERROR_MAGAZINE_NOT_PRESENT = 1163,
    ERROR_DEVICE_REINITIALIZATION_NEEDED = 1164,
    ERROR_DEVICE_REQUIRES_CLEANING = 1165,
    ERROR_DEVICE_DOOR_OPEN = 1166,
    ERROR_DEVICE_NOT_CONNECTED = 1167,
    ERROR_NOT_FOUND = 1168,
    ERROR_NO_MATCH = 1169,
    ERROR_SET_NOT_FOUND = 1170,
    ERROR_POINT_NOT_FOUND = 1171,
    ERROR_NO_TRACKING_SERVICE = 1172,
    ERROR_NO_VOLUME_ID = 1173,
    ERROR_UNABLE_TO_REMOVE_REPLACED = 1175,
    ERROR_UNABLE_TO_MOVE_REPLACEMENT = 1176,
    ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 = 1177,
    ERROR_JOURNAL_DELETE_IN_PROGRESS = 1178,
    ERROR_JOURNAL_NOT_ACTIVE = 1179,
    ERROR_POTENTIAL_FILE_FOUND = 1180,
    ERROR_JOURNAL_ENTRY_DELETED = 1181,
    ERROR_SHUTDOWN_IS_SCHEDULED = 1190,
    ERROR_SHUTDOWN_USERS_LOGGED_ON = 1191,
    ERROR_BAD_DEVICE = 1200,
    ERROR_CONNECTION_UNAVAIL = 1201,
    ERROR_DEVICE_ALREADY_REMEMBERED = 1202,
    ERROR_NO_NET_OR_BAD_PATH = 1203,
    ERROR_BAD_PROVIDER = 1204,
    ERROR_CANNOT_OPEN_PROFILE = 1205,
    ERROR_BAD_PROFILE = 1206,
    ERROR_NOT_CONTAINER = 1207,
    ERROR_EXTENDED_ERROR = 1208,
    ERROR_INVALID_GROUPNAME = 1209,
    ERROR_INVALID_COMPUTERNAME = 1210,
    ERROR_INVALID_EVENTNAME = 1211,
    ERROR_INVALID_DOMAINNAME = 1212,
    ERROR_INVALID_SERVICENAME = 1213,
    ERROR_INVALID_NETNAME = 1214,
    ERROR_INVALID_SHARENAME = 1215,
    ERROR_INVALID_PASSWORDNAME = 1216,
    ERROR_INVALID_MESSAGENAME = 1217,
    ERROR_INVALID_MESSAGEDEST = 1218,
    ERROR_SESSION_CREDENTIAL_CONFLICT = 1219,
    ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = 1220,
    ERROR_DUP_DOMAINNAME = 1221,
    ERROR_NO_NETWORK = 1222,
    ERROR_CANCELLED = 1223,
    ERROR_USER_MAPPED_FILE = 1224,
    ERROR_CONNECTION_REFUSED = 1225,
    ERROR_GRACEFUL_DISCONNECT = 1226,
    ERROR_ADDRESS_ALREADY_ASSOCIATED = 1227,
    ERROR_ADDRESS_NOT_ASSOCIATED = 1228,
    ERROR_CONNECTION_INVALID = 1229,
    ERROR_CONNECTION_ACTIVE = 1230,
    ERROR_NETWORK_UNREACHABLE = 1231,
    ERROR_HOST_UNREACHABLE = 1232,
    ERROR_PROTOCOL_UNREACHABLE = 1233,
    ERROR_PORT_UNREACHABLE = 1234,
    ERROR_REQUEST_ABORTED = 1235,
    ERROR_CONNECTION_ABORTED = 1236,
    ERROR_RETRY = 1237,
    ERROR_CONNECTION_COUNT_LIMIT = 1238,
    ERROR_LOGIN_TIME_RESTRICTION = 1239,
    ERROR_LOGIN_WKSTA_RESTRICTION = 1240,
    ERROR_INCORRECT_ADDRESS = 1241,
    ERROR_ALREADY_REGISTERED = 1242,
    ERROR_SERVICE_NOT_FOUND = 1243,
    ERROR_NOT_AUTHENTICATED = 1244,
    ERROR_NOT_LOGGED_ON = 1245,
    ERROR_CONTINUE = 1246,
    ERROR_ALREADY_INITIALIZED = 1247,
    ERROR_NO_MORE_DEVICES = 1248,
    ERROR_NO_SUCH_SITE = 1249,
    ERROR_DOMAIN_CONTROLLER_EXISTS = 1250,
    ERROR_ONLY_IF_CONNECTED = 1251,
    ERROR_OVERRIDE_NOCHANGES = 1252,
    ERROR_BAD_USER_PROFILE = 1253,
    ERROR_NOT_SUPPORTED_ON_SBS = 1254,
    ERROR_SERVER_SHUTDOWN_IN_PROGRESS = 1255,
    ERROR_HOST_DOWN = 1256,
    ERROR_NON_ACCOUNT_SID = 1257,
    ERROR_NON_DOMAIN_SID = 1258,
    ERROR_APPHELP_BLOCK = 1259,
    ERROR_ACCESS_DISABLED_BY_POLICY = 1260,
    ERROR_REG_NAT_CONSUMPTION = 1261,
    ERROR_CSCSHARE_OFFLINE = 1262,
    ERROR_PKINIT_FAILURE = 1263,
    ERROR_SMARTCARD_SUBSYSTEM_FAILURE = 1264,
    ERROR_DOWNGRADE_DETECTED = 1265,
    ERROR_MACHINE_LOCKED = 1271,
    ERROR_SMB_GUEST_LOGON_BLOCKED = 1272,
    ERROR_CALLBACK_SUPPLIED_INVALID_DATA = 1273,
    ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED = 1274,
    ERROR_DRIVER_BLOCKED = 1275,
    ERROR_INVALID_IMPORT_OF_NON_DLL = 1276,
    ERROR_ACCESS_DISABLED_WEBBLADE = 1277,
    ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER = 1278,
    ERROR_RECOVERY_FAILURE = 1279,
    ERROR_ALREADY_FIBER = 1280,
    ERROR_ALREADY_THREAD = 1281,
    ERROR_STACK_BUFFER_OVERRUN = 1282,
    ERROR_PARAMETER_QUOTA_EXCEEDED = 1283,
    ERROR_DEBUGGER_INACTIVE = 1284,
    ERROR_DELAY_LOAD_FAILED = 1285,
    ERROR_VDM_DISALLOWED = 1286,
    ERROR_UNIDENTIFIED_ERROR = 1287,
    ERROR_INVALID_CRUNTIME_PARAMETER = 1288,
    ERROR_BEYOND_VDL = 1289,
    ERROR_INCOMPATIBLE_SERVICE_SID_TYPE = 1290,
    ERROR_DRIVER_PROCESS_TERMINATED = 1291,
    ERROR_IMPLEMENTATION_LIMIT = 1292,
    ERROR_PROCESS_IS_PROTECTED = 1293,
    ERROR_SERVICE_NOTIFY_CLIENT_LAGGING = 1294,
    ERROR_DISK_QUOTA_EXCEEDED = 1295,
    ERROR_CONTENT_BLOCKED = 1296,
    ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE = 1297,
    ERROR_APP_HANG = 1298,
    ERROR_INVALID_LABEL = 1299,
    ERROR_NOT_ALL_ASSIGNED = 1300,
    ERROR_SOME_NOT_MAPPED = 1301,
    ERROR_NO_QUOTAS_FOR_ACCOUNT = 1302,
    ERROR_LOCAL_USER_SESSION_KEY = 1303,
    ERROR_NULL_LM_PASSWORD = 1304,
    ERROR_UNKNOWN_REVISION = 1305,
    ERROR_REVISION_MISMATCH = 1306,
    ERROR_INVALID_OWNER = 1307,
    ERROR_INVALID_PRIMARY_GROUP = 1308,
    ERROR_NO_IMPERSONATION_TOKEN = 1309,
    ERROR_CANT_DISABLE_MANDATORY = 1310,
    ERROR_NO_LOGON_SERVERS = 1311,
    ERROR_NO_SUCH_LOGON_SESSION = 1312,
    ERROR_NO_SUCH_PRIVILEGE = 1313,
    ERROR_PRIVILEGE_NOT_HELD = 1314,
    ERROR_INVALID_ACCOUNT_NAME = 1315,
    ERROR_USER_EXISTS = 1316,
    ERROR_NO_SUCH_USER = 1317,
    ERROR_GROUP_EXISTS = 1318,
    ERROR_NO_SUCH_GROUP = 1319,
    ERROR_MEMBER_IN_GROUP = 1320,
    ERROR_MEMBER_NOT_IN_GROUP = 1321,
    ERROR_LAST_ADMIN = 1322,
    ERROR_WRONG_PASSWORD = 1323,
    ERROR_ILL_FORMED_PASSWORD = 1324,
    ERROR_PASSWORD_RESTRICTION = 1325,
    ERROR_LOGON_FAILURE = 1326,
    ERROR_ACCOUNT_RESTRICTION = 1327,
    ERROR_INVALID_LOGON_HOURS = 1328,
    ERROR_INVALID_WORKSTATION = 1329,
    ERROR_PASSWORD_EXPIRED = 1330,
    ERROR_ACCOUNT_DISABLED = 1331,
    ERROR_NONE_MAPPED = 1332,
    ERROR_TOO_MANY_LUIDS_REQUESTED = 1333,
    ERROR_LUIDS_EXHAUSTED = 1334,
    ERROR_INVALID_SUB_AUTHORITY = 1335,
    ERROR_INVALID_ACL = 1336,
    ERROR_INVALID_SID = 1337,
    ERROR_INVALID_SECURITY_DESCR = 1338,
    ERROR_BAD_INHERITANCE_ACL = 1340,
    ERROR_SERVER_DISABLED = 1341,
    ERROR_SERVER_NOT_DISABLED = 1342,
    ERROR_INVALID_ID_AUTHORITY = 1343,
    ERROR_ALLOTTED_SPACE_EXCEEDED = 1344,
    ERROR_INVALID_GROUP_ATTRIBUTES = 1345,
    ERROR_BAD_IMPERSONATION_LEVEL = 1346,
    ERROR_CANT_OPEN_ANONYMOUS = 1347,
    ERROR_BAD_VALIDATION_CLASS = 1348,
    ERROR_BAD_TOKEN_TYPE = 1349,
    ERROR_NO_SECURITY_ON_OBJECT = 1350,
    ERROR_CANT_ACCESS_DOMAIN_INFO = 1351,
    ERROR_INVALID_SERVER_STATE = 1352,
    ERROR_INVALID_DOMAIN_STATE = 1353,
    ERROR_INVALID_DOMAIN_ROLE = 1354,
    ERROR_NO_SUCH_DOMAIN = 1355,
    ERROR_DOMAIN_EXISTS = 1356,
    ERROR_DOMAIN_LIMIT_EXCEEDED = 1357,
    ERROR_INTERNAL_DB_CORRUPTION = 1358,
    ERROR_INTERNAL_ERROR = 1359,
    ERROR_GENERIC_NOT_MAPPED = 1360,
    ERROR_BAD_DESCRIPTOR_FORMAT = 1361,
    ERROR_NOT_LOGON_PROCESS = 1362,
    ERROR_LOGON_SESSION_EXISTS = 1363,
    ERROR_NO_SUCH_PACKAGE = 1364,
    ERROR_BAD_LOGON_SESSION_STATE = 1365,
    ERROR_LOGON_SESSION_COLLISION = 1366,
    ERROR_INVALID_LOGON_TYPE = 1367,
    ERROR_CANNOT_IMPERSONATE = 1368,
    ERROR_RXACT_INVALID_STATE = 1369,
    ERROR_RXACT_COMMIT_FAILURE = 1370,
    ERROR_SPECIAL_ACCOUNT = 1371,
    ERROR_SPECIAL_GROUP = 1372,
    ERROR_SPECIAL_USER = 1373,
    ERROR_MEMBERS_PRIMARY_GROUP = 1374,
    ERROR_TOKEN_ALREADY_IN_USE = 1375,
    ERROR_NO_SUCH_ALIAS = 1376,
    ERROR_MEMBER_NOT_IN_ALIAS = 1377,
    ERROR_MEMBER_IN_ALIAS = 1378,
    ERROR_ALIAS_EXISTS = 1379,
    ERROR_LOGON_NOT_GRANTED = 1380,
    ERROR_TOO_MANY_SECRETS = 1381,
    ERROR_SECRET_TOO_LONG = 1382,
    ERROR_INTERNAL_DB_ERROR = 1383,
    ERROR_TOO_MANY_CONTEXT_IDS = 1384,
    ERROR_LOGON_TYPE_NOT_GRANTED = 1385,
    ERROR_NT_CROSS_ENCRYPTION_REQUIRED = 1386,
    ERROR_NO_SUCH_MEMBER = 1387,
    ERROR_INVALID_MEMBER = 1388,
    ERROR_TOO_MANY_SIDS = 1389,
    ERROR_LM_CROSS_ENCRYPTION_REQUIRED = 1390,
    ERROR_NO_INHERITANCE = 1391,
    ERROR_FILE_CORRUPT = 1392,
    ERROR_DISK_CORRUPT = 1393,
    ERROR_NO_USER_SESSION_KEY = 1394,
    ERROR_LICENSE_QUOTA_EXCEEDED = 1395,
    ERROR_WRONG_TARGET_NAME = 1396,
    ERROR_MUTUAL_AUTH_FAILED = 1397,
    ERROR_TIME_SKEW = 1398,
    ERROR_CURRENT_DOMAIN_NOT_ALLOWED = 1399,
    ERROR_INVALID_WINDOW_HANDLE = 1400,
    ERROR_INVALID_MENU_HANDLE = 1401,
    ERROR_INVALID_CURSOR_HANDLE = 1402,
    ERROR_INVALID_ACCEL_HANDLE = 1403,
    ERROR_INVALID_HOOK_HANDLE = 1404,
    ERROR_INVALID_DWP_HANDLE = 1405,
    ERROR_TLW_WITH_WSCHILD = 1406,
    ERROR_CANNOT_FIND_WND_CLASS = 1407,
    ERROR_WINDOW_OF_OTHER_THREAD = 1408,
    ERROR_HOTKEY_ALREADY_REGISTERED = 1409,
    ERROR_CLASS_ALREADY_EXISTS = 1410,
    ERROR_CLASS_DOES_NOT_EXIST = 1411,
    ERROR_CLASS_HAS_WINDOWS = 1412,
    ERROR_INVALID_INDEX = 1413,
    ERROR_INVALID_ICON_HANDLE = 1414,
    ERROR_PRIVATE_DIALOG_INDEX = 1415,
    ERROR_LISTBOX_ID_NOT_FOUND = 1416,
    ERROR_NO_WILDCARD_CHARACTERS = 1417,
    ERROR_CLIPBOARD_NOT_OPEN = 1418,
    ERROR_HOTKEY_NOT_REGISTERED = 1419,
    ERROR_WINDOW_NOT_DIALOG = 1420,
    ERROR_CONTROL_ID_NOT_FOUND = 1421,
    ERROR_INVALID_COMBOBOX_MESSAGE = 1422,
    ERROR_WINDOW_NOT_COMBOBOX = 1423,
    ERROR_INVALID_EDIT_HEIGHT = 1424,
    ERROR_DC_NOT_FOUND = 1425,
    ERROR_INVALID_HOOK_FILTER = 1426,
    ERROR_INVALID_FILTER_PROC = 1427,
    ERROR_HOOK_NEEDS_HMOD = 1428,
    ERROR_GLOBAL_ONLY_HOOK = 1429,
    ERROR_JOURNAL_HOOK_SET = 1430,
    ERROR_HOOK_NOT_INSTALLED = 1431,
    ERROR_INVALID_LB_MESSAGE = 1432,
    ERROR_SETCOUNT_ON_BAD_LB = 1433,
    ERROR_LB_WITHOUT_TABSTOPS = 1434,
    ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = 1435,
    ERROR_CHILD_WINDOW_MENU = 1436,
    ERROR_NO_SYSTEM_MENU = 1437,
    ERROR_INVALID_MSGBOX_STYLE = 1438,
    ERROR_INVALID_SPI_VALUE = 1439,
    ERROR_SCREEN_ALREADY_LOCKED = 1440,
    ERROR_HWNDS_HAVE_DIFF_PARENT = 1441,
    ERROR_NOT_CHILD_WINDOW = 1442,
    ERROR_INVALID_GW_COMMAND = 1443,
    ERROR_INVALID_THREAD_ID = 1444,
    ERROR_NON_MDICHILD_WINDOW = 1445,
    ERROR_POPUP_ALREADY_ACTIVE = 1446,
    ERROR_NO_SCROLLBARS = 1447,
    ERROR_INVALID_SCROLLBAR_RANGE = 1448,
    ERROR_INVALID_SHOWWIN_COMMAND = 1449,
    ERROR_NO_SYSTEM_RESOURCES = 1450,
    ERROR_NONPAGED_SYSTEM_RESOURCES = 1451,
    ERROR_PAGED_SYSTEM_RESOURCES = 1452,
    ERROR_WORKING_SET_QUOTA = 1453,
    ERROR_PAGEFILE_QUOTA = 1454,
    ERROR_COMMITMENT_LIMIT = 1455,
    ERROR_MENU_ITEM_NOT_FOUND = 1456,
    ERROR_INVALID_KEYBOARD_HANDLE = 1457,
    ERROR_HOOK_TYPE_NOT_ALLOWED = 1458,
    ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = 1459,
    ERROR_TIMEOUT = 1460,
    ERROR_INVALID_MONITOR_HANDLE = 1461,
    ERROR_INCORRECT_SIZE = 1462,
    ERROR_SYMLINK_CLASS_DISABLED = 1463,
    ERROR_SYMLINK_NOT_SUPPORTED = 1464,
    ERROR_XML_PARSE_ERROR = 1465,
    ERROR_XMLDSIG_ERROR = 1466,
    ERROR_RESTART_APPLICATION = 1467,
    ERROR_WRONG_COMPARTMENT = 1468,
    ERROR_AUTHIP_FAILURE = 1469,
    ERROR_NO_NVRAM_RESOURCES = 1470,
    ERROR_NOT_GUI_PROCESS = 1471,
    ERROR_EVENTLOG_FILE_CORRUPT = 1500,
    ERROR_EVENTLOG_CANT_START = 1501,
    ERROR_LOG_FILE_FULL = 1502,
    ERROR_EVENTLOG_FILE_CHANGED = 1503,
    ERROR_CONTAINER_ASSIGNED = 1504,
    ERROR_JOB_NO_CONTAINER = 1505,
    ERROR_INVALID_TASK_NAME = 1550,
    ERROR_INVALID_TASK_INDEX = 1551,
    ERROR_THREAD_ALREADY_IN_TASK = 1552,
    ERROR_INSTALL_SERVICE_FAILURE = 1601,
    ERROR_INSTALL_USEREXIT = 1602,
    ERROR_INSTALL_FAILURE = 1603,
    ERROR_INSTALL_SUSPEND = 1604,
    ERROR_UNKNOWN_PRODUCT = 1605,
    ERROR_UNKNOWN_FEATURE = 1606,
    ERROR_UNKNOWN_COMPONENT = 1607,
    ERROR_UNKNOWN_PROPERTY = 1608,
    ERROR_INVALID_HANDLE_STATE = 1609,
    ERROR_BAD_CONFIGURATION = 1610,
    ERROR_INDEX_ABSENT = 1611,
    ERROR_INSTALL_SOURCE_ABSENT = 1612,
    ERROR_INSTALL_PACKAGE_VERSION = 1613,
    ERROR_PRODUCT_UNINSTALLED = 1614,
    ERROR_BAD_QUERY_SYNTAX = 1615,
    ERROR_INVALID_FIELD = 1616,
    ERROR_DEVICE_REMOVED = 1617,
    ERROR_INSTALL_ALREADY_RUNNING = 1618,
    ERROR_INSTALL_PACKAGE_OPEN_FAILED = 1619,
    ERROR_INSTALL_PACKAGE_INVALID = 1620,
    ERROR_INSTALL_UI_FAILURE = 1621,
    ERROR_INSTALL_LOG_FAILURE = 1622,
    ERROR_INSTALL_LANGUAGE_UNSUPPORTED = 1623,
    ERROR_INSTALL_TRANSFORM_FAILURE = 1624,
    ERROR_INSTALL_PACKAGE_REJECTED = 1625,
    ERROR_FUNCTION_NOT_CALLED = 1626,
    ERROR_FUNCTION_FAILED = 1627,
    ERROR_INVALID_TABLE = 1628,
    ERROR_DATATYPE_MISMATCH = 1629,
    ERROR_UNSUPPORTED_TYPE = 1630,
    ERROR_CREATE_FAILED = 1631,
    ERROR_INSTALL_TEMP_UNWRITABLE = 1632,
    ERROR_INSTALL_PLATFORM_UNSUPPORTED = 1633,
    ERROR_INSTALL_NOTUSED = 1634,
    ERROR_PATCH_PACKAGE_OPEN_FAILED = 1635,
    ERROR_PATCH_PACKAGE_INVALID = 1636,
    ERROR_PATCH_PACKAGE_UNSUPPORTED = 1637,
    ERROR_PRODUCT_VERSION = 1638,
    ERROR_INVALID_COMMAND_LINE = 1639,
    ERROR_INSTALL_REMOTE_DISALLOWED = 1640,
    ERROR_SUCCESS_REBOOT_INITIATED = 1641,
    ERROR_PATCH_TARGET_NOT_FOUND = 1642,
    ERROR_PATCH_PACKAGE_REJECTED = 1643,
    ERROR_INSTALL_TRANSFORM_REJECTED = 1644,
    ERROR_INSTALL_REMOTE_PROHIBITED = 1645,
    ERROR_PATCH_REMOVAL_UNSUPPORTED = 1646,
    ERROR_UNKNOWN_PATCH = 1647,
    ERROR_PATCH_NO_SEQUENCE = 1648,
    ERROR_PATCH_REMOVAL_DISALLOWED = 1649,
    ERROR_INVALID_PATCH_XML = 1650,
    ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT = 1651,
    ERROR_INSTALL_SERVICE_SAFEBOOT = 1652,
    ERROR_FAIL_FAST_EXCEPTION = 1653,
    ERROR_INSTALL_REJECTED = 1654,
    ERROR_DYNAMIC_CODE_BLOCKED = 1655,
    ERROR_NOT_SAME_OBJECT = 1656,
    ERROR_STRICT_CFG_VIOLATION = 1657,
    ERROR_SET_CONTEXT_DENIED = 1660,
    ERROR_CROSS_PARTITION_VIOLATION = 1661,
    ERROR_RETURN_ADDRESS_HIJACK_ATTEMPT = 1662,
    ERROR_INVALID_USER_BUFFER = 1784,
    ERROR_UNRECOGNIZED_MEDIA = 1785,
    ERROR_NO_TRUST_LSA_SECRET = 1786,
    ERROR_NO_TRUST_SAM_ACCOUNT = 1787,
    ERROR_TRUSTED_DOMAIN_FAILURE = 1788,
    ERROR_TRUSTED_RELATIONSHIP_FAILURE = 1789,
    ERROR_TRUST_FAILURE = 1790,
    ERROR_NETLOGON_NOT_STARTED = 1792,
    ERROR_ACCOUNT_EXPIRED = 1793,
    ERROR_REDIRECTOR_HAS_OPEN_HANDLES = 1794,
    ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = 1795,
    ERROR_UNKNOWN_PORT = 1796,
    ERROR_UNKNOWN_PRINTER_DRIVER = 1797,
    ERROR_UNKNOWN_PRINTPROCESSOR = 1798,
    ERROR_INVALID_SEPARATOR_FILE = 1799,
    ERROR_INVALID_PRIORITY = 1800,
    ERROR_INVALID_PRINTER_NAME = 1801,
    ERROR_PRINTER_ALREADY_EXISTS = 1802,
    ERROR_INVALID_PRINTER_COMMAND = 1803,
    ERROR_INVALID_DATATYPE = 1804,
    ERROR_INVALID_ENVIRONMENT = 1805,
    ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = 1807,
    ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = 1808,
    ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = 1809,
    ERROR_DOMAIN_TRUST_INCONSISTENT = 1810,
    ERROR_SERVER_HAS_OPEN_HANDLES = 1811,
    ERROR_RESOURCE_DATA_NOT_FOUND = 1812,
    ERROR_RESOURCE_TYPE_NOT_FOUND = 1813,
    ERROR_RESOURCE_NAME_NOT_FOUND = 1814,
    ERROR_RESOURCE_LANG_NOT_FOUND = 1815,
    ERROR_NOT_ENOUGH_QUOTA = 1816,
    ERROR_INVALID_TIME = 1901,
    ERROR_INVALID_FORM_NAME = 1902,
    ERROR_INVALID_FORM_SIZE = 1903,
    ERROR_ALREADY_WAITING = 1904,
    ERROR_PRINTER_DELETED = 1905,
    ERROR_INVALID_PRINTER_STATE = 1906,
    ERROR_PASSWORD_MUST_CHANGE = 1907,
    ERROR_DOMAIN_CONTROLLER_NOT_FOUND = 1908,
    ERROR_ACCOUNT_LOCKED_OUT = 1909,
    ERROR_NO_SITENAME = 1919,
    ERROR_CANT_ACCESS_FILE = 1920,
    ERROR_CANT_RESOLVE_FILENAME = 1921,
    ERROR_KM_DRIVER_BLOCKED = 1930,
    ERROR_CONTEXT_EXPIRED = 1931,
    ERROR_PER_USER_TRUST_QUOTA_EXCEEDED = 1932,
    ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED = 1933,
    ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED = 1934,
    ERROR_AUTHENTICATION_FIREWALL_FAILED = 1935,
    ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED = 1936,
    ERROR_NTLM_BLOCKED = 1937,
    ERROR_PASSWORD_CHANGE_REQUIRED = 1938,
    ERROR_LOST_MODE_LOGON_RESTRICTION = 1939,
    ERROR_INVALID_PIXEL_FORMAT = 2000,
    ERROR_BAD_DRIVER = 2001,
    ERROR_INVALID_WINDOW_STYLE = 2002,
    ERROR_METAFILE_NOT_SUPPORTED = 2003,
    ERROR_TRANSFORM_NOT_SUPPORTED = 2004,
    ERROR_CLIPPING_NOT_SUPPORTED = 2005,
    ERROR_INVALID_CMM = 2010,
    ERROR_INVALID_PROFILE = 2011,
    ERROR_TAG_NOT_FOUND = 2012,
    ERROR_TAG_NOT_PRESENT = 2013,
    ERROR_DUPLICATE_TAG = 2014,
    ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = 2015,
    ERROR_PROFILE_NOT_FOUND = 2016,
    ERROR_INVALID_COLORSPACE = 2017,
    ERROR_ICM_NOT_ENABLED = 2018,
    ERROR_DELETING_ICM_XFORM = 2019,
    ERROR_INVALID_TRANSFORM = 2020,
    ERROR_COLORSPACE_MISMATCH = 2021,
    ERROR_INVALID_COLORINDEX = 2022,
    ERROR_PROFILE_DOES_NOT_MATCH_DEVICE = 2023,
    ERROR_CONNECTED_OTHER_PASSWORD = 2108,
    ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT = 2109,
    ERROR_BAD_USERNAME = 2202,
    ERROR_NOT_CONNECTED = 2250,
    ERROR_OPEN_FILES = 2401,
    ERROR_ACTIVE_CONNECTIONS = 2402,
    ERROR_DEVICE_IN_USE = 2404,
    ERROR_UNKNOWN_PRINT_MONITOR = 3000,
    ERROR_PRINTER_DRIVER_IN_USE = 3001,
    ERROR_SPOOL_FILE_NOT_FOUND = 3002,
    ERROR_SPL_NO_STARTDOC = 3003,
    ERROR_SPL_NO_ADDJOB = 3004,
    ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = 3005,
    ERROR_PRINT_MONITOR_ALREADY_INSTALLED = 3006,
    ERROR_INVALID_PRINT_MONITOR = 3007,
    ERROR_PRINT_MONITOR_IN_USE = 3008,
    ERROR_PRINTER_HAS_JOBS_QUEUED = 3009,
    ERROR_SUCCESS_REBOOT_REQUIRED = 3010,
    ERROR_SUCCESS_RESTART_REQUIRED = 3011,
    ERROR_PRINTER_NOT_FOUND = 3012,
    ERROR_PRINTER_DRIVER_WARNED = 3013,
    ERROR_PRINTER_DRIVER_BLOCKED = 3014,
    ERROR_PRINTER_DRIVER_PACKAGE_IN_USE = 3015,
    ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND = 3016,
    ERROR_FAIL_REBOOT_REQUIRED = 3017,
    ERROR_FAIL_REBOOT_INITIATED = 3018,
    ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED = 3019,
    ERROR_PRINT_JOB_RESTART_REQUIRED = 3020,
    ERROR_INVALID_PRINTER_DRIVER_MANIFEST = 3021,
    ERROR_PRINTER_NOT_SHAREABLE = 3022,
    ERROR_REQUEST_PAUSED = 3050,
    ERROR_APPEXEC_CONDITION_NOT_SATISFIED = 3060,
    ERROR_APPEXEC_HANDLE_INVALIDATED = 3061,
    ERROR_APPEXEC_INVALID_HOST_GENERATION = 3062,
    ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION = 3063,
    ERROR_APPEXEC_INVALID_HOST_STATE = 3064,
    ERROR_APPEXEC_NO_DONOR = 3065,
    ERROR_APPEXEC_HOST_ID_MISMATCH = 3066,
    ERROR_APPEXEC_UNKNOWN_USER = 3067,
    ERROR_IO_REISSUE_AS_CACHED = 3950,
    ERROR_WINS_INTERNAL = 4000,
    ERROR_CAN_NOT_DEL_LOCAL_WINS = 4001,
    ERROR_STATIC_INIT = 4002,
    ERROR_INC_BACKUP = 4003,
    ERROR_FULL_BACKUP = 4004,
    ERROR_REC_NON_EXISTENT = 4005,
    ERROR_RPL_NOT_ALLOWED = 4006,
    ERROR_DHCP_ADDRESS_CONFLICT = 4100,
    ERROR_WMI_GUID_NOT_FOUND = 4200,
    ERROR_WMI_INSTANCE_NOT_FOUND = 4201,
    ERROR_WMI_ITEMID_NOT_FOUND = 4202,
    ERROR_WMI_TRY_AGAIN = 4203,
    ERROR_WMI_DP_NOT_FOUND = 4204,
    ERROR_WMI_UNRESOLVED_INSTANCE_REF = 4205,
    ERROR_WMI_ALREADY_ENABLED = 4206,
    ERROR_WMI_GUID_DISCONNECTED = 4207,
    ERROR_WMI_SERVER_UNAVAILABLE = 4208,
    ERROR_WMI_DP_FAILED = 4209,
    ERROR_WMI_INVALID_MOF = 4210,
    ERROR_WMI_INVALID_REGINFO = 4211,
    ERROR_WMI_ALREADY_DISABLED = 4212,
    ERROR_WMI_READ_ONLY = 4213,
    ERROR_WMI_SET_FAILURE = 4214,
    ERROR_NOT_APPCONTAINER = 4250,
    ERROR_APPCONTAINER_REQUIRED = 4251,
    ERROR_NOT_SUPPORTED_IN_APPCONTAINER = 4252,
    ERROR_INVALID_PACKAGE_SID_LENGTH = 4253,
    ERROR_INVALID_MEDIA = 4300,
    ERROR_INVALID_LIBRARY = 4301,
    ERROR_INVALID_MEDIA_POOL = 4302,
    ERROR_DRIVE_MEDIA_MISMATCH = 4303,
    ERROR_MEDIA_OFFLINE = 4304,
    ERROR_LIBRARY_OFFLINE = 4305,
    ERROR_EMPTY = 4306,
    ERROR_NOT_EMPTY = 4307,
    ERROR_MEDIA_UNAVAILABLE = 4308,
    ERROR_RESOURCE_DISABLED = 4309,
    ERROR_INVALID_CLEANER = 4310,
    ERROR_UNABLE_TO_CLEAN = 4311,
    ERROR_OBJECT_NOT_FOUND = 4312,
    ERROR_DATABASE_FAILURE = 4313,
    ERROR_DATABASE_FULL = 4314,
    ERROR_MEDIA_INCOMPATIBLE = 4315,
    ERROR_RESOURCE_NOT_PRESENT = 4316,
    ERROR_INVALID_OPERATION = 4317,
    ERROR_MEDIA_NOT_AVAILABLE = 4318,
    ERROR_DEVICE_NOT_AVAILABLE = 4319,
    ERROR_REQUEST_REFUSED = 4320,
    ERROR_INVALID_DRIVE_OBJECT = 4321,
    ERROR_LIBRARY_FULL = 4322,
    ERROR_MEDIUM_NOT_ACCESSIBLE = 4323,
    ERROR_UNABLE_TO_LOAD_MEDIUM = 4324,
    ERROR_UNABLE_TO_INVENTORY_DRIVE = 4325,
    ERROR_UNABLE_TO_INVENTORY_SLOT = 4326,
    ERROR_UNABLE_TO_INVENTORY_TRANSPORT = 4327,
    ERROR_TRANSPORT_FULL = 4328,
    ERROR_CONTROLLING_IEPORT = 4329,
    ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA = 4330,
    ERROR_CLEANER_SLOT_SET = 4331,
    ERROR_CLEANER_SLOT_NOT_SET = 4332,
    ERROR_CLEANER_CARTRIDGE_SPENT = 4333,
    ERROR_UNEXPECTED_OMID = 4334,
    ERROR_CANT_DELETE_LAST_ITEM = 4335,
    ERROR_MESSAGE_EXCEEDS_MAX_SIZE = 4336,
    ERROR_VOLUME_CONTAINS_SYS_FILES = 4337,
    ERROR_INDIGENOUS_TYPE = 4338,
    ERROR_NO_SUPPORTING_DRIVES = 4339,
    ERROR_CLEANER_CARTRIDGE_INSTALLED = 4340,
    ERROR_IEPORT_FULL = 4341,
    ERROR_FILE_OFFLINE = 4350,
    ERROR_REMOTE_STORAGE_NOT_ACTIVE = 4351,
    ERROR_REMOTE_STORAGE_MEDIA_ERROR = 4352,
    ERROR_NOT_A_REPARSE_POINT = 4390,
    ERROR_REPARSE_ATTRIBUTE_CONFLICT = 4391,
    ERROR_INVALID_REPARSE_DATA = 4392,
    ERROR_REPARSE_TAG_INVALID = 4393,
    ERROR_REPARSE_TAG_MISMATCH = 4394,
    ERROR_REPARSE_POINT_ENCOUNTERED = 4395,
    ERROR_APP_DATA_NOT_FOUND = 4400,
    ERROR_APP_DATA_EXPIRED = 4401,
    ERROR_APP_DATA_CORRUPT = 4402,
    ERROR_APP_DATA_LIMIT_EXCEEDED = 4403,
    ERROR_APP_DATA_REBOOT_REQUIRED = 4404,
    ERROR_SECUREBOOT_ROLLBACK_DETECTED = 4420,
    ERROR_SECUREBOOT_POLICY_VIOLATION = 4421,
    ERROR_SECUREBOOT_INVALID_POLICY = 4422,
    ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = 4423,
    ERROR_SECUREBOOT_POLICY_NOT_SIGNED = 4424,
    ERROR_SECUREBOOT_NOT_ENABLED = 4425,
    ERROR_SECUREBOOT_FILE_REPLACED = 4426,
    ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED = 4427,
    ERROR_SECUREBOOT_POLICY_UNKNOWN = 4428,
    ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION = 4429,
    ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH = 4430,
    ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED = 4431,
    ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH = 4432,
    ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING = 4433,
    ERROR_SECUREBOOT_NOT_BASE_POLICY = 4434,
    ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY = 4435,
    ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED = 4440,
    ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = 4441,
    ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED = 4442,
    ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = 4443,
    ERROR_ALREADY_HAS_STREAM_ID = 4444,
    ERROR_SMR_GARBAGE_COLLECTION_REQUIRED = 4445,
    ERROR_WOF_WIM_HEADER_CORRUPT = 4446,
    ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT = 4447,
    ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT = 4448,
    ERROR_VOLUME_NOT_SIS_ENABLED = 4500,
    ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED = 4550,
    ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION = 4551,
    ERROR_SYSTEM_INTEGRITY_INVALID_POLICY = 4552,
    ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED = 4553,
    ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES = 4554,
    ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED = 4555,
    ERROR_VSM_NOT_INITIALIZED = 4560,
    ERROR_VSM_DMA_PROTECTION_NOT_IN_USE = 4561,
    ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED = 4570,
    ERROR_PLATFORM_MANIFEST_INVALID = 4571,
    ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED = 4572,
    ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED = 4573,
    ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND = 4574,
    ERROR_PLATFORM_MANIFEST_NOT_ACTIVE = 4575,
    ERROR_PLATFORM_MANIFEST_NOT_SIGNED = 4576,
    ERROR_DEPENDENT_RESOURCE_EXISTS = 5001,
    ERROR_DEPENDENCY_NOT_FOUND = 5002,
    ERROR_DEPENDENCY_ALREADY_EXISTS = 5003,
    ERROR_RESOURCE_NOT_ONLINE = 5004,
    ERROR_HOST_NODE_NOT_AVAILABLE = 5005,
    ERROR_RESOURCE_NOT_AVAILABLE = 5006,
    ERROR_RESOURCE_NOT_FOUND = 5007,
    ERROR_SHUTDOWN_CLUSTER = 5008,
    ERROR_CANT_EVICT_ACTIVE_NODE = 5009,
    ERROR_OBJECT_ALREADY_EXISTS = 5010,
    ERROR_OBJECT_IN_LIST = 5011,
    ERROR_GROUP_NOT_AVAILABLE = 5012,
    ERROR_GROUP_NOT_FOUND = 5013,
    ERROR_GROUP_NOT_ONLINE = 5014,
    ERROR_HOST_NODE_NOT_RESOURCE_OWNER = 5015,
    ERROR_HOST_NODE_NOT_GROUP_OWNER = 5016,
    ERROR_RESMON_CREATE_FAILED = 5017,
    ERROR_RESMON_ONLINE_FAILED = 5018,
    ERROR_RESOURCE_ONLINE = 5019,
    ERROR_QUORUM_RESOURCE = 5020,
    ERROR_NOT_QUORUM_CAPABLE = 5021,
    ERROR_CLUSTER_SHUTTING_DOWN = 5022,
    ERROR_INVALID_STATE = 5023,
    ERROR_RESOURCE_PROPERTIES_STORED = 5024,
    ERROR_NOT_QUORUM_CLASS = 5025,
    ERROR_CORE_RESOURCE = 5026,
    ERROR_QUORUM_RESOURCE_ONLINE_FAILED = 5027,
    ERROR_QUORUMLOG_OPEN_FAILED = 5028,
    ERROR_CLUSTERLOG_CORRUPT = 5029,
    ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = 5030,
    ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE = 5031,
    ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND = 5032,
    ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE = 5033,
    ERROR_QUORUM_OWNER_ALIVE = 5034,
    ERROR_NETWORK_NOT_AVAILABLE = 5035,
    ERROR_NODE_NOT_AVAILABLE = 5036,
    ERROR_ALL_NODES_NOT_AVAILABLE = 5037,
    ERROR_RESOURCE_FAILED = 5038,
    ERROR_CLUSTER_INVALID_NODE = 5039,
    ERROR_CLUSTER_NODE_EXISTS = 5040,
    ERROR_CLUSTER_JOIN_IN_PROGRESS = 5041,
    ERROR_CLUSTER_NODE_NOT_FOUND = 5042,
    ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND = 5043,
    ERROR_CLUSTER_NETWORK_EXISTS = 5044,
    ERROR_CLUSTER_NETWORK_NOT_FOUND = 5045,
    ERROR_CLUSTER_NETINTERFACE_EXISTS = 5046,
    ERROR_CLUSTER_NETINTERFACE_NOT_FOUND = 5047,
    ERROR_CLUSTER_INVALID_REQUEST = 5048,
    ERROR_CLUSTER_INVALID_NETWORK_PROVIDER = 5049,
    ERROR_CLUSTER_NODE_DOWN = 5050,
    ERROR_CLUSTER_NODE_UNREACHABLE = 5051,
    ERROR_CLUSTER_NODE_NOT_MEMBER = 5052,
    ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS = 5053,
    ERROR_CLUSTER_INVALID_NETWORK = 5054,
    ERROR_CLUSTER_NODE_UP = 5056,
    ERROR_CLUSTER_IPADDR_IN_USE = 5057,
    ERROR_CLUSTER_NODE_NOT_PAUSED = 5058,
    ERROR_CLUSTER_NO_SECURITY_CONTEXT = 5059,
    ERROR_CLUSTER_NETWORK_NOT_INTERNAL = 5060,
    ERROR_CLUSTER_NODE_ALREADY_UP = 5061,
    ERROR_CLUSTER_NODE_ALREADY_DOWN = 5062,
    ERROR_CLUSTER_NETWORK_ALREADY_ONLINE = 5063,
    ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE = 5064,
    ERROR_CLUSTER_NODE_ALREADY_MEMBER = 5065,
    ERROR_CLUSTER_LAST_INTERNAL_NETWORK = 5066,
    ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS = 5067,
    ERROR_INVALID_OPERATION_ON_QUORUM = 5068,
    ERROR_DEPENDENCY_NOT_ALLOWED = 5069,
    ERROR_CLUSTER_NODE_PAUSED = 5070,
    ERROR_NODE_CANT_HOST_RESOURCE = 5071,
    ERROR_CLUSTER_NODE_NOT_READY = 5072,
    ERROR_CLUSTER_NODE_SHUTTING_DOWN = 5073,
    ERROR_CLUSTER_JOIN_ABORTED = 5074,
    ERROR_CLUSTER_INCOMPATIBLE_VERSIONS = 5075,
    ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED = 5076,
    ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED = 5077,
    ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND = 5078,
    ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED = 5079,
    ERROR_CLUSTER_RESNAME_NOT_FOUND = 5080,
    ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED = 5081,
    ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST = 5082,
    ERROR_CLUSTER_DATABASE_SEQMISMATCH = 5083,
    ERROR_RESMON_INVALID_STATE = 5084,
    ERROR_CLUSTER_GUM_NOT_LOCKER = 5085,
    ERROR_QUORUM_DISK_NOT_FOUND = 5086,
    ERROR_DATABASE_BACKUP_CORRUPT = 5087,
    ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT = 5088,
    ERROR_RESOURCE_PROPERTY_UNCHANGEABLE = 5089,
    ERROR_NO_ADMIN_ACCESS_POINT = 5090,
    ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE = 5890,
    ERROR_CLUSTER_QUORUMLOG_NOT_FOUND = 5891,
    ERROR_CLUSTER_MEMBERSHIP_HALT = 5892,
    ERROR_CLUSTER_INSTANCE_ID_MISMATCH = 5893,
    ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP = 5894,
    ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH = 5895,
    ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP = 5896,
    ERROR_CLUSTER_PARAMETER_MISMATCH = 5897,
    ERROR_NODE_CANNOT_BE_CLUSTERED = 5898,
    ERROR_CLUSTER_WRONG_OS_VERSION = 5899,
    ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME = 5900,
    ERROR_CLUSCFG_ALREADY_COMMITTED = 5901,
    ERROR_CLUSCFG_ROLLBACK_FAILED = 5902,
    ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT = 5903,
    ERROR_CLUSTER_OLD_VERSION = 5904,
    ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME = 5905,
    ERROR_CLUSTER_NO_NET_ADAPTERS = 5906,
    ERROR_CLUSTER_POISONED = 5907,
    ERROR_CLUSTER_GROUP_MOVING = 5908,
    ERROR_CLUSTER_RESOURCE_TYPE_BUSY = 5909,
    ERROR_RESOURCE_CALL_TIMED_OUT = 5910,
    ERROR_INVALID_CLUSTER_IPV6_ADDRESS = 5911,
    ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION = 5912,
    ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS = 5913,
    ERROR_CLUSTER_PARTIAL_SEND = 5914,
    ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION = 5915,
    ERROR_CLUSTER_INVALID_STRING_TERMINATION = 5916,
    ERROR_CLUSTER_INVALID_STRING_FORMAT = 5917,
    ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS = 5918,
    ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS = 5919,
    ERROR_CLUSTER_NULL_DATA = 5920,
    ERROR_CLUSTER_PARTIAL_READ = 5921,
    ERROR_CLUSTER_PARTIAL_WRITE = 5922,
    ERROR_CLUSTER_CANT_DESERIALIZE_DATA = 5923,
    ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT = 5924,
    ERROR_CLUSTER_NO_QUORUM = 5925,
    ERROR_CLUSTER_INVALID_IPV6_NETWORK = 5926,
    ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK = 5927,
    ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP = 5928,
    ERROR_DEPENDENCY_TREE_TOO_COMPLEX = 5929,
    ERROR_EXCEPTION_IN_RESOURCE_CALL = 5930,
    ERROR_CLUSTER_RHS_FAILED_INITIALIZATION = 5931,
    ERROR_CLUSTER_NOT_INSTALLED = 5932,
    ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE = 5933,
    ERROR_CLUSTER_MAX_NODES_IN_CLUSTER = 5934,
    ERROR_CLUSTER_TOO_MANY_NODES = 5935,
    ERROR_CLUSTER_OBJECT_ALREADY_USED = 5936,
    ERROR_NONCORE_GROUPS_FOUND = 5937,
    ERROR_FILE_SHARE_RESOURCE_CONFLICT = 5938,
    ERROR_CLUSTER_EVICT_INVALID_REQUEST = 5939,
    ERROR_CLUSTER_SINGLETON_RESOURCE = 5940,
    ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE = 5941,
    ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED = 5942,
    ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR = 5943,
    ERROR_CLUSTER_GROUP_BUSY = 5944,
    ERROR_CLUSTER_NOT_SHARED_VOLUME = 5945,
    ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR = 5946,
    ERROR_CLUSTER_SHARED_VOLUMES_IN_USE = 5947,
    ERROR_CLUSTER_USE_SHARED_VOLUMES_API = 5948,
    ERROR_CLUSTER_BACKUP_IN_PROGRESS = 5949,
    ERROR_NON_CSV_PATH = 5950,
    ERROR_CSV_VOLUME_NOT_LOCAL = 5951,
    ERROR_CLUSTER_WATCHDOG_TERMINATING = 5952,
    ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES = 5953,
    ERROR_CLUSTER_INVALID_NODE_WEIGHT = 5954,
    ERROR_CLUSTER_RESOURCE_VETOED_CALL = 5955,
    ERROR_RESMON_SYSTEM_RESOURCES_LACKING = 5956,
    ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION = 5957,
    ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE = 5958,
    ERROR_CLUSTER_GROUP_QUEUED = 5959,
    ERROR_CLUSTER_RESOURCE_LOCKED_STATUS = 5960,
    ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED = 5961,
    ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS = 5962,
    ERROR_CLUSTER_DISK_NOT_CONNECTED = 5963,
    ERROR_DISK_NOT_CSV_CAPABLE = 5964,
    ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE = 5965,
    ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED = 5966,
    ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED = 5967,
    ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES = 5968,
    ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES = 5969,
    ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE = 5970,
    ERROR_CLUSTER_AFFINITY_CONFLICT = 5971,
    ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE = 5972,
    ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS = 5973,
    ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED = 5974,
    ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED = 5975,
    ERROR_CLUSTER_UPGRADE_IN_PROGRESS = 5976,
    ERROR_CLUSTER_UPGRADE_INCOMPLETE = 5977,
    ERROR_CLUSTER_NODE_IN_GRACE_PERIOD = 5978,
    ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT = 5979,
    ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER = 5980,
    ERROR_CLUSTER_RESOURCE_NOT_MONITORED = 5981,
    ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED = 5982,
    ERROR_CLUSTER_RESOURCE_IS_REPLICATED = 5983,
    ERROR_CLUSTER_NODE_ISOLATED = 5984,
    ERROR_CLUSTER_NODE_QUARANTINED = 5985,
    ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED = 5986,
    ERROR_CLUSTER_SPACE_DEGRADED = 5987,
    ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED = 5988,
    ERROR_CLUSTER_CSV_INVALID_HANDLE = 5989,
    ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR = 5990,
    ERROR_GROUPSET_NOT_AVAILABLE = 5991,
    ERROR_GROUPSET_NOT_FOUND = 5992,
    ERROR_GROUPSET_CANT_PROVIDE = 5993,
    ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND = 5994,
    ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY = 5995,
    ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION = 5996,
    ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS = 5997,
    ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME = 5998,
    ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE = 5999,
    ERROR_ENCRYPTION_FAILED = 6000,
    ERROR_DECRYPTION_FAILED = 6001,
    ERROR_FILE_ENCRYPTED = 6002,
    ERROR_NO_RECOVERY_POLICY = 6003,
    ERROR_NO_EFS = 6004,
    ERROR_WRONG_EFS = 6005,
    ERROR_NO_USER_KEYS = 6006,
    ERROR_FILE_NOT_ENCRYPTED = 6007,
    ERROR_NOT_EXPORT_FORMAT = 6008,
    ERROR_FILE_READ_ONLY = 6009,
    ERROR_DIR_EFS_DISALLOWED = 6010,
    ERROR_EFS_SERVER_NOT_TRUSTED = 6011,
    ERROR_BAD_RECOVERY_POLICY = 6012,
    ERROR_EFS_ALG_BLOB_TOO_BIG = 6013,
    ERROR_VOLUME_NOT_SUPPORT_EFS = 6014,
    ERROR_EFS_DISABLED = 6015,
    ERROR_EFS_VERSION_NOT_SUPPORT = 6016,
    ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = 6017,
    ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER = 6018,
    ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = 6019,
    ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = 6020,
    ERROR_CS_ENCRYPTION_FILE_NOT_CSE = 6021,
    ERROR_ENCRYPTION_POLICY_DENIES_OPERATION = 6022,
    ERROR_WIP_ENCRYPTION_FAILED = 6023,
    ERROR_NO_BROWSER_SERVERS_FOUND = 6118,
    ERROR_CLUSTER_OBJECT_IS_CLUSTER_SET_VM = 6250,
    ERROR_LOG_SECTOR_INVALID = 6600,
    ERROR_LOG_SECTOR_PARITY_INVALID = 6601,
    ERROR_LOG_SECTOR_REMAPPED = 6602,
    ERROR_LOG_BLOCK_INCOMPLETE = 6603,
    ERROR_LOG_INVALID_RANGE = 6604,
    ERROR_LOG_BLOCKS_EXHAUSTED = 6605,
    ERROR_LOG_READ_CONTEXT_INVALID = 6606,
    ERROR_LOG_RESTART_INVALID = 6607,
    ERROR_LOG_BLOCK_VERSION = 6608,
    ERROR_LOG_BLOCK_INVALID = 6609,
    ERROR_LOG_READ_MODE_INVALID = 6610,
    ERROR_LOG_NO_RESTART = 6611,
    ERROR_LOG_METADATA_CORRUPT = 6612,
    ERROR_LOG_METADATA_INVALID = 6613,
    ERROR_LOG_METADATA_INCONSISTENT = 6614,
    ERROR_LOG_RESERVATION_INVALID = 6615,
    ERROR_LOG_CANT_DELETE = 6616,
    ERROR_LOG_CONTAINER_LIMIT_EXCEEDED = 6617,
    ERROR_LOG_START_OF_LOG = 6618,
    ERROR_LOG_POLICY_ALREADY_INSTALLED = 6619,
    ERROR_LOG_POLICY_NOT_INSTALLED = 6620,
    ERROR_LOG_POLICY_INVALID = 6621,
    ERROR_LOG_POLICY_CONFLICT = 6622,
    ERROR_LOG_PINNED_ARCHIVE_TAIL = 6623,
    ERROR_LOG_RECORD_NONEXISTENT = 6624,
    ERROR_LOG_RECORDS_RESERVED_INVALID = 6625,
    ERROR_LOG_SPACE_RESERVED_INVALID = 6626,
    ERROR_LOG_TAIL_INVALID = 6627,
    ERROR_LOG_FULL = 6628,
    ERROR_COULD_NOT_RESIZE_LOG = 6629,
    ERROR_LOG_MULTIPLEXED = 6630,
    ERROR_LOG_DEDICATED = 6631,
    ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS = 6632,
    ERROR_LOG_ARCHIVE_IN_PROGRESS = 6633,
    ERROR_LOG_EPHEMERAL = 6634,
    ERROR_LOG_NOT_ENOUGH_CONTAINERS = 6635,
    ERROR_LOG_CLIENT_ALREADY_REGISTERED = 6636,
    ERROR_LOG_CLIENT_NOT_REGISTERED = 6637,
    ERROR_LOG_FULL_HANDLER_IN_PROGRESS = 6638,
    ERROR_LOG_CONTAINER_READ_FAILED = 6639,
    ERROR_LOG_CONTAINER_WRITE_FAILED = 6640,
    ERROR_LOG_CONTAINER_OPEN_FAILED = 6641,
    ERROR_LOG_CONTAINER_STATE_INVALID = 6642,
    ERROR_LOG_STATE_INVALID = 6643,
    ERROR_LOG_PINNED = 6644,
    ERROR_LOG_METADATA_FLUSH_FAILED = 6645,
    ERROR_LOG_INCONSISTENT_SECURITY = 6646,
    ERROR_LOG_APPENDED_FLUSH_FAILED = 6647,
    ERROR_LOG_PINNED_RESERVATION = 6648,
    ERROR_INVALID_TRANSACTION = 6700,
    ERROR_TRANSACTION_NOT_ACTIVE = 6701,
    ERROR_TRANSACTION_REQUEST_NOT_VALID = 6702,
    ERROR_TRANSACTION_NOT_REQUESTED = 6703,
    ERROR_TRANSACTION_ALREADY_ABORTED = 6704,
    ERROR_TRANSACTION_ALREADY_COMMITTED = 6705,
    ERROR_TM_INITIALIZATION_FAILED = 6706,
    ERROR_RESOURCEMANAGER_READ_ONLY = 6707,
    ERROR_TRANSACTION_NOT_JOINED = 6708,
    ERROR_TRANSACTION_SUPERIOR_EXISTS = 6709,
    ERROR_CRM_PROTOCOL_ALREADY_EXISTS = 6710,
    ERROR_TRANSACTION_PROPAGATION_FAILED = 6711,
    ERROR_CRM_PROTOCOL_NOT_FOUND = 6712,
    ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER = 6713,
    ERROR_CURRENT_TRANSACTION_NOT_VALID = 6714,
    ERROR_TRANSACTION_NOT_FOUND = 6715,
    ERROR_RESOURCEMANAGER_NOT_FOUND = 6716,
    ERROR_ENLISTMENT_NOT_FOUND = 6717,
    ERROR_TRANSACTIONMANAGER_NOT_FOUND = 6718,
    ERROR_TRANSACTIONMANAGER_NOT_ONLINE = 6719,
    ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = 6720,
    ERROR_TRANSACTION_NOT_ROOT = 6721,
    ERROR_TRANSACTION_OBJECT_EXPIRED = 6722,
    ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED = 6723,
    ERROR_TRANSACTION_RECORD_TOO_LONG = 6724,
    ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED = 6725,
    ERROR_TRANSACTION_INTEGRITY_VIOLATED = 6726,
    ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH = 6727,
    ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = 6728,
    ERROR_TRANSACTION_MUST_WRITETHROUGH = 6729,
    ERROR_TRANSACTION_NO_SUPERIOR = 6730,
    ERROR_HEURISTIC_DAMAGE_POSSIBLE = 6731,
    ERROR_TRANSACTIONAL_CONFLICT = 6800,
    ERROR_RM_NOT_ACTIVE = 6801,
    ERROR_RM_METADATA_CORRUPT = 6802,
    ERROR_DIRECTORY_NOT_RM = 6803,
    ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE = 6805,
    ERROR_LOG_RESIZE_INVALID_SIZE = 6806,
    ERROR_OBJECT_NO_LONGER_EXISTS = 6807,
    ERROR_STREAM_MINIVERSION_NOT_FOUND = 6808,
    ERROR_STREAM_MINIVERSION_NOT_VALID = 6809,
    ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = 6810,
    ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = 6811,
    ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS = 6812,
    ERROR_REMOTE_FILE_VERSION_MISMATCH = 6814,
    ERROR_HANDLE_NO_LONGER_VALID = 6815,
    ERROR_NO_TXF_METADATA = 6816,
    ERROR_LOG_CORRUPTION_DETECTED = 6817,
    ERROR_CANT_RECOVER_WITH_HANDLE_OPEN = 6818,
    ERROR_RM_DISCONNECTED = 6819,
    ERROR_ENLISTMENT_NOT_SUPERIOR = 6820,
    ERROR_RECOVERY_NOT_NEEDED = 6821,
    ERROR_RM_ALREADY_STARTED = 6822,
    ERROR_FILE_IDENTITY_NOT_PERSISTENT = 6823,
    ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = 6824,
    ERROR_CANT_CROSS_RM_BOUNDARY = 6825,
    ERROR_TXF_DIR_NOT_EMPTY = 6826,
    ERROR_INDOUBT_TRANSACTIONS_EXIST = 6827,
    ERROR_TM_VOLATILE = 6828,
    ERROR_ROLLBACK_TIMER_EXPIRED = 6829,
    ERROR_TXF_ATTRIBUTE_CORRUPT = 6830,
    ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION = 6831,
    ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED = 6832,
    ERROR_LOG_GROWTH_FAILED = 6833,
    ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = 6834,
    ERROR_TXF_METADATA_ALREADY_PRESENT = 6835,
    ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = 6836,
    ERROR_TRANSACTION_REQUIRED_PROMOTION = 6837,
    ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION = 6838,
    ERROR_TRANSACTIONS_NOT_FROZEN = 6839,
    ERROR_TRANSACTION_FREEZE_IN_PROGRESS = 6840,
    ERROR_NOT_SNAPSHOT_VOLUME = 6841,
    ERROR_NO_SAVEPOINT_WITH_OPEN_FILES = 6842,
    ERROR_DATA_LOST_REPAIR = 6843,
    ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION = 6844,
    ERROR_TM_IDENTITY_MISMATCH = 6845,
    ERROR_FLOATED_SECTION = 6846,
    ERROR_CANNOT_ACCEPT_TRANSACTED_WORK = 6847,
    ERROR_CANNOT_ABORT_TRANSACTIONS = 6848,
    ERROR_BAD_CLUSTERS = 6849,
    ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = 6850,
    ERROR_VOLUME_DIRTY = 6851,
    ERROR_NO_LINK_TRACKING_IN_TRANSACTION = 6852,
    ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = 6853,
    ERROR_EXPIRED_HANDLE = 6854,
    ERROR_TRANSACTION_NOT_ENLISTED = 6855,
    ERROR_CTX_WINSTATION_NAME_INVALID = 7001,
    ERROR_CTX_INVALID_PD = 7002,
    ERROR_CTX_PD_NOT_FOUND = 7003,
    ERROR_CTX_WD_NOT_FOUND = 7004,
    ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY = 7005,
    ERROR_CTX_SERVICE_NAME_COLLISION = 7006,
    ERROR_CTX_CLOSE_PENDING = 7007,
    ERROR_CTX_NO_OUTBUF = 7008,
    ERROR_CTX_MODEM_INF_NOT_FOUND = 7009,
    ERROR_CTX_INVALID_MODEMNAME = 7010,
    ERROR_CTX_MODEM_RESPONSE_ERROR = 7011,
    ERROR_CTX_MODEM_RESPONSE_TIMEOUT = 7012,
    ERROR_CTX_MODEM_RESPONSE_NO_CARRIER = 7013,
    ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE = 7014,
    ERROR_CTX_MODEM_RESPONSE_BUSY = 7015,
    ERROR_CTX_MODEM_RESPONSE_VOICE = 7016,
    ERROR_CTX_TD_ERROR = 7017,
    ERROR_CTX_WINSTATION_NOT_FOUND = 7022,
    ERROR_CTX_WINSTATION_ALREADY_EXISTS = 7023,
    ERROR_CTX_WINSTATION_BUSY = 7024,
    ERROR_CTX_BAD_VIDEO_MODE = 7025,
    ERROR_CTX_GRAPHICS_INVALID = 7035,
    ERROR_CTX_LOGON_DISABLED = 7037,
    ERROR_CTX_NOT_CONSOLE = 7038,
    ERROR_CTX_CLIENT_QUERY_TIMEOUT = 7040,
    ERROR_CTX_CONSOLE_DISCONNECT = 7041,
    ERROR_CTX_CONSOLE_CONNECT = 7042,
    ERROR_CTX_SHADOW_DENIED = 7044,
    ERROR_CTX_WINSTATION_ACCESS_DENIED = 7045,
    ERROR_CTX_INVALID_WD = 7049,
    ERROR_CTX_SHADOW_INVALID = 7050,
    ERROR_CTX_SHADOW_DISABLED = 7051,
    ERROR_CTX_CLIENT_LICENSE_IN_USE = 7052,
    ERROR_CTX_CLIENT_LICENSE_NOT_SET = 7053,
    ERROR_CTX_LICENSE_NOT_AVAILABLE = 7054,
    ERROR_CTX_LICENSE_CLIENT_INVALID = 7055,
    ERROR_CTX_LICENSE_EXPIRED = 7056,
    ERROR_CTX_SHADOW_NOT_RUNNING = 7057,
    ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE = 7058,
    ERROR_ACTIVATION_COUNT_EXCEEDED = 7059,
    ERROR_CTX_WINSTATIONS_DISABLED = 7060,
    ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED = 7061,
    ERROR_CTX_SESSION_IN_USE = 7062,
    ERROR_CTX_NO_FORCE_LOGOFF = 7063,
    ERROR_CTX_ACCOUNT_RESTRICTION = 7064,
    ERROR_RDP_PROTOCOL_ERROR = 7065,
    ERROR_CTX_CDM_CONNECT = 7066,
    ERROR_CTX_CDM_DISCONNECT = 7067,
    ERROR_CTX_SECURITY_LAYER_ERROR = 7068,
    ERROR_TS_INCOMPATIBLE_SESSIONS = 7069,
    ERROR_TS_VIDEO_SUBSYSTEM_ERROR = 7070,
    ERROR_DS_NOT_INSTALLED = 8200,
    ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = 8201,
    ERROR_DS_NO_ATTRIBUTE_OR_VALUE = 8202,
    ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = 8203,
    ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED = 8204,
    ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = 8205,
    ERROR_DS_BUSY = 8206,
    ERROR_DS_UNAVAILABLE = 8207,
    ERROR_DS_NO_RIDS_ALLOCATED = 8208,
    ERROR_DS_NO_MORE_RIDS = 8209,
    ERROR_DS_INCORRECT_ROLE_OWNER = 8210,
    ERROR_DS_RIDMGR_INIT_ERROR = 8211,
    ERROR_DS_OBJ_CLASS_VIOLATION = 8212,
    ERROR_DS_CANT_ON_NON_LEAF = 8213,
    ERROR_DS_CANT_ON_RDN = 8214,
    ERROR_DS_CANT_MOD_OBJ_CLASS = 8215,
    ERROR_DS_CROSS_DOM_MOVE_ERROR = 8216,
    ERROR_DS_GC_NOT_AVAILABLE = 8217,
    ERROR_SHARED_POLICY = 8218,
    ERROR_POLICY_OBJECT_NOT_FOUND = 8219,
    ERROR_POLICY_ONLY_IN_DS = 8220,
    ERROR_PROMOTION_ACTIVE = 8221,
    ERROR_NO_PROMOTION_ACTIVE = 8222,
    ERROR_DS_OPERATIONS_ERROR = 8224,
    ERROR_DS_PROTOCOL_ERROR = 8225,
    ERROR_DS_TIMELIMIT_EXCEEDED = 8226,
    ERROR_DS_SIZELIMIT_EXCEEDED = 8227,
    ERROR_DS_ADMIN_LIMIT_EXCEEDED = 8228,
    ERROR_DS_COMPARE_FALSE = 8229,
    ERROR_DS_COMPARE_TRUE = 8230,
    ERROR_DS_AUTH_METHOD_NOT_SUPPORTED = 8231,
    ERROR_DS_STRONG_AUTH_REQUIRED = 8232,
    ERROR_DS_INAPPROPRIATE_AUTH = 8233,
    ERROR_DS_AUTH_UNKNOWN = 8234,
    ERROR_DS_REFERRAL = 8235,
    ERROR_DS_UNAVAILABLE_CRIT_EXTENSION = 8236,
    ERROR_DS_CONFIDENTIALITY_REQUIRED = 8237,
    ERROR_DS_INAPPROPRIATE_MATCHING = 8238,
    ERROR_DS_CONSTRAINT_VIOLATION = 8239,
    ERROR_DS_NO_SUCH_OBJECT = 8240,
    ERROR_DS_ALIAS_PROBLEM = 8241,
    ERROR_DS_INVALID_DN_SYNTAX = 8242,
    ERROR_DS_IS_LEAF = 8243,
    ERROR_DS_ALIAS_DEREF_PROBLEM = 8244,
    ERROR_DS_UNWILLING_TO_PERFORM = 8245,
    ERROR_DS_LOOP_DETECT = 8246,
    ERROR_DS_NAMING_VIOLATION = 8247,
    ERROR_DS_OBJECT_RESULTS_TOO_LARGE = 8248,
    ERROR_DS_AFFECTS_MULTIPLE_DSAS = 8249,
    ERROR_DS_SERVER_DOWN = 8250,
    ERROR_DS_LOCAL_ERROR = 8251,
    ERROR_DS_ENCODING_ERROR = 8252,
    ERROR_DS_DECODING_ERROR = 8253,
    ERROR_DS_FILTER_UNKNOWN = 8254,
    ERROR_DS_PARAM_ERROR = 8255,
    ERROR_DS_NOT_SUPPORTED = 8256,
    ERROR_DS_NO_RESULTS_RETURNED = 8257,
    ERROR_DS_CONTROL_NOT_FOUND = 8258,
    ERROR_DS_CLIENT_LOOP = 8259,
    ERROR_DS_REFERRAL_LIMIT_EXCEEDED = 8260,
    ERROR_DS_SORT_CONTROL_MISSING = 8261,
    ERROR_DS_OFFSET_RANGE_ERROR = 8262,
    ERROR_DS_RIDMGR_DISABLED = 8263,
    ERROR_DS_ROOT_MUST_BE_NC = 8301,
    ERROR_DS_ADD_REPLICA_INHIBITED = 8302,
    ERROR_DS_ATT_NOT_DEF_IN_SCHEMA = 8303,
    ERROR_DS_MAX_OBJ_SIZE_EXCEEDED = 8304,
    ERROR_DS_OBJ_STRING_NAME_EXISTS = 8305,
    ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA = 8306,
    ERROR_DS_RDN_DOESNT_MATCH_SCHEMA = 8307,
    ERROR_DS_NO_REQUESTED_ATTS_FOUND = 8308,
    ERROR_DS_USER_BUFFER_TO_SMALL = 8309,
    ERROR_DS_ATT_IS_NOT_ON_OBJ = 8310,
    ERROR_DS_ILLEGAL_MOD_OPERATION = 8311,
    ERROR_DS_OBJ_TOO_LARGE = 8312,
    ERROR_DS_BAD_INSTANCE_TYPE = 8313,
    ERROR_DS_MASTERDSA_REQUIRED = 8314,
    ERROR_DS_OBJECT_CLASS_REQUIRED = 8315,
    ERROR_DS_MISSING_REQUIRED_ATT = 8316,
    ERROR_DS_ATT_NOT_DEF_FOR_CLASS = 8317,
    ERROR_DS_ATT_ALREADY_EXISTS = 8318,
    ERROR_DS_CANT_ADD_ATT_VALUES = 8320,
    ERROR_DS_SINGLE_VALUE_CONSTRAINT = 8321,
    ERROR_DS_RANGE_CONSTRAINT = 8322,
    ERROR_DS_ATT_VAL_ALREADY_EXISTS = 8323,
    ERROR_DS_CANT_REM_MISSING_ATT = 8324,
    ERROR_DS_CANT_REM_MISSING_ATT_VAL = 8325,
    ERROR_DS_ROOT_CANT_BE_SUBREF = 8326,
    ERROR_DS_NO_CHAINING = 8327,
    ERROR_DS_NO_CHAINED_EVAL = 8328,
    ERROR_DS_NO_PARENT_OBJECT = 8329,
    ERROR_DS_PARENT_IS_AN_ALIAS = 8330,
    ERROR_DS_CANT_MIX_MASTER_AND_REPS = 8331,
    ERROR_DS_CHILDREN_EXIST = 8332,
    ERROR_DS_OBJ_NOT_FOUND = 8333,
    ERROR_DS_ALIASED_OBJ_MISSING = 8334,
    ERROR_DS_BAD_NAME_SYNTAX = 8335,
    ERROR_DS_ALIAS_POINTS_TO_ALIAS = 8336,
    ERROR_DS_CANT_DEREF_ALIAS = 8337,
    ERROR_DS_OUT_OF_SCOPE = 8338,
    ERROR_DS_OBJECT_BEING_REMOVED = 8339,
    ERROR_DS_CANT_DELETE_DSA_OBJ = 8340,
    ERROR_DS_GENERIC_ERROR = 8341,
    ERROR_DS_DSA_MUST_BE_INT_MASTER = 8342,
    ERROR_DS_CLASS_NOT_DSA = 8343,
    ERROR_DS_INSUFF_ACCESS_RIGHTS = 8344,
    ERROR_DS_ILLEGAL_SUPERIOR = 8345,
    ERROR_DS_ATTRIBUTE_OWNED_BY_SAM = 8346,
    ERROR_DS_NAME_TOO_MANY_PARTS = 8347,
    ERROR_DS_NAME_TOO_LONG = 8348,
    ERROR_DS_NAME_VALUE_TOO_LONG = 8349,
    ERROR_DS_NAME_UNPARSEABLE = 8350,
    ERROR_DS_NAME_TYPE_UNKNOWN = 8351,
    ERROR_DS_NOT_AN_OBJECT = 8352,
    ERROR_DS_SEC_DESC_TOO_SHORT = 8353,
    ERROR_DS_SEC_DESC_INVALID = 8354,
    ERROR_DS_NO_DELETED_NAME = 8355,
    ERROR_DS_SUBREF_MUST_HAVE_PARENT = 8356,
    ERROR_DS_NCNAME_MUST_BE_NC = 8357,
    ERROR_DS_CANT_ADD_SYSTEM_ONLY = 8358,
    ERROR_DS_CLASS_MUST_BE_CONCRETE = 8359,
    ERROR_DS_INVALID_DMD = 8360,
    ERROR_DS_OBJ_GUID_EXISTS = 8361,
    ERROR_DS_NOT_ON_BACKLINK = 8362,
    ERROR_DS_NO_CROSSREF_FOR_NC = 8363,
    ERROR_DS_SHUTTING_DOWN = 8364,
    ERROR_DS_UNKNOWN_OPERATION = 8365,
    ERROR_DS_INVALID_ROLE_OWNER = 8366,
    ERROR_DS_COULDNT_CONTACT_FSMO = 8367,
    ERROR_DS_CROSS_NC_DN_RENAME = 8368,
    ERROR_DS_CANT_MOD_SYSTEM_ONLY = 8369,
    ERROR_DS_REPLICATOR_ONLY = 8370,
    ERROR_DS_OBJ_CLASS_NOT_DEFINED = 8371,
    ERROR_DS_OBJ_CLASS_NOT_SUBCLASS = 8372,
    ERROR_DS_NAME_REFERENCE_INVALID = 8373,
    ERROR_DS_CROSS_REF_EXISTS = 8374,
    ERROR_DS_CANT_DEL_MASTER_CROSSREF = 8375,
    ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD = 8376,
    ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX = 8377,
    ERROR_DS_DUP_RDN = 8378,
    ERROR_DS_DUP_OID = 8379,
    ERROR_DS_DUP_MAPI_ID = 8380,
    ERROR_DS_DUP_SCHEMA_ID_GUID = 8381,
    ERROR_DS_DUP_LDAP_DISPLAY_NAME = 8382,
    ERROR_DS_SEMANTIC_ATT_TEST = 8383,
    ERROR_DS_SYNTAX_MISMATCH = 8384,
    ERROR_DS_EXISTS_IN_MUST_HAVE = 8385,
    ERROR_DS_EXISTS_IN_MAY_HAVE = 8386,
    ERROR_DS_NONEXISTENT_MAY_HAVE = 8387,
    ERROR_DS_NONEXISTENT_MUST_HAVE = 8388,
    ERROR_DS_AUX_CLS_TEST_FAIL = 8389,
    ERROR_DS_NONEXISTENT_POSS_SUP = 8390,
    ERROR_DS_SUB_CLS_TEST_FAIL = 8391,
    ERROR_DS_BAD_RDN_ATT_ID_SYNTAX = 8392,
    ERROR_DS_EXISTS_IN_AUX_CLS = 8393,
    ERROR_DS_EXISTS_IN_SUB_CLS = 8394,
    ERROR_DS_EXISTS_IN_POSS_SUP = 8395,
    ERROR_DS_RECALCSCHEMA_FAILED = 8396,
    ERROR_DS_TREE_DELETE_NOT_FINISHED = 8397,
    ERROR_DS_CANT_DELETE = 8398,
    ERROR_DS_ATT_SCHEMA_REQ_ID = 8399,
    ERROR_DS_BAD_ATT_SCHEMA_SYNTAX = 8400,
    ERROR_DS_CANT_CACHE_ATT = 8401,
    ERROR_DS_CANT_CACHE_CLASS = 8402,
    ERROR_DS_CANT_REMOVE_ATT_CACHE = 8403,
    ERROR_DS_CANT_REMOVE_CLASS_CACHE = 8404,
    ERROR_DS_CANT_RETRIEVE_DN = 8405,
    ERROR_DS_MISSING_SUPREF = 8406,
    ERROR_DS_CANT_RETRIEVE_INSTANCE = 8407,
    ERROR_DS_CODE_INCONSISTENCY = 8408,
    ERROR_DS_DATABASE_ERROR = 8409,
    ERROR_DS_GOVERNSID_MISSING = 8410,
    ERROR_DS_MISSING_EXPECTED_ATT = 8411,
    ERROR_DS_NCNAME_MISSING_CR_REF = 8412,
    ERROR_DS_SECURITY_CHECKING_ERROR = 8413,
    ERROR_DS_SCHEMA_NOT_LOADED = 8414,
    ERROR_DS_SCHEMA_ALLOC_FAILED = 8415,
    ERROR_DS_ATT_SCHEMA_REQ_SYNTAX = 8416,
    ERROR_DS_GCVERIFY_ERROR = 8417,
    ERROR_DS_DRA_SCHEMA_MISMATCH = 8418,
    ERROR_DS_CANT_FIND_DSA_OBJ = 8419,
    ERROR_DS_CANT_FIND_EXPECTED_NC = 8420,
    ERROR_DS_CANT_FIND_NC_IN_CACHE = 8421,
    ERROR_DS_CANT_RETRIEVE_CHILD = 8422,
    ERROR_DS_SECURITY_ILLEGAL_MODIFY = 8423,
    ERROR_DS_CANT_REPLACE_HIDDEN_REC = 8424,
    ERROR_DS_BAD_HIERARCHY_FILE = 8425,
    ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED = 8426,
    ERROR_DS_CONFIG_PARAM_MISSING = 8427,
    ERROR_DS_COUNTING_AB_INDICES_FAILED = 8428,
    ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED = 8429,
    ERROR_DS_INTERNAL_FAILURE = 8430,
    ERROR_DS_UNKNOWN_ERROR = 8431,
    ERROR_DS_ROOT_REQUIRES_CLASS_TOP = 8432,
    ERROR_DS_REFUSING_FSMO_ROLES = 8433,
    ERROR_DS_MISSING_FSMO_SETTINGS = 8434,
    ERROR_DS_UNABLE_TO_SURRENDER_ROLES = 8435,
    ERROR_DS_DRA_GENERIC = 8436,
    ERROR_DS_DRA_INVALID_PARAMETER = 8437,
    ERROR_DS_DRA_BUSY = 8438,
    ERROR_DS_DRA_BAD_DN = 8439,
    ERROR_DS_DRA_BAD_NC = 8440,
    ERROR_DS_DRA_DN_EXISTS = 8441,
    ERROR_DS_DRA_INTERNAL_ERROR = 8442,
    ERROR_DS_DRA_INCONSISTENT_DIT = 8443,
    ERROR_DS_DRA_CONNECTION_FAILED = 8444,
    ERROR_DS_DRA_BAD_INSTANCE_TYPE = 8445,
    ERROR_DS_DRA_OUT_OF_MEM = 8446,
    ERROR_DS_DRA_MAIL_PROBLEM = 8447,
    ERROR_DS_DRA_REF_ALREADY_EXISTS = 8448,
    ERROR_DS_DRA_REF_NOT_FOUND = 8449,
    ERROR_DS_DRA_OBJ_IS_REP_SOURCE = 8450,
    ERROR_DS_DRA_DB_ERROR = 8451,
    ERROR_DS_DRA_NO_REPLICA = 8452,
    ERROR_DS_DRA_ACCESS_DENIED = 8453,
    ERROR_DS_DRA_NOT_SUPPORTED = 8454,
    ERROR_DS_DRA_RPC_CANCELLED = 8455,
    ERROR_DS_DRA_SOURCE_DISABLED = 8456,
    ERROR_DS_DRA_SINK_DISABLED = 8457,
    ERROR_DS_DRA_NAME_COLLISION = 8458,
    ERROR_DS_DRA_SOURCE_REINSTALLED = 8459,
    ERROR_DS_DRA_MISSING_PARENT = 8460,
    ERROR_DS_DRA_PREEMPTED = 8461,
    ERROR_DS_DRA_ABANDON_SYNC = 8462,
    ERROR_DS_DRA_SHUTDOWN = 8463,
    ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET = 8464,
    ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA = 8465,
    ERROR_DS_DRA_EXTN_CONNECTION_FAILED = 8466,
    ERROR_DS_INSTALL_SCHEMA_MISMATCH = 8467,
    ERROR_DS_DUP_LINK_ID = 8468,
    ERROR_DS_NAME_ERROR_RESOLVING = 8469,
    ERROR_DS_NAME_ERROR_NOT_FOUND = 8470,
    ERROR_DS_NAME_ERROR_NOT_UNIQUE = 8471,
    ERROR_DS_NAME_ERROR_NO_MAPPING = 8472,
    ERROR_DS_NAME_ERROR_DOMAIN_ONLY = 8473,
    ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = 8474,
    ERROR_DS_CONSTRUCTED_ATT_MOD = 8475,
    ERROR_DS_WRONG_OM_OBJ_CLASS = 8476,
    ERROR_DS_DRA_REPL_PENDING = 8477,
    ERROR_DS_DS_REQUIRED = 8478,
    ERROR_DS_INVALID_LDAP_DISPLAY_NAME = 8479,
    ERROR_DS_NON_BASE_SEARCH = 8480,
    ERROR_DS_CANT_RETRIEVE_ATTS = 8481,
    ERROR_DS_BACKLINK_WITHOUT_LINK = 8482,
    ERROR_DS_EPOCH_MISMATCH = 8483,
    ERROR_DS_SRC_NAME_MISMATCH = 8484,
    ERROR_DS_SRC_AND_DST_NC_IDENTICAL = 8485,
    ERROR_DS_DST_NC_MISMATCH = 8486,
    ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC = 8487,
    ERROR_DS_SRC_GUID_MISMATCH = 8488,
    ERROR_DS_CANT_MOVE_DELETED_OBJECT = 8489,
    ERROR_DS_PDC_OPERATION_IN_PROGRESS = 8490,
    ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD = 8491,
    ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION = 8492,
    ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS = 8493,
    ERROR_DS_NC_MUST_HAVE_NC_PARENT = 8494,
    ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE = 8495,
    ERROR_DS_DST_DOMAIN_NOT_NATIVE = 8496,
    ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER = 8497,
    ERROR_DS_CANT_MOVE_ACCOUNT_GROUP = 8498,
    ERROR_DS_CANT_MOVE_RESOURCE_GROUP = 8499,
    ERROR_DS_INVALID_SEARCH_FLAG = 8500,
    ERROR_DS_NO_TREE_DELETE_ABOVE_NC = 8501,
    ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE = 8502,
    ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE = 8503,
    ERROR_DS_SAM_INIT_FAILURE = 8504,
    ERROR_DS_SENSITIVE_GROUP_VIOLATION = 8505,
    ERROR_DS_CANT_MOD_PRIMARYGROUPID = 8506,
    ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD = 8507,
    ERROR_DS_NONSAFE_SCHEMA_CHANGE = 8508,
    ERROR_DS_SCHEMA_UPDATE_DISALLOWED = 8509,
    ERROR_DS_CANT_CREATE_UNDER_SCHEMA = 8510,
    ERROR_DS_INSTALL_NO_SRC_SCH_VERSION = 8511,
    ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE = 8512,
    ERROR_DS_INVALID_GROUP_TYPE = 8513,
    ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = 8514,
    ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = 8515,
    ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = 8516,
    ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = 8517,
    ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = 8518,
    ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = 8519,
    ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = 8520,
    ERROR_DS_HAVE_PRIMARY_MEMBERS = 8521,
    ERROR_DS_STRING_SD_CONVERSION_FAILED = 8522,
    ERROR_DS_NAMING_MASTER_GC = 8523,
    ERROR_DS_DNS_LOOKUP_FAILURE = 8524,
    ERROR_DS_COULDNT_UPDATE_SPNS = 8525,
    ERROR_DS_CANT_RETRIEVE_SD = 8526,
    ERROR_DS_KEY_NOT_UNIQUE = 8527,
    ERROR_DS_WRONG_LINKED_ATT_SYNTAX = 8528,
    ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD = 8529,
    ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY = 8530,
    ERROR_DS_CANT_START = 8531,
    ERROR_DS_INIT_FAILURE = 8532,
    ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION = 8533,
    ERROR_DS_SOURCE_DOMAIN_IN_FOREST = 8534,
    ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST = 8535,
    ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED = 8536,
    ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN = 8537,
    ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER = 8538,
    ERROR_DS_SRC_SID_EXISTS_IN_FOREST = 8539,
    ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH = 8540,
    ERROR_SAM_INIT_FAILURE = 8541,
    ERROR_DS_DRA_SCHEMA_INFO_SHIP = 8542,
    ERROR_DS_DRA_SCHEMA_CONFLICT = 8543,
    ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT = 8544,
    ERROR_DS_DRA_OBJ_NC_MISMATCH = 8545,
    ERROR_DS_NC_STILL_HAS_DSAS = 8546,
    ERROR_DS_GC_REQUIRED = 8547,
    ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = 8548,
    ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS = 8549,
    ERROR_DS_CANT_ADD_TO_GC = 8550,
    ERROR_DS_NO_CHECKPOINT_WITH_PDC = 8551,
    ERROR_DS_SOURCE_AUDITING_NOT_ENABLED = 8552,
    ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC = 8553,
    ERROR_DS_INVALID_NAME_FOR_SPN = 8554,
    ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS = 8555,
    ERROR_DS_UNICODEPWD_NOT_IN_QUOTES = 8556,
    ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = 8557,
    ERROR_DS_MUST_BE_RUN_ON_DST_DC = 8558,
    ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER = 8559,
    ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ = 8560,
    ERROR_DS_INIT_FAILURE_CONSOLE = 8561,
    ERROR_DS_SAM_INIT_FAILURE_CONSOLE = 8562,
    ERROR_DS_FOREST_VERSION_TOO_HIGH = 8563,
    ERROR_DS_DOMAIN_VERSION_TOO_HIGH = 8564,
    ERROR_DS_FOREST_VERSION_TOO_LOW = 8565,
    ERROR_DS_DOMAIN_VERSION_TOO_LOW = 8566,
    ERROR_DS_INCOMPATIBLE_VERSION = 8567,
    ERROR_DS_LOW_DSA_VERSION = 8568,
    ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN = 8569,
    ERROR_DS_NOT_SUPPORTED_SORT_ORDER = 8570,
    ERROR_DS_NAME_NOT_UNIQUE = 8571,
    ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 = 8572,
    ERROR_DS_OUT_OF_VERSION_STORE = 8573,
    ERROR_DS_INCOMPATIBLE_CONTROLS_USED = 8574,
    ERROR_DS_NO_REF_DOMAIN = 8575,
    ERROR_DS_RESERVED_LINK_ID = 8576,
    ERROR_DS_LINK_ID_NOT_AVAILABLE = 8577,
    ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = 8578,
    ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE = 8579,
    ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC = 8580,
    ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG = 8581,
    ERROR_DS_MODIFYDN_WRONG_GRANDPARENT = 8582,
    ERROR_DS_NAME_ERROR_TRUST_REFERRAL = 8583,
    ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER = 8584,
    ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD = 8585,
    ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 = 8586,
    ERROR_DS_THREAD_LIMIT_EXCEEDED = 8587,
    ERROR_DS_NOT_CLOSEST = 8588,
    ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF = 8589,
    ERROR_DS_SINGLE_USER_MODE_FAILED = 8590,
    ERROR_DS_NTDSCRIPT_SYNTAX_ERROR = 8591,
    ERROR_DS_NTDSCRIPT_PROCESS_ERROR = 8592,
    ERROR_DS_DIFFERENT_REPL_EPOCHS = 8593,
    ERROR_DS_DRS_EXTENSIONS_CHANGED = 8594,
    ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR = 8595,
    ERROR_DS_NO_MSDS_INTID = 8596,
    ERROR_DS_DUP_MSDS_INTID = 8597,
    ERROR_DS_EXISTS_IN_RDNATTID = 8598,
    ERROR_DS_AUTHORIZATION_FAILED = 8599,
    ERROR_DS_INVALID_SCRIPT = 8600,
    ERROR_DS_REMOTE_CROSSREF_OP_FAILED = 8601,
    ERROR_DS_CROSS_REF_BUSY = 8602,
    ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN = 8603,
    ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC = 8604,
    ERROR_DS_DUPLICATE_ID_FOUND = 8605,
    ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT = 8606,
    ERROR_DS_GROUP_CONVERSION_ERROR = 8607,
    ERROR_DS_CANT_MOVE_APP_BASIC_GROUP = 8608,
    ERROR_DS_CANT_MOVE_APP_QUERY_GROUP = 8609,
    ERROR_DS_ROLE_NOT_VERIFIED = 8610,
    ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL = 8611,
    ERROR_DS_DOMAIN_RENAME_IN_PROGRESS = 8612,
    ERROR_DS_EXISTING_AD_CHILD_NC = 8613,
    ERROR_DS_REPL_LIFETIME_EXCEEDED = 8614,
    ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER = 8615,
    ERROR_DS_LDAP_SEND_QUEUE_FULL = 8616,
    ERROR_DS_DRA_OUT_SCHEDULE_WINDOW = 8617,
    ERROR_DS_POLICY_NOT_KNOWN = 8618,
    ERROR_NO_SITE_SETTINGS_OBJECT = 8619,
    ERROR_NO_SECRETS = 8620,
    ERROR_NO_WRITABLE_DC_FOUND = 8621,
    ERROR_DS_NO_SERVER_OBJECT = 8622,
    ERROR_DS_NO_NTDSA_OBJECT = 8623,
    ERROR_DS_NON_ASQ_SEARCH = 8624,
    ERROR_DS_AUDIT_FAILURE = 8625,
    ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE = 8626,
    ERROR_DS_INVALID_SEARCH_FLAG_TUPLE = 8627,
    ERROR_DS_HIERARCHY_TABLE_TOO_DEEP = 8628,
    ERROR_DS_DRA_CORRUPT_UTD_VECTOR = 8629,
    ERROR_DS_DRA_SECRETS_DENIED = 8630,
    ERROR_DS_RESERVED_MAPI_ID = 8631,
    ERROR_DS_MAPI_ID_NOT_AVAILABLE = 8632,
    ERROR_DS_DRA_MISSING_KRBTGT_SECRET = 8633,
    ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST = 8634,
    ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST = 8635,
    ERROR_INVALID_USER_PRINCIPAL_NAME = 8636,
    ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = 8637,
    ERROR_DS_OID_NOT_FOUND = 8638,
    ERROR_DS_DRA_RECYCLED_TARGET = 8639,
    ERROR_DS_DISALLOWED_NC_REDIRECT = 8640,
    ERROR_DS_HIGH_ADLDS_FFL = 8641,
    ERROR_DS_HIGH_DSA_VERSION = 8642,
    ERROR_DS_LOW_ADLDS_FFL = 8643,
    ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION = 8644,
    ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED = 8645,
    ERROR_INCORRECT_ACCOUNT_TYPE = 8646,
    ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST = 8647,
    ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST = 8648,
    ERROR_DS_MISSING_FOREST_TRUST = 8649,
    ERROR_DS_VALUE_KEY_NOT_UNIQUE = 8650,
    DNS_ERROR_RESPONSE_CODES_BASE = 9000,
    // DNS_ERROR_RCODE_NO_ERROR = 0, this enum value conflicts with NO_ERROR
    // DNS_ERROR_MASK = 9000, this enum value conflicts with DNS_ERROR_RESPONSE_CODES_BASE
    DNS_ERROR_RCODE_FORMAT_ERROR = 9001,
    DNS_ERROR_RCODE_SERVER_FAILURE = 9002,
    DNS_ERROR_RCODE_NAME_ERROR = 9003,
    DNS_ERROR_RCODE_NOT_IMPLEMENTED = 9004,
    DNS_ERROR_RCODE_REFUSED = 9005,
    DNS_ERROR_RCODE_YXDOMAIN = 9006,
    DNS_ERROR_RCODE_YXRRSET = 9007,
    DNS_ERROR_RCODE_NXRRSET = 9008,
    DNS_ERROR_RCODE_NOTAUTH = 9009,
    DNS_ERROR_RCODE_NOTZONE = 9010,
    DNS_ERROR_RCODE_BADSIG = 9016,
    DNS_ERROR_RCODE_BADKEY = 9017,
    DNS_ERROR_RCODE_BADTIME = 9018,
    // DNS_ERROR_RCODE_LAST = 9018, this enum value conflicts with DNS_ERROR_RCODE_BADTIME
    DNS_ERROR_DNSSEC_BASE = 9100,
    DNS_ERROR_KEYMASTER_REQUIRED = 9101,
    DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE = 9102,
    DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1 = 9103,
    DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS = 9104,
    DNS_ERROR_UNSUPPORTED_ALGORITHM = 9105,
    DNS_ERROR_INVALID_KEY_SIZE = 9106,
    DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE = 9107,
    DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION = 9108,
    DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR = 9109,
    DNS_ERROR_UNEXPECTED_CNG_ERROR = 9110,
    DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION = 9111,
    DNS_ERROR_KSP_NOT_ACCESSIBLE = 9112,
    DNS_ERROR_TOO_MANY_SKDS = 9113,
    DNS_ERROR_INVALID_ROLLOVER_PERIOD = 9114,
    DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET = 9115,
    DNS_ERROR_ROLLOVER_IN_PROGRESS = 9116,
    DNS_ERROR_STANDBY_KEY_NOT_PRESENT = 9117,
    DNS_ERROR_NOT_ALLOWED_ON_ZSK = 9118,
    DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD = 9119,
    DNS_ERROR_ROLLOVER_ALREADY_QUEUED = 9120,
    DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE = 9121,
    DNS_ERROR_BAD_KEYMASTER = 9122,
    DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD = 9123,
    DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT = 9124,
    DNS_ERROR_DNSSEC_IS_DISABLED = 9125,
    DNS_ERROR_INVALID_XML = 9126,
    DNS_ERROR_NO_VALID_TRUST_ANCHORS = 9127,
    DNS_ERROR_ROLLOVER_NOT_POKEABLE = 9128,
    DNS_ERROR_NSEC3_NAME_COLLISION = 9129,
    DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1 = 9130,
    DNS_ERROR_PACKET_FMT_BASE = 9500,
    DNS_ERROR_BAD_PACKET = 9502,
    DNS_ERROR_NO_PACKET = 9503,
    DNS_ERROR_RCODE = 9504,
    DNS_ERROR_UNSECURE_PACKET = 9505,
    // DNS_ERROR_NO_MEMORY = 14, this enum value conflicts with ERROR_OUTOFMEMORY
    // DNS_ERROR_INVALID_NAME = 123, this enum value conflicts with ERROR_INVALID_NAME
    // DNS_ERROR_INVALID_DATA = 13, this enum value conflicts with ERROR_INVALID_DATA
    DNS_ERROR_GENERAL_API_BASE = 9550,
    DNS_ERROR_INVALID_TYPE = 9551,
    DNS_ERROR_INVALID_IP_ADDRESS = 9552,
    DNS_ERROR_INVALID_PROPERTY = 9553,
    DNS_ERROR_TRY_AGAIN_LATER = 9554,
    DNS_ERROR_NOT_UNIQUE = 9555,
    DNS_ERROR_NON_RFC_NAME = 9556,
    DNS_ERROR_INVALID_NAME_CHAR = 9560,
    DNS_ERROR_NUMERIC_NAME = 9561,
    DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER = 9562,
    DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION = 9563,
    DNS_ERROR_CANNOT_FIND_ROOT_HINTS = 9564,
    DNS_ERROR_INCONSISTENT_ROOT_HINTS = 9565,
    DNS_ERROR_DWORD_VALUE_TOO_SMALL = 9566,
    DNS_ERROR_DWORD_VALUE_TOO_LARGE = 9567,
    DNS_ERROR_BACKGROUND_LOADING = 9568,
    DNS_ERROR_NOT_ALLOWED_ON_RODC = 9569,
    DNS_ERROR_NOT_ALLOWED_UNDER_DNAME = 9570,
    DNS_ERROR_DELEGATION_REQUIRED = 9571,
    DNS_ERROR_INVALID_POLICY_TABLE = 9572,
    DNS_ERROR_ADDRESS_REQUIRED = 9573,
    DNS_ERROR_ZONE_BASE = 9600,
    DNS_ERROR_ZONE_DOES_NOT_EXIST = 9601,
    DNS_ERROR_NO_ZONE_INFO = 9602,
    DNS_ERROR_INVALID_ZONE_OPERATION = 9603,
    DNS_ERROR_ZONE_CONFIGURATION_ERROR = 9604,
    DNS_ERROR_ZONE_HAS_NO_SOA_RECORD = 9605,
    DNS_ERROR_ZONE_HAS_NO_NS_RECORDS = 9606,
    DNS_ERROR_ZONE_LOCKED = 9607,
    DNS_ERROR_ZONE_CREATION_FAILED = 9608,
    DNS_ERROR_ZONE_ALREADY_EXISTS = 9609,
    DNS_ERROR_AUTOZONE_ALREADY_EXISTS = 9610,
    DNS_ERROR_INVALID_ZONE_TYPE = 9611,
    DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP = 9612,
    DNS_ERROR_ZONE_NOT_SECONDARY = 9613,
    DNS_ERROR_NEED_SECONDARY_ADDRESSES = 9614,
    DNS_ERROR_WINS_INIT_FAILED = 9615,
    DNS_ERROR_NEED_WINS_SERVERS = 9616,
    DNS_ERROR_NBSTAT_INIT_FAILED = 9617,
    DNS_ERROR_SOA_DELETE_INVALID = 9618,
    DNS_ERROR_FORWARDER_ALREADY_EXISTS = 9619,
    DNS_ERROR_ZONE_REQUIRES_MASTER_IP = 9620,
    DNS_ERROR_ZONE_IS_SHUTDOWN = 9621,
    DNS_ERROR_ZONE_LOCKED_FOR_SIGNING = 9622,
    DNS_ERROR_DATAFILE_BASE = 9650,
    DNS_ERROR_PRIMARY_REQUIRES_DATAFILE = 9651,
    DNS_ERROR_INVALID_DATAFILE_NAME = 9652,
    DNS_ERROR_DATAFILE_OPEN_FAILURE = 9653,
    DNS_ERROR_FILE_WRITEBACK_FAILED = 9654,
    DNS_ERROR_DATAFILE_PARSING = 9655,
    DNS_ERROR_DATABASE_BASE = 9700,
    DNS_ERROR_RECORD_DOES_NOT_EXIST = 9701,
    DNS_ERROR_RECORD_FORMAT = 9702,
    DNS_ERROR_NODE_CREATION_FAILED = 9703,
    DNS_ERROR_UNKNOWN_RECORD_TYPE = 9704,
    DNS_ERROR_RECORD_TIMED_OUT = 9705,
    DNS_ERROR_NAME_NOT_IN_ZONE = 9706,
    DNS_ERROR_CNAME_LOOP = 9707,
    DNS_ERROR_NODE_IS_CNAME = 9708,
    DNS_ERROR_CNAME_COLLISION = 9709,
    DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT = 9710,
    DNS_ERROR_RECORD_ALREADY_EXISTS = 9711,
    DNS_ERROR_SECONDARY_DATA = 9712,
    DNS_ERROR_NO_CREATE_CACHE_DATA = 9713,
    DNS_ERROR_NAME_DOES_NOT_EXIST = 9714,
    DNS_ERROR_DS_UNAVAILABLE = 9717,
    DNS_ERROR_DS_ZONE_ALREADY_EXISTS = 9718,
    DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE = 9719,
    DNS_ERROR_NODE_IS_DNAME = 9720,
    DNS_ERROR_DNAME_COLLISION = 9721,
    DNS_ERROR_ALIAS_LOOP = 9722,
    DNS_ERROR_OPERATION_BASE = 9750,
    DNS_ERROR_AXFR = 9752,
    DNS_ERROR_SECURE_BASE = 9800,
    DNS_ERROR_SETUP_BASE = 9850,
    DNS_ERROR_NO_TCPIP = 9851,
    DNS_ERROR_NO_DNS_SERVERS = 9852,
    DNS_ERROR_DP_BASE = 9900,
    DNS_ERROR_DP_DOES_NOT_EXIST = 9901,
    DNS_ERROR_DP_ALREADY_EXISTS = 9902,
    DNS_ERROR_DP_NOT_ENLISTED = 9903,
    DNS_ERROR_DP_ALREADY_ENLISTED = 9904,
    DNS_ERROR_DP_NOT_AVAILABLE = 9905,
    DNS_ERROR_DP_FSMO_ERROR = 9906,
    DNS_ERROR_RRL_NOT_ENABLED = 9911,
    DNS_ERROR_RRL_INVALID_WINDOW_SIZE = 9912,
    DNS_ERROR_RRL_INVALID_IPV4_PREFIX = 9913,
    DNS_ERROR_RRL_INVALID_IPV6_PREFIX = 9914,
    DNS_ERROR_RRL_INVALID_TC_RATE = 9915,
    DNS_ERROR_RRL_INVALID_LEAK_RATE = 9916,
    DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE = 9917,
    DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS = 9921,
    DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST = 9922,
    DNS_ERROR_VIRTUALIZATION_TREE_LOCKED = 9923,
    DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME = 9924,
    DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE = 9925,
    DNS_ERROR_ZONESCOPE_ALREADY_EXISTS = 9951,
    DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST = 9952,
    DNS_ERROR_DEFAULT_ZONESCOPE = 9953,
    DNS_ERROR_INVALID_ZONESCOPE_NAME = 9954,
    DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES = 9955,
    DNS_ERROR_LOAD_ZONESCOPE_FAILED = 9956,
    DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED = 9957,
    DNS_ERROR_INVALID_SCOPE_NAME = 9958,
    DNS_ERROR_SCOPE_DOES_NOT_EXIST = 9959,
    DNS_ERROR_DEFAULT_SCOPE = 9960,
    DNS_ERROR_INVALID_SCOPE_OPERATION = 9961,
    DNS_ERROR_SCOPE_LOCKED = 9962,
    DNS_ERROR_SCOPE_ALREADY_EXISTS = 9963,
    DNS_ERROR_POLICY_ALREADY_EXISTS = 9971,
    DNS_ERROR_POLICY_DOES_NOT_EXIST = 9972,
    DNS_ERROR_POLICY_INVALID_CRITERIA = 9973,
    DNS_ERROR_POLICY_INVALID_SETTINGS = 9974,
    DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED = 9975,
    DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST = 9976,
    DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS = 9977,
    DNS_ERROR_SUBNET_DOES_NOT_EXIST = 9978,
    DNS_ERROR_SUBNET_ALREADY_EXISTS = 9979,
    DNS_ERROR_POLICY_LOCKED = 9980,
    DNS_ERROR_POLICY_INVALID_WEIGHT = 9981,
    DNS_ERROR_POLICY_INVALID_NAME = 9982,
    DNS_ERROR_POLICY_MISSING_CRITERIA = 9983,
    DNS_ERROR_INVALID_CLIENT_SUBNET_NAME = 9984,
    DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID = 9985,
    DNS_ERROR_POLICY_SCOPE_MISSING = 9986,
    DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED = 9987,
    DNS_ERROR_SERVERSCOPE_IS_REFERENCED = 9988,
    DNS_ERROR_ZONESCOPE_IS_REFERENCED = 9989,
    DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET = 9990,
    DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL = 9991,
    DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL = 9992,
    DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE = 9993,
    DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN = 9994,
    DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE = 9995,
    DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY = 9996,
    ERROR_IPSEC_QM_POLICY_EXISTS = 13000,
    ERROR_IPSEC_QM_POLICY_NOT_FOUND = 13001,
    ERROR_IPSEC_QM_POLICY_IN_USE = 13002,
    ERROR_IPSEC_MM_POLICY_EXISTS = 13003,
    ERROR_IPSEC_MM_POLICY_NOT_FOUND = 13004,
    ERROR_IPSEC_MM_POLICY_IN_USE = 13005,
    ERROR_IPSEC_MM_FILTER_EXISTS = 13006,
    ERROR_IPSEC_MM_FILTER_NOT_FOUND = 13007,
    ERROR_IPSEC_TRANSPORT_FILTER_EXISTS = 13008,
    ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND = 13009,
    ERROR_IPSEC_MM_AUTH_EXISTS = 13010,
    ERROR_IPSEC_MM_AUTH_NOT_FOUND = 13011,
    ERROR_IPSEC_MM_AUTH_IN_USE = 13012,
    ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND = 13013,
    ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND = 13014,
    ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND = 13015,
    ERROR_IPSEC_TUNNEL_FILTER_EXISTS = 13016,
    ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND = 13017,
    ERROR_IPSEC_MM_FILTER_PENDING_DELETION = 13018,
    ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION = 13019,
    ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION = 13020,
    ERROR_IPSEC_MM_POLICY_PENDING_DELETION = 13021,
    ERROR_IPSEC_MM_AUTH_PENDING_DELETION = 13022,
    ERROR_IPSEC_QM_POLICY_PENDING_DELETION = 13023,
    ERROR_IPSEC_IKE_NEG_STATUS_BEGIN = 13800,
    ERROR_IPSEC_IKE_AUTH_FAIL = 13801,
    ERROR_IPSEC_IKE_ATTRIB_FAIL = 13802,
    ERROR_IPSEC_IKE_NEGOTIATION_PENDING = 13803,
    ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR = 13804,
    ERROR_IPSEC_IKE_TIMED_OUT = 13805,
    ERROR_IPSEC_IKE_NO_CERT = 13806,
    ERROR_IPSEC_IKE_SA_DELETED = 13807,
    ERROR_IPSEC_IKE_SA_REAPED = 13808,
    ERROR_IPSEC_IKE_MM_ACQUIRE_DROP = 13809,
    ERROR_IPSEC_IKE_QM_ACQUIRE_DROP = 13810,
    ERROR_IPSEC_IKE_QUEUE_DROP_MM = 13811,
    ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM = 13812,
    ERROR_IPSEC_IKE_DROP_NO_RESPONSE = 13813,
    ERROR_IPSEC_IKE_MM_DELAY_DROP = 13814,
    ERROR_IPSEC_IKE_QM_DELAY_DROP = 13815,
    ERROR_IPSEC_IKE_ERROR = 13816,
    ERROR_IPSEC_IKE_CRL_FAILED = 13817,
    ERROR_IPSEC_IKE_INVALID_KEY_USAGE = 13818,
    ERROR_IPSEC_IKE_INVALID_CERT_TYPE = 13819,
    ERROR_IPSEC_IKE_NO_PRIVATE_KEY = 13820,
    ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY = 13821,
    ERROR_IPSEC_IKE_DH_FAIL = 13822,
    ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED = 13823,
    ERROR_IPSEC_IKE_INVALID_HEADER = 13824,
    ERROR_IPSEC_IKE_NO_POLICY = 13825,
    ERROR_IPSEC_IKE_INVALID_SIGNATURE = 13826,
    ERROR_IPSEC_IKE_KERBEROS_ERROR = 13827,
    ERROR_IPSEC_IKE_NO_PUBLIC_KEY = 13828,
    ERROR_IPSEC_IKE_PROCESS_ERR = 13829,
    ERROR_IPSEC_IKE_PROCESS_ERR_SA = 13830,
    ERROR_IPSEC_IKE_PROCESS_ERR_PROP = 13831,
    ERROR_IPSEC_IKE_PROCESS_ERR_TRANS = 13832,
    ERROR_IPSEC_IKE_PROCESS_ERR_KE = 13833,
    ERROR_IPSEC_IKE_PROCESS_ERR_ID = 13834,
    ERROR_IPSEC_IKE_PROCESS_ERR_CERT = 13835,
    ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ = 13836,
    ERROR_IPSEC_IKE_PROCESS_ERR_HASH = 13837,
    ERROR_IPSEC_IKE_PROCESS_ERR_SIG = 13838,
    ERROR_IPSEC_IKE_PROCESS_ERR_NONCE = 13839,
    ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY = 13840,
    ERROR_IPSEC_IKE_PROCESS_ERR_DELETE = 13841,
    ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR = 13842,
    ERROR_IPSEC_IKE_INVALID_PAYLOAD = 13843,
    ERROR_IPSEC_IKE_LOAD_SOFT_SA = 13844,
    ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN = 13845,
    ERROR_IPSEC_IKE_INVALID_COOKIE = 13846,
    ERROR_IPSEC_IKE_NO_PEER_CERT = 13847,
    ERROR_IPSEC_IKE_PEER_CRL_FAILED = 13848,
    ERROR_IPSEC_IKE_POLICY_CHANGE = 13849,
    ERROR_IPSEC_IKE_NO_MM_POLICY = 13850,
    ERROR_IPSEC_IKE_NOTCBPRIV = 13851,
    ERROR_IPSEC_IKE_SECLOADFAIL = 13852,
    ERROR_IPSEC_IKE_FAILSSPINIT = 13853,
    ERROR_IPSEC_IKE_FAILQUERYSSP = 13854,
    ERROR_IPSEC_IKE_SRVACQFAIL = 13855,
    ERROR_IPSEC_IKE_SRVQUERYCRED = 13856,
    ERROR_IPSEC_IKE_GETSPIFAIL = 13857,
    ERROR_IPSEC_IKE_INVALID_FILTER = 13858,
    ERROR_IPSEC_IKE_OUT_OF_MEMORY = 13859,
    ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED = 13860,
    ERROR_IPSEC_IKE_INVALID_POLICY = 13861,
    ERROR_IPSEC_IKE_UNKNOWN_DOI = 13862,
    ERROR_IPSEC_IKE_INVALID_SITUATION = 13863,
    ERROR_IPSEC_IKE_DH_FAILURE = 13864,
    ERROR_IPSEC_IKE_INVALID_GROUP = 13865,
    ERROR_IPSEC_IKE_ENCRYPT = 13866,
    ERROR_IPSEC_IKE_DECRYPT = 13867,
    ERROR_IPSEC_IKE_POLICY_MATCH = 13868,
    ERROR_IPSEC_IKE_UNSUPPORTED_ID = 13869,
    ERROR_IPSEC_IKE_INVALID_HASH = 13870,
    ERROR_IPSEC_IKE_INVALID_HASH_ALG = 13871,
    ERROR_IPSEC_IKE_INVALID_HASH_SIZE = 13872,
    ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG = 13873,
    ERROR_IPSEC_IKE_INVALID_AUTH_ALG = 13874,
    ERROR_IPSEC_IKE_INVALID_SIG = 13875,
    ERROR_IPSEC_IKE_LOAD_FAILED = 13876,
    ERROR_IPSEC_IKE_RPC_DELETE = 13877,
    ERROR_IPSEC_IKE_BENIGN_REINIT = 13878,
    ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY = 13879,
    ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION = 13880,
    ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN = 13881,
    ERROR_IPSEC_IKE_MM_LIMIT = 13882,
    ERROR_IPSEC_IKE_NEGOTIATION_DISABLED = 13883,
    ERROR_IPSEC_IKE_QM_LIMIT = 13884,
    ERROR_IPSEC_IKE_MM_EXPIRED = 13885,
    ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID = 13886,
    ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH = 13887,
    ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID = 13888,
    ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD = 13889,
    ERROR_IPSEC_IKE_DOS_COOKIE_SENT = 13890,
    ERROR_IPSEC_IKE_SHUTTING_DOWN = 13891,
    ERROR_IPSEC_IKE_CGA_AUTH_FAILED = 13892,
    ERROR_IPSEC_IKE_PROCESS_ERR_NATOA = 13893,
    ERROR_IPSEC_IKE_INVALID_MM_FOR_QM = 13894,
    ERROR_IPSEC_IKE_QM_EXPIRED = 13895,
    ERROR_IPSEC_IKE_TOO_MANY_FILTERS = 13896,
    ERROR_IPSEC_IKE_NEG_STATUS_END = 13897,
    ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL = 13898,
    ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE = 13899,
    ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING = 13900,
    ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING = 13901,
    ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS = 13902,
    ERROR_IPSEC_IKE_RATELIMIT_DROP = 13903,
    ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE = 13904,
    ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE = 13905,
    ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE = 13906,
    ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY = 13907,
    ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE = 13908,
    ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END = 13909,
    ERROR_IPSEC_BAD_SPI = 13910,
    ERROR_IPSEC_SA_LIFETIME_EXPIRED = 13911,
    ERROR_IPSEC_WRONG_SA = 13912,
    ERROR_IPSEC_REPLAY_CHECK_FAILED = 13913,
    ERROR_IPSEC_INVALID_PACKET = 13914,
    ERROR_IPSEC_INTEGRITY_CHECK_FAILED = 13915,
    ERROR_IPSEC_CLEAR_TEXT_DROP = 13916,
    ERROR_IPSEC_AUTH_FIREWALL_DROP = 13917,
    ERROR_IPSEC_THROTTLE_DROP = 13918,
    ERROR_IPSEC_DOSP_BLOCK = 13925,
    ERROR_IPSEC_DOSP_RECEIVED_MULTICAST = 13926,
    ERROR_IPSEC_DOSP_INVALID_PACKET = 13927,
    ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED = 13928,
    ERROR_IPSEC_DOSP_MAX_ENTRIES = 13929,
    ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = 13930,
    ERROR_IPSEC_DOSP_NOT_INSTALLED = 13931,
    ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = 13932,
    ERROR_SXS_SECTION_NOT_FOUND = 14000,
    ERROR_SXS_CANT_GEN_ACTCTX = 14001,
    ERROR_SXS_INVALID_ACTCTXDATA_FORMAT = 14002,
    ERROR_SXS_ASSEMBLY_NOT_FOUND = 14003,
    ERROR_SXS_MANIFEST_FORMAT_ERROR = 14004,
    ERROR_SXS_MANIFEST_PARSE_ERROR = 14005,
    ERROR_SXS_ACTIVATION_CONTEXT_DISABLED = 14006,
    ERROR_SXS_KEY_NOT_FOUND = 14007,
    ERROR_SXS_VERSION_CONFLICT = 14008,
    ERROR_SXS_WRONG_SECTION_TYPE = 14009,
    ERROR_SXS_THREAD_QUERIES_DISABLED = 14010,
    ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET = 14011,
    ERROR_SXS_UNKNOWN_ENCODING_GROUP = 14012,
    ERROR_SXS_UNKNOWN_ENCODING = 14013,
    ERROR_SXS_INVALID_XML_NAMESPACE_URI = 14014,
    ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED = 14015,
    ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED = 14016,
    ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE = 14017,
    ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE = 14018,
    ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE = 14019,
    ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT = 14020,
    ERROR_SXS_DUPLICATE_DLL_NAME = 14021,
    ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME = 14022,
    ERROR_SXS_DUPLICATE_CLSID = 14023,
    ERROR_SXS_DUPLICATE_IID = 14024,
    ERROR_SXS_DUPLICATE_TLBID = 14025,
    ERROR_SXS_DUPLICATE_PROGID = 14026,
    ERROR_SXS_DUPLICATE_ASSEMBLY_NAME = 14027,
    ERROR_SXS_FILE_HASH_MISMATCH = 14028,
    ERROR_SXS_POLICY_PARSE_ERROR = 14029,
    ERROR_SXS_XML_E_MISSINGQUOTE = 14030,
    ERROR_SXS_XML_E_COMMENTSYNTAX = 14031,
    ERROR_SXS_XML_E_BADSTARTNAMECHAR = 14032,
    ERROR_SXS_XML_E_BADNAMECHAR = 14033,
    ERROR_SXS_XML_E_BADCHARINSTRING = 14034,
    ERROR_SXS_XML_E_XMLDECLSYNTAX = 14035,
    ERROR_SXS_XML_E_BADCHARDATA = 14036,
    ERROR_SXS_XML_E_MISSINGWHITESPACE = 14037,
    ERROR_SXS_XML_E_EXPECTINGTAGEND = 14038,
    ERROR_SXS_XML_E_MISSINGSEMICOLON = 14039,
    ERROR_SXS_XML_E_UNBALANCEDPAREN = 14040,
    ERROR_SXS_XML_E_INTERNALERROR = 14041,
    ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE = 14042,
    ERROR_SXS_XML_E_INCOMPLETE_ENCODING = 14043,
    ERROR_SXS_XML_E_MISSING_PAREN = 14044,
    ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE = 14045,
    ERROR_SXS_XML_E_MULTIPLE_COLONS = 14046,
    ERROR_SXS_XML_E_INVALID_DECIMAL = 14047,
    ERROR_SXS_XML_E_INVALID_HEXIDECIMAL = 14048,
    ERROR_SXS_XML_E_INVALID_UNICODE = 14049,
    ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK = 14050,
    ERROR_SXS_XML_E_UNEXPECTEDENDTAG = 14051,
    ERROR_SXS_XML_E_UNCLOSEDTAG = 14052,
    ERROR_SXS_XML_E_DUPLICATEATTRIBUTE = 14053,
    ERROR_SXS_XML_E_MULTIPLEROOTS = 14054,
    ERROR_SXS_XML_E_INVALIDATROOTLEVEL = 14055,
    ERROR_SXS_XML_E_BADXMLDECL = 14056,
    ERROR_SXS_XML_E_MISSINGROOT = 14057,
    ERROR_SXS_XML_E_UNEXPECTEDEOF = 14058,
    ERROR_SXS_XML_E_BADPEREFINSUBSET = 14059,
    ERROR_SXS_XML_E_UNCLOSEDSTARTTAG = 14060,
    ERROR_SXS_XML_E_UNCLOSEDENDTAG = 14061,
    ERROR_SXS_XML_E_UNCLOSEDSTRING = 14062,
    ERROR_SXS_XML_E_UNCLOSEDCOMMENT = 14063,
    ERROR_SXS_XML_E_UNCLOSEDDECL = 14064,
    ERROR_SXS_XML_E_UNCLOSEDCDATA = 14065,
    ERROR_SXS_XML_E_RESERVEDNAMESPACE = 14066,
    ERROR_SXS_XML_E_INVALIDENCODING = 14067,
    ERROR_SXS_XML_E_INVALIDSWITCH = 14068,
    ERROR_SXS_XML_E_BADXMLCASE = 14069,
    ERROR_SXS_XML_E_INVALID_STANDALONE = 14070,
    ERROR_SXS_XML_E_UNEXPECTED_STANDALONE = 14071,
    ERROR_SXS_XML_E_INVALID_VERSION = 14072,
    ERROR_SXS_XML_E_MISSINGEQUALS = 14073,
    ERROR_SXS_PROTECTION_RECOVERY_FAILED = 14074,
    ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT = 14075,
    ERROR_SXS_PROTECTION_CATALOG_NOT_VALID = 14076,
    ERROR_SXS_UNTRANSLATABLE_HRESULT = 14077,
    ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING = 14078,
    ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE = 14079,
    ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME = 14080,
    ERROR_SXS_ASSEMBLY_MISSING = 14081,
    ERROR_SXS_CORRUPT_ACTIVATION_STACK = 14082,
    ERROR_SXS_CORRUPTION = 14083,
    ERROR_SXS_EARLY_DEACTIVATION = 14084,
    ERROR_SXS_INVALID_DEACTIVATION = 14085,
    ERROR_SXS_MULTIPLE_DEACTIVATION = 14086,
    ERROR_SXS_PROCESS_TERMINATION_REQUESTED = 14087,
    ERROR_SXS_RELEASE_ACTIVATION_CONTEXT = 14088,
    ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = 14089,
    ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = 14090,
    ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = 14091,
    ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = 14092,
    ERROR_SXS_IDENTITY_PARSE_ERROR = 14093,
    ERROR_MALFORMED_SUBSTITUTION_STRING = 14094,
    ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN = 14095,
    ERROR_UNMAPPED_SUBSTITUTION_STRING = 14096,
    ERROR_SXS_ASSEMBLY_NOT_LOCKED = 14097,
    ERROR_SXS_COMPONENT_STORE_CORRUPT = 14098,
    ERROR_ADVANCED_INSTALLER_FAILED = 14099,
    ERROR_XML_ENCODING_MISMATCH = 14100,
    ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = 14101,
    ERROR_SXS_IDENTITIES_DIFFERENT = 14102,
    ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = 14103,
    ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY = 14104,
    ERROR_SXS_MANIFEST_TOO_BIG = 14105,
    ERROR_SXS_SETTING_NOT_REGISTERED = 14106,
    ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE = 14107,
    ERROR_SMI_PRIMITIVE_INSTALLER_FAILED = 14108,
    ERROR_GENERIC_COMMAND_FAILED = 14109,
    ERROR_SXS_FILE_HASH_MISSING = 14110,
    ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS = 14111,
    ERROR_EVT_INVALID_CHANNEL_PATH = 15000,
    ERROR_EVT_INVALID_QUERY = 15001,
    ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND = 15002,
    ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND = 15003,
    ERROR_EVT_INVALID_PUBLISHER_NAME = 15004,
    ERROR_EVT_INVALID_EVENT_DATA = 15005,
    ERROR_EVT_CHANNEL_NOT_FOUND = 15007,
    ERROR_EVT_MALFORMED_XML_TEXT = 15008,
    ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL = 15009,
    ERROR_EVT_CONFIGURATION_ERROR = 15010,
    ERROR_EVT_QUERY_RESULT_STALE = 15011,
    ERROR_EVT_QUERY_RESULT_INVALID_POSITION = 15012,
    ERROR_EVT_NON_VALIDATING_MSXML = 15013,
    ERROR_EVT_FILTER_ALREADYSCOPED = 15014,
    ERROR_EVT_FILTER_NOTELTSET = 15015,
    ERROR_EVT_FILTER_INVARG = 15016,
    ERROR_EVT_FILTER_INVTEST = 15017,
    ERROR_EVT_FILTER_INVTYPE = 15018,
    ERROR_EVT_FILTER_PARSEERR = 15019,
    ERROR_EVT_FILTER_UNSUPPORTEDOP = 15020,
    ERROR_EVT_FILTER_UNEXPECTEDTOKEN = 15021,
    ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL = 15022,
    ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE = 15023,
    ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE = 15024,
    ERROR_EVT_CHANNEL_CANNOT_ACTIVATE = 15025,
    ERROR_EVT_FILTER_TOO_COMPLEX = 15026,
    ERROR_EVT_MESSAGE_NOT_FOUND = 15027,
    ERROR_EVT_MESSAGE_ID_NOT_FOUND = 15028,
    ERROR_EVT_UNRESOLVED_VALUE_INSERT = 15029,
    ERROR_EVT_UNRESOLVED_PARAMETER_INSERT = 15030,
    ERROR_EVT_MAX_INSERTS_REACHED = 15031,
    ERROR_EVT_EVENT_DEFINITION_NOT_FOUND = 15032,
    ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND = 15033,
    ERROR_EVT_VERSION_TOO_OLD = 15034,
    ERROR_EVT_VERSION_TOO_NEW = 15035,
    ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY = 15036,
    ERROR_EVT_PUBLISHER_DISABLED = 15037,
    ERROR_EVT_FILTER_OUT_OF_RANGE = 15038,
    ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE = 15080,
    ERROR_EC_LOG_DISABLED = 15081,
    ERROR_EC_CIRCULAR_FORWARDING = 15082,
    ERROR_EC_CREDSTORE_FULL = 15083,
    ERROR_EC_CRED_NOT_FOUND = 15084,
    ERROR_EC_NO_ACTIVE_CHANNEL = 15085,
    ERROR_MUI_FILE_NOT_FOUND = 15100,
    ERROR_MUI_INVALID_FILE = 15101,
    ERROR_MUI_INVALID_RC_CONFIG = 15102,
    ERROR_MUI_INVALID_LOCALE_NAME = 15103,
    ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME = 15104,
    ERROR_MUI_FILE_NOT_LOADED = 15105,
    ERROR_RESOURCE_ENUM_USER_STOP = 15106,
    ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED = 15107,
    ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME = 15108,
    ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE = 15110,
    ERROR_MRM_INVALID_PRICONFIG = 15111,
    ERROR_MRM_INVALID_FILE_TYPE = 15112,
    ERROR_MRM_UNKNOWN_QUALIFIER = 15113,
    ERROR_MRM_INVALID_QUALIFIER_VALUE = 15114,
    ERROR_MRM_NO_CANDIDATE = 15115,
    ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE = 15116,
    ERROR_MRM_RESOURCE_TYPE_MISMATCH = 15117,
    ERROR_MRM_DUPLICATE_MAP_NAME = 15118,
    ERROR_MRM_DUPLICATE_ENTRY = 15119,
    ERROR_MRM_INVALID_RESOURCE_IDENTIFIER = 15120,
    ERROR_MRM_FILEPATH_TOO_LONG = 15121,
    ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE = 15122,
    ERROR_MRM_INVALID_PRI_FILE = 15126,
    ERROR_MRM_NAMED_RESOURCE_NOT_FOUND = 15127,
    ERROR_MRM_MAP_NOT_FOUND = 15135,
    ERROR_MRM_UNSUPPORTED_PROFILE_TYPE = 15136,
    ERROR_MRM_INVALID_QUALIFIER_OPERATOR = 15137,
    ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE = 15138,
    ERROR_MRM_AUTOMERGE_ENABLED = 15139,
    ERROR_MRM_TOO_MANY_RESOURCES = 15140,
    ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE = 15141,
    ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE = 15142,
    ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD = 15143,
    ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST = 15144,
    ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT = 15145,
    ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE = 15146,
    ERROR_MRM_GENERATION_COUNT_MISMATCH = 15147,
    ERROR_PRI_MERGE_VERSION_MISMATCH = 15148,
    ERROR_PRI_MERGE_MISSING_SCHEMA = 15149,
    ERROR_PRI_MERGE_LOAD_FILE_FAILED = 15150,
    ERROR_PRI_MERGE_ADD_FILE_FAILED = 15151,
    ERROR_PRI_MERGE_WRITE_FILE_FAILED = 15152,
    ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED = 15153,
    ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED = 15154,
    ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED = 15155,
    ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED = 15156,
    ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED = 15157,
    ERROR_PRI_MERGE_INVALID_FILE_NAME = 15158,
    ERROR_MRM_PACKAGE_NOT_FOUND = 15159,
    ERROR_MRM_MISSING_DEFAULT_LANGUAGE = 15160,
    ERROR_MCA_INVALID_CAPABILITIES_STRING = 15200,
    ERROR_MCA_INVALID_VCP_VERSION = 15201,
    ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = 15202,
    ERROR_MCA_MCCS_VERSION_MISMATCH = 15203,
    ERROR_MCA_UNSUPPORTED_MCCS_VERSION = 15204,
    ERROR_MCA_INTERNAL_ERROR = 15205,
    ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = 15206,
    ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE = 15207,
    ERROR_AMBIGUOUS_SYSTEM_DEVICE = 15250,
    ERROR_SYSTEM_DEVICE_NOT_FOUND = 15299,
    ERROR_HASH_NOT_SUPPORTED = 15300,
    ERROR_HASH_NOT_PRESENT = 15301,
    ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED = 15321,
    ERROR_GPIO_CLIENT_INFORMATION_INVALID = 15322,
    ERROR_GPIO_VERSION_NOT_SUPPORTED = 15323,
    ERROR_GPIO_INVALID_REGISTRATION_PACKET = 15324,
    ERROR_GPIO_OPERATION_DENIED = 15325,
    ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE = 15326,
    ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED = 15327,
    ERROR_CANNOT_SWITCH_RUNLEVEL = 15400,
    ERROR_INVALID_RUNLEVEL_SETTING = 15401,
    ERROR_RUNLEVEL_SWITCH_TIMEOUT = 15402,
    ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT = 15403,
    ERROR_RUNLEVEL_SWITCH_IN_PROGRESS = 15404,
    ERROR_SERVICES_FAILED_AUTOSTART = 15405,
    ERROR_COM_TASK_STOP_PENDING = 15501,
    ERROR_INSTALL_OPEN_PACKAGE_FAILED = 15600,
    ERROR_INSTALL_PACKAGE_NOT_FOUND = 15601,
    ERROR_INSTALL_INVALID_PACKAGE = 15602,
    ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED = 15603,
    ERROR_INSTALL_OUT_OF_DISK_SPACE = 15604,
    ERROR_INSTALL_NETWORK_FAILURE = 15605,
    ERROR_INSTALL_REGISTRATION_FAILURE = 15606,
    ERROR_INSTALL_DEREGISTRATION_FAILURE = 15607,
    ERROR_INSTALL_CANCEL = 15608,
    ERROR_INSTALL_FAILED = 15609,
    ERROR_REMOVE_FAILED = 15610,
    ERROR_PACKAGE_ALREADY_EXISTS = 15611,
    ERROR_NEEDS_REMEDIATION = 15612,
    ERROR_INSTALL_PREREQUISITE_FAILED = 15613,
    ERROR_PACKAGE_REPOSITORY_CORRUPTED = 15614,
    ERROR_INSTALL_POLICY_FAILURE = 15615,
    ERROR_PACKAGE_UPDATING = 15616,
    ERROR_DEPLOYMENT_BLOCKED_BY_POLICY = 15617,
    ERROR_PACKAGES_IN_USE = 15618,
    ERROR_RECOVERY_FILE_CORRUPT = 15619,
    ERROR_INVALID_STAGED_SIGNATURE = 15620,
    ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED = 15621,
    ERROR_INSTALL_PACKAGE_DOWNGRADE = 15622,
    ERROR_SYSTEM_NEEDS_REMEDIATION = 15623,
    ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN = 15624,
    ERROR_RESILIENCY_FILE_CORRUPT = 15625,
    ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING = 15626,
    ERROR_PACKAGE_MOVE_FAILED = 15627,
    ERROR_INSTALL_VOLUME_NOT_EMPTY = 15628,
    ERROR_INSTALL_VOLUME_OFFLINE = 15629,
    ERROR_INSTALL_VOLUME_CORRUPT = 15630,
    ERROR_NEEDS_REGISTRATION = 15631,
    ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE = 15632,
    ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED = 15633,
    ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE = 15634,
    ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM = 15635,
    ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING = 15636,
    ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE = 15637,
    ERROR_PACKAGE_STAGING_ONHOLD = 15638,
    ERROR_INSTALL_INVALID_RELATED_SET_UPDATE = 15639,
    ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY = 15640,
    ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF = 15641,
    ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED = 15642,
    ERROR_PACKAGES_REPUTATION_CHECK_FAILED = 15643,
    ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT = 15644,
    ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED = 15645,
    ERROR_APPINSTALLER_ACTIVATION_BLOCKED = 15646,
    ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED = 15647,
    ERROR_APPX_RAW_DATA_WRITE_FAILED = 15648,
    ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE = 15649,
    ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE = 15650,
    ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY = 15651,
    ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY = 15652,
    ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER = 15653,
    ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED = 15654,
    ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE = 15655,
    ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES = 15656,
    ERROR_REDIRECTION_TO_DEFAULT_ACCOUNT_NOT_ALLOWED = 15657,
    ERROR_PACKAGE_LACKS_CAPABILITY_TO_DEPLOY_ON_HOST = 15658,
    ERROR_UNSIGNED_PACKAGE_INVALID_CONTENT = 15659,
    ERROR_UNSIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE = 15660,
    ERROR_SIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE = 15661,
    ERROR_PACKAGE_EXTERNAL_LOCATION_NOT_ALLOWED = 15662,
    ERROR_INSTALL_FULLTRUST_HOSTRUNTIME_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY = 15663,
    ERROR_STATE_LOAD_STORE_FAILED = 15800,
    ERROR_STATE_GET_VERSION_FAILED = 15801,
    ERROR_STATE_SET_VERSION_FAILED = 15802,
    ERROR_STATE_STRUCTURED_RESET_FAILED = 15803,
    ERROR_STATE_OPEN_CONTAINER_FAILED = 15804,
    ERROR_STATE_CREATE_CONTAINER_FAILED = 15805,
    ERROR_STATE_DELETE_CONTAINER_FAILED = 15806,
    ERROR_STATE_READ_SETTING_FAILED = 15807,
    ERROR_STATE_WRITE_SETTING_FAILED = 15808,
    ERROR_STATE_DELETE_SETTING_FAILED = 15809,
    ERROR_STATE_QUERY_SETTING_FAILED = 15810,
    ERROR_STATE_READ_COMPOSITE_SETTING_FAILED = 15811,
    ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED = 15812,
    ERROR_STATE_ENUMERATE_CONTAINER_FAILED = 15813,
    ERROR_STATE_ENUMERATE_SETTINGS_FAILED = 15814,
    ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = 15815,
    ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = 15816,
    ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED = 15817,
    ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED = 15818,
    ERROR_API_UNAVAILABLE = 15841,
    ERROR_NDIS_INTERFACE_CLOSING = 2150891522,
    ERROR_NDIS_BAD_VERSION = 2150891524,
    ERROR_NDIS_BAD_CHARACTERISTICS = 2150891525,
    ERROR_NDIS_ADAPTER_NOT_FOUND = 2150891526,
    ERROR_NDIS_OPEN_FAILED = 2150891527,
    ERROR_NDIS_DEVICE_FAILED = 2150891528,
    ERROR_NDIS_MULTICAST_FULL = 2150891529,
    ERROR_NDIS_MULTICAST_EXISTS = 2150891530,
    ERROR_NDIS_MULTICAST_NOT_FOUND = 2150891531,
    ERROR_NDIS_REQUEST_ABORTED = 2150891532,
    ERROR_NDIS_RESET_IN_PROGRESS = 2150891533,
    ERROR_NDIS_NOT_SUPPORTED = 2150891707,
    ERROR_NDIS_INVALID_PACKET = 2150891535,
    ERROR_NDIS_ADAPTER_NOT_READY = 2150891537,
    ERROR_NDIS_INVALID_LENGTH = 2150891540,
    ERROR_NDIS_INVALID_DATA = 2150891541,
    ERROR_NDIS_BUFFER_TOO_SHORT = 2150891542,
    ERROR_NDIS_INVALID_OID = 2150891543,
    ERROR_NDIS_ADAPTER_REMOVED = 2150891544,
    ERROR_NDIS_UNSUPPORTED_MEDIA = 2150891545,
    ERROR_NDIS_GROUP_ADDRESS_IN_USE = 2150891546,
    ERROR_NDIS_FILE_NOT_FOUND = 2150891547,
    ERROR_NDIS_ERROR_READING_FILE = 2150891548,
    ERROR_NDIS_ALREADY_MAPPED = 2150891549,
    ERROR_NDIS_RESOURCE_CONFLICT = 2150891550,
    ERROR_NDIS_MEDIA_DISCONNECTED = 2150891551,
    ERROR_NDIS_INVALID_ADDRESS = 2150891554,
    ERROR_NDIS_INVALID_DEVICE_REQUEST = 2150891536,
    ERROR_NDIS_PAUSED = 2150891562,
    ERROR_NDIS_INTERFACE_NOT_FOUND = 2150891563,
    ERROR_NDIS_UNSUPPORTED_REVISION = 2150891564,
    ERROR_NDIS_INVALID_PORT = 2150891565,
    ERROR_NDIS_INVALID_PORT_STATE = 2150891566,
    ERROR_NDIS_LOW_POWER_STATE = 2150891567,
    ERROR_NDIS_REINIT_REQUIRED = 2150891568,
    ERROR_NDIS_NO_QUEUES = 2150891569,
    ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED = 2150899712,
    ERROR_NDIS_DOT11_MEDIA_IN_USE = 2150899713,
    ERROR_NDIS_DOT11_POWER_STATE_INVALID = 2150899714,
    ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL = 2150899715,
    ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = 2150899716,
    ERROR_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE = 2150899717,
    ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE = 2150899718,
    ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED = 2150899719,
    ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED = 2150899720,
    ERROR_NDIS_INDICATION_REQUIRED = 3407873,
    ERROR_NDIS_OFFLOAD_POLICY = 3224637455,
    ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED = 3224637458,
    ERROR_NDIS_OFFLOAD_PATH_REJECTED = 3224637459,
    ERROR_HV_INVALID_HYPERCALL_CODE = 3224698882,
    ERROR_HV_INVALID_HYPERCALL_INPUT = 3224698883,
    ERROR_HV_INVALID_ALIGNMENT = 3224698884,
    ERROR_HV_INVALID_PARAMETER = 3224698885,
    ERROR_HV_ACCESS_DENIED = 3224698886,
    ERROR_HV_INVALID_PARTITION_STATE = 3224698887,
    ERROR_HV_OPERATION_DENIED = 3224698888,
    ERROR_HV_UNKNOWN_PROPERTY = 3224698889,
    ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE = 3224698890,
    ERROR_HV_INSUFFICIENT_MEMORY = 3224698891,
    ERROR_HV_PARTITION_TOO_DEEP = 3224698892,
    ERROR_HV_INVALID_PARTITION_ID = 3224698893,
    ERROR_HV_INVALID_VP_INDEX = 3224698894,
    ERROR_HV_INVALID_PORT_ID = 3224698897,
    ERROR_HV_INVALID_CONNECTION_ID = 3224698898,
    ERROR_HV_INSUFFICIENT_BUFFERS = 3224698899,
    ERROR_HV_NOT_ACKNOWLEDGED = 3224698900,
    ERROR_HV_INVALID_VP_STATE = 3224698901,
    ERROR_HV_ACKNOWLEDGED = 3224698902,
    ERROR_HV_INVALID_SAVE_RESTORE_STATE = 3224698903,
    ERROR_HV_INVALID_SYNIC_STATE = 3224698904,
    ERROR_HV_OBJECT_IN_USE = 3224698905,
    ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO = 3224698906,
    ERROR_HV_NO_DATA = 3224698907,
    ERROR_HV_INACTIVE = 3224698908,
    ERROR_HV_NO_RESOURCES = 3224698909,
    ERROR_HV_FEATURE_UNAVAILABLE = 3224698910,
    ERROR_HV_INSUFFICIENT_BUFFER = 3224698931,
    ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS = 3224698936,
    ERROR_HV_CPUID_FEATURE_VALIDATION = 3224698940,
    ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION = 3224698941,
    ERROR_HV_PROCESSOR_STARTUP_TIMEOUT = 3224698942,
    ERROR_HV_SMX_ENABLED = 3224698943,
    ERROR_HV_INVALID_LP_INDEX = 3224698945,
    ERROR_HV_INVALID_REGISTER_VALUE = 3224698960,
    ERROR_HV_INVALID_VTL_STATE = 3224698961,
    ERROR_HV_NX_NOT_DETECTED = 3224698965,
    ERROR_HV_INVALID_DEVICE_ID = 3224698967,
    ERROR_HV_INVALID_DEVICE_STATE = 3224698968,
    ERROR_HV_PENDING_PAGE_REQUESTS = 3473497,
    ERROR_HV_PAGE_REQUEST_INVALID = 3224698976,
    ERROR_HV_INVALID_CPU_GROUP_ID = 3224698991,
    ERROR_HV_INVALID_CPU_GROUP_STATE = 3224698992,
    ERROR_HV_OPERATION_FAILED = 3224698993,
    ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE = 3224698994,
    ERROR_HV_INSUFFICIENT_ROOT_MEMORY = 3224698995,
    ERROR_HV_EVENT_BUFFER_ALREADY_FREED = 3224698996,
    ERROR_HV_INSUFFICIENT_CONTIGUOUS_MEMORY = 3224698997,
    ERROR_HV_NOT_PRESENT = 3224702976,
    ERROR_VID_DUPLICATE_HANDLER = 3224829953,
    ERROR_VID_TOO_MANY_HANDLERS = 3224829954,
    ERROR_VID_QUEUE_FULL = 3224829955,
    ERROR_VID_HANDLER_NOT_PRESENT = 3224829956,
    ERROR_VID_INVALID_OBJECT_NAME = 3224829957,
    ERROR_VID_PARTITION_NAME_TOO_LONG = 3224829958,
    ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG = 3224829959,
    ERROR_VID_PARTITION_ALREADY_EXISTS = 3224829960,
    ERROR_VID_PARTITION_DOES_NOT_EXIST = 3224829961,
    ERROR_VID_PARTITION_NAME_NOT_FOUND = 3224829962,
    ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS = 3224829963,
    ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = 3224829964,
    ERROR_VID_MB_STILL_REFERENCED = 3224829965,
    ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED = 3224829966,
    ERROR_VID_INVALID_NUMA_SETTINGS = 3224829967,
    ERROR_VID_INVALID_NUMA_NODE_INDEX = 3224829968,
    ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED = 3224829969,
    ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE = 3224829970,
    ERROR_VID_PAGE_RANGE_OVERFLOW = 3224829971,
    ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE = 3224829972,
    ERROR_VID_INVALID_GPA_RANGE_HANDLE = 3224829973,
    ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE = 3224829974,
    ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = 3224829975,
    ERROR_VID_INVALID_PPM_HANDLE = 3224829976,
    ERROR_VID_MBPS_ARE_LOCKED = 3224829977,
    ERROR_VID_MESSAGE_QUEUE_CLOSED = 3224829978,
    ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED = 3224829979,
    ERROR_VID_STOP_PENDING = 3224829980,
    ERROR_VID_INVALID_PROCESSOR_STATE = 3224829981,
    ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT = 3224829982,
    ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED = 3224829983,
    ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET = 3224829984,
    ERROR_VID_MMIO_RANGE_DESTROYED = 3224829985,
    ERROR_VID_INVALID_CHILD_GPA_PAGE_SET = 3224829986,
    ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED = 3224829987,
    ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL = 3224829988,
    ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE = 3224829989,
    ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT = 3224829990,
    ERROR_VID_SAVED_STATE_CORRUPT = 3224829991,
    ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM = 3224829992,
    ERROR_VID_SAVED_STATE_INCOMPATIBLE = 3224829993,
    ERROR_VID_VTL_ACCESS_DENIED = 3224829994,
    ERROR_VMCOMPUTE_TERMINATED_DURING_START = 3224830208,
    ERROR_VMCOMPUTE_IMAGE_MISMATCH = 3224830209,
    ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED = 3224830210,
    ERROR_VMCOMPUTE_OPERATION_PENDING = 3224830211,
    ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS = 3224830212,
    ERROR_VMCOMPUTE_INVALID_STATE = 3224830213,
    ERROR_VMCOMPUTE_UNEXPECTED_EXIT = 3224830214,
    ERROR_VMCOMPUTE_TERMINATED = 3224830215,
    ERROR_VMCOMPUTE_CONNECT_FAILED = 3224830216,
    ERROR_VMCOMPUTE_TIMEOUT = 3224830217,
    ERROR_VMCOMPUTE_CONNECTION_CLOSED = 3224830218,
    ERROR_VMCOMPUTE_UNKNOWN_MESSAGE = 3224830219,
    ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION = 3224830220,
    ERROR_VMCOMPUTE_INVALID_JSON = 3224830221,
    ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND = 3224830222,
    ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS = 3224830223,
    ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED = 3224830224,
    ERROR_VMCOMPUTE_PROTOCOL_ERROR = 3224830225,
    ERROR_VMCOMPUTE_INVALID_LAYER = 3224830226,
    ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED = 3224830227,
    ERROR_VNET_VIRTUAL_SWITCH_NAME_NOT_FOUND = 3224830464,
    ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED = 2151088129,
    ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND = 3224830976,
    ERROR_VSMB_SAVED_STATE_CORRUPT = 3224830977,
    ERROR_VOLMGR_INCOMPLETE_REGENERATION = 2151153665,
    ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION = 2151153666,
    ERROR_VOLMGR_DATABASE_FULL = 3224895489,
    ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED = 3224895490,
    ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = 3224895491,
    ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED = 3224895492,
    ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME = 3224895493,
    ERROR_VOLMGR_DISK_DUPLICATE = 3224895494,
    ERROR_VOLMGR_DISK_DYNAMIC = 3224895495,
    ERROR_VOLMGR_DISK_ID_INVALID = 3224895496,
    ERROR_VOLMGR_DISK_INVALID = 3224895497,
    ERROR_VOLMGR_DISK_LAST_VOTER = 3224895498,
    ERROR_VOLMGR_DISK_LAYOUT_INVALID = 3224895499,
    ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = 3224895500,
    ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED = 3224895501,
    ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL = 3224895502,
    ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = 3224895503,
    ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS = 3224895504,
    ERROR_VOLMGR_DISK_MISSING = 3224895505,
    ERROR_VOLMGR_DISK_NOT_EMPTY = 3224895506,
    ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE = 3224895507,
    ERROR_VOLMGR_DISK_REVECTORING_FAILED = 3224895508,
    ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID = 3224895509,
    ERROR_VOLMGR_DISK_SET_NOT_CONTAINED = 3224895510,
    ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS = 3224895511,
    ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES = 3224895512,
    ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED = 3224895513,
    ERROR_VOLMGR_EXTENT_ALREADY_USED = 3224895514,
    ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS = 3224895515,
    ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION = 3224895516,
    ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED = 3224895517,
    ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION = 3224895518,
    ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = 3224895519,
    ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED = 3224895520,
    ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID = 3224895521,
    ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS = 3224895522,
    ERROR_VOLMGR_MEMBER_IN_SYNC = 3224895523,
    ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE = 3224895524,
    ERROR_VOLMGR_MEMBER_INDEX_INVALID = 3224895525,
    ERROR_VOLMGR_MEMBER_MISSING = 3224895526,
    ERROR_VOLMGR_MEMBER_NOT_DETACHED = 3224895527,
    ERROR_VOLMGR_MEMBER_REGENERATING = 3224895528,
    ERROR_VOLMGR_ALL_DISKS_FAILED = 3224895529,
    ERROR_VOLMGR_NO_REGISTERED_USERS = 3224895530,
    ERROR_VOLMGR_NO_SUCH_USER = 3224895531,
    ERROR_VOLMGR_NOTIFICATION_RESET = 3224895532,
    ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID = 3224895533,
    ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID = 3224895534,
    ERROR_VOLMGR_PACK_DUPLICATE = 3224895535,
    ERROR_VOLMGR_PACK_ID_INVALID = 3224895536,
    ERROR_VOLMGR_PACK_INVALID = 3224895537,
    ERROR_VOLMGR_PACK_NAME_INVALID = 3224895538,
    ERROR_VOLMGR_PACK_OFFLINE = 3224895539,
    ERROR_VOLMGR_PACK_HAS_QUORUM = 3224895540,
    ERROR_VOLMGR_PACK_WITHOUT_QUORUM = 3224895541,
    ERROR_VOLMGR_PARTITION_STYLE_INVALID = 3224895542,
    ERROR_VOLMGR_PARTITION_UPDATE_FAILED = 3224895543,
    ERROR_VOLMGR_PLEX_IN_SYNC = 3224895544,
    ERROR_VOLMGR_PLEX_INDEX_DUPLICATE = 3224895545,
    ERROR_VOLMGR_PLEX_INDEX_INVALID = 3224895546,
    ERROR_VOLMGR_PLEX_LAST_ACTIVE = 3224895547,
    ERROR_VOLMGR_PLEX_MISSING = 3224895548,
    ERROR_VOLMGR_PLEX_REGENERATING = 3224895549,
    ERROR_VOLMGR_PLEX_TYPE_INVALID = 3224895550,
    ERROR_VOLMGR_PLEX_NOT_RAID5 = 3224895551,
    ERROR_VOLMGR_PLEX_NOT_SIMPLE = 3224895552,
    ERROR_VOLMGR_STRUCTURE_SIZE_INVALID = 3224895553,
    ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS = 3224895554,
    ERROR_VOLMGR_TRANSACTION_IN_PROGRESS = 3224895555,
    ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE = 3224895556,
    ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK = 3224895557,
    ERROR_VOLMGR_VOLUME_ID_INVALID = 3224895558,
    ERROR_VOLMGR_VOLUME_LENGTH_INVALID = 3224895559,
    ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = 3224895560,
    ERROR_VOLMGR_VOLUME_NOT_MIRRORED = 3224895561,
    ERROR_VOLMGR_VOLUME_NOT_RETAINED = 3224895562,
    ERROR_VOLMGR_VOLUME_OFFLINE = 3224895563,
    ERROR_VOLMGR_VOLUME_RETAINED = 3224895564,
    ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID = 3224895565,
    ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE = 3224895566,
    ERROR_VOLMGR_BAD_BOOT_DISK = 3224895567,
    ERROR_VOLMGR_PACK_CONFIG_OFFLINE = 3224895568,
    ERROR_VOLMGR_PACK_CONFIG_ONLINE = 3224895569,
    ERROR_VOLMGR_NOT_PRIMARY_PACK = 3224895570,
    ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED = 3224895571,
    ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID = 3224895572,
    ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = 3224895573,
    ERROR_VOLMGR_VOLUME_MIRRORED = 3224895574,
    ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = 3224895575,
    ERROR_VOLMGR_NO_VALID_LOG_COPIES = 3224895576,
    ERROR_VOLMGR_PRIMARY_PACK_PRESENT = 3224895577,
    ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID = 3224895578,
    ERROR_VOLMGR_MIRROR_NOT_SUPPORTED = 3224895579,
    ERROR_VOLMGR_RAID5_NOT_SUPPORTED = 3224895580,
    ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED = 2151219201,
    ERROR_BCD_TOO_MANY_ELEMENTS = 3224961026,
    ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED = 2151219203,
    ERROR_VHD_DRIVE_FOOTER_MISSING = 3225026561,
    ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = 3225026562,
    ERROR_VHD_DRIVE_FOOTER_CORRUPT = 3225026563,
    ERROR_VHD_FORMAT_UNKNOWN = 3225026564,
    ERROR_VHD_FORMAT_UNSUPPORTED_VERSION = 3225026565,
    ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH = 3225026566,
    ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = 3225026567,
    ERROR_VHD_SPARSE_HEADER_CORRUPT = 3225026568,
    ERROR_VHD_BLOCK_ALLOCATION_FAILURE = 3225026569,
    ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = 3225026570,
    ERROR_VHD_INVALID_BLOCK_SIZE = 3225026571,
    ERROR_VHD_BITMAP_MISMATCH = 3225026572,
    ERROR_VHD_PARENT_VHD_NOT_FOUND = 3225026573,
    ERROR_VHD_CHILD_PARENT_ID_MISMATCH = 3225026574,
    ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = 3225026575,
    ERROR_VHD_METADATA_READ_FAILURE = 3225026576,
    ERROR_VHD_METADATA_WRITE_FAILURE = 3225026577,
    ERROR_VHD_INVALID_SIZE = 3225026578,
    ERROR_VHD_INVALID_FILE_SIZE = 3225026579,
    ERROR_VIRTDISK_PROVIDER_NOT_FOUND = 3225026580,
    ERROR_VIRTDISK_NOT_VIRTUAL_DISK = 3225026581,
    ERROR_VHD_PARENT_VHD_ACCESS_DENIED = 3225026582,
    ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH = 3225026583,
    ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = 3225026584,
    ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = 3225026585,
    ERROR_VIRTUAL_DISK_LIMITATION = 3225026586,
    ERROR_VHD_INVALID_TYPE = 3225026587,
    ERROR_VHD_INVALID_STATE = 3225026588,
    ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE = 3225026589,
    ERROR_VIRTDISK_DISK_ALREADY_OWNED = 3225026590,
    ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE = 3225026591,
    ERROR_CTLOG_TRACKING_NOT_INITIALIZED = 3225026592,
    ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE = 3225026593,
    ERROR_CTLOG_VHD_CHANGED_OFFLINE = 3225026594,
    ERROR_CTLOG_INVALID_TRACKING_STATE = 3225026595,
    ERROR_CTLOG_INCONSISTENT_TRACKING_FILE = 3225026596,
    ERROR_VHD_RESIZE_WOULD_TRUNCATE_DATA = 3225026597,
    ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE = 3225026598,
    ERROR_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE = 3225026599,
    ERROR_VHD_METADATA_FULL = 3225026600,
    ERROR_VHD_INVALID_CHANGE_TRACKING_ID = 3225026601,
    ERROR_VHD_CHANGE_TRACKING_DISABLED = 3225026602,
    ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION = 3225026608,
    ERROR_QUERY_STORAGE_ERROR = 2151284737,
};
pub const NO_ERROR = WIN32_ERROR.NO_ERROR;
pub const ERROR_SUCCESS = WIN32_ERROR.NO_ERROR;
pub const ERROR_INVALID_FUNCTION = WIN32_ERROR.ERROR_INVALID_FUNCTION;
pub const ERROR_FILE_NOT_FOUND = WIN32_ERROR.ERROR_FILE_NOT_FOUND;
pub const ERROR_PATH_NOT_FOUND = WIN32_ERROR.ERROR_PATH_NOT_FOUND;
pub const ERROR_TOO_MANY_OPEN_FILES = WIN32_ERROR.ERROR_TOO_MANY_OPEN_FILES;
pub const ERROR_ACCESS_DENIED = WIN32_ERROR.ERROR_ACCESS_DENIED;
pub const ERROR_INVALID_HANDLE = WIN32_ERROR.ERROR_INVALID_HANDLE;
pub const ERROR_ARENA_TRASHED = WIN32_ERROR.ERROR_ARENA_TRASHED;
pub const ERROR_NOT_ENOUGH_MEMORY = WIN32_ERROR.ERROR_NOT_ENOUGH_MEMORY;
pub const ERROR_INVALID_BLOCK = WIN32_ERROR.ERROR_INVALID_BLOCK;
pub const ERROR_BAD_ENVIRONMENT = WIN32_ERROR.ERROR_BAD_ENVIRONMENT;
pub const ERROR_BAD_FORMAT = WIN32_ERROR.ERROR_BAD_FORMAT;
pub const ERROR_INVALID_ACCESS = WIN32_ERROR.ERROR_INVALID_ACCESS;
pub const ERROR_INVALID_DATA = WIN32_ERROR.ERROR_INVALID_DATA;
pub const ERROR_OUTOFMEMORY = WIN32_ERROR.ERROR_OUTOFMEMORY;
pub const ERROR_INVALID_DRIVE = WIN32_ERROR.ERROR_INVALID_DRIVE;
pub const ERROR_CURRENT_DIRECTORY = WIN32_ERROR.ERROR_CURRENT_DIRECTORY;
pub const ERROR_NOT_SAME_DEVICE = WIN32_ERROR.ERROR_NOT_SAME_DEVICE;
pub const ERROR_NO_MORE_FILES = WIN32_ERROR.ERROR_NO_MORE_FILES;
pub const ERROR_WRITE_PROTECT = WIN32_ERROR.ERROR_WRITE_PROTECT;
pub const ERROR_BAD_UNIT = WIN32_ERROR.ERROR_BAD_UNIT;
pub const ERROR_NOT_READY = WIN32_ERROR.ERROR_NOT_READY;
pub const ERROR_BAD_COMMAND = WIN32_ERROR.ERROR_BAD_COMMAND;
pub const ERROR_CRC = WIN32_ERROR.ERROR_CRC;
pub const ERROR_BAD_LENGTH = WIN32_ERROR.ERROR_BAD_LENGTH;
pub const ERROR_SEEK = WIN32_ERROR.ERROR_SEEK;
pub const ERROR_NOT_DOS_DISK = WIN32_ERROR.ERROR_NOT_DOS_DISK;
pub const ERROR_SECTOR_NOT_FOUND = WIN32_ERROR.ERROR_SECTOR_NOT_FOUND;
pub const ERROR_OUT_OF_PAPER = WIN32_ERROR.ERROR_OUT_OF_PAPER;
pub const ERROR_WRITE_FAULT = WIN32_ERROR.ERROR_WRITE_FAULT;
pub const ERROR_READ_FAULT = WIN32_ERROR.ERROR_READ_FAULT;
pub const ERROR_GEN_FAILURE = WIN32_ERROR.ERROR_GEN_FAILURE;
pub const ERROR_SHARING_VIOLATION = WIN32_ERROR.ERROR_SHARING_VIOLATION;
pub const ERROR_LOCK_VIOLATION = WIN32_ERROR.ERROR_LOCK_VIOLATION;
pub const ERROR_WRONG_DISK = WIN32_ERROR.ERROR_WRONG_DISK;
pub const ERROR_SHARING_BUFFER_EXCEEDED = WIN32_ERROR.ERROR_SHARING_BUFFER_EXCEEDED;
pub const ERROR_HANDLE_EOF = WIN32_ERROR.ERROR_HANDLE_EOF;
pub const ERROR_HANDLE_DISK_FULL = WIN32_ERROR.ERROR_HANDLE_DISK_FULL;
pub const ERROR_NOT_SUPPORTED = WIN32_ERROR.ERROR_NOT_SUPPORTED;
pub const ERROR_REM_NOT_LIST = WIN32_ERROR.ERROR_REM_NOT_LIST;
pub const ERROR_DUP_NAME = WIN32_ERROR.ERROR_DUP_NAME;
pub const ERROR_BAD_NETPATH = WIN32_ERROR.ERROR_BAD_NETPATH;
pub const ERROR_NETWORK_BUSY = WIN32_ERROR.ERROR_NETWORK_BUSY;
pub const ERROR_DEV_NOT_EXIST = WIN32_ERROR.ERROR_DEV_NOT_EXIST;
pub const ERROR_TOO_MANY_CMDS = WIN32_ERROR.ERROR_TOO_MANY_CMDS;
pub const ERROR_ADAP_HDW_ERR = WIN32_ERROR.ERROR_ADAP_HDW_ERR;
pub const ERROR_BAD_NET_RESP = WIN32_ERROR.ERROR_BAD_NET_RESP;
pub const ERROR_UNEXP_NET_ERR = WIN32_ERROR.ERROR_UNEXP_NET_ERR;
pub const ERROR_BAD_REM_ADAP = WIN32_ERROR.ERROR_BAD_REM_ADAP;
pub const ERROR_PRINTQ_FULL = WIN32_ERROR.ERROR_PRINTQ_FULL;
pub const ERROR_NO_SPOOL_SPACE = WIN32_ERROR.ERROR_NO_SPOOL_SPACE;
pub const ERROR_PRINT_CANCELLED = WIN32_ERROR.ERROR_PRINT_CANCELLED;
pub const ERROR_NETNAME_DELETED = WIN32_ERROR.ERROR_NETNAME_DELETED;
pub const ERROR_NETWORK_ACCESS_DENIED = WIN32_ERROR.ERROR_NETWORK_ACCESS_DENIED;
pub const ERROR_BAD_DEV_TYPE = WIN32_ERROR.ERROR_BAD_DEV_TYPE;
pub const ERROR_BAD_NET_NAME = WIN32_ERROR.ERROR_BAD_NET_NAME;
pub const ERROR_TOO_MANY_NAMES = WIN32_ERROR.ERROR_TOO_MANY_NAMES;
pub const ERROR_TOO_MANY_SESS = WIN32_ERROR.ERROR_TOO_MANY_SESS;
pub const ERROR_SHARING_PAUSED = WIN32_ERROR.ERROR_SHARING_PAUSED;
pub const ERROR_REQ_NOT_ACCEP = WIN32_ERROR.ERROR_REQ_NOT_ACCEP;
pub const ERROR_REDIR_PAUSED = WIN32_ERROR.ERROR_REDIR_PAUSED;
pub const ERROR_FILE_EXISTS = WIN32_ERROR.ERROR_FILE_EXISTS;
pub const ERROR_CANNOT_MAKE = WIN32_ERROR.ERROR_CANNOT_MAKE;
pub const ERROR_FAIL_I24 = WIN32_ERROR.ERROR_FAIL_I24;
pub const ERROR_OUT_OF_STRUCTURES = WIN32_ERROR.ERROR_OUT_OF_STRUCTURES;
pub const ERROR_ALREADY_ASSIGNED = WIN32_ERROR.ERROR_ALREADY_ASSIGNED;
pub const ERROR_INVALID_PASSWORD = WIN32_ERROR.ERROR_INVALID_PASSWORD;
pub const ERROR_INVALID_PARAMETER = WIN32_ERROR.ERROR_INVALID_PARAMETER;
pub const ERROR_NET_WRITE_FAULT = WIN32_ERROR.ERROR_NET_WRITE_FAULT;
pub const ERROR_NO_PROC_SLOTS = WIN32_ERROR.ERROR_NO_PROC_SLOTS;
pub const ERROR_TOO_MANY_SEMAPHORES = WIN32_ERROR.ERROR_TOO_MANY_SEMAPHORES;
pub const ERROR_EXCL_SEM_ALREADY_OWNED = WIN32_ERROR.ERROR_EXCL_SEM_ALREADY_OWNED;
pub const ERROR_SEM_IS_SET = WIN32_ERROR.ERROR_SEM_IS_SET;
pub const ERROR_TOO_MANY_SEM_REQUESTS = WIN32_ERROR.ERROR_TOO_MANY_SEM_REQUESTS;
pub const ERROR_INVALID_AT_INTERRUPT_TIME = WIN32_ERROR.ERROR_INVALID_AT_INTERRUPT_TIME;
pub const ERROR_SEM_OWNER_DIED = WIN32_ERROR.ERROR_SEM_OWNER_DIED;
pub const ERROR_SEM_USER_LIMIT = WIN32_ERROR.ERROR_SEM_USER_LIMIT;
pub const ERROR_DISK_CHANGE = WIN32_ERROR.ERROR_DISK_CHANGE;
pub const ERROR_DRIVE_LOCKED = WIN32_ERROR.ERROR_DRIVE_LOCKED;
pub const ERROR_BROKEN_PIPE = WIN32_ERROR.ERROR_BROKEN_PIPE;
pub const ERROR_OPEN_FAILED = WIN32_ERROR.ERROR_OPEN_FAILED;
pub const ERROR_BUFFER_OVERFLOW = WIN32_ERROR.ERROR_BUFFER_OVERFLOW;
pub const ERROR_DISK_FULL = WIN32_ERROR.ERROR_DISK_FULL;
pub const ERROR_NO_MORE_SEARCH_HANDLES = WIN32_ERROR.ERROR_NO_MORE_SEARCH_HANDLES;
pub const ERROR_INVALID_TARGET_HANDLE = WIN32_ERROR.ERROR_INVALID_TARGET_HANDLE;
pub const ERROR_INVALID_CATEGORY = WIN32_ERROR.ERROR_INVALID_CATEGORY;
pub const ERROR_INVALID_VERIFY_SWITCH = WIN32_ERROR.ERROR_INVALID_VERIFY_SWITCH;
pub const ERROR_BAD_DRIVER_LEVEL = WIN32_ERROR.ERROR_BAD_DRIVER_LEVEL;
pub const ERROR_CALL_NOT_IMPLEMENTED = WIN32_ERROR.ERROR_CALL_NOT_IMPLEMENTED;
pub const ERROR_SEM_TIMEOUT = WIN32_ERROR.ERROR_SEM_TIMEOUT;
pub const ERROR_INSUFFICIENT_BUFFER = WIN32_ERROR.ERROR_INSUFFICIENT_BUFFER;
pub const ERROR_INVALID_NAME = WIN32_ERROR.ERROR_INVALID_NAME;
pub const ERROR_INVALID_LEVEL = WIN32_ERROR.ERROR_INVALID_LEVEL;
pub const ERROR_NO_VOLUME_LABEL = WIN32_ERROR.ERROR_NO_VOLUME_LABEL;
pub const ERROR_MOD_NOT_FOUND = WIN32_ERROR.ERROR_MOD_NOT_FOUND;
pub const ERROR_PROC_NOT_FOUND = WIN32_ERROR.ERROR_PROC_NOT_FOUND;
pub const ERROR_WAIT_NO_CHILDREN = WIN32_ERROR.ERROR_WAIT_NO_CHILDREN;
pub const ERROR_CHILD_NOT_COMPLETE = WIN32_ERROR.ERROR_CHILD_NOT_COMPLETE;
pub const ERROR_DIRECT_ACCESS_HANDLE = WIN32_ERROR.ERROR_DIRECT_ACCESS_HANDLE;
pub const ERROR_NEGATIVE_SEEK = WIN32_ERROR.ERROR_NEGATIVE_SEEK;
pub const ERROR_SEEK_ON_DEVICE = WIN32_ERROR.ERROR_SEEK_ON_DEVICE;
pub const ERROR_IS_JOIN_TARGET = WIN32_ERROR.ERROR_IS_JOIN_TARGET;
pub const ERROR_IS_JOINED = WIN32_ERROR.ERROR_IS_JOINED;
pub const ERROR_IS_SUBSTED = WIN32_ERROR.ERROR_IS_SUBSTED;
pub const ERROR_NOT_JOINED = WIN32_ERROR.ERROR_NOT_JOINED;
pub const ERROR_NOT_SUBSTED = WIN32_ERROR.ERROR_NOT_SUBSTED;
pub const ERROR_JOIN_TO_JOIN = WIN32_ERROR.ERROR_JOIN_TO_JOIN;
pub const ERROR_SUBST_TO_SUBST = WIN32_ERROR.ERROR_SUBST_TO_SUBST;
pub const ERROR_JOIN_TO_SUBST = WIN32_ERROR.ERROR_JOIN_TO_SUBST;
pub const ERROR_SUBST_TO_JOIN = WIN32_ERROR.ERROR_SUBST_TO_JOIN;
pub const ERROR_BUSY_DRIVE = WIN32_ERROR.ERROR_BUSY_DRIVE;
pub const ERROR_SAME_DRIVE = WIN32_ERROR.ERROR_SAME_DRIVE;
pub const ERROR_DIR_NOT_ROOT = WIN32_ERROR.ERROR_DIR_NOT_ROOT;
pub const ERROR_DIR_NOT_EMPTY = WIN32_ERROR.ERROR_DIR_NOT_EMPTY;
pub const ERROR_IS_SUBST_PATH = WIN32_ERROR.ERROR_IS_SUBST_PATH;
pub const ERROR_IS_JOIN_PATH = WIN32_ERROR.ERROR_IS_JOIN_PATH;
pub const ERROR_PATH_BUSY = WIN32_ERROR.ERROR_PATH_BUSY;
pub const ERROR_IS_SUBST_TARGET = WIN32_ERROR.ERROR_IS_SUBST_TARGET;
pub const ERROR_SYSTEM_TRACE = WIN32_ERROR.ERROR_SYSTEM_TRACE;
pub const ERROR_INVALID_EVENT_COUNT = WIN32_ERROR.ERROR_INVALID_EVENT_COUNT;
pub const ERROR_TOO_MANY_MUXWAITERS = WIN32_ERROR.ERROR_TOO_MANY_MUXWAITERS;
pub const ERROR_INVALID_LIST_FORMAT = WIN32_ERROR.ERROR_INVALID_LIST_FORMAT;
pub const ERROR_LABEL_TOO_LONG = WIN32_ERROR.ERROR_LABEL_TOO_LONG;
pub const ERROR_TOO_MANY_TCBS = WIN32_ERROR.ERROR_TOO_MANY_TCBS;
pub const ERROR_SIGNAL_REFUSED = WIN32_ERROR.ERROR_SIGNAL_REFUSED;
pub const ERROR_DISCARDED = WIN32_ERROR.ERROR_DISCARDED;
pub const ERROR_NOT_LOCKED = WIN32_ERROR.ERROR_NOT_LOCKED;
pub const ERROR_BAD_THREADID_ADDR = WIN32_ERROR.ERROR_BAD_THREADID_ADDR;
pub const ERROR_BAD_ARGUMENTS = WIN32_ERROR.ERROR_BAD_ARGUMENTS;
pub const ERROR_BAD_PATHNAME = WIN32_ERROR.ERROR_BAD_PATHNAME;
pub const ERROR_SIGNAL_PENDING = WIN32_ERROR.ERROR_SIGNAL_PENDING;
pub const ERROR_MAX_THRDS_REACHED = WIN32_ERROR.ERROR_MAX_THRDS_REACHED;
pub const ERROR_LOCK_FAILED = WIN32_ERROR.ERROR_LOCK_FAILED;
pub const ERROR_BUSY = WIN32_ERROR.ERROR_BUSY;
pub const ERROR_DEVICE_SUPPORT_IN_PROGRESS = WIN32_ERROR.ERROR_DEVICE_SUPPORT_IN_PROGRESS;
pub const ERROR_CANCEL_VIOLATION = WIN32_ERROR.ERROR_CANCEL_VIOLATION;
pub const ERROR_ATOMIC_LOCKS_NOT_SUPPORTED = WIN32_ERROR.ERROR_ATOMIC_LOCKS_NOT_SUPPORTED;
pub const ERROR_INVALID_SEGMENT_NUMBER = WIN32_ERROR.ERROR_INVALID_SEGMENT_NUMBER;
pub const ERROR_INVALID_ORDINAL = WIN32_ERROR.ERROR_INVALID_ORDINAL;
pub const ERROR_ALREADY_EXISTS = WIN32_ERROR.ERROR_ALREADY_EXISTS;
pub const ERROR_INVALID_FLAG_NUMBER = WIN32_ERROR.ERROR_INVALID_FLAG_NUMBER;
pub const ERROR_SEM_NOT_FOUND = WIN32_ERROR.ERROR_SEM_NOT_FOUND;
pub const ERROR_INVALID_STARTING_CODESEG = WIN32_ERROR.ERROR_INVALID_STARTING_CODESEG;
pub const ERROR_INVALID_STACKSEG = WIN32_ERROR.ERROR_INVALID_STACKSEG;
pub const ERROR_INVALID_MODULETYPE = WIN32_ERROR.ERROR_INVALID_MODULETYPE;
pub const ERROR_INVALID_EXE_SIGNATURE = WIN32_ERROR.ERROR_INVALID_EXE_SIGNATURE;
pub const ERROR_EXE_MARKED_INVALID = WIN32_ERROR.ERROR_EXE_MARKED_INVALID;
pub const ERROR_BAD_EXE_FORMAT = WIN32_ERROR.ERROR_BAD_EXE_FORMAT;
pub const ERROR_ITERATED_DATA_EXCEEDS_64k = WIN32_ERROR.ERROR_ITERATED_DATA_EXCEEDS_64k;
pub const ERROR_INVALID_MINALLOCSIZE = WIN32_ERROR.ERROR_INVALID_MINALLOCSIZE;
pub const ERROR_DYNLINK_FROM_INVALID_RING = WIN32_ERROR.ERROR_DYNLINK_FROM_INVALID_RING;
pub const ERROR_IOPL_NOT_ENABLED = WIN32_ERROR.ERROR_IOPL_NOT_ENABLED;
pub const ERROR_INVALID_SEGDPL = WIN32_ERROR.ERROR_INVALID_SEGDPL;
pub const ERROR_AUTODATASEG_EXCEEDS_64k = WIN32_ERROR.ERROR_AUTODATASEG_EXCEEDS_64k;
pub const ERROR_RING2SEG_MUST_BE_MOVABLE = WIN32_ERROR.ERROR_RING2SEG_MUST_BE_MOVABLE;
pub const ERROR_RELOC_CHAIN_XEEDS_SEGLIM = WIN32_ERROR.ERROR_RELOC_CHAIN_XEEDS_SEGLIM;
pub const ERROR_INFLOOP_IN_RELOC_CHAIN = WIN32_ERROR.ERROR_INFLOOP_IN_RELOC_CHAIN;
pub const ERROR_ENVVAR_NOT_FOUND = WIN32_ERROR.ERROR_ENVVAR_NOT_FOUND;
pub const ERROR_NO_SIGNAL_SENT = WIN32_ERROR.ERROR_NO_SIGNAL_SENT;
pub const ERROR_FILENAME_EXCED_RANGE = WIN32_ERROR.ERROR_FILENAME_EXCED_RANGE;
pub const ERROR_RING2_STACK_IN_USE = WIN32_ERROR.ERROR_RING2_STACK_IN_USE;
pub const ERROR_META_EXPANSION_TOO_LONG = WIN32_ERROR.ERROR_META_EXPANSION_TOO_LONG;
pub const ERROR_INVALID_SIGNAL_NUMBER = WIN32_ERROR.ERROR_INVALID_SIGNAL_NUMBER;
pub const ERROR_THREAD_1_INACTIVE = WIN32_ERROR.ERROR_THREAD_1_INACTIVE;
pub const ERROR_LOCKED = WIN32_ERROR.ERROR_LOCKED;
pub const ERROR_TOO_MANY_MODULES = WIN32_ERROR.ERROR_TOO_MANY_MODULES;
pub const ERROR_NESTING_NOT_ALLOWED = WIN32_ERROR.ERROR_NESTING_NOT_ALLOWED;
pub const ERROR_EXE_MACHINE_TYPE_MISMATCH = WIN32_ERROR.ERROR_EXE_MACHINE_TYPE_MISMATCH;
pub const ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY = WIN32_ERROR.ERROR_EXE_CANNOT_MODIFY_SIGNED_BINARY;
pub const ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY = WIN32_ERROR.ERROR_EXE_CANNOT_MODIFY_STRONG_SIGNED_BINARY;
pub const ERROR_FILE_CHECKED_OUT = WIN32_ERROR.ERROR_FILE_CHECKED_OUT;
pub const ERROR_CHECKOUT_REQUIRED = WIN32_ERROR.ERROR_CHECKOUT_REQUIRED;
pub const ERROR_BAD_FILE_TYPE = WIN32_ERROR.ERROR_BAD_FILE_TYPE;
pub const ERROR_FILE_TOO_LARGE = WIN32_ERROR.ERROR_FILE_TOO_LARGE;
pub const ERROR_FORMS_AUTH_REQUIRED = WIN32_ERROR.ERROR_FORMS_AUTH_REQUIRED;
pub const ERROR_VIRUS_INFECTED = WIN32_ERROR.ERROR_VIRUS_INFECTED;
pub const ERROR_VIRUS_DELETED = WIN32_ERROR.ERROR_VIRUS_DELETED;
pub const ERROR_PIPE_LOCAL = WIN32_ERROR.ERROR_PIPE_LOCAL;
pub const ERROR_BAD_PIPE = WIN32_ERROR.ERROR_BAD_PIPE;
pub const ERROR_PIPE_BUSY = WIN32_ERROR.ERROR_PIPE_BUSY;
pub const ERROR_NO_DATA = WIN32_ERROR.ERROR_NO_DATA;
pub const ERROR_PIPE_NOT_CONNECTED = WIN32_ERROR.ERROR_PIPE_NOT_CONNECTED;
pub const ERROR_MORE_DATA = WIN32_ERROR.ERROR_MORE_DATA;
pub const ERROR_NO_WORK_DONE = WIN32_ERROR.ERROR_NO_WORK_DONE;
pub const ERROR_VC_DISCONNECTED = WIN32_ERROR.ERROR_VC_DISCONNECTED;
pub const ERROR_INVALID_EA_NAME = WIN32_ERROR.ERROR_INVALID_EA_NAME;
pub const ERROR_EA_LIST_INCONSISTENT = WIN32_ERROR.ERROR_EA_LIST_INCONSISTENT;
pub const ERROR_NO_MORE_ITEMS = WIN32_ERROR.ERROR_NO_MORE_ITEMS;
pub const ERROR_CANNOT_COPY = WIN32_ERROR.ERROR_CANNOT_COPY;
pub const ERROR_DIRECTORY = WIN32_ERROR.ERROR_DIRECTORY;
pub const ERROR_EAS_DIDNT_FIT = WIN32_ERROR.ERROR_EAS_DIDNT_FIT;
pub const ERROR_EA_FILE_CORRUPT = WIN32_ERROR.ERROR_EA_FILE_CORRUPT;
pub const ERROR_EA_TABLE_FULL = WIN32_ERROR.ERROR_EA_TABLE_FULL;
pub const ERROR_INVALID_EA_HANDLE = WIN32_ERROR.ERROR_INVALID_EA_HANDLE;
pub const ERROR_EAS_NOT_SUPPORTED = WIN32_ERROR.ERROR_EAS_NOT_SUPPORTED;
pub const ERROR_NOT_OWNER = WIN32_ERROR.ERROR_NOT_OWNER;
pub const ERROR_TOO_MANY_POSTS = WIN32_ERROR.ERROR_TOO_MANY_POSTS;
pub const ERROR_PARTIAL_COPY = WIN32_ERROR.ERROR_PARTIAL_COPY;
pub const ERROR_OPLOCK_NOT_GRANTED = WIN32_ERROR.ERROR_OPLOCK_NOT_GRANTED;
pub const ERROR_INVALID_OPLOCK_PROTOCOL = WIN32_ERROR.ERROR_INVALID_OPLOCK_PROTOCOL;
pub const ERROR_DISK_TOO_FRAGMENTED = WIN32_ERROR.ERROR_DISK_TOO_FRAGMENTED;
pub const ERROR_DELETE_PENDING = WIN32_ERROR.ERROR_DELETE_PENDING;
pub const ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING = WIN32_ERROR.ERROR_INCOMPATIBLE_WITH_GLOBAL_SHORT_NAME_REGISTRY_SETTING;
pub const ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME = WIN32_ERROR.ERROR_SHORT_NAMES_NOT_ENABLED_ON_VOLUME;
pub const ERROR_SECURITY_STREAM_IS_INCONSISTENT = WIN32_ERROR.ERROR_SECURITY_STREAM_IS_INCONSISTENT;
pub const ERROR_INVALID_LOCK_RANGE = WIN32_ERROR.ERROR_INVALID_LOCK_RANGE;
pub const ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT = WIN32_ERROR.ERROR_IMAGE_SUBSYSTEM_NOT_PRESENT;
pub const ERROR_NOTIFICATION_GUID_ALREADY_DEFINED = WIN32_ERROR.ERROR_NOTIFICATION_GUID_ALREADY_DEFINED;
pub const ERROR_INVALID_EXCEPTION_HANDLER = WIN32_ERROR.ERROR_INVALID_EXCEPTION_HANDLER;
pub const ERROR_DUPLICATE_PRIVILEGES = WIN32_ERROR.ERROR_DUPLICATE_PRIVILEGES;
pub const ERROR_NO_RANGES_PROCESSED = WIN32_ERROR.ERROR_NO_RANGES_PROCESSED;
pub const ERROR_NOT_ALLOWED_ON_SYSTEM_FILE = WIN32_ERROR.ERROR_NOT_ALLOWED_ON_SYSTEM_FILE;
pub const ERROR_DISK_RESOURCES_EXHAUSTED = WIN32_ERROR.ERROR_DISK_RESOURCES_EXHAUSTED;
pub const ERROR_INVALID_TOKEN = WIN32_ERROR.ERROR_INVALID_TOKEN;
pub const ERROR_DEVICE_FEATURE_NOT_SUPPORTED = WIN32_ERROR.ERROR_DEVICE_FEATURE_NOT_SUPPORTED;
pub const ERROR_MR_MID_NOT_FOUND = WIN32_ERROR.ERROR_MR_MID_NOT_FOUND;
pub const ERROR_SCOPE_NOT_FOUND = WIN32_ERROR.ERROR_SCOPE_NOT_FOUND;
pub const ERROR_UNDEFINED_SCOPE = WIN32_ERROR.ERROR_UNDEFINED_SCOPE;
pub const ERROR_INVALID_CAP = WIN32_ERROR.ERROR_INVALID_CAP;
pub const ERROR_DEVICE_UNREACHABLE = WIN32_ERROR.ERROR_DEVICE_UNREACHABLE;
pub const ERROR_DEVICE_NO_RESOURCES = WIN32_ERROR.ERROR_DEVICE_NO_RESOURCES;
pub const ERROR_DATA_CHECKSUM_ERROR = WIN32_ERROR.ERROR_DATA_CHECKSUM_ERROR;
pub const ERROR_INTERMIXED_KERNEL_EA_OPERATION = WIN32_ERROR.ERROR_INTERMIXED_KERNEL_EA_OPERATION;
pub const ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED = WIN32_ERROR.ERROR_FILE_LEVEL_TRIM_NOT_SUPPORTED;
pub const ERROR_OFFSET_ALIGNMENT_VIOLATION = WIN32_ERROR.ERROR_OFFSET_ALIGNMENT_VIOLATION;
pub const ERROR_INVALID_FIELD_IN_PARAMETER_LIST = WIN32_ERROR.ERROR_INVALID_FIELD_IN_PARAMETER_LIST;
pub const ERROR_OPERATION_IN_PROGRESS = WIN32_ERROR.ERROR_OPERATION_IN_PROGRESS;
pub const ERROR_BAD_DEVICE_PATH = WIN32_ERROR.ERROR_BAD_DEVICE_PATH;
pub const ERROR_TOO_MANY_DESCRIPTORS = WIN32_ERROR.ERROR_TOO_MANY_DESCRIPTORS;
pub const ERROR_SCRUB_DATA_DISABLED = WIN32_ERROR.ERROR_SCRUB_DATA_DISABLED;
pub const ERROR_NOT_REDUNDANT_STORAGE = WIN32_ERROR.ERROR_NOT_REDUNDANT_STORAGE;
pub const ERROR_RESIDENT_FILE_NOT_SUPPORTED = WIN32_ERROR.ERROR_RESIDENT_FILE_NOT_SUPPORTED;
pub const ERROR_COMPRESSED_FILE_NOT_SUPPORTED = WIN32_ERROR.ERROR_COMPRESSED_FILE_NOT_SUPPORTED;
pub const ERROR_DIRECTORY_NOT_SUPPORTED = WIN32_ERROR.ERROR_DIRECTORY_NOT_SUPPORTED;
pub const ERROR_NOT_READ_FROM_COPY = WIN32_ERROR.ERROR_NOT_READ_FROM_COPY;
pub const ERROR_FT_WRITE_FAILURE = WIN32_ERROR.ERROR_FT_WRITE_FAILURE;
pub const ERROR_FT_DI_SCAN_REQUIRED = WIN32_ERROR.ERROR_FT_DI_SCAN_REQUIRED;
pub const ERROR_INVALID_KERNEL_INFO_VERSION = WIN32_ERROR.ERROR_INVALID_KERNEL_INFO_VERSION;
pub const ERROR_INVALID_PEP_INFO_VERSION = WIN32_ERROR.ERROR_INVALID_PEP_INFO_VERSION;
pub const ERROR_OBJECT_NOT_EXTERNALLY_BACKED = WIN32_ERROR.ERROR_OBJECT_NOT_EXTERNALLY_BACKED;
pub const ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN = WIN32_ERROR.ERROR_EXTERNAL_BACKING_PROVIDER_UNKNOWN;
pub const ERROR_COMPRESSION_NOT_BENEFICIAL = WIN32_ERROR.ERROR_COMPRESSION_NOT_BENEFICIAL;
pub const ERROR_STORAGE_TOPOLOGY_ID_MISMATCH = WIN32_ERROR.ERROR_STORAGE_TOPOLOGY_ID_MISMATCH;
pub const ERROR_BLOCKED_BY_PARENTAL_CONTROLS = WIN32_ERROR.ERROR_BLOCKED_BY_PARENTAL_CONTROLS;
pub const ERROR_BLOCK_TOO_MANY_REFERENCES = WIN32_ERROR.ERROR_BLOCK_TOO_MANY_REFERENCES;
pub const ERROR_MARKED_TO_DISALLOW_WRITES = WIN32_ERROR.ERROR_MARKED_TO_DISALLOW_WRITES;
pub const ERROR_ENCLAVE_FAILURE = WIN32_ERROR.ERROR_ENCLAVE_FAILURE;
pub const ERROR_FAIL_NOACTION_REBOOT = WIN32_ERROR.ERROR_FAIL_NOACTION_REBOOT;
pub const ERROR_FAIL_SHUTDOWN = WIN32_ERROR.ERROR_FAIL_SHUTDOWN;
pub const ERROR_FAIL_RESTART = WIN32_ERROR.ERROR_FAIL_RESTART;
pub const ERROR_MAX_SESSIONS_REACHED = WIN32_ERROR.ERROR_MAX_SESSIONS_REACHED;
pub const ERROR_NETWORK_ACCESS_DENIED_EDP = WIN32_ERROR.ERROR_NETWORK_ACCESS_DENIED_EDP;
pub const ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL = WIN32_ERROR.ERROR_DEVICE_HINT_NAME_BUFFER_TOO_SMALL;
pub const ERROR_EDP_POLICY_DENIES_OPERATION = WIN32_ERROR.ERROR_EDP_POLICY_DENIES_OPERATION;
pub const ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED = WIN32_ERROR.ERROR_EDP_DPL_POLICY_CANT_BE_SATISFIED;
pub const ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT = WIN32_ERROR.ERROR_CLOUD_FILE_SYNC_ROOT_METADATA_CORRUPT;
pub const ERROR_DEVICE_IN_MAINTENANCE = WIN32_ERROR.ERROR_DEVICE_IN_MAINTENANCE;
pub const ERROR_NOT_SUPPORTED_ON_DAX = WIN32_ERROR.ERROR_NOT_SUPPORTED_ON_DAX;
pub const ERROR_DAX_MAPPING_EXISTS = WIN32_ERROR.ERROR_DAX_MAPPING_EXISTS;
pub const ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING = WIN32_ERROR.ERROR_CLOUD_FILE_PROVIDER_NOT_RUNNING;
pub const ERROR_CLOUD_FILE_METADATA_CORRUPT = WIN32_ERROR.ERROR_CLOUD_FILE_METADATA_CORRUPT;
pub const ERROR_CLOUD_FILE_METADATA_TOO_LARGE = WIN32_ERROR.ERROR_CLOUD_FILE_METADATA_TOO_LARGE;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE = WIN32_ERROR.ERROR_CLOUD_FILE_PROPERTY_BLOB_TOO_LARGE;
pub const ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH = WIN32_ERROR.ERROR_CLOUD_FILE_PROPERTY_BLOB_CHECKSUM_MISMATCH;
pub const ERROR_CHILD_PROCESS_BLOCKED = WIN32_ERROR.ERROR_CHILD_PROCESS_BLOCKED;
pub const ERROR_STORAGE_LOST_DATA_PERSISTENCE = WIN32_ERROR.ERROR_STORAGE_LOST_DATA_PERSISTENCE;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE = WIN32_ERROR.ERROR_FILE_SYSTEM_VIRTUALIZATION_UNAVAILABLE;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT = WIN32_ERROR.ERROR_FILE_SYSTEM_VIRTUALIZATION_METADATA_CORRUPT;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY = WIN32_ERROR.ERROR_FILE_SYSTEM_VIRTUALIZATION_BUSY;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN = WIN32_ERROR.ERROR_FILE_SYSTEM_VIRTUALIZATION_PROVIDER_UNKNOWN;
pub const ERROR_GDI_HANDLE_LEAK = WIN32_ERROR.ERROR_GDI_HANDLE_LEAK;
pub const ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS = WIN32_ERROR.ERROR_CLOUD_FILE_TOO_MANY_PROPERTY_BLOBS;
pub const ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED = WIN32_ERROR.ERROR_CLOUD_FILE_PROPERTY_VERSION_NOT_SUPPORTED;
pub const ERROR_NOT_A_CLOUD_FILE = WIN32_ERROR.ERROR_NOT_A_CLOUD_FILE;
pub const ERROR_CLOUD_FILE_NOT_IN_SYNC = WIN32_ERROR.ERROR_CLOUD_FILE_NOT_IN_SYNC;
pub const ERROR_CLOUD_FILE_ALREADY_CONNECTED = WIN32_ERROR.ERROR_CLOUD_FILE_ALREADY_CONNECTED;
pub const ERROR_CLOUD_FILE_NOT_SUPPORTED = WIN32_ERROR.ERROR_CLOUD_FILE_NOT_SUPPORTED;
pub const ERROR_CLOUD_FILE_INVALID_REQUEST = WIN32_ERROR.ERROR_CLOUD_FILE_INVALID_REQUEST;
pub const ERROR_CLOUD_FILE_READ_ONLY_VOLUME = WIN32_ERROR.ERROR_CLOUD_FILE_READ_ONLY_VOLUME;
pub const ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY = WIN32_ERROR.ERROR_CLOUD_FILE_CONNECTED_PROVIDER_ONLY;
pub const ERROR_CLOUD_FILE_VALIDATION_FAILED = WIN32_ERROR.ERROR_CLOUD_FILE_VALIDATION_FAILED;
pub const ERROR_SMB1_NOT_AVAILABLE = WIN32_ERROR.ERROR_SMB1_NOT_AVAILABLE;
pub const ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION = WIN32_ERROR.ERROR_FILE_SYSTEM_VIRTUALIZATION_INVALID_OPERATION;
pub const ERROR_CLOUD_FILE_AUTHENTICATION_FAILED = WIN32_ERROR.ERROR_CLOUD_FILE_AUTHENTICATION_FAILED;
pub const ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES = WIN32_ERROR.ERROR_CLOUD_FILE_INSUFFICIENT_RESOURCES;
pub const ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE = WIN32_ERROR.ERROR_CLOUD_FILE_NETWORK_UNAVAILABLE;
pub const ERROR_CLOUD_FILE_UNSUCCESSFUL = WIN32_ERROR.ERROR_CLOUD_FILE_UNSUCCESSFUL;
pub const ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT = WIN32_ERROR.ERROR_CLOUD_FILE_NOT_UNDER_SYNC_ROOT;
pub const ERROR_CLOUD_FILE_IN_USE = WIN32_ERROR.ERROR_CLOUD_FILE_IN_USE;
pub const ERROR_CLOUD_FILE_PINNED = WIN32_ERROR.ERROR_CLOUD_FILE_PINNED;
pub const ERROR_CLOUD_FILE_REQUEST_ABORTED = WIN32_ERROR.ERROR_CLOUD_FILE_REQUEST_ABORTED;
pub const ERROR_CLOUD_FILE_PROPERTY_CORRUPT = WIN32_ERROR.ERROR_CLOUD_FILE_PROPERTY_CORRUPT;
pub const ERROR_CLOUD_FILE_ACCESS_DENIED = WIN32_ERROR.ERROR_CLOUD_FILE_ACCESS_DENIED;
pub const ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS = WIN32_ERROR.ERROR_CLOUD_FILE_INCOMPATIBLE_HARDLINKS;
pub const ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT = WIN32_ERROR.ERROR_CLOUD_FILE_PROPERTY_LOCK_CONFLICT;
pub const ERROR_CLOUD_FILE_REQUEST_CANCELED = WIN32_ERROR.ERROR_CLOUD_FILE_REQUEST_CANCELED;
pub const ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED = WIN32_ERROR.ERROR_EXTERNAL_SYSKEY_NOT_SUPPORTED;
pub const ERROR_THREAD_MODE_ALREADY_BACKGROUND = WIN32_ERROR.ERROR_THREAD_MODE_ALREADY_BACKGROUND;
pub const ERROR_THREAD_MODE_NOT_BACKGROUND = WIN32_ERROR.ERROR_THREAD_MODE_NOT_BACKGROUND;
pub const ERROR_PROCESS_MODE_ALREADY_BACKGROUND = WIN32_ERROR.ERROR_PROCESS_MODE_ALREADY_BACKGROUND;
pub const ERROR_PROCESS_MODE_NOT_BACKGROUND = WIN32_ERROR.ERROR_PROCESS_MODE_NOT_BACKGROUND;
pub const ERROR_CLOUD_FILE_PROVIDER_TERMINATED = WIN32_ERROR.ERROR_CLOUD_FILE_PROVIDER_TERMINATED;
pub const ERROR_NOT_A_CLOUD_SYNC_ROOT = WIN32_ERROR.ERROR_NOT_A_CLOUD_SYNC_ROOT;
pub const ERROR_FILE_PROTECTED_UNDER_DPL = WIN32_ERROR.ERROR_FILE_PROTECTED_UNDER_DPL;
pub const ERROR_VOLUME_NOT_CLUSTER_ALIGNED = WIN32_ERROR.ERROR_VOLUME_NOT_CLUSTER_ALIGNED;
pub const ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND = WIN32_ERROR.ERROR_NO_PHYSICALLY_ALIGNED_FREE_SPACE_FOUND;
pub const ERROR_APPX_FILE_NOT_ENCRYPTED = WIN32_ERROR.ERROR_APPX_FILE_NOT_ENCRYPTED;
pub const ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED = WIN32_ERROR.ERROR_RWRAW_ENCRYPTED_FILE_NOT_ENCRYPTED;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET = WIN32_ERROR.ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILEOFFSET;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE = WIN32_ERROR.ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_FILERANGE;
pub const ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER = WIN32_ERROR.ERROR_RWRAW_ENCRYPTED_INVALID_EDATAINFO_PARAMETER;
pub const ERROR_LINUX_SUBSYSTEM_NOT_PRESENT = WIN32_ERROR.ERROR_LINUX_SUBSYSTEM_NOT_PRESENT;
pub const ERROR_FT_READ_FAILURE = WIN32_ERROR.ERROR_FT_READ_FAILURE;
pub const ERROR_STORAGE_RESERVE_ID_INVALID = WIN32_ERROR.ERROR_STORAGE_RESERVE_ID_INVALID;
pub const ERROR_STORAGE_RESERVE_DOES_NOT_EXIST = WIN32_ERROR.ERROR_STORAGE_RESERVE_DOES_NOT_EXIST;
pub const ERROR_STORAGE_RESERVE_ALREADY_EXISTS = WIN32_ERROR.ERROR_STORAGE_RESERVE_ALREADY_EXISTS;
pub const ERROR_STORAGE_RESERVE_NOT_EMPTY = WIN32_ERROR.ERROR_STORAGE_RESERVE_NOT_EMPTY;
pub const ERROR_NOT_A_DAX_VOLUME = WIN32_ERROR.ERROR_NOT_A_DAX_VOLUME;
pub const ERROR_NOT_DAX_MAPPABLE = WIN32_ERROR.ERROR_NOT_DAX_MAPPABLE;
pub const ERROR_TIME_SENSITIVE_THREAD = WIN32_ERROR.ERROR_TIME_SENSITIVE_THREAD;
pub const ERROR_DPL_NOT_SUPPORTED_FOR_USER = WIN32_ERROR.ERROR_DPL_NOT_SUPPORTED_FOR_USER;
pub const ERROR_CASE_DIFFERING_NAMES_IN_DIR = WIN32_ERROR.ERROR_CASE_DIFFERING_NAMES_IN_DIR;
pub const ERROR_FILE_NOT_SUPPORTED = WIN32_ERROR.ERROR_FILE_NOT_SUPPORTED;
pub const ERROR_CLOUD_FILE_REQUEST_TIMEOUT = WIN32_ERROR.ERROR_CLOUD_FILE_REQUEST_TIMEOUT;
pub const ERROR_NO_TASK_QUEUE = WIN32_ERROR.ERROR_NO_TASK_QUEUE;
pub const ERROR_SRC_SRV_DLL_LOAD_FAILED = WIN32_ERROR.ERROR_SRC_SRV_DLL_LOAD_FAILED;
pub const ERROR_NOT_SUPPORTED_WITH_BTT = WIN32_ERROR.ERROR_NOT_SUPPORTED_WITH_BTT;
pub const ERROR_ENCRYPTION_DISABLED = WIN32_ERROR.ERROR_ENCRYPTION_DISABLED;
pub const ERROR_ENCRYPTING_METADATA_DISALLOWED = WIN32_ERROR.ERROR_ENCRYPTING_METADATA_DISALLOWED;
pub const ERROR_CANT_CLEAR_ENCRYPTION_FLAG = WIN32_ERROR.ERROR_CANT_CLEAR_ENCRYPTION_FLAG;
pub const ERROR_NO_SUCH_DEVICE = WIN32_ERROR.ERROR_NO_SUCH_DEVICE;
pub const ERROR_CLOUD_FILE_DEHYDRATION_DISALLOWED = WIN32_ERROR.ERROR_CLOUD_FILE_DEHYDRATION_DISALLOWED;
pub const ERROR_FILE_SNAP_IN_PROGRESS = WIN32_ERROR.ERROR_FILE_SNAP_IN_PROGRESS;
pub const ERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED = WIN32_ERROR.ERROR_FILE_SNAP_USER_SECTION_NOT_SUPPORTED;
pub const ERROR_FILE_SNAP_MODIFY_NOT_SUPPORTED = WIN32_ERROR.ERROR_FILE_SNAP_MODIFY_NOT_SUPPORTED;
pub const ERROR_FILE_SNAP_IO_NOT_COORDINATED = WIN32_ERROR.ERROR_FILE_SNAP_IO_NOT_COORDINATED;
pub const ERROR_FILE_SNAP_UNEXPECTED_ERROR = WIN32_ERROR.ERROR_FILE_SNAP_UNEXPECTED_ERROR;
pub const ERROR_FILE_SNAP_INVALID_PARAMETER = WIN32_ERROR.ERROR_FILE_SNAP_INVALID_PARAMETER;
pub const ERROR_UNSATISFIED_DEPENDENCIES = WIN32_ERROR.ERROR_UNSATISFIED_DEPENDENCIES;
pub const ERROR_CASE_SENSITIVE_PATH = WIN32_ERROR.ERROR_CASE_SENSITIVE_PATH;
pub const ERROR_UNEXPECTED_NTCACHEMANAGER_ERROR = WIN32_ERROR.ERROR_UNEXPECTED_NTCACHEMANAGER_ERROR;
pub const ERROR_CAPAUTHZ_NOT_DEVUNLOCKED = WIN32_ERROR.ERROR_CAPAUTHZ_NOT_DEVUNLOCKED;
pub const ERROR_CAPAUTHZ_CHANGE_TYPE = WIN32_ERROR.ERROR_CAPAUTHZ_CHANGE_TYPE;
pub const ERROR_CAPAUTHZ_NOT_PROVISIONED = WIN32_ERROR.ERROR_CAPAUTHZ_NOT_PROVISIONED;
pub const ERROR_CAPAUTHZ_NOT_AUTHORIZED = WIN32_ERROR.ERROR_CAPAUTHZ_NOT_AUTHORIZED;
pub const ERROR_CAPAUTHZ_NO_POLICY = WIN32_ERROR.ERROR_CAPAUTHZ_NO_POLICY;
pub const ERROR_CAPAUTHZ_DB_CORRUPTED = WIN32_ERROR.ERROR_CAPAUTHZ_DB_CORRUPTED;
pub const ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG = WIN32_ERROR.ERROR_CAPAUTHZ_SCCD_INVALID_CATALOG;
pub const ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY = WIN32_ERROR.ERROR_CAPAUTHZ_SCCD_NO_AUTH_ENTITY;
pub const ERROR_CAPAUTHZ_SCCD_PARSE_ERROR = WIN32_ERROR.ERROR_CAPAUTHZ_SCCD_PARSE_ERROR;
pub const ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED = WIN32_ERROR.ERROR_CAPAUTHZ_SCCD_DEV_MODE_REQUIRED;
pub const ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH = WIN32_ERROR.ERROR_CAPAUTHZ_SCCD_NO_CAPABILITY_MATCH;
pub const ERROR_CIMFS_IMAGE_CORRUPT = WIN32_ERROR.ERROR_CIMFS_IMAGE_CORRUPT;
pub const ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT = WIN32_ERROR.ERROR_PNP_QUERY_REMOVE_DEVICE_TIMEOUT;
pub const ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT = WIN32_ERROR.ERROR_PNP_QUERY_REMOVE_RELATED_DEVICE_TIMEOUT;
pub const ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT = WIN32_ERROR.ERROR_PNP_QUERY_REMOVE_UNRELATED_DEVICE_TIMEOUT;
pub const ERROR_DEVICE_HARDWARE_ERROR = WIN32_ERROR.ERROR_DEVICE_HARDWARE_ERROR;
pub const ERROR_INVALID_ADDRESS = WIN32_ERROR.ERROR_INVALID_ADDRESS;
pub const ERROR_VRF_CFG_AND_IO_ENABLED = WIN32_ERROR.ERROR_VRF_CFG_AND_IO_ENABLED;
pub const ERROR_PARTITION_TERMINATING = WIN32_ERROR.ERROR_PARTITION_TERMINATING;
pub const ERROR_USER_PROFILE_LOAD = WIN32_ERROR.ERROR_USER_PROFILE_LOAD;
pub const ERROR_ARITHMETIC_OVERFLOW = WIN32_ERROR.ERROR_ARITHMETIC_OVERFLOW;
pub const ERROR_PIPE_CONNECTED = WIN32_ERROR.ERROR_PIPE_CONNECTED;
pub const ERROR_PIPE_LISTENING = WIN32_ERROR.ERROR_PIPE_LISTENING;
pub const ERROR_VERIFIER_STOP = WIN32_ERROR.ERROR_VERIFIER_STOP;
pub const ERROR_ABIOS_ERROR = WIN32_ERROR.ERROR_ABIOS_ERROR;
pub const ERROR_WX86_WARNING = WIN32_ERROR.ERROR_WX86_WARNING;
pub const ERROR_WX86_ERROR = WIN32_ERROR.ERROR_WX86_ERROR;
pub const ERROR_TIMER_NOT_CANCELED = WIN32_ERROR.ERROR_TIMER_NOT_CANCELED;
pub const ERROR_UNWIND = WIN32_ERROR.ERROR_UNWIND;
pub const ERROR_BAD_STACK = WIN32_ERROR.ERROR_BAD_STACK;
pub const ERROR_INVALID_UNWIND_TARGET = WIN32_ERROR.ERROR_INVALID_UNWIND_TARGET;
pub const ERROR_INVALID_PORT_ATTRIBUTES = WIN32_ERROR.ERROR_INVALID_PORT_ATTRIBUTES;
pub const ERROR_PORT_MESSAGE_TOO_LONG = WIN32_ERROR.ERROR_PORT_MESSAGE_TOO_LONG;
pub const ERROR_INVALID_QUOTA_LOWER = WIN32_ERROR.ERROR_INVALID_QUOTA_LOWER;
pub const ERROR_DEVICE_ALREADY_ATTACHED = WIN32_ERROR.ERROR_DEVICE_ALREADY_ATTACHED;
pub const ERROR_INSTRUCTION_MISALIGNMENT = WIN32_ERROR.ERROR_INSTRUCTION_MISALIGNMENT;
pub const ERROR_PROFILING_NOT_STARTED = WIN32_ERROR.ERROR_PROFILING_NOT_STARTED;
pub const ERROR_PROFILING_NOT_STOPPED = WIN32_ERROR.ERROR_PROFILING_NOT_STOPPED;
pub const ERROR_COULD_NOT_INTERPRET = WIN32_ERROR.ERROR_COULD_NOT_INTERPRET;
pub const ERROR_PROFILING_AT_LIMIT = WIN32_ERROR.ERROR_PROFILING_AT_LIMIT;
pub const ERROR_CANT_WAIT = WIN32_ERROR.ERROR_CANT_WAIT;
pub const ERROR_CANT_TERMINATE_SELF = WIN32_ERROR.ERROR_CANT_TERMINATE_SELF;
pub const ERROR_UNEXPECTED_MM_CREATE_ERR = WIN32_ERROR.ERROR_UNEXPECTED_MM_CREATE_ERR;
pub const ERROR_UNEXPECTED_MM_MAP_ERROR = WIN32_ERROR.ERROR_UNEXPECTED_MM_MAP_ERROR;
pub const ERROR_UNEXPECTED_MM_EXTEND_ERR = WIN32_ERROR.ERROR_UNEXPECTED_MM_EXTEND_ERR;
pub const ERROR_BAD_FUNCTION_TABLE = WIN32_ERROR.ERROR_BAD_FUNCTION_TABLE;
pub const ERROR_NO_GUID_TRANSLATION = WIN32_ERROR.ERROR_NO_GUID_TRANSLATION;
pub const ERROR_INVALID_LDT_SIZE = WIN32_ERROR.ERROR_INVALID_LDT_SIZE;
pub const ERROR_INVALID_LDT_OFFSET = WIN32_ERROR.ERROR_INVALID_LDT_OFFSET;
pub const ERROR_INVALID_LDT_DESCRIPTOR = WIN32_ERROR.ERROR_INVALID_LDT_DESCRIPTOR;
pub const ERROR_TOO_MANY_THREADS = WIN32_ERROR.ERROR_TOO_MANY_THREADS;
pub const ERROR_THREAD_NOT_IN_PROCESS = WIN32_ERROR.ERROR_THREAD_NOT_IN_PROCESS;
pub const ERROR_PAGEFILE_QUOTA_EXCEEDED = WIN32_ERROR.ERROR_PAGEFILE_QUOTA_EXCEEDED;
pub const ERROR_LOGON_SERVER_CONFLICT = WIN32_ERROR.ERROR_LOGON_SERVER_CONFLICT;
pub const ERROR_SYNCHRONIZATION_REQUIRED = WIN32_ERROR.ERROR_SYNCHRONIZATION_REQUIRED;
pub const ERROR_NET_OPEN_FAILED = WIN32_ERROR.ERROR_NET_OPEN_FAILED;
pub const ERROR_IO_PRIVILEGE_FAILED = WIN32_ERROR.ERROR_IO_PRIVILEGE_FAILED;
pub const ERROR_CONTROL_C_EXIT = WIN32_ERROR.ERROR_CONTROL_C_EXIT;
pub const ERROR_MISSING_SYSTEMFILE = WIN32_ERROR.ERROR_MISSING_SYSTEMFILE;
pub const ERROR_UNHANDLED_EXCEPTION = WIN32_ERROR.ERROR_UNHANDLED_EXCEPTION;
pub const ERROR_APP_INIT_FAILURE = WIN32_ERROR.ERROR_APP_INIT_FAILURE;
pub const ERROR_PAGEFILE_CREATE_FAILED = WIN32_ERROR.ERROR_PAGEFILE_CREATE_FAILED;
pub const ERROR_INVALID_IMAGE_HASH = WIN32_ERROR.ERROR_INVALID_IMAGE_HASH;
pub const ERROR_NO_PAGEFILE = WIN32_ERROR.ERROR_NO_PAGEFILE;
pub const ERROR_ILLEGAL_FLOAT_CONTEXT = WIN32_ERROR.ERROR_ILLEGAL_FLOAT_CONTEXT;
pub const ERROR_NO_EVENT_PAIR = WIN32_ERROR.ERROR_NO_EVENT_PAIR;
pub const ERROR_DOMAIN_CTRLR_CONFIG_ERROR = WIN32_ERROR.ERROR_DOMAIN_CTRLR_CONFIG_ERROR;
pub const ERROR_ILLEGAL_CHARACTER = WIN32_ERROR.ERROR_ILLEGAL_CHARACTER;
pub const ERROR_UNDEFINED_CHARACTER = WIN32_ERROR.ERROR_UNDEFINED_CHARACTER;
pub const ERROR_FLOPPY_VOLUME = WIN32_ERROR.ERROR_FLOPPY_VOLUME;
pub const ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT = WIN32_ERROR.ERROR_BIOS_FAILED_TO_CONNECT_INTERRUPT;
pub const ERROR_BACKUP_CONTROLLER = WIN32_ERROR.ERROR_BACKUP_CONTROLLER;
pub const ERROR_MUTANT_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_MUTANT_LIMIT_EXCEEDED;
pub const ERROR_FS_DRIVER_REQUIRED = WIN32_ERROR.ERROR_FS_DRIVER_REQUIRED;
pub const ERROR_CANNOT_LOAD_REGISTRY_FILE = WIN32_ERROR.ERROR_CANNOT_LOAD_REGISTRY_FILE;
pub const ERROR_DEBUG_ATTACH_FAILED = WIN32_ERROR.ERROR_DEBUG_ATTACH_FAILED;
pub const ERROR_SYSTEM_PROCESS_TERMINATED = WIN32_ERROR.ERROR_SYSTEM_PROCESS_TERMINATED;
pub const ERROR_DATA_NOT_ACCEPTED = WIN32_ERROR.ERROR_DATA_NOT_ACCEPTED;
pub const ERROR_VDM_HARD_ERROR = WIN32_ERROR.ERROR_VDM_HARD_ERROR;
pub const ERROR_DRIVER_CANCEL_TIMEOUT = WIN32_ERROR.ERROR_DRIVER_CANCEL_TIMEOUT;
pub const ERROR_REPLY_MESSAGE_MISMATCH = WIN32_ERROR.ERROR_REPLY_MESSAGE_MISMATCH;
pub const ERROR_LOST_WRITEBEHIND_DATA = WIN32_ERROR.ERROR_LOST_WRITEBEHIND_DATA;
pub const ERROR_CLIENT_SERVER_PARAMETERS_INVALID = WIN32_ERROR.ERROR_CLIENT_SERVER_PARAMETERS_INVALID;
pub const ERROR_NOT_TINY_STREAM = WIN32_ERROR.ERROR_NOT_TINY_STREAM;
pub const ERROR_STACK_OVERFLOW_READ = WIN32_ERROR.ERROR_STACK_OVERFLOW_READ;
pub const ERROR_CONVERT_TO_LARGE = WIN32_ERROR.ERROR_CONVERT_TO_LARGE;
pub const ERROR_FOUND_OUT_OF_SCOPE = WIN32_ERROR.ERROR_FOUND_OUT_OF_SCOPE;
pub const ERROR_ALLOCATE_BUCKET = WIN32_ERROR.ERROR_ALLOCATE_BUCKET;
pub const ERROR_MARSHALL_OVERFLOW = WIN32_ERROR.ERROR_MARSHALL_OVERFLOW;
pub const ERROR_INVALID_VARIANT = WIN32_ERROR.ERROR_INVALID_VARIANT;
pub const ERROR_BAD_COMPRESSION_BUFFER = WIN32_ERROR.ERROR_BAD_COMPRESSION_BUFFER;
pub const ERROR_AUDIT_FAILED = WIN32_ERROR.ERROR_AUDIT_FAILED;
pub const ERROR_TIMER_RESOLUTION_NOT_SET = WIN32_ERROR.ERROR_TIMER_RESOLUTION_NOT_SET;
pub const ERROR_INSUFFICIENT_LOGON_INFO = WIN32_ERROR.ERROR_INSUFFICIENT_LOGON_INFO;
pub const ERROR_BAD_DLL_ENTRYPOINT = WIN32_ERROR.ERROR_BAD_DLL_ENTRYPOINT;
pub const ERROR_BAD_SERVICE_ENTRYPOINT = WIN32_ERROR.ERROR_BAD_SERVICE_ENTRYPOINT;
pub const ERROR_IP_ADDRESS_CONFLICT1 = WIN32_ERROR.ERROR_IP_ADDRESS_CONFLICT1;
pub const ERROR_IP_ADDRESS_CONFLICT2 = WIN32_ERROR.ERROR_IP_ADDRESS_CONFLICT2;
pub const ERROR_REGISTRY_QUOTA_LIMIT = WIN32_ERROR.ERROR_REGISTRY_QUOTA_LIMIT;
pub const ERROR_NO_CALLBACK_ACTIVE = WIN32_ERROR.ERROR_NO_CALLBACK_ACTIVE;
pub const ERROR_PWD_TOO_SHORT = WIN32_ERROR.ERROR_PWD_TOO_SHORT;
pub const ERROR_PWD_TOO_RECENT = WIN32_ERROR.ERROR_PWD_TOO_RECENT;
pub const ERROR_PWD_HISTORY_CONFLICT = WIN32_ERROR.ERROR_PWD_HISTORY_CONFLICT;
pub const ERROR_UNSUPPORTED_COMPRESSION = WIN32_ERROR.ERROR_UNSUPPORTED_COMPRESSION;
pub const ERROR_INVALID_HW_PROFILE = WIN32_ERROR.ERROR_INVALID_HW_PROFILE;
pub const ERROR_INVALID_PLUGPLAY_DEVICE_PATH = WIN32_ERROR.ERROR_INVALID_PLUGPLAY_DEVICE_PATH;
pub const ERROR_QUOTA_LIST_INCONSISTENT = WIN32_ERROR.ERROR_QUOTA_LIST_INCONSISTENT;
pub const ERROR_EVALUATION_EXPIRATION = WIN32_ERROR.ERROR_EVALUATION_EXPIRATION;
pub const ERROR_ILLEGAL_DLL_RELOCATION = WIN32_ERROR.ERROR_ILLEGAL_DLL_RELOCATION;
pub const ERROR_DLL_INIT_FAILED_LOGOFF = WIN32_ERROR.ERROR_DLL_INIT_FAILED_LOGOFF;
pub const ERROR_VALIDATE_CONTINUE = WIN32_ERROR.ERROR_VALIDATE_CONTINUE;
pub const ERROR_NO_MORE_MATCHES = WIN32_ERROR.ERROR_NO_MORE_MATCHES;
pub const ERROR_RANGE_LIST_CONFLICT = WIN32_ERROR.ERROR_RANGE_LIST_CONFLICT;
pub const ERROR_SERVER_SID_MISMATCH = WIN32_ERROR.ERROR_SERVER_SID_MISMATCH;
pub const ERROR_CANT_ENABLE_DENY_ONLY = WIN32_ERROR.ERROR_CANT_ENABLE_DENY_ONLY;
pub const ERROR_FLOAT_MULTIPLE_FAULTS = WIN32_ERROR.ERROR_FLOAT_MULTIPLE_FAULTS;
pub const ERROR_FLOAT_MULTIPLE_TRAPS = WIN32_ERROR.ERROR_FLOAT_MULTIPLE_TRAPS;
pub const ERROR_NOINTERFACE = WIN32_ERROR.ERROR_NOINTERFACE;
pub const ERROR_DRIVER_FAILED_SLEEP = WIN32_ERROR.ERROR_DRIVER_FAILED_SLEEP;
pub const ERROR_CORRUPT_SYSTEM_FILE = WIN32_ERROR.ERROR_CORRUPT_SYSTEM_FILE;
pub const ERROR_COMMITMENT_MINIMUM = WIN32_ERROR.ERROR_COMMITMENT_MINIMUM;
pub const ERROR_PNP_RESTART_ENUMERATION = WIN32_ERROR.ERROR_PNP_RESTART_ENUMERATION;
pub const ERROR_SYSTEM_IMAGE_BAD_SIGNATURE = WIN32_ERROR.ERROR_SYSTEM_IMAGE_BAD_SIGNATURE;
pub const ERROR_PNP_REBOOT_REQUIRED = WIN32_ERROR.ERROR_PNP_REBOOT_REQUIRED;
pub const ERROR_INSUFFICIENT_POWER = WIN32_ERROR.ERROR_INSUFFICIENT_POWER;
pub const ERROR_MULTIPLE_FAULT_VIOLATION = WIN32_ERROR.ERROR_MULTIPLE_FAULT_VIOLATION;
pub const ERROR_SYSTEM_SHUTDOWN = WIN32_ERROR.ERROR_SYSTEM_SHUTDOWN;
pub const ERROR_PORT_NOT_SET = WIN32_ERROR.ERROR_PORT_NOT_SET;
pub const ERROR_DS_VERSION_CHECK_FAILURE = WIN32_ERROR.ERROR_DS_VERSION_CHECK_FAILURE;
pub const ERROR_RANGE_NOT_FOUND = WIN32_ERROR.ERROR_RANGE_NOT_FOUND;
pub const ERROR_NOT_SAFE_MODE_DRIVER = WIN32_ERROR.ERROR_NOT_SAFE_MODE_DRIVER;
pub const ERROR_FAILED_DRIVER_ENTRY = WIN32_ERROR.ERROR_FAILED_DRIVER_ENTRY;
pub const ERROR_DEVICE_ENUMERATION_ERROR = WIN32_ERROR.ERROR_DEVICE_ENUMERATION_ERROR;
pub const ERROR_MOUNT_POINT_NOT_RESOLVED = WIN32_ERROR.ERROR_MOUNT_POINT_NOT_RESOLVED;
pub const ERROR_INVALID_DEVICE_OBJECT_PARAMETER = WIN32_ERROR.ERROR_INVALID_DEVICE_OBJECT_PARAMETER;
pub const ERROR_MCA_OCCURED = WIN32_ERROR.ERROR_MCA_OCCURED;
pub const ERROR_DRIVER_DATABASE_ERROR = WIN32_ERROR.ERROR_DRIVER_DATABASE_ERROR;
pub const ERROR_SYSTEM_HIVE_TOO_LARGE = WIN32_ERROR.ERROR_SYSTEM_HIVE_TOO_LARGE;
pub const ERROR_DRIVER_FAILED_PRIOR_UNLOAD = WIN32_ERROR.ERROR_DRIVER_FAILED_PRIOR_UNLOAD;
pub const ERROR_VOLSNAP_PREPARE_HIBERNATE = WIN32_ERROR.ERROR_VOLSNAP_PREPARE_HIBERNATE;
pub const ERROR_HIBERNATION_FAILURE = WIN32_ERROR.ERROR_HIBERNATION_FAILURE;
pub const ERROR_PWD_TOO_LONG = WIN32_ERROR.ERROR_PWD_TOO_LONG;
pub const ERROR_FILE_SYSTEM_LIMITATION = WIN32_ERROR.ERROR_FILE_SYSTEM_LIMITATION;
pub const ERROR_ASSERTION_FAILURE = WIN32_ERROR.ERROR_ASSERTION_FAILURE;
pub const ERROR_ACPI_ERROR = WIN32_ERROR.ERROR_ACPI_ERROR;
pub const ERROR_WOW_ASSERTION = WIN32_ERROR.ERROR_WOW_ASSERTION;
pub const ERROR_PNP_BAD_MPS_TABLE = WIN32_ERROR.ERROR_PNP_BAD_MPS_TABLE;
pub const ERROR_PNP_TRANSLATION_FAILED = WIN32_ERROR.ERROR_PNP_TRANSLATION_FAILED;
pub const ERROR_PNP_IRQ_TRANSLATION_FAILED = WIN32_ERROR.ERROR_PNP_IRQ_TRANSLATION_FAILED;
pub const ERROR_PNP_INVALID_ID = WIN32_ERROR.ERROR_PNP_INVALID_ID;
pub const ERROR_WAKE_SYSTEM_DEBUGGER = WIN32_ERROR.ERROR_WAKE_SYSTEM_DEBUGGER;
pub const ERROR_HANDLES_CLOSED = WIN32_ERROR.ERROR_HANDLES_CLOSED;
pub const ERROR_EXTRANEOUS_INFORMATION = WIN32_ERROR.ERROR_EXTRANEOUS_INFORMATION;
pub const ERROR_RXACT_COMMIT_NECESSARY = WIN32_ERROR.ERROR_RXACT_COMMIT_NECESSARY;
pub const ERROR_MEDIA_CHECK = WIN32_ERROR.ERROR_MEDIA_CHECK;
pub const ERROR_GUID_SUBSTITUTION_MADE = WIN32_ERROR.ERROR_GUID_SUBSTITUTION_MADE;
pub const ERROR_STOPPED_ON_SYMLINK = WIN32_ERROR.ERROR_STOPPED_ON_SYMLINK;
pub const ERROR_LONGJUMP = WIN32_ERROR.ERROR_LONGJUMP;
pub const ERROR_PLUGPLAY_QUERY_VETOED = WIN32_ERROR.ERROR_PLUGPLAY_QUERY_VETOED;
pub const ERROR_UNWIND_CONSOLIDATE = WIN32_ERROR.ERROR_UNWIND_CONSOLIDATE;
pub const ERROR_REGISTRY_HIVE_RECOVERED = WIN32_ERROR.ERROR_REGISTRY_HIVE_RECOVERED;
pub const ERROR_DLL_MIGHT_BE_INSECURE = WIN32_ERROR.ERROR_DLL_MIGHT_BE_INSECURE;
pub const ERROR_DLL_MIGHT_BE_INCOMPATIBLE = WIN32_ERROR.ERROR_DLL_MIGHT_BE_INCOMPATIBLE;
pub const ERROR_DBG_EXCEPTION_NOT_HANDLED = WIN32_ERROR.ERROR_DBG_EXCEPTION_NOT_HANDLED;
pub const ERROR_DBG_REPLY_LATER = WIN32_ERROR.ERROR_DBG_REPLY_LATER;
pub const ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE = WIN32_ERROR.ERROR_DBG_UNABLE_TO_PROVIDE_HANDLE;
pub const ERROR_DBG_TERMINATE_THREAD = WIN32_ERROR.ERROR_DBG_TERMINATE_THREAD;
pub const ERROR_DBG_TERMINATE_PROCESS = WIN32_ERROR.ERROR_DBG_TERMINATE_PROCESS;
pub const ERROR_DBG_CONTROL_C = WIN32_ERROR.ERROR_DBG_CONTROL_C;
pub const ERROR_DBG_PRINTEXCEPTION_C = WIN32_ERROR.ERROR_DBG_PRINTEXCEPTION_C;
pub const ERROR_DBG_RIPEXCEPTION = WIN32_ERROR.ERROR_DBG_RIPEXCEPTION;
pub const ERROR_DBG_CONTROL_BREAK = WIN32_ERROR.ERROR_DBG_CONTROL_BREAK;
pub const ERROR_DBG_COMMAND_EXCEPTION = WIN32_ERROR.ERROR_DBG_COMMAND_EXCEPTION;
pub const ERROR_OBJECT_NAME_EXISTS = WIN32_ERROR.ERROR_OBJECT_NAME_EXISTS;
pub const ERROR_THREAD_WAS_SUSPENDED = WIN32_ERROR.ERROR_THREAD_WAS_SUSPENDED;
pub const ERROR_IMAGE_NOT_AT_BASE = WIN32_ERROR.ERROR_IMAGE_NOT_AT_BASE;
pub const ERROR_RXACT_STATE_CREATED = WIN32_ERROR.ERROR_RXACT_STATE_CREATED;
pub const ERROR_SEGMENT_NOTIFICATION = WIN32_ERROR.ERROR_SEGMENT_NOTIFICATION;
pub const ERROR_BAD_CURRENT_DIRECTORY = WIN32_ERROR.ERROR_BAD_CURRENT_DIRECTORY;
pub const ERROR_FT_READ_RECOVERY_FROM_BACKUP = WIN32_ERROR.ERROR_FT_READ_RECOVERY_FROM_BACKUP;
pub const ERROR_FT_WRITE_RECOVERY = WIN32_ERROR.ERROR_FT_WRITE_RECOVERY;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH = WIN32_ERROR.ERROR_IMAGE_MACHINE_TYPE_MISMATCH;
pub const ERROR_RECEIVE_PARTIAL = WIN32_ERROR.ERROR_RECEIVE_PARTIAL;
pub const ERROR_RECEIVE_EXPEDITED = WIN32_ERROR.ERROR_RECEIVE_EXPEDITED;
pub const ERROR_RECEIVE_PARTIAL_EXPEDITED = WIN32_ERROR.ERROR_RECEIVE_PARTIAL_EXPEDITED;
pub const ERROR_EVENT_DONE = WIN32_ERROR.ERROR_EVENT_DONE;
pub const ERROR_EVENT_PENDING = WIN32_ERROR.ERROR_EVENT_PENDING;
pub const ERROR_CHECKING_FILE_SYSTEM = WIN32_ERROR.ERROR_CHECKING_FILE_SYSTEM;
pub const ERROR_FATAL_APP_EXIT = WIN32_ERROR.ERROR_FATAL_APP_EXIT;
pub const ERROR_PREDEFINED_HANDLE = WIN32_ERROR.ERROR_PREDEFINED_HANDLE;
pub const ERROR_WAS_UNLOCKED = WIN32_ERROR.ERROR_WAS_UNLOCKED;
pub const ERROR_SERVICE_NOTIFICATION = WIN32_ERROR.ERROR_SERVICE_NOTIFICATION;
pub const ERROR_WAS_LOCKED = WIN32_ERROR.ERROR_WAS_LOCKED;
pub const ERROR_LOG_HARD_ERROR = WIN32_ERROR.ERROR_LOG_HARD_ERROR;
pub const ERROR_ALREADY_WIN32 = WIN32_ERROR.ERROR_ALREADY_WIN32;
pub const ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE = WIN32_ERROR.ERROR_IMAGE_MACHINE_TYPE_MISMATCH_EXE;
pub const ERROR_NO_YIELD_PERFORMED = WIN32_ERROR.ERROR_NO_YIELD_PERFORMED;
pub const ERROR_TIMER_RESUME_IGNORED = WIN32_ERROR.ERROR_TIMER_RESUME_IGNORED;
pub const ERROR_ARBITRATION_UNHANDLED = WIN32_ERROR.ERROR_ARBITRATION_UNHANDLED;
pub const ERROR_CARDBUS_NOT_SUPPORTED = WIN32_ERROR.ERROR_CARDBUS_NOT_SUPPORTED;
pub const ERROR_MP_PROCESSOR_MISMATCH = WIN32_ERROR.ERROR_MP_PROCESSOR_MISMATCH;
pub const ERROR_HIBERNATED = WIN32_ERROR.ERROR_HIBERNATED;
pub const ERROR_RESUME_HIBERNATION = WIN32_ERROR.ERROR_RESUME_HIBERNATION;
pub const ERROR_FIRMWARE_UPDATED = WIN32_ERROR.ERROR_FIRMWARE_UPDATED;
pub const ERROR_DRIVERS_LEAKING_LOCKED_PAGES = WIN32_ERROR.ERROR_DRIVERS_LEAKING_LOCKED_PAGES;
pub const ERROR_WAKE_SYSTEM = WIN32_ERROR.ERROR_WAKE_SYSTEM;
pub const ERROR_WAIT_1 = WIN32_ERROR.ERROR_WAIT_1;
pub const ERROR_WAIT_2 = WIN32_ERROR.ERROR_WAIT_2;
pub const ERROR_WAIT_3 = WIN32_ERROR.ERROR_WAIT_3;
pub const ERROR_WAIT_63 = WIN32_ERROR.ERROR_WAIT_63;
pub const ERROR_ABANDONED_WAIT_0 = WIN32_ERROR.ERROR_ABANDONED_WAIT_0;
pub const ERROR_ABANDONED_WAIT_63 = WIN32_ERROR.ERROR_ABANDONED_WAIT_63;
pub const ERROR_USER_APC = WIN32_ERROR.ERROR_USER_APC;
pub const ERROR_KERNEL_APC = WIN32_ERROR.ERROR_KERNEL_APC;
pub const ERROR_ALERTED = WIN32_ERROR.ERROR_ALERTED;
pub const ERROR_ELEVATION_REQUIRED = WIN32_ERROR.ERROR_ELEVATION_REQUIRED;
pub const ERROR_REPARSE = WIN32_ERROR.ERROR_REPARSE;
pub const ERROR_OPLOCK_BREAK_IN_PROGRESS = WIN32_ERROR.ERROR_OPLOCK_BREAK_IN_PROGRESS;
pub const ERROR_VOLUME_MOUNTED = WIN32_ERROR.ERROR_VOLUME_MOUNTED;
pub const ERROR_RXACT_COMMITTED = WIN32_ERROR.ERROR_RXACT_COMMITTED;
pub const ERROR_NOTIFY_CLEANUP = WIN32_ERROR.ERROR_NOTIFY_CLEANUP;
pub const ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED = WIN32_ERROR.ERROR_PRIMARY_TRANSPORT_CONNECT_FAILED;
pub const ERROR_PAGE_FAULT_TRANSITION = WIN32_ERROR.ERROR_PAGE_FAULT_TRANSITION;
pub const ERROR_PAGE_FAULT_DEMAND_ZERO = WIN32_ERROR.ERROR_PAGE_FAULT_DEMAND_ZERO;
pub const ERROR_PAGE_FAULT_COPY_ON_WRITE = WIN32_ERROR.ERROR_PAGE_FAULT_COPY_ON_WRITE;
pub const ERROR_PAGE_FAULT_GUARD_PAGE = WIN32_ERROR.ERROR_PAGE_FAULT_GUARD_PAGE;
pub const ERROR_PAGE_FAULT_PAGING_FILE = WIN32_ERROR.ERROR_PAGE_FAULT_PAGING_FILE;
pub const ERROR_CACHE_PAGE_LOCKED = WIN32_ERROR.ERROR_CACHE_PAGE_LOCKED;
pub const ERROR_CRASH_DUMP = WIN32_ERROR.ERROR_CRASH_DUMP;
pub const ERROR_BUFFER_ALL_ZEROS = WIN32_ERROR.ERROR_BUFFER_ALL_ZEROS;
pub const ERROR_REPARSE_OBJECT = WIN32_ERROR.ERROR_REPARSE_OBJECT;
pub const ERROR_RESOURCE_REQUIREMENTS_CHANGED = WIN32_ERROR.ERROR_RESOURCE_REQUIREMENTS_CHANGED;
pub const ERROR_TRANSLATION_COMPLETE = WIN32_ERROR.ERROR_TRANSLATION_COMPLETE;
pub const ERROR_NOTHING_TO_TERMINATE = WIN32_ERROR.ERROR_NOTHING_TO_TERMINATE;
pub const ERROR_PROCESS_NOT_IN_JOB = WIN32_ERROR.ERROR_PROCESS_NOT_IN_JOB;
pub const ERROR_PROCESS_IN_JOB = WIN32_ERROR.ERROR_PROCESS_IN_JOB;
pub const ERROR_VOLSNAP_HIBERNATE_READY = WIN32_ERROR.ERROR_VOLSNAP_HIBERNATE_READY;
pub const ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY = WIN32_ERROR.ERROR_FSFILTER_OP_COMPLETED_SUCCESSFULLY;
pub const ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED = WIN32_ERROR.ERROR_INTERRUPT_VECTOR_ALREADY_CONNECTED;
pub const ERROR_INTERRUPT_STILL_CONNECTED = WIN32_ERROR.ERROR_INTERRUPT_STILL_CONNECTED;
pub const ERROR_WAIT_FOR_OPLOCK = WIN32_ERROR.ERROR_WAIT_FOR_OPLOCK;
pub const ERROR_DBG_EXCEPTION_HANDLED = WIN32_ERROR.ERROR_DBG_EXCEPTION_HANDLED;
pub const ERROR_DBG_CONTINUE = WIN32_ERROR.ERROR_DBG_CONTINUE;
pub const ERROR_CALLBACK_POP_STACK = WIN32_ERROR.ERROR_CALLBACK_POP_STACK;
pub const ERROR_COMPRESSION_DISABLED = WIN32_ERROR.ERROR_COMPRESSION_DISABLED;
pub const ERROR_CANTFETCHBACKWARDS = WIN32_ERROR.ERROR_CANTFETCHBACKWARDS;
pub const ERROR_CANTSCROLLBACKWARDS = WIN32_ERROR.ERROR_CANTSCROLLBACKWARDS;
pub const ERROR_ROWSNOTRELEASED = WIN32_ERROR.ERROR_ROWSNOTRELEASED;
pub const ERROR_BAD_ACCESSOR_FLAGS = WIN32_ERROR.ERROR_BAD_ACCESSOR_FLAGS;
pub const ERROR_ERRORS_ENCOUNTERED = WIN32_ERROR.ERROR_ERRORS_ENCOUNTERED;
pub const ERROR_NOT_CAPABLE = WIN32_ERROR.ERROR_NOT_CAPABLE;
pub const ERROR_REQUEST_OUT_OF_SEQUENCE = WIN32_ERROR.ERROR_REQUEST_OUT_OF_SEQUENCE;
pub const ERROR_VERSION_PARSE_ERROR = WIN32_ERROR.ERROR_VERSION_PARSE_ERROR;
pub const ERROR_BADSTARTPOSITION = WIN32_ERROR.ERROR_BADSTARTPOSITION;
pub const ERROR_MEMORY_HARDWARE = WIN32_ERROR.ERROR_MEMORY_HARDWARE;
pub const ERROR_DISK_REPAIR_DISABLED = WIN32_ERROR.ERROR_DISK_REPAIR_DISABLED;
pub const ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE = WIN32_ERROR.ERROR_INSUFFICIENT_RESOURCE_FOR_SPECIFIED_SHARED_SECTION_SIZE;
pub const ERROR_SYSTEM_POWERSTATE_TRANSITION = WIN32_ERROR.ERROR_SYSTEM_POWERSTATE_TRANSITION;
pub const ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION = WIN32_ERROR.ERROR_SYSTEM_POWERSTATE_COMPLEX_TRANSITION;
pub const ERROR_MCA_EXCEPTION = WIN32_ERROR.ERROR_MCA_EXCEPTION;
pub const ERROR_ACCESS_AUDIT_BY_POLICY = WIN32_ERROR.ERROR_ACCESS_AUDIT_BY_POLICY;
pub const ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY = WIN32_ERROR.ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY;
pub const ERROR_ABANDON_HIBERFILE = WIN32_ERROR.ERROR_ABANDON_HIBERFILE;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED = WIN32_ERROR.ERROR_LOST_WRITEBEHIND_DATA_NETWORK_DISCONNECTED;
pub const ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR = WIN32_ERROR.ERROR_LOST_WRITEBEHIND_DATA_NETWORK_SERVER_ERROR;
pub const ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR = WIN32_ERROR.ERROR_LOST_WRITEBEHIND_DATA_LOCAL_DISK_ERROR;
pub const ERROR_BAD_MCFG_TABLE = WIN32_ERROR.ERROR_BAD_MCFG_TABLE;
pub const ERROR_DISK_REPAIR_REDIRECTED = WIN32_ERROR.ERROR_DISK_REPAIR_REDIRECTED;
pub const ERROR_DISK_REPAIR_UNSUCCESSFUL = WIN32_ERROR.ERROR_DISK_REPAIR_UNSUCCESSFUL;
pub const ERROR_CORRUPT_LOG_OVERFULL = WIN32_ERROR.ERROR_CORRUPT_LOG_OVERFULL;
pub const ERROR_CORRUPT_LOG_CORRUPTED = WIN32_ERROR.ERROR_CORRUPT_LOG_CORRUPTED;
pub const ERROR_CORRUPT_LOG_UNAVAILABLE = WIN32_ERROR.ERROR_CORRUPT_LOG_UNAVAILABLE;
pub const ERROR_CORRUPT_LOG_DELETED_FULL = WIN32_ERROR.ERROR_CORRUPT_LOG_DELETED_FULL;
pub const ERROR_CORRUPT_LOG_CLEARED = WIN32_ERROR.ERROR_CORRUPT_LOG_CLEARED;
pub const ERROR_ORPHAN_NAME_EXHAUSTED = WIN32_ERROR.ERROR_ORPHAN_NAME_EXHAUSTED;
pub const ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE = WIN32_ERROR.ERROR_OPLOCK_SWITCHED_TO_NEW_HANDLE;
pub const ERROR_CANNOT_GRANT_REQUESTED_OPLOCK = WIN32_ERROR.ERROR_CANNOT_GRANT_REQUESTED_OPLOCK;
pub const ERROR_CANNOT_BREAK_OPLOCK = WIN32_ERROR.ERROR_CANNOT_BREAK_OPLOCK;
pub const ERROR_OPLOCK_HANDLE_CLOSED = WIN32_ERROR.ERROR_OPLOCK_HANDLE_CLOSED;
pub const ERROR_NO_ACE_CONDITION = WIN32_ERROR.ERROR_NO_ACE_CONDITION;
pub const ERROR_INVALID_ACE_CONDITION = WIN32_ERROR.ERROR_INVALID_ACE_CONDITION;
pub const ERROR_FILE_HANDLE_REVOKED = WIN32_ERROR.ERROR_FILE_HANDLE_REVOKED;
pub const ERROR_IMAGE_AT_DIFFERENT_BASE = WIN32_ERROR.ERROR_IMAGE_AT_DIFFERENT_BASE;
pub const ERROR_ENCRYPTED_IO_NOT_POSSIBLE = WIN32_ERROR.ERROR_ENCRYPTED_IO_NOT_POSSIBLE;
pub const ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS = WIN32_ERROR.ERROR_FILE_METADATA_OPTIMIZATION_IN_PROGRESS;
pub const ERROR_QUOTA_ACTIVITY = WIN32_ERROR.ERROR_QUOTA_ACTIVITY;
pub const ERROR_HANDLE_REVOKED = WIN32_ERROR.ERROR_HANDLE_REVOKED;
pub const ERROR_CALLBACK_INVOKE_INLINE = WIN32_ERROR.ERROR_CALLBACK_INVOKE_INLINE;
pub const ERROR_CPU_SET_INVALID = WIN32_ERROR.ERROR_CPU_SET_INVALID;
pub const ERROR_ENCLAVE_NOT_TERMINATED = WIN32_ERROR.ERROR_ENCLAVE_NOT_TERMINATED;
pub const ERROR_ENCLAVE_VIOLATION = WIN32_ERROR.ERROR_ENCLAVE_VIOLATION;
pub const ERROR_EA_ACCESS_DENIED = WIN32_ERROR.ERROR_EA_ACCESS_DENIED;
pub const ERROR_OPERATION_ABORTED = WIN32_ERROR.ERROR_OPERATION_ABORTED;
pub const ERROR_IO_INCOMPLETE = WIN32_ERROR.ERROR_IO_INCOMPLETE;
pub const ERROR_IO_PENDING = WIN32_ERROR.ERROR_IO_PENDING;
pub const ERROR_NOACCESS = WIN32_ERROR.ERROR_NOACCESS;
pub const ERROR_SWAPERROR = WIN32_ERROR.ERROR_SWAPERROR;
pub const ERROR_STACK_OVERFLOW = WIN32_ERROR.ERROR_STACK_OVERFLOW;
pub const ERROR_INVALID_MESSAGE = WIN32_ERROR.ERROR_INVALID_MESSAGE;
pub const ERROR_CAN_NOT_COMPLETE = WIN32_ERROR.ERROR_CAN_NOT_COMPLETE;
pub const ERROR_INVALID_FLAGS = WIN32_ERROR.ERROR_INVALID_FLAGS;
pub const ERROR_UNRECOGNIZED_VOLUME = WIN32_ERROR.ERROR_UNRECOGNIZED_VOLUME;
pub const ERROR_FILE_INVALID = WIN32_ERROR.ERROR_FILE_INVALID;
pub const ERROR_FULLSCREEN_MODE = WIN32_ERROR.ERROR_FULLSCREEN_MODE;
pub const ERROR_NO_TOKEN = WIN32_ERROR.ERROR_NO_TOKEN;
pub const ERROR_BADDB = WIN32_ERROR.ERROR_BADDB;
pub const ERROR_BADKEY = WIN32_ERROR.ERROR_BADKEY;
pub const ERROR_CANTOPEN = WIN32_ERROR.ERROR_CANTOPEN;
pub const ERROR_CANTREAD = WIN32_ERROR.ERROR_CANTREAD;
pub const ERROR_CANTWRITE = WIN32_ERROR.ERROR_CANTWRITE;
pub const ERROR_REGISTRY_RECOVERED = WIN32_ERROR.ERROR_REGISTRY_RECOVERED;
pub const ERROR_REGISTRY_CORRUPT = WIN32_ERROR.ERROR_REGISTRY_CORRUPT;
pub const ERROR_REGISTRY_IO_FAILED = WIN32_ERROR.ERROR_REGISTRY_IO_FAILED;
pub const ERROR_NOT_REGISTRY_FILE = WIN32_ERROR.ERROR_NOT_REGISTRY_FILE;
pub const ERROR_KEY_DELETED = WIN32_ERROR.ERROR_KEY_DELETED;
pub const ERROR_NO_LOG_SPACE = WIN32_ERROR.ERROR_NO_LOG_SPACE;
pub const ERROR_KEY_HAS_CHILDREN = WIN32_ERROR.ERROR_KEY_HAS_CHILDREN;
pub const ERROR_CHILD_MUST_BE_VOLATILE = WIN32_ERROR.ERROR_CHILD_MUST_BE_VOLATILE;
pub const ERROR_NOTIFY_ENUM_DIR = WIN32_ERROR.ERROR_NOTIFY_ENUM_DIR;
pub const ERROR_DEPENDENT_SERVICES_RUNNING = WIN32_ERROR.ERROR_DEPENDENT_SERVICES_RUNNING;
pub const ERROR_INVALID_SERVICE_CONTROL = WIN32_ERROR.ERROR_INVALID_SERVICE_CONTROL;
pub const ERROR_SERVICE_REQUEST_TIMEOUT = WIN32_ERROR.ERROR_SERVICE_REQUEST_TIMEOUT;
pub const ERROR_SERVICE_NO_THREAD = WIN32_ERROR.ERROR_SERVICE_NO_THREAD;
pub const ERROR_SERVICE_DATABASE_LOCKED = WIN32_ERROR.ERROR_SERVICE_DATABASE_LOCKED;
pub const ERROR_SERVICE_ALREADY_RUNNING = WIN32_ERROR.ERROR_SERVICE_ALREADY_RUNNING;
pub const ERROR_INVALID_SERVICE_ACCOUNT = WIN32_ERROR.ERROR_INVALID_SERVICE_ACCOUNT;
pub const ERROR_SERVICE_DISABLED = WIN32_ERROR.ERROR_SERVICE_DISABLED;
pub const ERROR_CIRCULAR_DEPENDENCY = WIN32_ERROR.ERROR_CIRCULAR_DEPENDENCY;
pub const ERROR_SERVICE_DOES_NOT_EXIST = WIN32_ERROR.ERROR_SERVICE_DOES_NOT_EXIST;
pub const ERROR_SERVICE_CANNOT_ACCEPT_CTRL = WIN32_ERROR.ERROR_SERVICE_CANNOT_ACCEPT_CTRL;
pub const ERROR_SERVICE_NOT_ACTIVE = WIN32_ERROR.ERROR_SERVICE_NOT_ACTIVE;
pub const ERROR_FAILED_SERVICE_CONTROLLER_CONNECT = WIN32_ERROR.ERROR_FAILED_SERVICE_CONTROLLER_CONNECT;
pub const ERROR_EXCEPTION_IN_SERVICE = WIN32_ERROR.ERROR_EXCEPTION_IN_SERVICE;
pub const ERROR_DATABASE_DOES_NOT_EXIST = WIN32_ERROR.ERROR_DATABASE_DOES_NOT_EXIST;
pub const ERROR_SERVICE_SPECIFIC_ERROR = WIN32_ERROR.ERROR_SERVICE_SPECIFIC_ERROR;
pub const ERROR_PROCESS_ABORTED = WIN32_ERROR.ERROR_PROCESS_ABORTED;
pub const ERROR_SERVICE_DEPENDENCY_FAIL = WIN32_ERROR.ERROR_SERVICE_DEPENDENCY_FAIL;
pub const ERROR_SERVICE_LOGON_FAILED = WIN32_ERROR.ERROR_SERVICE_LOGON_FAILED;
pub const ERROR_SERVICE_START_HANG = WIN32_ERROR.ERROR_SERVICE_START_HANG;
pub const ERROR_INVALID_SERVICE_LOCK = WIN32_ERROR.ERROR_INVALID_SERVICE_LOCK;
pub const ERROR_SERVICE_MARKED_FOR_DELETE = WIN32_ERROR.ERROR_SERVICE_MARKED_FOR_DELETE;
pub const ERROR_SERVICE_EXISTS = WIN32_ERROR.ERROR_SERVICE_EXISTS;
pub const ERROR_ALREADY_RUNNING_LKG = WIN32_ERROR.ERROR_ALREADY_RUNNING_LKG;
pub const ERROR_SERVICE_DEPENDENCY_DELETED = WIN32_ERROR.ERROR_SERVICE_DEPENDENCY_DELETED;
pub const ERROR_BOOT_ALREADY_ACCEPTED = WIN32_ERROR.ERROR_BOOT_ALREADY_ACCEPTED;
pub const ERROR_SERVICE_NEVER_STARTED = WIN32_ERROR.ERROR_SERVICE_NEVER_STARTED;
pub const ERROR_DUPLICATE_SERVICE_NAME = WIN32_ERROR.ERROR_DUPLICATE_SERVICE_NAME;
pub const ERROR_DIFFERENT_SERVICE_ACCOUNT = WIN32_ERROR.ERROR_DIFFERENT_SERVICE_ACCOUNT;
pub const ERROR_CANNOT_DETECT_DRIVER_FAILURE = WIN32_ERROR.ERROR_CANNOT_DETECT_DRIVER_FAILURE;
pub const ERROR_CANNOT_DETECT_PROCESS_ABORT = WIN32_ERROR.ERROR_CANNOT_DETECT_PROCESS_ABORT;
pub const ERROR_NO_RECOVERY_PROGRAM = WIN32_ERROR.ERROR_NO_RECOVERY_PROGRAM;
pub const ERROR_SERVICE_NOT_IN_EXE = WIN32_ERROR.ERROR_SERVICE_NOT_IN_EXE;
pub const ERROR_NOT_SAFEBOOT_SERVICE = WIN32_ERROR.ERROR_NOT_SAFEBOOT_SERVICE;
pub const ERROR_END_OF_MEDIA = WIN32_ERROR.ERROR_END_OF_MEDIA;
pub const ERROR_FILEMARK_DETECTED = WIN32_ERROR.ERROR_FILEMARK_DETECTED;
pub const ERROR_BEGINNING_OF_MEDIA = WIN32_ERROR.ERROR_BEGINNING_OF_MEDIA;
pub const ERROR_SETMARK_DETECTED = WIN32_ERROR.ERROR_SETMARK_DETECTED;
pub const ERROR_NO_DATA_DETECTED = WIN32_ERROR.ERROR_NO_DATA_DETECTED;
pub const ERROR_PARTITION_FAILURE = WIN32_ERROR.ERROR_PARTITION_FAILURE;
pub const ERROR_INVALID_BLOCK_LENGTH = WIN32_ERROR.ERROR_INVALID_BLOCK_LENGTH;
pub const ERROR_DEVICE_NOT_PARTITIONED = WIN32_ERROR.ERROR_DEVICE_NOT_PARTITIONED;
pub const ERROR_UNABLE_TO_LOCK_MEDIA = WIN32_ERROR.ERROR_UNABLE_TO_LOCK_MEDIA;
pub const ERROR_UNABLE_TO_UNLOAD_MEDIA = WIN32_ERROR.ERROR_UNABLE_TO_UNLOAD_MEDIA;
pub const ERROR_MEDIA_CHANGED = WIN32_ERROR.ERROR_MEDIA_CHANGED;
pub const ERROR_BUS_RESET = WIN32_ERROR.ERROR_BUS_RESET;
pub const ERROR_NO_MEDIA_IN_DRIVE = WIN32_ERROR.ERROR_NO_MEDIA_IN_DRIVE;
pub const ERROR_NO_UNICODE_TRANSLATION = WIN32_ERROR.ERROR_NO_UNICODE_TRANSLATION;
pub const ERROR_DLL_INIT_FAILED = WIN32_ERROR.ERROR_DLL_INIT_FAILED;
pub const ERROR_SHUTDOWN_IN_PROGRESS = WIN32_ERROR.ERROR_SHUTDOWN_IN_PROGRESS;
pub const ERROR_NO_SHUTDOWN_IN_PROGRESS = WIN32_ERROR.ERROR_NO_SHUTDOWN_IN_PROGRESS;
pub const ERROR_IO_DEVICE = WIN32_ERROR.ERROR_IO_DEVICE;
pub const ERROR_SERIAL_NO_DEVICE = WIN32_ERROR.ERROR_SERIAL_NO_DEVICE;
pub const ERROR_IRQ_BUSY = WIN32_ERROR.ERROR_IRQ_BUSY;
pub const ERROR_MORE_WRITES = WIN32_ERROR.ERROR_MORE_WRITES;
pub const ERROR_COUNTER_TIMEOUT = WIN32_ERROR.ERROR_COUNTER_TIMEOUT;
pub const ERROR_FLOPPY_ID_MARK_NOT_FOUND = WIN32_ERROR.ERROR_FLOPPY_ID_MARK_NOT_FOUND;
pub const ERROR_FLOPPY_WRONG_CYLINDER = WIN32_ERROR.ERROR_FLOPPY_WRONG_CYLINDER;
pub const ERROR_FLOPPY_UNKNOWN_ERROR = WIN32_ERROR.ERROR_FLOPPY_UNKNOWN_ERROR;
pub const ERROR_FLOPPY_BAD_REGISTERS = WIN32_ERROR.ERROR_FLOPPY_BAD_REGISTERS;
pub const ERROR_DISK_RECALIBRATE_FAILED = WIN32_ERROR.ERROR_DISK_RECALIBRATE_FAILED;
pub const ERROR_DISK_OPERATION_FAILED = WIN32_ERROR.ERROR_DISK_OPERATION_FAILED;
pub const ERROR_DISK_RESET_FAILED = WIN32_ERROR.ERROR_DISK_RESET_FAILED;
pub const ERROR_EOM_OVERFLOW = WIN32_ERROR.ERROR_EOM_OVERFLOW;
pub const ERROR_NOT_ENOUGH_SERVER_MEMORY = WIN32_ERROR.ERROR_NOT_ENOUGH_SERVER_MEMORY;
pub const ERROR_POSSIBLE_DEADLOCK = WIN32_ERROR.ERROR_POSSIBLE_DEADLOCK;
pub const ERROR_MAPPED_ALIGNMENT = WIN32_ERROR.ERROR_MAPPED_ALIGNMENT;
pub const ERROR_SET_POWER_STATE_VETOED = WIN32_ERROR.ERROR_SET_POWER_STATE_VETOED;
pub const ERROR_SET_POWER_STATE_FAILED = WIN32_ERROR.ERROR_SET_POWER_STATE_FAILED;
pub const ERROR_TOO_MANY_LINKS = WIN32_ERROR.ERROR_TOO_MANY_LINKS;
pub const ERROR_OLD_WIN_VERSION = WIN32_ERROR.ERROR_OLD_WIN_VERSION;
pub const ERROR_APP_WRONG_OS = WIN32_ERROR.ERROR_APP_WRONG_OS;
pub const ERROR_SINGLE_INSTANCE_APP = WIN32_ERROR.ERROR_SINGLE_INSTANCE_APP;
pub const ERROR_RMODE_APP = WIN32_ERROR.ERROR_RMODE_APP;
pub const ERROR_INVALID_DLL = WIN32_ERROR.ERROR_INVALID_DLL;
pub const ERROR_NO_ASSOCIATION = WIN32_ERROR.ERROR_NO_ASSOCIATION;
pub const ERROR_DDE_FAIL = WIN32_ERROR.ERROR_DDE_FAIL;
pub const ERROR_DLL_NOT_FOUND = WIN32_ERROR.ERROR_DLL_NOT_FOUND;
pub const ERROR_NO_MORE_USER_HANDLES = WIN32_ERROR.ERROR_NO_MORE_USER_HANDLES;
pub const ERROR_MESSAGE_SYNC_ONLY = WIN32_ERROR.ERROR_MESSAGE_SYNC_ONLY;
pub const ERROR_SOURCE_ELEMENT_EMPTY = WIN32_ERROR.ERROR_SOURCE_ELEMENT_EMPTY;
pub const ERROR_DESTINATION_ELEMENT_FULL = WIN32_ERROR.ERROR_DESTINATION_ELEMENT_FULL;
pub const ERROR_ILLEGAL_ELEMENT_ADDRESS = WIN32_ERROR.ERROR_ILLEGAL_ELEMENT_ADDRESS;
pub const ERROR_MAGAZINE_NOT_PRESENT = WIN32_ERROR.ERROR_MAGAZINE_NOT_PRESENT;
pub const ERROR_DEVICE_REINITIALIZATION_NEEDED = WIN32_ERROR.ERROR_DEVICE_REINITIALIZATION_NEEDED;
pub const ERROR_DEVICE_REQUIRES_CLEANING = WIN32_ERROR.ERROR_DEVICE_REQUIRES_CLEANING;
pub const ERROR_DEVICE_DOOR_OPEN = WIN32_ERROR.ERROR_DEVICE_DOOR_OPEN;
pub const ERROR_DEVICE_NOT_CONNECTED = WIN32_ERROR.ERROR_DEVICE_NOT_CONNECTED;
pub const ERROR_NOT_FOUND = WIN32_ERROR.ERROR_NOT_FOUND;
pub const ERROR_NO_MATCH = WIN32_ERROR.ERROR_NO_MATCH;
pub const ERROR_SET_NOT_FOUND = WIN32_ERROR.ERROR_SET_NOT_FOUND;
pub const ERROR_POINT_NOT_FOUND = WIN32_ERROR.ERROR_POINT_NOT_FOUND;
pub const ERROR_NO_TRACKING_SERVICE = WIN32_ERROR.ERROR_NO_TRACKING_SERVICE;
pub const ERROR_NO_VOLUME_ID = WIN32_ERROR.ERROR_NO_VOLUME_ID;
pub const ERROR_UNABLE_TO_REMOVE_REPLACED = WIN32_ERROR.ERROR_UNABLE_TO_REMOVE_REPLACED;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT = WIN32_ERROR.ERROR_UNABLE_TO_MOVE_REPLACEMENT;
pub const ERROR_UNABLE_TO_MOVE_REPLACEMENT_2 = WIN32_ERROR.ERROR_UNABLE_TO_MOVE_REPLACEMENT_2;
pub const ERROR_JOURNAL_DELETE_IN_PROGRESS = WIN32_ERROR.ERROR_JOURNAL_DELETE_IN_PROGRESS;
pub const ERROR_JOURNAL_NOT_ACTIVE = WIN32_ERROR.ERROR_JOURNAL_NOT_ACTIVE;
pub const ERROR_POTENTIAL_FILE_FOUND = WIN32_ERROR.ERROR_POTENTIAL_FILE_FOUND;
pub const ERROR_JOURNAL_ENTRY_DELETED = WIN32_ERROR.ERROR_JOURNAL_ENTRY_DELETED;
pub const ERROR_SHUTDOWN_IS_SCHEDULED = WIN32_ERROR.ERROR_SHUTDOWN_IS_SCHEDULED;
pub const ERROR_SHUTDOWN_USERS_LOGGED_ON = WIN32_ERROR.ERROR_SHUTDOWN_USERS_LOGGED_ON;
pub const ERROR_BAD_DEVICE = WIN32_ERROR.ERROR_BAD_DEVICE;
pub const ERROR_CONNECTION_UNAVAIL = WIN32_ERROR.ERROR_CONNECTION_UNAVAIL;
pub const ERROR_DEVICE_ALREADY_REMEMBERED = WIN32_ERROR.ERROR_DEVICE_ALREADY_REMEMBERED;
pub const ERROR_NO_NET_OR_BAD_PATH = WIN32_ERROR.ERROR_NO_NET_OR_BAD_PATH;
pub const ERROR_BAD_PROVIDER = WIN32_ERROR.ERROR_BAD_PROVIDER;
pub const ERROR_CANNOT_OPEN_PROFILE = WIN32_ERROR.ERROR_CANNOT_OPEN_PROFILE;
pub const ERROR_BAD_PROFILE = WIN32_ERROR.ERROR_BAD_PROFILE;
pub const ERROR_NOT_CONTAINER = WIN32_ERROR.ERROR_NOT_CONTAINER;
pub const ERROR_EXTENDED_ERROR = WIN32_ERROR.ERROR_EXTENDED_ERROR;
pub const ERROR_INVALID_GROUPNAME = WIN32_ERROR.ERROR_INVALID_GROUPNAME;
pub const ERROR_INVALID_COMPUTERNAME = WIN32_ERROR.ERROR_INVALID_COMPUTERNAME;
pub const ERROR_INVALID_EVENTNAME = WIN32_ERROR.ERROR_INVALID_EVENTNAME;
pub const ERROR_INVALID_DOMAINNAME = WIN32_ERROR.ERROR_INVALID_DOMAINNAME;
pub const ERROR_INVALID_SERVICENAME = WIN32_ERROR.ERROR_INVALID_SERVICENAME;
pub const ERROR_INVALID_NETNAME = WIN32_ERROR.ERROR_INVALID_NETNAME;
pub const ERROR_INVALID_SHARENAME = WIN32_ERROR.ERROR_INVALID_SHARENAME;
pub const ERROR_INVALID_PASSWORDNAME = WIN32_ERROR.ERROR_INVALID_PASSWORDNAME;
pub const ERROR_INVALID_MESSAGENAME = WIN32_ERROR.ERROR_INVALID_MESSAGENAME;
pub const ERROR_INVALID_MESSAGEDEST = WIN32_ERROR.ERROR_INVALID_MESSAGEDEST;
pub const ERROR_SESSION_CREDENTIAL_CONFLICT = WIN32_ERROR.ERROR_SESSION_CREDENTIAL_CONFLICT;
pub const ERROR_REMOTE_SESSION_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_REMOTE_SESSION_LIMIT_EXCEEDED;
pub const ERROR_DUP_DOMAINNAME = WIN32_ERROR.ERROR_DUP_DOMAINNAME;
pub const ERROR_NO_NETWORK = WIN32_ERROR.ERROR_NO_NETWORK;
pub const ERROR_CANCELLED = WIN32_ERROR.ERROR_CANCELLED;
pub const ERROR_USER_MAPPED_FILE = WIN32_ERROR.ERROR_USER_MAPPED_FILE;
pub const ERROR_CONNECTION_REFUSED = WIN32_ERROR.ERROR_CONNECTION_REFUSED;
pub const ERROR_GRACEFUL_DISCONNECT = WIN32_ERROR.ERROR_GRACEFUL_DISCONNECT;
pub const ERROR_ADDRESS_ALREADY_ASSOCIATED = WIN32_ERROR.ERROR_ADDRESS_ALREADY_ASSOCIATED;
pub const ERROR_ADDRESS_NOT_ASSOCIATED = WIN32_ERROR.ERROR_ADDRESS_NOT_ASSOCIATED;
pub const ERROR_CONNECTION_INVALID = WIN32_ERROR.ERROR_CONNECTION_INVALID;
pub const ERROR_CONNECTION_ACTIVE = WIN32_ERROR.ERROR_CONNECTION_ACTIVE;
pub const ERROR_NETWORK_UNREACHABLE = WIN32_ERROR.ERROR_NETWORK_UNREACHABLE;
pub const ERROR_HOST_UNREACHABLE = WIN32_ERROR.ERROR_HOST_UNREACHABLE;
pub const ERROR_PROTOCOL_UNREACHABLE = WIN32_ERROR.ERROR_PROTOCOL_UNREACHABLE;
pub const ERROR_PORT_UNREACHABLE = WIN32_ERROR.ERROR_PORT_UNREACHABLE;
pub const ERROR_REQUEST_ABORTED = WIN32_ERROR.ERROR_REQUEST_ABORTED;
pub const ERROR_CONNECTION_ABORTED = WIN32_ERROR.ERROR_CONNECTION_ABORTED;
pub const ERROR_RETRY = WIN32_ERROR.ERROR_RETRY;
pub const ERROR_CONNECTION_COUNT_LIMIT = WIN32_ERROR.ERROR_CONNECTION_COUNT_LIMIT;
pub const ERROR_LOGIN_TIME_RESTRICTION = WIN32_ERROR.ERROR_LOGIN_TIME_RESTRICTION;
pub const ERROR_LOGIN_WKSTA_RESTRICTION = WIN32_ERROR.ERROR_LOGIN_WKSTA_RESTRICTION;
pub const ERROR_INCORRECT_ADDRESS = WIN32_ERROR.ERROR_INCORRECT_ADDRESS;
pub const ERROR_ALREADY_REGISTERED = WIN32_ERROR.ERROR_ALREADY_REGISTERED;
pub const ERROR_SERVICE_NOT_FOUND = WIN32_ERROR.ERROR_SERVICE_NOT_FOUND;
pub const ERROR_NOT_AUTHENTICATED = WIN32_ERROR.ERROR_NOT_AUTHENTICATED;
pub const ERROR_NOT_LOGGED_ON = WIN32_ERROR.ERROR_NOT_LOGGED_ON;
pub const ERROR_CONTINUE = WIN32_ERROR.ERROR_CONTINUE;
pub const ERROR_ALREADY_INITIALIZED = WIN32_ERROR.ERROR_ALREADY_INITIALIZED;
pub const ERROR_NO_MORE_DEVICES = WIN32_ERROR.ERROR_NO_MORE_DEVICES;
pub const ERROR_NO_SUCH_SITE = WIN32_ERROR.ERROR_NO_SUCH_SITE;
pub const ERROR_DOMAIN_CONTROLLER_EXISTS = WIN32_ERROR.ERROR_DOMAIN_CONTROLLER_EXISTS;
pub const ERROR_ONLY_IF_CONNECTED = WIN32_ERROR.ERROR_ONLY_IF_CONNECTED;
pub const ERROR_OVERRIDE_NOCHANGES = WIN32_ERROR.ERROR_OVERRIDE_NOCHANGES;
pub const ERROR_BAD_USER_PROFILE = WIN32_ERROR.ERROR_BAD_USER_PROFILE;
pub const ERROR_NOT_SUPPORTED_ON_SBS = WIN32_ERROR.ERROR_NOT_SUPPORTED_ON_SBS;
pub const ERROR_SERVER_SHUTDOWN_IN_PROGRESS = WIN32_ERROR.ERROR_SERVER_SHUTDOWN_IN_PROGRESS;
pub const ERROR_HOST_DOWN = WIN32_ERROR.ERROR_HOST_DOWN;
pub const ERROR_NON_ACCOUNT_SID = WIN32_ERROR.ERROR_NON_ACCOUNT_SID;
pub const ERROR_NON_DOMAIN_SID = WIN32_ERROR.ERROR_NON_DOMAIN_SID;
pub const ERROR_APPHELP_BLOCK = WIN32_ERROR.ERROR_APPHELP_BLOCK;
pub const ERROR_ACCESS_DISABLED_BY_POLICY = WIN32_ERROR.ERROR_ACCESS_DISABLED_BY_POLICY;
pub const ERROR_REG_NAT_CONSUMPTION = WIN32_ERROR.ERROR_REG_NAT_CONSUMPTION;
pub const ERROR_CSCSHARE_OFFLINE = WIN32_ERROR.ERROR_CSCSHARE_OFFLINE;
pub const ERROR_PKINIT_FAILURE = WIN32_ERROR.ERROR_PKINIT_FAILURE;
pub const ERROR_SMARTCARD_SUBSYSTEM_FAILURE = WIN32_ERROR.ERROR_SMARTCARD_SUBSYSTEM_FAILURE;
pub const ERROR_DOWNGRADE_DETECTED = WIN32_ERROR.ERROR_DOWNGRADE_DETECTED;
pub const ERROR_MACHINE_LOCKED = WIN32_ERROR.ERROR_MACHINE_LOCKED;
pub const ERROR_SMB_GUEST_LOGON_BLOCKED = WIN32_ERROR.ERROR_SMB_GUEST_LOGON_BLOCKED;
pub const ERROR_CALLBACK_SUPPLIED_INVALID_DATA = WIN32_ERROR.ERROR_CALLBACK_SUPPLIED_INVALID_DATA;
pub const ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED = WIN32_ERROR.ERROR_SYNC_FOREGROUND_REFRESH_REQUIRED;
pub const ERROR_DRIVER_BLOCKED = WIN32_ERROR.ERROR_DRIVER_BLOCKED;
pub const ERROR_INVALID_IMPORT_OF_NON_DLL = WIN32_ERROR.ERROR_INVALID_IMPORT_OF_NON_DLL;
pub const ERROR_ACCESS_DISABLED_WEBBLADE = WIN32_ERROR.ERROR_ACCESS_DISABLED_WEBBLADE;
pub const ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER = WIN32_ERROR.ERROR_ACCESS_DISABLED_WEBBLADE_TAMPER;
pub const ERROR_RECOVERY_FAILURE = WIN32_ERROR.ERROR_RECOVERY_FAILURE;
pub const ERROR_ALREADY_FIBER = WIN32_ERROR.ERROR_ALREADY_FIBER;
pub const ERROR_ALREADY_THREAD = WIN32_ERROR.ERROR_ALREADY_THREAD;
pub const ERROR_STACK_BUFFER_OVERRUN = WIN32_ERROR.ERROR_STACK_BUFFER_OVERRUN;
pub const ERROR_PARAMETER_QUOTA_EXCEEDED = WIN32_ERROR.ERROR_PARAMETER_QUOTA_EXCEEDED;
pub const ERROR_DEBUGGER_INACTIVE = WIN32_ERROR.ERROR_DEBUGGER_INACTIVE;
pub const ERROR_DELAY_LOAD_FAILED = WIN32_ERROR.ERROR_DELAY_LOAD_FAILED;
pub const ERROR_VDM_DISALLOWED = WIN32_ERROR.ERROR_VDM_DISALLOWED;
pub const ERROR_UNIDENTIFIED_ERROR = WIN32_ERROR.ERROR_UNIDENTIFIED_ERROR;
pub const ERROR_INVALID_CRUNTIME_PARAMETER = WIN32_ERROR.ERROR_INVALID_CRUNTIME_PARAMETER;
pub const ERROR_BEYOND_VDL = WIN32_ERROR.ERROR_BEYOND_VDL;
pub const ERROR_INCOMPATIBLE_SERVICE_SID_TYPE = WIN32_ERROR.ERROR_INCOMPATIBLE_SERVICE_SID_TYPE;
pub const ERROR_DRIVER_PROCESS_TERMINATED = WIN32_ERROR.ERROR_DRIVER_PROCESS_TERMINATED;
pub const ERROR_IMPLEMENTATION_LIMIT = WIN32_ERROR.ERROR_IMPLEMENTATION_LIMIT;
pub const ERROR_PROCESS_IS_PROTECTED = WIN32_ERROR.ERROR_PROCESS_IS_PROTECTED;
pub const ERROR_SERVICE_NOTIFY_CLIENT_LAGGING = WIN32_ERROR.ERROR_SERVICE_NOTIFY_CLIENT_LAGGING;
pub const ERROR_DISK_QUOTA_EXCEEDED = WIN32_ERROR.ERROR_DISK_QUOTA_EXCEEDED;
pub const ERROR_CONTENT_BLOCKED = WIN32_ERROR.ERROR_CONTENT_BLOCKED;
pub const ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE = WIN32_ERROR.ERROR_INCOMPATIBLE_SERVICE_PRIVILEGE;
pub const ERROR_APP_HANG = WIN32_ERROR.ERROR_APP_HANG;
pub const ERROR_INVALID_LABEL = WIN32_ERROR.ERROR_INVALID_LABEL;
pub const ERROR_NOT_ALL_ASSIGNED = WIN32_ERROR.ERROR_NOT_ALL_ASSIGNED;
pub const ERROR_SOME_NOT_MAPPED = WIN32_ERROR.ERROR_SOME_NOT_MAPPED;
pub const ERROR_NO_QUOTAS_FOR_ACCOUNT = WIN32_ERROR.ERROR_NO_QUOTAS_FOR_ACCOUNT;
pub const ERROR_LOCAL_USER_SESSION_KEY = WIN32_ERROR.ERROR_LOCAL_USER_SESSION_KEY;
pub const ERROR_NULL_LM_PASSWORD = WIN32_ERROR.ERROR_NULL_LM_PASSWORD;
pub const ERROR_UNKNOWN_REVISION = WIN32_ERROR.ERROR_UNKNOWN_REVISION;
pub const ERROR_REVISION_MISMATCH = WIN32_ERROR.ERROR_REVISION_MISMATCH;
pub const ERROR_INVALID_OWNER = WIN32_ERROR.ERROR_INVALID_OWNER;
pub const ERROR_INVALID_PRIMARY_GROUP = WIN32_ERROR.ERROR_INVALID_PRIMARY_GROUP;
pub const ERROR_NO_IMPERSONATION_TOKEN = WIN32_ERROR.ERROR_NO_IMPERSONATION_TOKEN;
pub const ERROR_CANT_DISABLE_MANDATORY = WIN32_ERROR.ERROR_CANT_DISABLE_MANDATORY;
pub const ERROR_NO_LOGON_SERVERS = WIN32_ERROR.ERROR_NO_LOGON_SERVERS;
pub const ERROR_NO_SUCH_LOGON_SESSION = WIN32_ERROR.ERROR_NO_SUCH_LOGON_SESSION;
pub const ERROR_NO_SUCH_PRIVILEGE = WIN32_ERROR.ERROR_NO_SUCH_PRIVILEGE;
pub const ERROR_PRIVILEGE_NOT_HELD = WIN32_ERROR.ERROR_PRIVILEGE_NOT_HELD;
pub const ERROR_INVALID_ACCOUNT_NAME = WIN32_ERROR.ERROR_INVALID_ACCOUNT_NAME;
pub const ERROR_USER_EXISTS = WIN32_ERROR.ERROR_USER_EXISTS;
pub const ERROR_NO_SUCH_USER = WIN32_ERROR.ERROR_NO_SUCH_USER;
pub const ERROR_GROUP_EXISTS = WIN32_ERROR.ERROR_GROUP_EXISTS;
pub const ERROR_NO_SUCH_GROUP = WIN32_ERROR.ERROR_NO_SUCH_GROUP;
pub const ERROR_MEMBER_IN_GROUP = WIN32_ERROR.ERROR_MEMBER_IN_GROUP;
pub const ERROR_MEMBER_NOT_IN_GROUP = WIN32_ERROR.ERROR_MEMBER_NOT_IN_GROUP;
pub const ERROR_LAST_ADMIN = WIN32_ERROR.ERROR_LAST_ADMIN;
pub const ERROR_WRONG_PASSWORD = WIN32_ERROR.ERROR_WRONG_PASSWORD;
pub const ERROR_ILL_FORMED_PASSWORD = WIN32_ERROR.ERROR_ILL_FORMED_PASSWORD;
pub const ERROR_PASSWORD_RESTRICTION = WIN32_ERROR.ERROR_PASSWORD_RESTRICTION;
pub const ERROR_LOGON_FAILURE = WIN32_ERROR.ERROR_LOGON_FAILURE;
pub const ERROR_ACCOUNT_RESTRICTION = WIN32_ERROR.ERROR_ACCOUNT_RESTRICTION;
pub const ERROR_INVALID_LOGON_HOURS = WIN32_ERROR.ERROR_INVALID_LOGON_HOURS;
pub const ERROR_INVALID_WORKSTATION = WIN32_ERROR.ERROR_INVALID_WORKSTATION;
pub const ERROR_PASSWORD_EXPIRED = WIN32_ERROR.ERROR_PASSWORD_EXPIRED;
pub const ERROR_ACCOUNT_DISABLED = WIN32_ERROR.ERROR_ACCOUNT_DISABLED;
pub const ERROR_NONE_MAPPED = WIN32_ERROR.ERROR_NONE_MAPPED;
pub const ERROR_TOO_MANY_LUIDS_REQUESTED = WIN32_ERROR.ERROR_TOO_MANY_LUIDS_REQUESTED;
pub const ERROR_LUIDS_EXHAUSTED = WIN32_ERROR.ERROR_LUIDS_EXHAUSTED;
pub const ERROR_INVALID_SUB_AUTHORITY = WIN32_ERROR.ERROR_INVALID_SUB_AUTHORITY;
pub const ERROR_INVALID_ACL = WIN32_ERROR.ERROR_INVALID_ACL;
pub const ERROR_INVALID_SID = WIN32_ERROR.ERROR_INVALID_SID;
pub const ERROR_INVALID_SECURITY_DESCR = WIN32_ERROR.ERROR_INVALID_SECURITY_DESCR;
pub const ERROR_BAD_INHERITANCE_ACL = WIN32_ERROR.ERROR_BAD_INHERITANCE_ACL;
pub const ERROR_SERVER_DISABLED = WIN32_ERROR.ERROR_SERVER_DISABLED;
pub const ERROR_SERVER_NOT_DISABLED = WIN32_ERROR.ERROR_SERVER_NOT_DISABLED;
pub const ERROR_INVALID_ID_AUTHORITY = WIN32_ERROR.ERROR_INVALID_ID_AUTHORITY;
pub const ERROR_ALLOTTED_SPACE_EXCEEDED = WIN32_ERROR.ERROR_ALLOTTED_SPACE_EXCEEDED;
pub const ERROR_INVALID_GROUP_ATTRIBUTES = WIN32_ERROR.ERROR_INVALID_GROUP_ATTRIBUTES;
pub const ERROR_BAD_IMPERSONATION_LEVEL = WIN32_ERROR.ERROR_BAD_IMPERSONATION_LEVEL;
pub const ERROR_CANT_OPEN_ANONYMOUS = WIN32_ERROR.ERROR_CANT_OPEN_ANONYMOUS;
pub const ERROR_BAD_VALIDATION_CLASS = WIN32_ERROR.ERROR_BAD_VALIDATION_CLASS;
pub const ERROR_BAD_TOKEN_TYPE = WIN32_ERROR.ERROR_BAD_TOKEN_TYPE;
pub const ERROR_NO_SECURITY_ON_OBJECT = WIN32_ERROR.ERROR_NO_SECURITY_ON_OBJECT;
pub const ERROR_CANT_ACCESS_DOMAIN_INFO = WIN32_ERROR.ERROR_CANT_ACCESS_DOMAIN_INFO;
pub const ERROR_INVALID_SERVER_STATE = WIN32_ERROR.ERROR_INVALID_SERVER_STATE;
pub const ERROR_INVALID_DOMAIN_STATE = WIN32_ERROR.ERROR_INVALID_DOMAIN_STATE;
pub const ERROR_INVALID_DOMAIN_ROLE = WIN32_ERROR.ERROR_INVALID_DOMAIN_ROLE;
pub const ERROR_NO_SUCH_DOMAIN = WIN32_ERROR.ERROR_NO_SUCH_DOMAIN;
pub const ERROR_DOMAIN_EXISTS = WIN32_ERROR.ERROR_DOMAIN_EXISTS;
pub const ERROR_DOMAIN_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_DOMAIN_LIMIT_EXCEEDED;
pub const ERROR_INTERNAL_DB_CORRUPTION = WIN32_ERROR.ERROR_INTERNAL_DB_CORRUPTION;
pub const ERROR_INTERNAL_ERROR = WIN32_ERROR.ERROR_INTERNAL_ERROR;
pub const ERROR_GENERIC_NOT_MAPPED = WIN32_ERROR.ERROR_GENERIC_NOT_MAPPED;
pub const ERROR_BAD_DESCRIPTOR_FORMAT = WIN32_ERROR.ERROR_BAD_DESCRIPTOR_FORMAT;
pub const ERROR_NOT_LOGON_PROCESS = WIN32_ERROR.ERROR_NOT_LOGON_PROCESS;
pub const ERROR_LOGON_SESSION_EXISTS = WIN32_ERROR.ERROR_LOGON_SESSION_EXISTS;
pub const ERROR_NO_SUCH_PACKAGE = WIN32_ERROR.ERROR_NO_SUCH_PACKAGE;
pub const ERROR_BAD_LOGON_SESSION_STATE = WIN32_ERROR.ERROR_BAD_LOGON_SESSION_STATE;
pub const ERROR_LOGON_SESSION_COLLISION = WIN32_ERROR.ERROR_LOGON_SESSION_COLLISION;
pub const ERROR_INVALID_LOGON_TYPE = WIN32_ERROR.ERROR_INVALID_LOGON_TYPE;
pub const ERROR_CANNOT_IMPERSONATE = WIN32_ERROR.ERROR_CANNOT_IMPERSONATE;
pub const ERROR_RXACT_INVALID_STATE = WIN32_ERROR.ERROR_RXACT_INVALID_STATE;
pub const ERROR_RXACT_COMMIT_FAILURE = WIN32_ERROR.ERROR_RXACT_COMMIT_FAILURE;
pub const ERROR_SPECIAL_ACCOUNT = WIN32_ERROR.ERROR_SPECIAL_ACCOUNT;
pub const ERROR_SPECIAL_GROUP = WIN32_ERROR.ERROR_SPECIAL_GROUP;
pub const ERROR_SPECIAL_USER = WIN32_ERROR.ERROR_SPECIAL_USER;
pub const ERROR_MEMBERS_PRIMARY_GROUP = WIN32_ERROR.ERROR_MEMBERS_PRIMARY_GROUP;
pub const ERROR_TOKEN_ALREADY_IN_USE = WIN32_ERROR.ERROR_TOKEN_ALREADY_IN_USE;
pub const ERROR_NO_SUCH_ALIAS = WIN32_ERROR.ERROR_NO_SUCH_ALIAS;
pub const ERROR_MEMBER_NOT_IN_ALIAS = WIN32_ERROR.ERROR_MEMBER_NOT_IN_ALIAS;
pub const ERROR_MEMBER_IN_ALIAS = WIN32_ERROR.ERROR_MEMBER_IN_ALIAS;
pub const ERROR_ALIAS_EXISTS = WIN32_ERROR.ERROR_ALIAS_EXISTS;
pub const ERROR_LOGON_NOT_GRANTED = WIN32_ERROR.ERROR_LOGON_NOT_GRANTED;
pub const ERROR_TOO_MANY_SECRETS = WIN32_ERROR.ERROR_TOO_MANY_SECRETS;
pub const ERROR_SECRET_TOO_LONG = WIN32_ERROR.ERROR_SECRET_TOO_LONG;
pub const ERROR_INTERNAL_DB_ERROR = WIN32_ERROR.ERROR_INTERNAL_DB_ERROR;
pub const ERROR_TOO_MANY_CONTEXT_IDS = WIN32_ERROR.ERROR_TOO_MANY_CONTEXT_IDS;
pub const ERROR_LOGON_TYPE_NOT_GRANTED = WIN32_ERROR.ERROR_LOGON_TYPE_NOT_GRANTED;
pub const ERROR_NT_CROSS_ENCRYPTION_REQUIRED = WIN32_ERROR.ERROR_NT_CROSS_ENCRYPTION_REQUIRED;
pub const ERROR_NO_SUCH_MEMBER = WIN32_ERROR.ERROR_NO_SUCH_MEMBER;
pub const ERROR_INVALID_MEMBER = WIN32_ERROR.ERROR_INVALID_MEMBER;
pub const ERROR_TOO_MANY_SIDS = WIN32_ERROR.ERROR_TOO_MANY_SIDS;
pub const ERROR_LM_CROSS_ENCRYPTION_REQUIRED = WIN32_ERROR.ERROR_LM_CROSS_ENCRYPTION_REQUIRED;
pub const ERROR_NO_INHERITANCE = WIN32_ERROR.ERROR_NO_INHERITANCE;
pub const ERROR_FILE_CORRUPT = WIN32_ERROR.ERROR_FILE_CORRUPT;
pub const ERROR_DISK_CORRUPT = WIN32_ERROR.ERROR_DISK_CORRUPT;
pub const ERROR_NO_USER_SESSION_KEY = WIN32_ERROR.ERROR_NO_USER_SESSION_KEY;
pub const ERROR_LICENSE_QUOTA_EXCEEDED = WIN32_ERROR.ERROR_LICENSE_QUOTA_EXCEEDED;
pub const ERROR_WRONG_TARGET_NAME = WIN32_ERROR.ERROR_WRONG_TARGET_NAME;
pub const ERROR_MUTUAL_AUTH_FAILED = WIN32_ERROR.ERROR_MUTUAL_AUTH_FAILED;
pub const ERROR_TIME_SKEW = WIN32_ERROR.ERROR_TIME_SKEW;
pub const ERROR_CURRENT_DOMAIN_NOT_ALLOWED = WIN32_ERROR.ERROR_CURRENT_DOMAIN_NOT_ALLOWED;
pub const ERROR_INVALID_WINDOW_HANDLE = WIN32_ERROR.ERROR_INVALID_WINDOW_HANDLE;
pub const ERROR_INVALID_MENU_HANDLE = WIN32_ERROR.ERROR_INVALID_MENU_HANDLE;
pub const ERROR_INVALID_CURSOR_HANDLE = WIN32_ERROR.ERROR_INVALID_CURSOR_HANDLE;
pub const ERROR_INVALID_ACCEL_HANDLE = WIN32_ERROR.ERROR_INVALID_ACCEL_HANDLE;
pub const ERROR_INVALID_HOOK_HANDLE = WIN32_ERROR.ERROR_INVALID_HOOK_HANDLE;
pub const ERROR_INVALID_DWP_HANDLE = WIN32_ERROR.ERROR_INVALID_DWP_HANDLE;
pub const ERROR_TLW_WITH_WSCHILD = WIN32_ERROR.ERROR_TLW_WITH_WSCHILD;
pub const ERROR_CANNOT_FIND_WND_CLASS = WIN32_ERROR.ERROR_CANNOT_FIND_WND_CLASS;
pub const ERROR_WINDOW_OF_OTHER_THREAD = WIN32_ERROR.ERROR_WINDOW_OF_OTHER_THREAD;
pub const ERROR_HOTKEY_ALREADY_REGISTERED = WIN32_ERROR.ERROR_HOTKEY_ALREADY_REGISTERED;
pub const ERROR_CLASS_ALREADY_EXISTS = WIN32_ERROR.ERROR_CLASS_ALREADY_EXISTS;
pub const ERROR_CLASS_DOES_NOT_EXIST = WIN32_ERROR.ERROR_CLASS_DOES_NOT_EXIST;
pub const ERROR_CLASS_HAS_WINDOWS = WIN32_ERROR.ERROR_CLASS_HAS_WINDOWS;
pub const ERROR_INVALID_INDEX = WIN32_ERROR.ERROR_INVALID_INDEX;
pub const ERROR_INVALID_ICON_HANDLE = WIN32_ERROR.ERROR_INVALID_ICON_HANDLE;
pub const ERROR_PRIVATE_DIALOG_INDEX = WIN32_ERROR.ERROR_PRIVATE_DIALOG_INDEX;
pub const ERROR_LISTBOX_ID_NOT_FOUND = WIN32_ERROR.ERROR_LISTBOX_ID_NOT_FOUND;
pub const ERROR_NO_WILDCARD_CHARACTERS = WIN32_ERROR.ERROR_NO_WILDCARD_CHARACTERS;
pub const ERROR_CLIPBOARD_NOT_OPEN = WIN32_ERROR.ERROR_CLIPBOARD_NOT_OPEN;
pub const ERROR_HOTKEY_NOT_REGISTERED = WIN32_ERROR.ERROR_HOTKEY_NOT_REGISTERED;
pub const ERROR_WINDOW_NOT_DIALOG = WIN32_ERROR.ERROR_WINDOW_NOT_DIALOG;
pub const ERROR_CONTROL_ID_NOT_FOUND = WIN32_ERROR.ERROR_CONTROL_ID_NOT_FOUND;
pub const ERROR_INVALID_COMBOBOX_MESSAGE = WIN32_ERROR.ERROR_INVALID_COMBOBOX_MESSAGE;
pub const ERROR_WINDOW_NOT_COMBOBOX = WIN32_ERROR.ERROR_WINDOW_NOT_COMBOBOX;
pub const ERROR_INVALID_EDIT_HEIGHT = WIN32_ERROR.ERROR_INVALID_EDIT_HEIGHT;
pub const ERROR_DC_NOT_FOUND = WIN32_ERROR.ERROR_DC_NOT_FOUND;
pub const ERROR_INVALID_HOOK_FILTER = WIN32_ERROR.ERROR_INVALID_HOOK_FILTER;
pub const ERROR_INVALID_FILTER_PROC = WIN32_ERROR.ERROR_INVALID_FILTER_PROC;
pub const ERROR_HOOK_NEEDS_HMOD = WIN32_ERROR.ERROR_HOOK_NEEDS_HMOD;
pub const ERROR_GLOBAL_ONLY_HOOK = WIN32_ERROR.ERROR_GLOBAL_ONLY_HOOK;
pub const ERROR_JOURNAL_HOOK_SET = WIN32_ERROR.ERROR_JOURNAL_HOOK_SET;
pub const ERROR_HOOK_NOT_INSTALLED = WIN32_ERROR.ERROR_HOOK_NOT_INSTALLED;
pub const ERROR_INVALID_LB_MESSAGE = WIN32_ERROR.ERROR_INVALID_LB_MESSAGE;
pub const ERROR_SETCOUNT_ON_BAD_LB = WIN32_ERROR.ERROR_SETCOUNT_ON_BAD_LB;
pub const ERROR_LB_WITHOUT_TABSTOPS = WIN32_ERROR.ERROR_LB_WITHOUT_TABSTOPS;
pub const ERROR_DESTROY_OBJECT_OF_OTHER_THREAD = WIN32_ERROR.ERROR_DESTROY_OBJECT_OF_OTHER_THREAD;
pub const ERROR_CHILD_WINDOW_MENU = WIN32_ERROR.ERROR_CHILD_WINDOW_MENU;
pub const ERROR_NO_SYSTEM_MENU = WIN32_ERROR.ERROR_NO_SYSTEM_MENU;
pub const ERROR_INVALID_MSGBOX_STYLE = WIN32_ERROR.ERROR_INVALID_MSGBOX_STYLE;
pub const ERROR_INVALID_SPI_VALUE = WIN32_ERROR.ERROR_INVALID_SPI_VALUE;
pub const ERROR_SCREEN_ALREADY_LOCKED = WIN32_ERROR.ERROR_SCREEN_ALREADY_LOCKED;
pub const ERROR_HWNDS_HAVE_DIFF_PARENT = WIN32_ERROR.ERROR_HWNDS_HAVE_DIFF_PARENT;
pub const ERROR_NOT_CHILD_WINDOW = WIN32_ERROR.ERROR_NOT_CHILD_WINDOW;
pub const ERROR_INVALID_GW_COMMAND = WIN32_ERROR.ERROR_INVALID_GW_COMMAND;
pub const ERROR_INVALID_THREAD_ID = WIN32_ERROR.ERROR_INVALID_THREAD_ID;
pub const ERROR_NON_MDICHILD_WINDOW = WIN32_ERROR.ERROR_NON_MDICHILD_WINDOW;
pub const ERROR_POPUP_ALREADY_ACTIVE = WIN32_ERROR.ERROR_POPUP_ALREADY_ACTIVE;
pub const ERROR_NO_SCROLLBARS = WIN32_ERROR.ERROR_NO_SCROLLBARS;
pub const ERROR_INVALID_SCROLLBAR_RANGE = WIN32_ERROR.ERROR_INVALID_SCROLLBAR_RANGE;
pub const ERROR_INVALID_SHOWWIN_COMMAND = WIN32_ERROR.ERROR_INVALID_SHOWWIN_COMMAND;
pub const ERROR_NO_SYSTEM_RESOURCES = WIN32_ERROR.ERROR_NO_SYSTEM_RESOURCES;
pub const ERROR_NONPAGED_SYSTEM_RESOURCES = WIN32_ERROR.ERROR_NONPAGED_SYSTEM_RESOURCES;
pub const ERROR_PAGED_SYSTEM_RESOURCES = WIN32_ERROR.ERROR_PAGED_SYSTEM_RESOURCES;
pub const ERROR_WORKING_SET_QUOTA = WIN32_ERROR.ERROR_WORKING_SET_QUOTA;
pub const ERROR_PAGEFILE_QUOTA = WIN32_ERROR.ERROR_PAGEFILE_QUOTA;
pub const ERROR_COMMITMENT_LIMIT = WIN32_ERROR.ERROR_COMMITMENT_LIMIT;
pub const ERROR_MENU_ITEM_NOT_FOUND = WIN32_ERROR.ERROR_MENU_ITEM_NOT_FOUND;
pub const ERROR_INVALID_KEYBOARD_HANDLE = WIN32_ERROR.ERROR_INVALID_KEYBOARD_HANDLE;
pub const ERROR_HOOK_TYPE_NOT_ALLOWED = WIN32_ERROR.ERROR_HOOK_TYPE_NOT_ALLOWED;
pub const ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION = WIN32_ERROR.ERROR_REQUIRES_INTERACTIVE_WINDOWSTATION;
pub const ERROR_TIMEOUT = WIN32_ERROR.ERROR_TIMEOUT;
pub const ERROR_INVALID_MONITOR_HANDLE = WIN32_ERROR.ERROR_INVALID_MONITOR_HANDLE;
pub const ERROR_INCORRECT_SIZE = WIN32_ERROR.ERROR_INCORRECT_SIZE;
pub const ERROR_SYMLINK_CLASS_DISABLED = WIN32_ERROR.ERROR_SYMLINK_CLASS_DISABLED;
pub const ERROR_SYMLINK_NOT_SUPPORTED = WIN32_ERROR.ERROR_SYMLINK_NOT_SUPPORTED;
pub const ERROR_XML_PARSE_ERROR = WIN32_ERROR.ERROR_XML_PARSE_ERROR;
pub const ERROR_XMLDSIG_ERROR = WIN32_ERROR.ERROR_XMLDSIG_ERROR;
pub const ERROR_RESTART_APPLICATION = WIN32_ERROR.ERROR_RESTART_APPLICATION;
pub const ERROR_WRONG_COMPARTMENT = WIN32_ERROR.ERROR_WRONG_COMPARTMENT;
pub const ERROR_AUTHIP_FAILURE = WIN32_ERROR.ERROR_AUTHIP_FAILURE;
pub const ERROR_NO_NVRAM_RESOURCES = WIN32_ERROR.ERROR_NO_NVRAM_RESOURCES;
pub const ERROR_NOT_GUI_PROCESS = WIN32_ERROR.ERROR_NOT_GUI_PROCESS;
pub const ERROR_EVENTLOG_FILE_CORRUPT = WIN32_ERROR.ERROR_EVENTLOG_FILE_CORRUPT;
pub const ERROR_EVENTLOG_CANT_START = WIN32_ERROR.ERROR_EVENTLOG_CANT_START;
pub const ERROR_LOG_FILE_FULL = WIN32_ERROR.ERROR_LOG_FILE_FULL;
pub const ERROR_EVENTLOG_FILE_CHANGED = WIN32_ERROR.ERROR_EVENTLOG_FILE_CHANGED;
pub const ERROR_CONTAINER_ASSIGNED = WIN32_ERROR.ERROR_CONTAINER_ASSIGNED;
pub const ERROR_JOB_NO_CONTAINER = WIN32_ERROR.ERROR_JOB_NO_CONTAINER;
pub const ERROR_INVALID_TASK_NAME = WIN32_ERROR.ERROR_INVALID_TASK_NAME;
pub const ERROR_INVALID_TASK_INDEX = WIN32_ERROR.ERROR_INVALID_TASK_INDEX;
pub const ERROR_THREAD_ALREADY_IN_TASK = WIN32_ERROR.ERROR_THREAD_ALREADY_IN_TASK;
pub const ERROR_INSTALL_SERVICE_FAILURE = WIN32_ERROR.ERROR_INSTALL_SERVICE_FAILURE;
pub const ERROR_INSTALL_USEREXIT = WIN32_ERROR.ERROR_INSTALL_USEREXIT;
pub const ERROR_INSTALL_FAILURE = WIN32_ERROR.ERROR_INSTALL_FAILURE;
pub const ERROR_INSTALL_SUSPEND = WIN32_ERROR.ERROR_INSTALL_SUSPEND;
pub const ERROR_UNKNOWN_PRODUCT = WIN32_ERROR.ERROR_UNKNOWN_PRODUCT;
pub const ERROR_UNKNOWN_FEATURE = WIN32_ERROR.ERROR_UNKNOWN_FEATURE;
pub const ERROR_UNKNOWN_COMPONENT = WIN32_ERROR.ERROR_UNKNOWN_COMPONENT;
pub const ERROR_UNKNOWN_PROPERTY = WIN32_ERROR.ERROR_UNKNOWN_PROPERTY;
pub const ERROR_INVALID_HANDLE_STATE = WIN32_ERROR.ERROR_INVALID_HANDLE_STATE;
pub const ERROR_BAD_CONFIGURATION = WIN32_ERROR.ERROR_BAD_CONFIGURATION;
pub const ERROR_INDEX_ABSENT = WIN32_ERROR.ERROR_INDEX_ABSENT;
pub const ERROR_INSTALL_SOURCE_ABSENT = WIN32_ERROR.ERROR_INSTALL_SOURCE_ABSENT;
pub const ERROR_INSTALL_PACKAGE_VERSION = WIN32_ERROR.ERROR_INSTALL_PACKAGE_VERSION;
pub const ERROR_PRODUCT_UNINSTALLED = WIN32_ERROR.ERROR_PRODUCT_UNINSTALLED;
pub const ERROR_BAD_QUERY_SYNTAX = WIN32_ERROR.ERROR_BAD_QUERY_SYNTAX;
pub const ERROR_INVALID_FIELD = WIN32_ERROR.ERROR_INVALID_FIELD;
pub const ERROR_DEVICE_REMOVED = WIN32_ERROR.ERROR_DEVICE_REMOVED;
pub const ERROR_INSTALL_ALREADY_RUNNING = WIN32_ERROR.ERROR_INSTALL_ALREADY_RUNNING;
pub const ERROR_INSTALL_PACKAGE_OPEN_FAILED = WIN32_ERROR.ERROR_INSTALL_PACKAGE_OPEN_FAILED;
pub const ERROR_INSTALL_PACKAGE_INVALID = WIN32_ERROR.ERROR_INSTALL_PACKAGE_INVALID;
pub const ERROR_INSTALL_UI_FAILURE = WIN32_ERROR.ERROR_INSTALL_UI_FAILURE;
pub const ERROR_INSTALL_LOG_FAILURE = WIN32_ERROR.ERROR_INSTALL_LOG_FAILURE;
pub const ERROR_INSTALL_LANGUAGE_UNSUPPORTED = WIN32_ERROR.ERROR_INSTALL_LANGUAGE_UNSUPPORTED;
pub const ERROR_INSTALL_TRANSFORM_FAILURE = WIN32_ERROR.ERROR_INSTALL_TRANSFORM_FAILURE;
pub const ERROR_INSTALL_PACKAGE_REJECTED = WIN32_ERROR.ERROR_INSTALL_PACKAGE_REJECTED;
pub const ERROR_FUNCTION_NOT_CALLED = WIN32_ERROR.ERROR_FUNCTION_NOT_CALLED;
pub const ERROR_FUNCTION_FAILED = WIN32_ERROR.ERROR_FUNCTION_FAILED;
pub const ERROR_INVALID_TABLE = WIN32_ERROR.ERROR_INVALID_TABLE;
pub const ERROR_DATATYPE_MISMATCH = WIN32_ERROR.ERROR_DATATYPE_MISMATCH;
pub const ERROR_UNSUPPORTED_TYPE = WIN32_ERROR.ERROR_UNSUPPORTED_TYPE;
pub const ERROR_CREATE_FAILED = WIN32_ERROR.ERROR_CREATE_FAILED;
pub const ERROR_INSTALL_TEMP_UNWRITABLE = WIN32_ERROR.ERROR_INSTALL_TEMP_UNWRITABLE;
pub const ERROR_INSTALL_PLATFORM_UNSUPPORTED = WIN32_ERROR.ERROR_INSTALL_PLATFORM_UNSUPPORTED;
pub const ERROR_INSTALL_NOTUSED = WIN32_ERROR.ERROR_INSTALL_NOTUSED;
pub const ERROR_PATCH_PACKAGE_OPEN_FAILED = WIN32_ERROR.ERROR_PATCH_PACKAGE_OPEN_FAILED;
pub const ERROR_PATCH_PACKAGE_INVALID = WIN32_ERROR.ERROR_PATCH_PACKAGE_INVALID;
pub const ERROR_PATCH_PACKAGE_UNSUPPORTED = WIN32_ERROR.ERROR_PATCH_PACKAGE_UNSUPPORTED;
pub const ERROR_PRODUCT_VERSION = WIN32_ERROR.ERROR_PRODUCT_VERSION;
pub const ERROR_INVALID_COMMAND_LINE = WIN32_ERROR.ERROR_INVALID_COMMAND_LINE;
pub const ERROR_INSTALL_REMOTE_DISALLOWED = WIN32_ERROR.ERROR_INSTALL_REMOTE_DISALLOWED;
pub const ERROR_SUCCESS_REBOOT_INITIATED = WIN32_ERROR.ERROR_SUCCESS_REBOOT_INITIATED;
pub const ERROR_PATCH_TARGET_NOT_FOUND = WIN32_ERROR.ERROR_PATCH_TARGET_NOT_FOUND;
pub const ERROR_PATCH_PACKAGE_REJECTED = WIN32_ERROR.ERROR_PATCH_PACKAGE_REJECTED;
pub const ERROR_INSTALL_TRANSFORM_REJECTED = WIN32_ERROR.ERROR_INSTALL_TRANSFORM_REJECTED;
pub const ERROR_INSTALL_REMOTE_PROHIBITED = WIN32_ERROR.ERROR_INSTALL_REMOTE_PROHIBITED;
pub const ERROR_PATCH_REMOVAL_UNSUPPORTED = WIN32_ERROR.ERROR_PATCH_REMOVAL_UNSUPPORTED;
pub const ERROR_UNKNOWN_PATCH = WIN32_ERROR.ERROR_UNKNOWN_PATCH;
pub const ERROR_PATCH_NO_SEQUENCE = WIN32_ERROR.ERROR_PATCH_NO_SEQUENCE;
pub const ERROR_PATCH_REMOVAL_DISALLOWED = WIN32_ERROR.ERROR_PATCH_REMOVAL_DISALLOWED;
pub const ERROR_INVALID_PATCH_XML = WIN32_ERROR.ERROR_INVALID_PATCH_XML;
pub const ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT = WIN32_ERROR.ERROR_PATCH_MANAGED_ADVERTISED_PRODUCT;
pub const ERROR_INSTALL_SERVICE_SAFEBOOT = WIN32_ERROR.ERROR_INSTALL_SERVICE_SAFEBOOT;
pub const ERROR_FAIL_FAST_EXCEPTION = WIN32_ERROR.ERROR_FAIL_FAST_EXCEPTION;
pub const ERROR_INSTALL_REJECTED = WIN32_ERROR.ERROR_INSTALL_REJECTED;
pub const ERROR_DYNAMIC_CODE_BLOCKED = WIN32_ERROR.ERROR_DYNAMIC_CODE_BLOCKED;
pub const ERROR_NOT_SAME_OBJECT = WIN32_ERROR.ERROR_NOT_SAME_OBJECT;
pub const ERROR_STRICT_CFG_VIOLATION = WIN32_ERROR.ERROR_STRICT_CFG_VIOLATION;
pub const ERROR_SET_CONTEXT_DENIED = WIN32_ERROR.ERROR_SET_CONTEXT_DENIED;
pub const ERROR_CROSS_PARTITION_VIOLATION = WIN32_ERROR.ERROR_CROSS_PARTITION_VIOLATION;
pub const ERROR_RETURN_ADDRESS_HIJACK_ATTEMPT = WIN32_ERROR.ERROR_RETURN_ADDRESS_HIJACK_ATTEMPT;
pub const ERROR_INVALID_USER_BUFFER = WIN32_ERROR.ERROR_INVALID_USER_BUFFER;
pub const ERROR_UNRECOGNIZED_MEDIA = WIN32_ERROR.ERROR_UNRECOGNIZED_MEDIA;
pub const ERROR_NO_TRUST_LSA_SECRET = WIN32_ERROR.ERROR_NO_TRUST_LSA_SECRET;
pub const ERROR_NO_TRUST_SAM_ACCOUNT = WIN32_ERROR.ERROR_NO_TRUST_SAM_ACCOUNT;
pub const ERROR_TRUSTED_DOMAIN_FAILURE = WIN32_ERROR.ERROR_TRUSTED_DOMAIN_FAILURE;
pub const ERROR_TRUSTED_RELATIONSHIP_FAILURE = WIN32_ERROR.ERROR_TRUSTED_RELATIONSHIP_FAILURE;
pub const ERROR_TRUST_FAILURE = WIN32_ERROR.ERROR_TRUST_FAILURE;
pub const ERROR_NETLOGON_NOT_STARTED = WIN32_ERROR.ERROR_NETLOGON_NOT_STARTED;
pub const ERROR_ACCOUNT_EXPIRED = WIN32_ERROR.ERROR_ACCOUNT_EXPIRED;
pub const ERROR_REDIRECTOR_HAS_OPEN_HANDLES = WIN32_ERROR.ERROR_REDIRECTOR_HAS_OPEN_HANDLES;
pub const ERROR_PRINTER_DRIVER_ALREADY_INSTALLED = WIN32_ERROR.ERROR_PRINTER_DRIVER_ALREADY_INSTALLED;
pub const ERROR_UNKNOWN_PORT = WIN32_ERROR.ERROR_UNKNOWN_PORT;
pub const ERROR_UNKNOWN_PRINTER_DRIVER = WIN32_ERROR.ERROR_UNKNOWN_PRINTER_DRIVER;
pub const ERROR_UNKNOWN_PRINTPROCESSOR = WIN32_ERROR.ERROR_UNKNOWN_PRINTPROCESSOR;
pub const ERROR_INVALID_SEPARATOR_FILE = WIN32_ERROR.ERROR_INVALID_SEPARATOR_FILE;
pub const ERROR_INVALID_PRIORITY = WIN32_ERROR.ERROR_INVALID_PRIORITY;
pub const ERROR_INVALID_PRINTER_NAME = WIN32_ERROR.ERROR_INVALID_PRINTER_NAME;
pub const ERROR_PRINTER_ALREADY_EXISTS = WIN32_ERROR.ERROR_PRINTER_ALREADY_EXISTS;
pub const ERROR_INVALID_PRINTER_COMMAND = WIN32_ERROR.ERROR_INVALID_PRINTER_COMMAND;
pub const ERROR_INVALID_DATATYPE = WIN32_ERROR.ERROR_INVALID_DATATYPE;
pub const ERROR_INVALID_ENVIRONMENT = WIN32_ERROR.ERROR_INVALID_ENVIRONMENT;
pub const ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT = WIN32_ERROR.ERROR_NOLOGON_INTERDOMAIN_TRUST_ACCOUNT;
pub const ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT = WIN32_ERROR.ERROR_NOLOGON_WORKSTATION_TRUST_ACCOUNT;
pub const ERROR_NOLOGON_SERVER_TRUST_ACCOUNT = WIN32_ERROR.ERROR_NOLOGON_SERVER_TRUST_ACCOUNT;
pub const ERROR_DOMAIN_TRUST_INCONSISTENT = WIN32_ERROR.ERROR_DOMAIN_TRUST_INCONSISTENT;
pub const ERROR_SERVER_HAS_OPEN_HANDLES = WIN32_ERROR.ERROR_SERVER_HAS_OPEN_HANDLES;
pub const ERROR_RESOURCE_DATA_NOT_FOUND = WIN32_ERROR.ERROR_RESOURCE_DATA_NOT_FOUND;
pub const ERROR_RESOURCE_TYPE_NOT_FOUND = WIN32_ERROR.ERROR_RESOURCE_TYPE_NOT_FOUND;
pub const ERROR_RESOURCE_NAME_NOT_FOUND = WIN32_ERROR.ERROR_RESOURCE_NAME_NOT_FOUND;
pub const ERROR_RESOURCE_LANG_NOT_FOUND = WIN32_ERROR.ERROR_RESOURCE_LANG_NOT_FOUND;
pub const ERROR_NOT_ENOUGH_QUOTA = WIN32_ERROR.ERROR_NOT_ENOUGH_QUOTA;
pub const ERROR_INVALID_TIME = WIN32_ERROR.ERROR_INVALID_TIME;
pub const ERROR_INVALID_FORM_NAME = WIN32_ERROR.ERROR_INVALID_FORM_NAME;
pub const ERROR_INVALID_FORM_SIZE = WIN32_ERROR.ERROR_INVALID_FORM_SIZE;
pub const ERROR_ALREADY_WAITING = WIN32_ERROR.ERROR_ALREADY_WAITING;
pub const ERROR_PRINTER_DELETED = WIN32_ERROR.ERROR_PRINTER_DELETED;
pub const ERROR_INVALID_PRINTER_STATE = WIN32_ERROR.ERROR_INVALID_PRINTER_STATE;
pub const ERROR_PASSWORD_MUST_CHANGE = WIN32_ERROR.ERROR_PASSWORD_MUST_CHANGE;
pub const ERROR_DOMAIN_CONTROLLER_NOT_FOUND = WIN32_ERROR.ERROR_DOMAIN_CONTROLLER_NOT_FOUND;
pub const ERROR_ACCOUNT_LOCKED_OUT = WIN32_ERROR.ERROR_ACCOUNT_LOCKED_OUT;
pub const ERROR_NO_SITENAME = WIN32_ERROR.ERROR_NO_SITENAME;
pub const ERROR_CANT_ACCESS_FILE = WIN32_ERROR.ERROR_CANT_ACCESS_FILE;
pub const ERROR_CANT_RESOLVE_FILENAME = WIN32_ERROR.ERROR_CANT_RESOLVE_FILENAME;
pub const ERROR_KM_DRIVER_BLOCKED = WIN32_ERROR.ERROR_KM_DRIVER_BLOCKED;
pub const ERROR_CONTEXT_EXPIRED = WIN32_ERROR.ERROR_CONTEXT_EXPIRED;
pub const ERROR_PER_USER_TRUST_QUOTA_EXCEEDED = WIN32_ERROR.ERROR_PER_USER_TRUST_QUOTA_EXCEEDED;
pub const ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED = WIN32_ERROR.ERROR_ALL_USER_TRUST_QUOTA_EXCEEDED;
pub const ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED = WIN32_ERROR.ERROR_USER_DELETE_TRUST_QUOTA_EXCEEDED;
pub const ERROR_AUTHENTICATION_FIREWALL_FAILED = WIN32_ERROR.ERROR_AUTHENTICATION_FIREWALL_FAILED;
pub const ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED = WIN32_ERROR.ERROR_REMOTE_PRINT_CONNECTIONS_BLOCKED;
pub const ERROR_NTLM_BLOCKED = WIN32_ERROR.ERROR_NTLM_BLOCKED;
pub const ERROR_PASSWORD_CHANGE_REQUIRED = WIN32_ERROR.ERROR_PASSWORD_CHANGE_REQUIRED;
pub const ERROR_LOST_MODE_LOGON_RESTRICTION = WIN32_ERROR.ERROR_LOST_MODE_LOGON_RESTRICTION;
pub const ERROR_INVALID_PIXEL_FORMAT = WIN32_ERROR.ERROR_INVALID_PIXEL_FORMAT;
pub const ERROR_BAD_DRIVER = WIN32_ERROR.ERROR_BAD_DRIVER;
pub const ERROR_INVALID_WINDOW_STYLE = WIN32_ERROR.ERROR_INVALID_WINDOW_STYLE;
pub const ERROR_METAFILE_NOT_SUPPORTED = WIN32_ERROR.ERROR_METAFILE_NOT_SUPPORTED;
pub const ERROR_TRANSFORM_NOT_SUPPORTED = WIN32_ERROR.ERROR_TRANSFORM_NOT_SUPPORTED;
pub const ERROR_CLIPPING_NOT_SUPPORTED = WIN32_ERROR.ERROR_CLIPPING_NOT_SUPPORTED;
pub const ERROR_INVALID_CMM = WIN32_ERROR.ERROR_INVALID_CMM;
pub const ERROR_INVALID_PROFILE = WIN32_ERROR.ERROR_INVALID_PROFILE;
pub const ERROR_TAG_NOT_FOUND = WIN32_ERROR.ERROR_TAG_NOT_FOUND;
pub const ERROR_TAG_NOT_PRESENT = WIN32_ERROR.ERROR_TAG_NOT_PRESENT;
pub const ERROR_DUPLICATE_TAG = WIN32_ERROR.ERROR_DUPLICATE_TAG;
pub const ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE = WIN32_ERROR.ERROR_PROFILE_NOT_ASSOCIATED_WITH_DEVICE;
pub const ERROR_PROFILE_NOT_FOUND = WIN32_ERROR.ERROR_PROFILE_NOT_FOUND;
pub const ERROR_INVALID_COLORSPACE = WIN32_ERROR.ERROR_INVALID_COLORSPACE;
pub const ERROR_ICM_NOT_ENABLED = WIN32_ERROR.ERROR_ICM_NOT_ENABLED;
pub const ERROR_DELETING_ICM_XFORM = WIN32_ERROR.ERROR_DELETING_ICM_XFORM;
pub const ERROR_INVALID_TRANSFORM = WIN32_ERROR.ERROR_INVALID_TRANSFORM;
pub const ERROR_COLORSPACE_MISMATCH = WIN32_ERROR.ERROR_COLORSPACE_MISMATCH;
pub const ERROR_INVALID_COLORINDEX = WIN32_ERROR.ERROR_INVALID_COLORINDEX;
pub const ERROR_PROFILE_DOES_NOT_MATCH_DEVICE = WIN32_ERROR.ERROR_PROFILE_DOES_NOT_MATCH_DEVICE;
pub const ERROR_CONNECTED_OTHER_PASSWORD = WIN32_ERROR.ERROR_CONNECTED_OTHER_PASSWORD;
pub const ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT = WIN32_ERROR.ERROR_CONNECTED_OTHER_PASSWORD_DEFAULT;
pub const ERROR_BAD_USERNAME = WIN32_ERROR.ERROR_BAD_USERNAME;
pub const ERROR_NOT_CONNECTED = WIN32_ERROR.ERROR_NOT_CONNECTED;
pub const ERROR_OPEN_FILES = WIN32_ERROR.ERROR_OPEN_FILES;
pub const ERROR_ACTIVE_CONNECTIONS = WIN32_ERROR.ERROR_ACTIVE_CONNECTIONS;
pub const ERROR_DEVICE_IN_USE = WIN32_ERROR.ERROR_DEVICE_IN_USE;
pub const ERROR_UNKNOWN_PRINT_MONITOR = WIN32_ERROR.ERROR_UNKNOWN_PRINT_MONITOR;
pub const ERROR_PRINTER_DRIVER_IN_USE = WIN32_ERROR.ERROR_PRINTER_DRIVER_IN_USE;
pub const ERROR_SPOOL_FILE_NOT_FOUND = WIN32_ERROR.ERROR_SPOOL_FILE_NOT_FOUND;
pub const ERROR_SPL_NO_STARTDOC = WIN32_ERROR.ERROR_SPL_NO_STARTDOC;
pub const ERROR_SPL_NO_ADDJOB = WIN32_ERROR.ERROR_SPL_NO_ADDJOB;
pub const ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED = WIN32_ERROR.ERROR_PRINT_PROCESSOR_ALREADY_INSTALLED;
pub const ERROR_PRINT_MONITOR_ALREADY_INSTALLED = WIN32_ERROR.ERROR_PRINT_MONITOR_ALREADY_INSTALLED;
pub const ERROR_INVALID_PRINT_MONITOR = WIN32_ERROR.ERROR_INVALID_PRINT_MONITOR;
pub const ERROR_PRINT_MONITOR_IN_USE = WIN32_ERROR.ERROR_PRINT_MONITOR_IN_USE;
pub const ERROR_PRINTER_HAS_JOBS_QUEUED = WIN32_ERROR.ERROR_PRINTER_HAS_JOBS_QUEUED;
pub const ERROR_SUCCESS_REBOOT_REQUIRED = WIN32_ERROR.ERROR_SUCCESS_REBOOT_REQUIRED;
pub const ERROR_SUCCESS_RESTART_REQUIRED = WIN32_ERROR.ERROR_SUCCESS_RESTART_REQUIRED;
pub const ERROR_PRINTER_NOT_FOUND = WIN32_ERROR.ERROR_PRINTER_NOT_FOUND;
pub const ERROR_PRINTER_DRIVER_WARNED = WIN32_ERROR.ERROR_PRINTER_DRIVER_WARNED;
pub const ERROR_PRINTER_DRIVER_BLOCKED = WIN32_ERROR.ERROR_PRINTER_DRIVER_BLOCKED;
pub const ERROR_PRINTER_DRIVER_PACKAGE_IN_USE = WIN32_ERROR.ERROR_PRINTER_DRIVER_PACKAGE_IN_USE;
pub const ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND = WIN32_ERROR.ERROR_CORE_DRIVER_PACKAGE_NOT_FOUND;
pub const ERROR_FAIL_REBOOT_REQUIRED = WIN32_ERROR.ERROR_FAIL_REBOOT_REQUIRED;
pub const ERROR_FAIL_REBOOT_INITIATED = WIN32_ERROR.ERROR_FAIL_REBOOT_INITIATED;
pub const ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED = WIN32_ERROR.ERROR_PRINTER_DRIVER_DOWNLOAD_NEEDED;
pub const ERROR_PRINT_JOB_RESTART_REQUIRED = WIN32_ERROR.ERROR_PRINT_JOB_RESTART_REQUIRED;
pub const ERROR_INVALID_PRINTER_DRIVER_MANIFEST = WIN32_ERROR.ERROR_INVALID_PRINTER_DRIVER_MANIFEST;
pub const ERROR_PRINTER_NOT_SHAREABLE = WIN32_ERROR.ERROR_PRINTER_NOT_SHAREABLE;
pub const ERROR_REQUEST_PAUSED = WIN32_ERROR.ERROR_REQUEST_PAUSED;
pub const ERROR_APPEXEC_CONDITION_NOT_SATISFIED = WIN32_ERROR.ERROR_APPEXEC_CONDITION_NOT_SATISFIED;
pub const ERROR_APPEXEC_HANDLE_INVALIDATED = WIN32_ERROR.ERROR_APPEXEC_HANDLE_INVALIDATED;
pub const ERROR_APPEXEC_INVALID_HOST_GENERATION = WIN32_ERROR.ERROR_APPEXEC_INVALID_HOST_GENERATION;
pub const ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION = WIN32_ERROR.ERROR_APPEXEC_UNEXPECTED_PROCESS_REGISTRATION;
pub const ERROR_APPEXEC_INVALID_HOST_STATE = WIN32_ERROR.ERROR_APPEXEC_INVALID_HOST_STATE;
pub const ERROR_APPEXEC_NO_DONOR = WIN32_ERROR.ERROR_APPEXEC_NO_DONOR;
pub const ERROR_APPEXEC_HOST_ID_MISMATCH = WIN32_ERROR.ERROR_APPEXEC_HOST_ID_MISMATCH;
pub const ERROR_APPEXEC_UNKNOWN_USER = WIN32_ERROR.ERROR_APPEXEC_UNKNOWN_USER;
pub const ERROR_IO_REISSUE_AS_CACHED = WIN32_ERROR.ERROR_IO_REISSUE_AS_CACHED;
pub const ERROR_WINS_INTERNAL = WIN32_ERROR.ERROR_WINS_INTERNAL;
pub const ERROR_CAN_NOT_DEL_LOCAL_WINS = WIN32_ERROR.ERROR_CAN_NOT_DEL_LOCAL_WINS;
pub const ERROR_STATIC_INIT = WIN32_ERROR.ERROR_STATIC_INIT;
pub const ERROR_INC_BACKUP = WIN32_ERROR.ERROR_INC_BACKUP;
pub const ERROR_FULL_BACKUP = WIN32_ERROR.ERROR_FULL_BACKUP;
pub const ERROR_REC_NON_EXISTENT = WIN32_ERROR.ERROR_REC_NON_EXISTENT;
pub const ERROR_RPL_NOT_ALLOWED = WIN32_ERROR.ERROR_RPL_NOT_ALLOWED;
pub const ERROR_DHCP_ADDRESS_CONFLICT = WIN32_ERROR.ERROR_DHCP_ADDRESS_CONFLICT;
pub const ERROR_WMI_GUID_NOT_FOUND = WIN32_ERROR.ERROR_WMI_GUID_NOT_FOUND;
pub const ERROR_WMI_INSTANCE_NOT_FOUND = WIN32_ERROR.ERROR_WMI_INSTANCE_NOT_FOUND;
pub const ERROR_WMI_ITEMID_NOT_FOUND = WIN32_ERROR.ERROR_WMI_ITEMID_NOT_FOUND;
pub const ERROR_WMI_TRY_AGAIN = WIN32_ERROR.ERROR_WMI_TRY_AGAIN;
pub const ERROR_WMI_DP_NOT_FOUND = WIN32_ERROR.ERROR_WMI_DP_NOT_FOUND;
pub const ERROR_WMI_UNRESOLVED_INSTANCE_REF = WIN32_ERROR.ERROR_WMI_UNRESOLVED_INSTANCE_REF;
pub const ERROR_WMI_ALREADY_ENABLED = WIN32_ERROR.ERROR_WMI_ALREADY_ENABLED;
pub const ERROR_WMI_GUID_DISCONNECTED = WIN32_ERROR.ERROR_WMI_GUID_DISCONNECTED;
pub const ERROR_WMI_SERVER_UNAVAILABLE = WIN32_ERROR.ERROR_WMI_SERVER_UNAVAILABLE;
pub const ERROR_WMI_DP_FAILED = WIN32_ERROR.ERROR_WMI_DP_FAILED;
pub const ERROR_WMI_INVALID_MOF = WIN32_ERROR.ERROR_WMI_INVALID_MOF;
pub const ERROR_WMI_INVALID_REGINFO = WIN32_ERROR.ERROR_WMI_INVALID_REGINFO;
pub const ERROR_WMI_ALREADY_DISABLED = WIN32_ERROR.ERROR_WMI_ALREADY_DISABLED;
pub const ERROR_WMI_READ_ONLY = WIN32_ERROR.ERROR_WMI_READ_ONLY;
pub const ERROR_WMI_SET_FAILURE = WIN32_ERROR.ERROR_WMI_SET_FAILURE;
pub const ERROR_NOT_APPCONTAINER = WIN32_ERROR.ERROR_NOT_APPCONTAINER;
pub const ERROR_APPCONTAINER_REQUIRED = WIN32_ERROR.ERROR_APPCONTAINER_REQUIRED;
pub const ERROR_NOT_SUPPORTED_IN_APPCONTAINER = WIN32_ERROR.ERROR_NOT_SUPPORTED_IN_APPCONTAINER;
pub const ERROR_INVALID_PACKAGE_SID_LENGTH = WIN32_ERROR.ERROR_INVALID_PACKAGE_SID_LENGTH;
pub const ERROR_INVALID_MEDIA = WIN32_ERROR.ERROR_INVALID_MEDIA;
pub const ERROR_INVALID_LIBRARY = WIN32_ERROR.ERROR_INVALID_LIBRARY;
pub const ERROR_INVALID_MEDIA_POOL = WIN32_ERROR.ERROR_INVALID_MEDIA_POOL;
pub const ERROR_DRIVE_MEDIA_MISMATCH = WIN32_ERROR.ERROR_DRIVE_MEDIA_MISMATCH;
pub const ERROR_MEDIA_OFFLINE = WIN32_ERROR.ERROR_MEDIA_OFFLINE;
pub const ERROR_LIBRARY_OFFLINE = WIN32_ERROR.ERROR_LIBRARY_OFFLINE;
pub const ERROR_EMPTY = WIN32_ERROR.ERROR_EMPTY;
pub const ERROR_NOT_EMPTY = WIN32_ERROR.ERROR_NOT_EMPTY;
pub const ERROR_MEDIA_UNAVAILABLE = WIN32_ERROR.ERROR_MEDIA_UNAVAILABLE;
pub const ERROR_RESOURCE_DISABLED = WIN32_ERROR.ERROR_RESOURCE_DISABLED;
pub const ERROR_INVALID_CLEANER = WIN32_ERROR.ERROR_INVALID_CLEANER;
pub const ERROR_UNABLE_TO_CLEAN = WIN32_ERROR.ERROR_UNABLE_TO_CLEAN;
pub const ERROR_OBJECT_NOT_FOUND = WIN32_ERROR.ERROR_OBJECT_NOT_FOUND;
pub const ERROR_DATABASE_FAILURE = WIN32_ERROR.ERROR_DATABASE_FAILURE;
pub const ERROR_DATABASE_FULL = WIN32_ERROR.ERROR_DATABASE_FULL;
pub const ERROR_MEDIA_INCOMPATIBLE = WIN32_ERROR.ERROR_MEDIA_INCOMPATIBLE;
pub const ERROR_RESOURCE_NOT_PRESENT = WIN32_ERROR.ERROR_RESOURCE_NOT_PRESENT;
pub const ERROR_INVALID_OPERATION = WIN32_ERROR.ERROR_INVALID_OPERATION;
pub const ERROR_MEDIA_NOT_AVAILABLE = WIN32_ERROR.ERROR_MEDIA_NOT_AVAILABLE;
pub const ERROR_DEVICE_NOT_AVAILABLE = WIN32_ERROR.ERROR_DEVICE_NOT_AVAILABLE;
pub const ERROR_REQUEST_REFUSED = WIN32_ERROR.ERROR_REQUEST_REFUSED;
pub const ERROR_INVALID_DRIVE_OBJECT = WIN32_ERROR.ERROR_INVALID_DRIVE_OBJECT;
pub const ERROR_LIBRARY_FULL = WIN32_ERROR.ERROR_LIBRARY_FULL;
pub const ERROR_MEDIUM_NOT_ACCESSIBLE = WIN32_ERROR.ERROR_MEDIUM_NOT_ACCESSIBLE;
pub const ERROR_UNABLE_TO_LOAD_MEDIUM = WIN32_ERROR.ERROR_UNABLE_TO_LOAD_MEDIUM;
pub const ERROR_UNABLE_TO_INVENTORY_DRIVE = WIN32_ERROR.ERROR_UNABLE_TO_INVENTORY_DRIVE;
pub const ERROR_UNABLE_TO_INVENTORY_SLOT = WIN32_ERROR.ERROR_UNABLE_TO_INVENTORY_SLOT;
pub const ERROR_UNABLE_TO_INVENTORY_TRANSPORT = WIN32_ERROR.ERROR_UNABLE_TO_INVENTORY_TRANSPORT;
pub const ERROR_TRANSPORT_FULL = WIN32_ERROR.ERROR_TRANSPORT_FULL;
pub const ERROR_CONTROLLING_IEPORT = WIN32_ERROR.ERROR_CONTROLLING_IEPORT;
pub const ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA = WIN32_ERROR.ERROR_UNABLE_TO_EJECT_MOUNTED_MEDIA;
pub const ERROR_CLEANER_SLOT_SET = WIN32_ERROR.ERROR_CLEANER_SLOT_SET;
pub const ERROR_CLEANER_SLOT_NOT_SET = WIN32_ERROR.ERROR_CLEANER_SLOT_NOT_SET;
pub const ERROR_CLEANER_CARTRIDGE_SPENT = WIN32_ERROR.ERROR_CLEANER_CARTRIDGE_SPENT;
pub const ERROR_UNEXPECTED_OMID = WIN32_ERROR.ERROR_UNEXPECTED_OMID;
pub const ERROR_CANT_DELETE_LAST_ITEM = WIN32_ERROR.ERROR_CANT_DELETE_LAST_ITEM;
pub const ERROR_MESSAGE_EXCEEDS_MAX_SIZE = WIN32_ERROR.ERROR_MESSAGE_EXCEEDS_MAX_SIZE;
pub const ERROR_VOLUME_CONTAINS_SYS_FILES = WIN32_ERROR.ERROR_VOLUME_CONTAINS_SYS_FILES;
pub const ERROR_INDIGENOUS_TYPE = WIN32_ERROR.ERROR_INDIGENOUS_TYPE;
pub const ERROR_NO_SUPPORTING_DRIVES = WIN32_ERROR.ERROR_NO_SUPPORTING_DRIVES;
pub const ERROR_CLEANER_CARTRIDGE_INSTALLED = WIN32_ERROR.ERROR_CLEANER_CARTRIDGE_INSTALLED;
pub const ERROR_IEPORT_FULL = WIN32_ERROR.ERROR_IEPORT_FULL;
pub const ERROR_FILE_OFFLINE = WIN32_ERROR.ERROR_FILE_OFFLINE;
pub const ERROR_REMOTE_STORAGE_NOT_ACTIVE = WIN32_ERROR.ERROR_REMOTE_STORAGE_NOT_ACTIVE;
pub const ERROR_REMOTE_STORAGE_MEDIA_ERROR = WIN32_ERROR.ERROR_REMOTE_STORAGE_MEDIA_ERROR;
pub const ERROR_NOT_A_REPARSE_POINT = WIN32_ERROR.ERROR_NOT_A_REPARSE_POINT;
pub const ERROR_REPARSE_ATTRIBUTE_CONFLICT = WIN32_ERROR.ERROR_REPARSE_ATTRIBUTE_CONFLICT;
pub const ERROR_INVALID_REPARSE_DATA = WIN32_ERROR.ERROR_INVALID_REPARSE_DATA;
pub const ERROR_REPARSE_TAG_INVALID = WIN32_ERROR.ERROR_REPARSE_TAG_INVALID;
pub const ERROR_REPARSE_TAG_MISMATCH = WIN32_ERROR.ERROR_REPARSE_TAG_MISMATCH;
pub const ERROR_REPARSE_POINT_ENCOUNTERED = WIN32_ERROR.ERROR_REPARSE_POINT_ENCOUNTERED;
pub const ERROR_APP_DATA_NOT_FOUND = WIN32_ERROR.ERROR_APP_DATA_NOT_FOUND;
pub const ERROR_APP_DATA_EXPIRED = WIN32_ERROR.ERROR_APP_DATA_EXPIRED;
pub const ERROR_APP_DATA_CORRUPT = WIN32_ERROR.ERROR_APP_DATA_CORRUPT;
pub const ERROR_APP_DATA_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_APP_DATA_LIMIT_EXCEEDED;
pub const ERROR_APP_DATA_REBOOT_REQUIRED = WIN32_ERROR.ERROR_APP_DATA_REBOOT_REQUIRED;
pub const ERROR_SECUREBOOT_ROLLBACK_DETECTED = WIN32_ERROR.ERROR_SECUREBOOT_ROLLBACK_DETECTED;
pub const ERROR_SECUREBOOT_POLICY_VIOLATION = WIN32_ERROR.ERROR_SECUREBOOT_POLICY_VIOLATION;
pub const ERROR_SECUREBOOT_INVALID_POLICY = WIN32_ERROR.ERROR_SECUREBOOT_INVALID_POLICY;
pub const ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND = WIN32_ERROR.ERROR_SECUREBOOT_POLICY_PUBLISHER_NOT_FOUND;
pub const ERROR_SECUREBOOT_POLICY_NOT_SIGNED = WIN32_ERROR.ERROR_SECUREBOOT_POLICY_NOT_SIGNED;
pub const ERROR_SECUREBOOT_NOT_ENABLED = WIN32_ERROR.ERROR_SECUREBOOT_NOT_ENABLED;
pub const ERROR_SECUREBOOT_FILE_REPLACED = WIN32_ERROR.ERROR_SECUREBOOT_FILE_REPLACED;
pub const ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED = WIN32_ERROR.ERROR_SECUREBOOT_POLICY_NOT_AUTHORIZED;
pub const ERROR_SECUREBOOT_POLICY_UNKNOWN = WIN32_ERROR.ERROR_SECUREBOOT_POLICY_UNKNOWN;
pub const ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION = WIN32_ERROR.ERROR_SECUREBOOT_POLICY_MISSING_ANTIROLLBACKVERSION;
pub const ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH = WIN32_ERROR.ERROR_SECUREBOOT_PLATFORM_ID_MISMATCH;
pub const ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED = WIN32_ERROR.ERROR_SECUREBOOT_POLICY_ROLLBACK_DETECTED;
pub const ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH = WIN32_ERROR.ERROR_SECUREBOOT_POLICY_UPGRADE_MISMATCH;
pub const ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING = WIN32_ERROR.ERROR_SECUREBOOT_REQUIRED_POLICY_FILE_MISSING;
pub const ERROR_SECUREBOOT_NOT_BASE_POLICY = WIN32_ERROR.ERROR_SECUREBOOT_NOT_BASE_POLICY;
pub const ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY = WIN32_ERROR.ERROR_SECUREBOOT_NOT_SUPPLEMENTAL_POLICY;
pub const ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED = WIN32_ERROR.ERROR_OFFLOAD_READ_FLT_NOT_SUPPORTED;
pub const ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED = WIN32_ERROR.ERROR_OFFLOAD_WRITE_FLT_NOT_SUPPORTED;
pub const ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED = WIN32_ERROR.ERROR_OFFLOAD_READ_FILE_NOT_SUPPORTED;
pub const ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED = WIN32_ERROR.ERROR_OFFLOAD_WRITE_FILE_NOT_SUPPORTED;
pub const ERROR_ALREADY_HAS_STREAM_ID = WIN32_ERROR.ERROR_ALREADY_HAS_STREAM_ID;
pub const ERROR_SMR_GARBAGE_COLLECTION_REQUIRED = WIN32_ERROR.ERROR_SMR_GARBAGE_COLLECTION_REQUIRED;
pub const ERROR_WOF_WIM_HEADER_CORRUPT = WIN32_ERROR.ERROR_WOF_WIM_HEADER_CORRUPT;
pub const ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT = WIN32_ERROR.ERROR_WOF_WIM_RESOURCE_TABLE_CORRUPT;
pub const ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT = WIN32_ERROR.ERROR_WOF_FILE_RESOURCE_TABLE_CORRUPT;
pub const ERROR_VOLUME_NOT_SIS_ENABLED = WIN32_ERROR.ERROR_VOLUME_NOT_SIS_ENABLED;
pub const ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED = WIN32_ERROR.ERROR_SYSTEM_INTEGRITY_ROLLBACK_DETECTED;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION = WIN32_ERROR.ERROR_SYSTEM_INTEGRITY_POLICY_VIOLATION;
pub const ERROR_SYSTEM_INTEGRITY_INVALID_POLICY = WIN32_ERROR.ERROR_SYSTEM_INTEGRITY_INVALID_POLICY;
pub const ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED = WIN32_ERROR.ERROR_SYSTEM_INTEGRITY_POLICY_NOT_SIGNED;
pub const ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES = WIN32_ERROR.ERROR_SYSTEM_INTEGRITY_TOO_MANY_POLICIES;
pub const ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED = WIN32_ERROR.ERROR_SYSTEM_INTEGRITY_SUPPLEMENTAL_POLICY_NOT_AUTHORIZED;
pub const ERROR_VSM_NOT_INITIALIZED = WIN32_ERROR.ERROR_VSM_NOT_INITIALIZED;
pub const ERROR_VSM_DMA_PROTECTION_NOT_IN_USE = WIN32_ERROR.ERROR_VSM_DMA_PROTECTION_NOT_IN_USE;
pub const ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED = WIN32_ERROR.ERROR_PLATFORM_MANIFEST_NOT_AUTHORIZED;
pub const ERROR_PLATFORM_MANIFEST_INVALID = WIN32_ERROR.ERROR_PLATFORM_MANIFEST_INVALID;
pub const ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED = WIN32_ERROR.ERROR_PLATFORM_MANIFEST_FILE_NOT_AUTHORIZED;
pub const ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED = WIN32_ERROR.ERROR_PLATFORM_MANIFEST_CATALOG_NOT_AUTHORIZED;
pub const ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND = WIN32_ERROR.ERROR_PLATFORM_MANIFEST_BINARY_ID_NOT_FOUND;
pub const ERROR_PLATFORM_MANIFEST_NOT_ACTIVE = WIN32_ERROR.ERROR_PLATFORM_MANIFEST_NOT_ACTIVE;
pub const ERROR_PLATFORM_MANIFEST_NOT_SIGNED = WIN32_ERROR.ERROR_PLATFORM_MANIFEST_NOT_SIGNED;
pub const ERROR_DEPENDENT_RESOURCE_EXISTS = WIN32_ERROR.ERROR_DEPENDENT_RESOURCE_EXISTS;
pub const ERROR_DEPENDENCY_NOT_FOUND = WIN32_ERROR.ERROR_DEPENDENCY_NOT_FOUND;
pub const ERROR_DEPENDENCY_ALREADY_EXISTS = WIN32_ERROR.ERROR_DEPENDENCY_ALREADY_EXISTS;
pub const ERROR_RESOURCE_NOT_ONLINE = WIN32_ERROR.ERROR_RESOURCE_NOT_ONLINE;
pub const ERROR_HOST_NODE_NOT_AVAILABLE = WIN32_ERROR.ERROR_HOST_NODE_NOT_AVAILABLE;
pub const ERROR_RESOURCE_NOT_AVAILABLE = WIN32_ERROR.ERROR_RESOURCE_NOT_AVAILABLE;
pub const ERROR_RESOURCE_NOT_FOUND = WIN32_ERROR.ERROR_RESOURCE_NOT_FOUND;
pub const ERROR_SHUTDOWN_CLUSTER = WIN32_ERROR.ERROR_SHUTDOWN_CLUSTER;
pub const ERROR_CANT_EVICT_ACTIVE_NODE = WIN32_ERROR.ERROR_CANT_EVICT_ACTIVE_NODE;
pub const ERROR_OBJECT_ALREADY_EXISTS = WIN32_ERROR.ERROR_OBJECT_ALREADY_EXISTS;
pub const ERROR_OBJECT_IN_LIST = WIN32_ERROR.ERROR_OBJECT_IN_LIST;
pub const ERROR_GROUP_NOT_AVAILABLE = WIN32_ERROR.ERROR_GROUP_NOT_AVAILABLE;
pub const ERROR_GROUP_NOT_FOUND = WIN32_ERROR.ERROR_GROUP_NOT_FOUND;
pub const ERROR_GROUP_NOT_ONLINE = WIN32_ERROR.ERROR_GROUP_NOT_ONLINE;
pub const ERROR_HOST_NODE_NOT_RESOURCE_OWNER = WIN32_ERROR.ERROR_HOST_NODE_NOT_RESOURCE_OWNER;
pub const ERROR_HOST_NODE_NOT_GROUP_OWNER = WIN32_ERROR.ERROR_HOST_NODE_NOT_GROUP_OWNER;
pub const ERROR_RESMON_CREATE_FAILED = WIN32_ERROR.ERROR_RESMON_CREATE_FAILED;
pub const ERROR_RESMON_ONLINE_FAILED = WIN32_ERROR.ERROR_RESMON_ONLINE_FAILED;
pub const ERROR_RESOURCE_ONLINE = WIN32_ERROR.ERROR_RESOURCE_ONLINE;
pub const ERROR_QUORUM_RESOURCE = WIN32_ERROR.ERROR_QUORUM_RESOURCE;
pub const ERROR_NOT_QUORUM_CAPABLE = WIN32_ERROR.ERROR_NOT_QUORUM_CAPABLE;
pub const ERROR_CLUSTER_SHUTTING_DOWN = WIN32_ERROR.ERROR_CLUSTER_SHUTTING_DOWN;
pub const ERROR_INVALID_STATE = WIN32_ERROR.ERROR_INVALID_STATE;
pub const ERROR_RESOURCE_PROPERTIES_STORED = WIN32_ERROR.ERROR_RESOURCE_PROPERTIES_STORED;
pub const ERROR_NOT_QUORUM_CLASS = WIN32_ERROR.ERROR_NOT_QUORUM_CLASS;
pub const ERROR_CORE_RESOURCE = WIN32_ERROR.ERROR_CORE_RESOURCE;
pub const ERROR_QUORUM_RESOURCE_ONLINE_FAILED = WIN32_ERROR.ERROR_QUORUM_RESOURCE_ONLINE_FAILED;
pub const ERROR_QUORUMLOG_OPEN_FAILED = WIN32_ERROR.ERROR_QUORUMLOG_OPEN_FAILED;
pub const ERROR_CLUSTERLOG_CORRUPT = WIN32_ERROR.ERROR_CLUSTERLOG_CORRUPT;
pub const ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE = WIN32_ERROR.ERROR_CLUSTERLOG_RECORD_EXCEEDS_MAXSIZE;
pub const ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE = WIN32_ERROR.ERROR_CLUSTERLOG_EXCEEDS_MAXSIZE;
pub const ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTERLOG_CHKPOINT_NOT_FOUND;
pub const ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE = WIN32_ERROR.ERROR_CLUSTERLOG_NOT_ENOUGH_SPACE;
pub const ERROR_QUORUM_OWNER_ALIVE = WIN32_ERROR.ERROR_QUORUM_OWNER_ALIVE;
pub const ERROR_NETWORK_NOT_AVAILABLE = WIN32_ERROR.ERROR_NETWORK_NOT_AVAILABLE;
pub const ERROR_NODE_NOT_AVAILABLE = WIN32_ERROR.ERROR_NODE_NOT_AVAILABLE;
pub const ERROR_ALL_NODES_NOT_AVAILABLE = WIN32_ERROR.ERROR_ALL_NODES_NOT_AVAILABLE;
pub const ERROR_RESOURCE_FAILED = WIN32_ERROR.ERROR_RESOURCE_FAILED;
pub const ERROR_CLUSTER_INVALID_NODE = WIN32_ERROR.ERROR_CLUSTER_INVALID_NODE;
pub const ERROR_CLUSTER_NODE_EXISTS = WIN32_ERROR.ERROR_CLUSTER_NODE_EXISTS;
pub const ERROR_CLUSTER_JOIN_IN_PROGRESS = WIN32_ERROR.ERROR_CLUSTER_JOIN_IN_PROGRESS;
pub const ERROR_CLUSTER_NODE_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTER_NODE_NOT_FOUND;
pub const ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTER_LOCAL_NODE_NOT_FOUND;
pub const ERROR_CLUSTER_NETWORK_EXISTS = WIN32_ERROR.ERROR_CLUSTER_NETWORK_EXISTS;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTER_NETWORK_NOT_FOUND;
pub const ERROR_CLUSTER_NETINTERFACE_EXISTS = WIN32_ERROR.ERROR_CLUSTER_NETINTERFACE_EXISTS;
pub const ERROR_CLUSTER_NETINTERFACE_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTER_NETINTERFACE_NOT_FOUND;
pub const ERROR_CLUSTER_INVALID_REQUEST = WIN32_ERROR.ERROR_CLUSTER_INVALID_REQUEST;
pub const ERROR_CLUSTER_INVALID_NETWORK_PROVIDER = WIN32_ERROR.ERROR_CLUSTER_INVALID_NETWORK_PROVIDER;
pub const ERROR_CLUSTER_NODE_DOWN = WIN32_ERROR.ERROR_CLUSTER_NODE_DOWN;
pub const ERROR_CLUSTER_NODE_UNREACHABLE = WIN32_ERROR.ERROR_CLUSTER_NODE_UNREACHABLE;
pub const ERROR_CLUSTER_NODE_NOT_MEMBER = WIN32_ERROR.ERROR_CLUSTER_NODE_NOT_MEMBER;
pub const ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS = WIN32_ERROR.ERROR_CLUSTER_JOIN_NOT_IN_PROGRESS;
pub const ERROR_CLUSTER_INVALID_NETWORK = WIN32_ERROR.ERROR_CLUSTER_INVALID_NETWORK;
pub const ERROR_CLUSTER_NODE_UP = WIN32_ERROR.ERROR_CLUSTER_NODE_UP;
pub const ERROR_CLUSTER_IPADDR_IN_USE = WIN32_ERROR.ERROR_CLUSTER_IPADDR_IN_USE;
pub const ERROR_CLUSTER_NODE_NOT_PAUSED = WIN32_ERROR.ERROR_CLUSTER_NODE_NOT_PAUSED;
pub const ERROR_CLUSTER_NO_SECURITY_CONTEXT = WIN32_ERROR.ERROR_CLUSTER_NO_SECURITY_CONTEXT;
pub const ERROR_CLUSTER_NETWORK_NOT_INTERNAL = WIN32_ERROR.ERROR_CLUSTER_NETWORK_NOT_INTERNAL;
pub const ERROR_CLUSTER_NODE_ALREADY_UP = WIN32_ERROR.ERROR_CLUSTER_NODE_ALREADY_UP;
pub const ERROR_CLUSTER_NODE_ALREADY_DOWN = WIN32_ERROR.ERROR_CLUSTER_NODE_ALREADY_DOWN;
pub const ERROR_CLUSTER_NETWORK_ALREADY_ONLINE = WIN32_ERROR.ERROR_CLUSTER_NETWORK_ALREADY_ONLINE;
pub const ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE = WIN32_ERROR.ERROR_CLUSTER_NETWORK_ALREADY_OFFLINE;
pub const ERROR_CLUSTER_NODE_ALREADY_MEMBER = WIN32_ERROR.ERROR_CLUSTER_NODE_ALREADY_MEMBER;
pub const ERROR_CLUSTER_LAST_INTERNAL_NETWORK = WIN32_ERROR.ERROR_CLUSTER_LAST_INTERNAL_NETWORK;
pub const ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS = WIN32_ERROR.ERROR_CLUSTER_NETWORK_HAS_DEPENDENTS;
pub const ERROR_INVALID_OPERATION_ON_QUORUM = WIN32_ERROR.ERROR_INVALID_OPERATION_ON_QUORUM;
pub const ERROR_DEPENDENCY_NOT_ALLOWED = WIN32_ERROR.ERROR_DEPENDENCY_NOT_ALLOWED;
pub const ERROR_CLUSTER_NODE_PAUSED = WIN32_ERROR.ERROR_CLUSTER_NODE_PAUSED;
pub const ERROR_NODE_CANT_HOST_RESOURCE = WIN32_ERROR.ERROR_NODE_CANT_HOST_RESOURCE;
pub const ERROR_CLUSTER_NODE_NOT_READY = WIN32_ERROR.ERROR_CLUSTER_NODE_NOT_READY;
pub const ERROR_CLUSTER_NODE_SHUTTING_DOWN = WIN32_ERROR.ERROR_CLUSTER_NODE_SHUTTING_DOWN;
pub const ERROR_CLUSTER_JOIN_ABORTED = WIN32_ERROR.ERROR_CLUSTER_JOIN_ABORTED;
pub const ERROR_CLUSTER_INCOMPATIBLE_VERSIONS = WIN32_ERROR.ERROR_CLUSTER_INCOMPATIBLE_VERSIONS;
pub const ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED = WIN32_ERROR.ERROR_CLUSTER_MAXNUM_OF_RESOURCES_EXCEEDED;
pub const ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED = WIN32_ERROR.ERROR_CLUSTER_SYSTEM_CONFIG_CHANGED;
pub const ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_TYPE_NOT_FOUND;
pub const ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED = WIN32_ERROR.ERROR_CLUSTER_RESTYPE_NOT_SUPPORTED;
pub const ERROR_CLUSTER_RESNAME_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTER_RESNAME_NOT_FOUND;
pub const ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED = WIN32_ERROR.ERROR_CLUSTER_NO_RPC_PACKAGES_REGISTERED;
pub const ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST = WIN32_ERROR.ERROR_CLUSTER_OWNER_NOT_IN_PREFLIST;
pub const ERROR_CLUSTER_DATABASE_SEQMISMATCH = WIN32_ERROR.ERROR_CLUSTER_DATABASE_SEQMISMATCH;
pub const ERROR_RESMON_INVALID_STATE = WIN32_ERROR.ERROR_RESMON_INVALID_STATE;
pub const ERROR_CLUSTER_GUM_NOT_LOCKER = WIN32_ERROR.ERROR_CLUSTER_GUM_NOT_LOCKER;
pub const ERROR_QUORUM_DISK_NOT_FOUND = WIN32_ERROR.ERROR_QUORUM_DISK_NOT_FOUND;
pub const ERROR_DATABASE_BACKUP_CORRUPT = WIN32_ERROR.ERROR_DATABASE_BACKUP_CORRUPT;
pub const ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT = WIN32_ERROR.ERROR_CLUSTER_NODE_ALREADY_HAS_DFS_ROOT;
pub const ERROR_RESOURCE_PROPERTY_UNCHANGEABLE = WIN32_ERROR.ERROR_RESOURCE_PROPERTY_UNCHANGEABLE;
pub const ERROR_NO_ADMIN_ACCESS_POINT = WIN32_ERROR.ERROR_NO_ADMIN_ACCESS_POINT;
pub const ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE = WIN32_ERROR.ERROR_CLUSTER_MEMBERSHIP_INVALID_STATE;
pub const ERROR_CLUSTER_QUORUMLOG_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTER_QUORUMLOG_NOT_FOUND;
pub const ERROR_CLUSTER_MEMBERSHIP_HALT = WIN32_ERROR.ERROR_CLUSTER_MEMBERSHIP_HALT;
pub const ERROR_CLUSTER_INSTANCE_ID_MISMATCH = WIN32_ERROR.ERROR_CLUSTER_INSTANCE_ID_MISMATCH;
pub const ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP = WIN32_ERROR.ERROR_CLUSTER_NETWORK_NOT_FOUND_FOR_IP;
pub const ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH = WIN32_ERROR.ERROR_CLUSTER_PROPERTY_DATA_TYPE_MISMATCH;
pub const ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP = WIN32_ERROR.ERROR_CLUSTER_EVICT_WITHOUT_CLEANUP;
pub const ERROR_CLUSTER_PARAMETER_MISMATCH = WIN32_ERROR.ERROR_CLUSTER_PARAMETER_MISMATCH;
pub const ERROR_NODE_CANNOT_BE_CLUSTERED = WIN32_ERROR.ERROR_NODE_CANNOT_BE_CLUSTERED;
pub const ERROR_CLUSTER_WRONG_OS_VERSION = WIN32_ERROR.ERROR_CLUSTER_WRONG_OS_VERSION;
pub const ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME = WIN32_ERROR.ERROR_CLUSTER_CANT_CREATE_DUP_CLUSTER_NAME;
pub const ERROR_CLUSCFG_ALREADY_COMMITTED = WIN32_ERROR.ERROR_CLUSCFG_ALREADY_COMMITTED;
pub const ERROR_CLUSCFG_ROLLBACK_FAILED = WIN32_ERROR.ERROR_CLUSCFG_ROLLBACK_FAILED;
pub const ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT = WIN32_ERROR.ERROR_CLUSCFG_SYSTEM_DISK_DRIVE_LETTER_CONFLICT;
pub const ERROR_CLUSTER_OLD_VERSION = WIN32_ERROR.ERROR_CLUSTER_OLD_VERSION;
pub const ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME = WIN32_ERROR.ERROR_CLUSTER_MISMATCHED_COMPUTER_ACCT_NAME;
pub const ERROR_CLUSTER_NO_NET_ADAPTERS = WIN32_ERROR.ERROR_CLUSTER_NO_NET_ADAPTERS;
pub const ERROR_CLUSTER_POISONED = WIN32_ERROR.ERROR_CLUSTER_POISONED;
pub const ERROR_CLUSTER_GROUP_MOVING = WIN32_ERROR.ERROR_CLUSTER_GROUP_MOVING;
pub const ERROR_CLUSTER_RESOURCE_TYPE_BUSY = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_TYPE_BUSY;
pub const ERROR_RESOURCE_CALL_TIMED_OUT = WIN32_ERROR.ERROR_RESOURCE_CALL_TIMED_OUT;
pub const ERROR_INVALID_CLUSTER_IPV6_ADDRESS = WIN32_ERROR.ERROR_INVALID_CLUSTER_IPV6_ADDRESS;
pub const ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION = WIN32_ERROR.ERROR_CLUSTER_INTERNAL_INVALID_FUNCTION;
pub const ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS = WIN32_ERROR.ERROR_CLUSTER_PARAMETER_OUT_OF_BOUNDS;
pub const ERROR_CLUSTER_PARTIAL_SEND = WIN32_ERROR.ERROR_CLUSTER_PARTIAL_SEND;
pub const ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION = WIN32_ERROR.ERROR_CLUSTER_REGISTRY_INVALID_FUNCTION;
pub const ERROR_CLUSTER_INVALID_STRING_TERMINATION = WIN32_ERROR.ERROR_CLUSTER_INVALID_STRING_TERMINATION;
pub const ERROR_CLUSTER_INVALID_STRING_FORMAT = WIN32_ERROR.ERROR_CLUSTER_INVALID_STRING_FORMAT;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS = WIN32_ERROR.ERROR_CLUSTER_DATABASE_TRANSACTION_IN_PROGRESS;
pub const ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS = WIN32_ERROR.ERROR_CLUSTER_DATABASE_TRANSACTION_NOT_IN_PROGRESS;
pub const ERROR_CLUSTER_NULL_DATA = WIN32_ERROR.ERROR_CLUSTER_NULL_DATA;
pub const ERROR_CLUSTER_PARTIAL_READ = WIN32_ERROR.ERROR_CLUSTER_PARTIAL_READ;
pub const ERROR_CLUSTER_PARTIAL_WRITE = WIN32_ERROR.ERROR_CLUSTER_PARTIAL_WRITE;
pub const ERROR_CLUSTER_CANT_DESERIALIZE_DATA = WIN32_ERROR.ERROR_CLUSTER_CANT_DESERIALIZE_DATA;
pub const ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT = WIN32_ERROR.ERROR_DEPENDENT_RESOURCE_PROPERTY_CONFLICT;
pub const ERROR_CLUSTER_NO_QUORUM = WIN32_ERROR.ERROR_CLUSTER_NO_QUORUM;
pub const ERROR_CLUSTER_INVALID_IPV6_NETWORK = WIN32_ERROR.ERROR_CLUSTER_INVALID_IPV6_NETWORK;
pub const ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK = WIN32_ERROR.ERROR_CLUSTER_INVALID_IPV6_TUNNEL_NETWORK;
pub const ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP = WIN32_ERROR.ERROR_QUORUM_NOT_ALLOWED_IN_THIS_GROUP;
pub const ERROR_DEPENDENCY_TREE_TOO_COMPLEX = WIN32_ERROR.ERROR_DEPENDENCY_TREE_TOO_COMPLEX;
pub const ERROR_EXCEPTION_IN_RESOURCE_CALL = WIN32_ERROR.ERROR_EXCEPTION_IN_RESOURCE_CALL;
pub const ERROR_CLUSTER_RHS_FAILED_INITIALIZATION = WIN32_ERROR.ERROR_CLUSTER_RHS_FAILED_INITIALIZATION;
pub const ERROR_CLUSTER_NOT_INSTALLED = WIN32_ERROR.ERROR_CLUSTER_NOT_INSTALLED;
pub const ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE = WIN32_ERROR.ERROR_CLUSTER_RESOURCES_MUST_BE_ONLINE_ON_THE_SAME_NODE;
pub const ERROR_CLUSTER_MAX_NODES_IN_CLUSTER = WIN32_ERROR.ERROR_CLUSTER_MAX_NODES_IN_CLUSTER;
pub const ERROR_CLUSTER_TOO_MANY_NODES = WIN32_ERROR.ERROR_CLUSTER_TOO_MANY_NODES;
pub const ERROR_CLUSTER_OBJECT_ALREADY_USED = WIN32_ERROR.ERROR_CLUSTER_OBJECT_ALREADY_USED;
pub const ERROR_NONCORE_GROUPS_FOUND = WIN32_ERROR.ERROR_NONCORE_GROUPS_FOUND;
pub const ERROR_FILE_SHARE_RESOURCE_CONFLICT = WIN32_ERROR.ERROR_FILE_SHARE_RESOURCE_CONFLICT;
pub const ERROR_CLUSTER_EVICT_INVALID_REQUEST = WIN32_ERROR.ERROR_CLUSTER_EVICT_INVALID_REQUEST;
pub const ERROR_CLUSTER_SINGLETON_RESOURCE = WIN32_ERROR.ERROR_CLUSTER_SINGLETON_RESOURCE;
pub const ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE = WIN32_ERROR.ERROR_CLUSTER_GROUP_SINGLETON_RESOURCE;
pub const ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_PROVIDER_FAILED;
pub const ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_CONFIGURATION_ERROR;
pub const ERROR_CLUSTER_GROUP_BUSY = WIN32_ERROR.ERROR_CLUSTER_GROUP_BUSY;
pub const ERROR_CLUSTER_NOT_SHARED_VOLUME = WIN32_ERROR.ERROR_CLUSTER_NOT_SHARED_VOLUME;
pub const ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR = WIN32_ERROR.ERROR_CLUSTER_INVALID_SECURITY_DESCRIPTOR;
pub const ERROR_CLUSTER_SHARED_VOLUMES_IN_USE = WIN32_ERROR.ERROR_CLUSTER_SHARED_VOLUMES_IN_USE;
pub const ERROR_CLUSTER_USE_SHARED_VOLUMES_API = WIN32_ERROR.ERROR_CLUSTER_USE_SHARED_VOLUMES_API;
pub const ERROR_CLUSTER_BACKUP_IN_PROGRESS = WIN32_ERROR.ERROR_CLUSTER_BACKUP_IN_PROGRESS;
pub const ERROR_NON_CSV_PATH = WIN32_ERROR.ERROR_NON_CSV_PATH;
pub const ERROR_CSV_VOLUME_NOT_LOCAL = WIN32_ERROR.ERROR_CSV_VOLUME_NOT_LOCAL;
pub const ERROR_CLUSTER_WATCHDOG_TERMINATING = WIN32_ERROR.ERROR_CLUSTER_WATCHDOG_TERMINATING;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_VETOED_MOVE_INCOMPATIBLE_NODES;
pub const ERROR_CLUSTER_INVALID_NODE_WEIGHT = WIN32_ERROR.ERROR_CLUSTER_INVALID_NODE_WEIGHT;
pub const ERROR_CLUSTER_RESOURCE_VETOED_CALL = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_VETOED_CALL;
pub const ERROR_RESMON_SYSTEM_RESOURCES_LACKING = WIN32_ERROR.ERROR_RESMON_SYSTEM_RESOURCES_LACKING;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_DESTINATION;
pub const ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_VETOED_MOVE_NOT_ENOUGH_RESOURCES_ON_SOURCE;
pub const ERROR_CLUSTER_GROUP_QUEUED = WIN32_ERROR.ERROR_CLUSTER_GROUP_QUEUED;
pub const ERROR_CLUSTER_RESOURCE_LOCKED_STATUS = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_LOCKED_STATUS;
pub const ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED = WIN32_ERROR.ERROR_CLUSTER_SHARED_VOLUME_FAILOVER_NOT_ALLOWED;
pub const ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS = WIN32_ERROR.ERROR_CLUSTER_NODE_DRAIN_IN_PROGRESS;
pub const ERROR_CLUSTER_DISK_NOT_CONNECTED = WIN32_ERROR.ERROR_CLUSTER_DISK_NOT_CONNECTED;
pub const ERROR_DISK_NOT_CSV_CAPABLE = WIN32_ERROR.ERROR_DISK_NOT_CSV_CAPABLE;
pub const ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE = WIN32_ERROR.ERROR_RESOURCE_NOT_IN_AVAILABLE_STORAGE;
pub const ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED = WIN32_ERROR.ERROR_CLUSTER_SHARED_VOLUME_REDIRECTED;
pub const ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED = WIN32_ERROR.ERROR_CLUSTER_SHARED_VOLUME_NOT_REDIRECTED;
pub const ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES = WIN32_ERROR.ERROR_CLUSTER_CANNOT_RETURN_PROPERTIES;
pub const ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_CONTAINS_UNSUPPORTED_DIFF_AREA_FOR_SHARED_VOLUMES;
pub const ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_IS_IN_MAINTENANCE_MODE;
pub const ERROR_CLUSTER_AFFINITY_CONFLICT = WIN32_ERROR.ERROR_CLUSTER_AFFINITY_CONFLICT;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_IS_REPLICA_VIRTUAL_MACHINE;
pub const ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS = WIN32_ERROR.ERROR_CLUSTER_UPGRADE_INCOMPATIBLE_VERSIONS;
pub const ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED = WIN32_ERROR.ERROR_CLUSTER_UPGRADE_FIX_QUORUM_NOT_SUPPORTED;
pub const ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED = WIN32_ERROR.ERROR_CLUSTER_UPGRADE_RESTART_REQUIRED;
pub const ERROR_CLUSTER_UPGRADE_IN_PROGRESS = WIN32_ERROR.ERROR_CLUSTER_UPGRADE_IN_PROGRESS;
pub const ERROR_CLUSTER_UPGRADE_INCOMPLETE = WIN32_ERROR.ERROR_CLUSTER_UPGRADE_INCOMPLETE;
pub const ERROR_CLUSTER_NODE_IN_GRACE_PERIOD = WIN32_ERROR.ERROR_CLUSTER_NODE_IN_GRACE_PERIOD;
pub const ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT = WIN32_ERROR.ERROR_CLUSTER_CSV_IO_PAUSE_TIMEOUT;
pub const ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER = WIN32_ERROR.ERROR_NODE_NOT_ACTIVE_CLUSTER_MEMBER;
pub const ERROR_CLUSTER_RESOURCE_NOT_MONITORED = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_NOT_MONITORED;
pub const ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_DOES_NOT_SUPPORT_UNMONITORED;
pub const ERROR_CLUSTER_RESOURCE_IS_REPLICATED = WIN32_ERROR.ERROR_CLUSTER_RESOURCE_IS_REPLICATED;
pub const ERROR_CLUSTER_NODE_ISOLATED = WIN32_ERROR.ERROR_CLUSTER_NODE_ISOLATED;
pub const ERROR_CLUSTER_NODE_QUARANTINED = WIN32_ERROR.ERROR_CLUSTER_NODE_QUARANTINED;
pub const ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED = WIN32_ERROR.ERROR_CLUSTER_DATABASE_UPDATE_CONDITION_FAILED;
pub const ERROR_CLUSTER_SPACE_DEGRADED = WIN32_ERROR.ERROR_CLUSTER_SPACE_DEGRADED;
pub const ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED = WIN32_ERROR.ERROR_CLUSTER_TOKEN_DELEGATION_NOT_SUPPORTED;
pub const ERROR_CLUSTER_CSV_INVALID_HANDLE = WIN32_ERROR.ERROR_CLUSTER_CSV_INVALID_HANDLE;
pub const ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR = WIN32_ERROR.ERROR_CLUSTER_CSV_SUPPORTED_ONLY_ON_COORDINATOR;
pub const ERROR_GROUPSET_NOT_AVAILABLE = WIN32_ERROR.ERROR_GROUPSET_NOT_AVAILABLE;
pub const ERROR_GROUPSET_NOT_FOUND = WIN32_ERROR.ERROR_GROUPSET_NOT_FOUND;
pub const ERROR_GROUPSET_CANT_PROVIDE = WIN32_ERROR.ERROR_GROUPSET_CANT_PROVIDE;
pub const ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND = WIN32_ERROR.ERROR_CLUSTER_FAULT_DOMAIN_PARENT_NOT_FOUND;
pub const ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY = WIN32_ERROR.ERROR_CLUSTER_FAULT_DOMAIN_INVALID_HIERARCHY;
pub const ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION = WIN32_ERROR.ERROR_CLUSTER_FAULT_DOMAIN_FAILED_S2D_VALIDATION;
pub const ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS = WIN32_ERROR.ERROR_CLUSTER_FAULT_DOMAIN_S2D_CONNECTIVITY_LOSS;
pub const ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME = WIN32_ERROR.ERROR_CLUSTER_INVALID_INFRASTRUCTURE_FILESERVER_NAME;
pub const ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE = WIN32_ERROR.ERROR_CLUSTERSET_MANAGEMENT_CLUSTER_UNREACHABLE;
pub const ERROR_ENCRYPTION_FAILED = WIN32_ERROR.ERROR_ENCRYPTION_FAILED;
pub const ERROR_DECRYPTION_FAILED = WIN32_ERROR.ERROR_DECRYPTION_FAILED;
pub const ERROR_FILE_ENCRYPTED = WIN32_ERROR.ERROR_FILE_ENCRYPTED;
pub const ERROR_NO_RECOVERY_POLICY = WIN32_ERROR.ERROR_NO_RECOVERY_POLICY;
pub const ERROR_NO_EFS = WIN32_ERROR.ERROR_NO_EFS;
pub const ERROR_WRONG_EFS = WIN32_ERROR.ERROR_WRONG_EFS;
pub const ERROR_NO_USER_KEYS = WIN32_ERROR.ERROR_NO_USER_KEYS;
pub const ERROR_FILE_NOT_ENCRYPTED = WIN32_ERROR.ERROR_FILE_NOT_ENCRYPTED;
pub const ERROR_NOT_EXPORT_FORMAT = WIN32_ERROR.ERROR_NOT_EXPORT_FORMAT;
pub const ERROR_FILE_READ_ONLY = WIN32_ERROR.ERROR_FILE_READ_ONLY;
pub const ERROR_DIR_EFS_DISALLOWED = WIN32_ERROR.ERROR_DIR_EFS_DISALLOWED;
pub const ERROR_EFS_SERVER_NOT_TRUSTED = WIN32_ERROR.ERROR_EFS_SERVER_NOT_TRUSTED;
pub const ERROR_BAD_RECOVERY_POLICY = WIN32_ERROR.ERROR_BAD_RECOVERY_POLICY;
pub const ERROR_EFS_ALG_BLOB_TOO_BIG = WIN32_ERROR.ERROR_EFS_ALG_BLOB_TOO_BIG;
pub const ERROR_VOLUME_NOT_SUPPORT_EFS = WIN32_ERROR.ERROR_VOLUME_NOT_SUPPORT_EFS;
pub const ERROR_EFS_DISABLED = WIN32_ERROR.ERROR_EFS_DISABLED;
pub const ERROR_EFS_VERSION_NOT_SUPPORT = WIN32_ERROR.ERROR_EFS_VERSION_NOT_SUPPORT;
pub const ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE = WIN32_ERROR.ERROR_CS_ENCRYPTION_INVALID_SERVER_RESPONSE;
pub const ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER = WIN32_ERROR.ERROR_CS_ENCRYPTION_UNSUPPORTED_SERVER;
pub const ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE = WIN32_ERROR.ERROR_CS_ENCRYPTION_EXISTING_ENCRYPTED_FILE;
pub const ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE = WIN32_ERROR.ERROR_CS_ENCRYPTION_NEW_ENCRYPTED_FILE;
pub const ERROR_CS_ENCRYPTION_FILE_NOT_CSE = WIN32_ERROR.ERROR_CS_ENCRYPTION_FILE_NOT_CSE;
pub const ERROR_ENCRYPTION_POLICY_DENIES_OPERATION = WIN32_ERROR.ERROR_ENCRYPTION_POLICY_DENIES_OPERATION;
pub const ERROR_WIP_ENCRYPTION_FAILED = WIN32_ERROR.ERROR_WIP_ENCRYPTION_FAILED;
pub const ERROR_NO_BROWSER_SERVERS_FOUND = WIN32_ERROR.ERROR_NO_BROWSER_SERVERS_FOUND;
pub const ERROR_CLUSTER_OBJECT_IS_CLUSTER_SET_VM = WIN32_ERROR.ERROR_CLUSTER_OBJECT_IS_CLUSTER_SET_VM;
pub const ERROR_LOG_SECTOR_INVALID = WIN32_ERROR.ERROR_LOG_SECTOR_INVALID;
pub const ERROR_LOG_SECTOR_PARITY_INVALID = WIN32_ERROR.ERROR_LOG_SECTOR_PARITY_INVALID;
pub const ERROR_LOG_SECTOR_REMAPPED = WIN32_ERROR.ERROR_LOG_SECTOR_REMAPPED;
pub const ERROR_LOG_BLOCK_INCOMPLETE = WIN32_ERROR.ERROR_LOG_BLOCK_INCOMPLETE;
pub const ERROR_LOG_INVALID_RANGE = WIN32_ERROR.ERROR_LOG_INVALID_RANGE;
pub const ERROR_LOG_BLOCKS_EXHAUSTED = WIN32_ERROR.ERROR_LOG_BLOCKS_EXHAUSTED;
pub const ERROR_LOG_READ_CONTEXT_INVALID = WIN32_ERROR.ERROR_LOG_READ_CONTEXT_INVALID;
pub const ERROR_LOG_RESTART_INVALID = WIN32_ERROR.ERROR_LOG_RESTART_INVALID;
pub const ERROR_LOG_BLOCK_VERSION = WIN32_ERROR.ERROR_LOG_BLOCK_VERSION;
pub const ERROR_LOG_BLOCK_INVALID = WIN32_ERROR.ERROR_LOG_BLOCK_INVALID;
pub const ERROR_LOG_READ_MODE_INVALID = WIN32_ERROR.ERROR_LOG_READ_MODE_INVALID;
pub const ERROR_LOG_NO_RESTART = WIN32_ERROR.ERROR_LOG_NO_RESTART;
pub const ERROR_LOG_METADATA_CORRUPT = WIN32_ERROR.ERROR_LOG_METADATA_CORRUPT;
pub const ERROR_LOG_METADATA_INVALID = WIN32_ERROR.ERROR_LOG_METADATA_INVALID;
pub const ERROR_LOG_METADATA_INCONSISTENT = WIN32_ERROR.ERROR_LOG_METADATA_INCONSISTENT;
pub const ERROR_LOG_RESERVATION_INVALID = WIN32_ERROR.ERROR_LOG_RESERVATION_INVALID;
pub const ERROR_LOG_CANT_DELETE = WIN32_ERROR.ERROR_LOG_CANT_DELETE;
pub const ERROR_LOG_CONTAINER_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_LOG_CONTAINER_LIMIT_EXCEEDED;
pub const ERROR_LOG_START_OF_LOG = WIN32_ERROR.ERROR_LOG_START_OF_LOG;
pub const ERROR_LOG_POLICY_ALREADY_INSTALLED = WIN32_ERROR.ERROR_LOG_POLICY_ALREADY_INSTALLED;
pub const ERROR_LOG_POLICY_NOT_INSTALLED = WIN32_ERROR.ERROR_LOG_POLICY_NOT_INSTALLED;
pub const ERROR_LOG_POLICY_INVALID = WIN32_ERROR.ERROR_LOG_POLICY_INVALID;
pub const ERROR_LOG_POLICY_CONFLICT = WIN32_ERROR.ERROR_LOG_POLICY_CONFLICT;
pub const ERROR_LOG_PINNED_ARCHIVE_TAIL = WIN32_ERROR.ERROR_LOG_PINNED_ARCHIVE_TAIL;
pub const ERROR_LOG_RECORD_NONEXISTENT = WIN32_ERROR.ERROR_LOG_RECORD_NONEXISTENT;
pub const ERROR_LOG_RECORDS_RESERVED_INVALID = WIN32_ERROR.ERROR_LOG_RECORDS_RESERVED_INVALID;
pub const ERROR_LOG_SPACE_RESERVED_INVALID = WIN32_ERROR.ERROR_LOG_SPACE_RESERVED_INVALID;
pub const ERROR_LOG_TAIL_INVALID = WIN32_ERROR.ERROR_LOG_TAIL_INVALID;
pub const ERROR_LOG_FULL = WIN32_ERROR.ERROR_LOG_FULL;
pub const ERROR_COULD_NOT_RESIZE_LOG = WIN32_ERROR.ERROR_COULD_NOT_RESIZE_LOG;
pub const ERROR_LOG_MULTIPLEXED = WIN32_ERROR.ERROR_LOG_MULTIPLEXED;
pub const ERROR_LOG_DEDICATED = WIN32_ERROR.ERROR_LOG_DEDICATED;
pub const ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS = WIN32_ERROR.ERROR_LOG_ARCHIVE_NOT_IN_PROGRESS;
pub const ERROR_LOG_ARCHIVE_IN_PROGRESS = WIN32_ERROR.ERROR_LOG_ARCHIVE_IN_PROGRESS;
pub const ERROR_LOG_EPHEMERAL = WIN32_ERROR.ERROR_LOG_EPHEMERAL;
pub const ERROR_LOG_NOT_ENOUGH_CONTAINERS = WIN32_ERROR.ERROR_LOG_NOT_ENOUGH_CONTAINERS;
pub const ERROR_LOG_CLIENT_ALREADY_REGISTERED = WIN32_ERROR.ERROR_LOG_CLIENT_ALREADY_REGISTERED;
pub const ERROR_LOG_CLIENT_NOT_REGISTERED = WIN32_ERROR.ERROR_LOG_CLIENT_NOT_REGISTERED;
pub const ERROR_LOG_FULL_HANDLER_IN_PROGRESS = WIN32_ERROR.ERROR_LOG_FULL_HANDLER_IN_PROGRESS;
pub const ERROR_LOG_CONTAINER_READ_FAILED = WIN32_ERROR.ERROR_LOG_CONTAINER_READ_FAILED;
pub const ERROR_LOG_CONTAINER_WRITE_FAILED = WIN32_ERROR.ERROR_LOG_CONTAINER_WRITE_FAILED;
pub const ERROR_LOG_CONTAINER_OPEN_FAILED = WIN32_ERROR.ERROR_LOG_CONTAINER_OPEN_FAILED;
pub const ERROR_LOG_CONTAINER_STATE_INVALID = WIN32_ERROR.ERROR_LOG_CONTAINER_STATE_INVALID;
pub const ERROR_LOG_STATE_INVALID = WIN32_ERROR.ERROR_LOG_STATE_INVALID;
pub const ERROR_LOG_PINNED = WIN32_ERROR.ERROR_LOG_PINNED;
pub const ERROR_LOG_METADATA_FLUSH_FAILED = WIN32_ERROR.ERROR_LOG_METADATA_FLUSH_FAILED;
pub const ERROR_LOG_INCONSISTENT_SECURITY = WIN32_ERROR.ERROR_LOG_INCONSISTENT_SECURITY;
pub const ERROR_LOG_APPENDED_FLUSH_FAILED = WIN32_ERROR.ERROR_LOG_APPENDED_FLUSH_FAILED;
pub const ERROR_LOG_PINNED_RESERVATION = WIN32_ERROR.ERROR_LOG_PINNED_RESERVATION;
pub const ERROR_INVALID_TRANSACTION = WIN32_ERROR.ERROR_INVALID_TRANSACTION;
pub const ERROR_TRANSACTION_NOT_ACTIVE = WIN32_ERROR.ERROR_TRANSACTION_NOT_ACTIVE;
pub const ERROR_TRANSACTION_REQUEST_NOT_VALID = WIN32_ERROR.ERROR_TRANSACTION_REQUEST_NOT_VALID;
pub const ERROR_TRANSACTION_NOT_REQUESTED = WIN32_ERROR.ERROR_TRANSACTION_NOT_REQUESTED;
pub const ERROR_TRANSACTION_ALREADY_ABORTED = WIN32_ERROR.ERROR_TRANSACTION_ALREADY_ABORTED;
pub const ERROR_TRANSACTION_ALREADY_COMMITTED = WIN32_ERROR.ERROR_TRANSACTION_ALREADY_COMMITTED;
pub const ERROR_TM_INITIALIZATION_FAILED = WIN32_ERROR.ERROR_TM_INITIALIZATION_FAILED;
pub const ERROR_RESOURCEMANAGER_READ_ONLY = WIN32_ERROR.ERROR_RESOURCEMANAGER_READ_ONLY;
pub const ERROR_TRANSACTION_NOT_JOINED = WIN32_ERROR.ERROR_TRANSACTION_NOT_JOINED;
pub const ERROR_TRANSACTION_SUPERIOR_EXISTS = WIN32_ERROR.ERROR_TRANSACTION_SUPERIOR_EXISTS;
pub const ERROR_CRM_PROTOCOL_ALREADY_EXISTS = WIN32_ERROR.ERROR_CRM_PROTOCOL_ALREADY_EXISTS;
pub const ERROR_TRANSACTION_PROPAGATION_FAILED = WIN32_ERROR.ERROR_TRANSACTION_PROPAGATION_FAILED;
pub const ERROR_CRM_PROTOCOL_NOT_FOUND = WIN32_ERROR.ERROR_CRM_PROTOCOL_NOT_FOUND;
pub const ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER = WIN32_ERROR.ERROR_TRANSACTION_INVALID_MARSHALL_BUFFER;
pub const ERROR_CURRENT_TRANSACTION_NOT_VALID = WIN32_ERROR.ERROR_CURRENT_TRANSACTION_NOT_VALID;
pub const ERROR_TRANSACTION_NOT_FOUND = WIN32_ERROR.ERROR_TRANSACTION_NOT_FOUND;
pub const ERROR_RESOURCEMANAGER_NOT_FOUND = WIN32_ERROR.ERROR_RESOURCEMANAGER_NOT_FOUND;
pub const ERROR_ENLISTMENT_NOT_FOUND = WIN32_ERROR.ERROR_ENLISTMENT_NOT_FOUND;
pub const ERROR_TRANSACTIONMANAGER_NOT_FOUND = WIN32_ERROR.ERROR_TRANSACTIONMANAGER_NOT_FOUND;
pub const ERROR_TRANSACTIONMANAGER_NOT_ONLINE = WIN32_ERROR.ERROR_TRANSACTIONMANAGER_NOT_ONLINE;
pub const ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION = WIN32_ERROR.ERROR_TRANSACTIONMANAGER_RECOVERY_NAME_COLLISION;
pub const ERROR_TRANSACTION_NOT_ROOT = WIN32_ERROR.ERROR_TRANSACTION_NOT_ROOT;
pub const ERROR_TRANSACTION_OBJECT_EXPIRED = WIN32_ERROR.ERROR_TRANSACTION_OBJECT_EXPIRED;
pub const ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED = WIN32_ERROR.ERROR_TRANSACTION_RESPONSE_NOT_ENLISTED;
pub const ERROR_TRANSACTION_RECORD_TOO_LONG = WIN32_ERROR.ERROR_TRANSACTION_RECORD_TOO_LONG;
pub const ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED = WIN32_ERROR.ERROR_IMPLICIT_TRANSACTION_NOT_SUPPORTED;
pub const ERROR_TRANSACTION_INTEGRITY_VIOLATED = WIN32_ERROR.ERROR_TRANSACTION_INTEGRITY_VIOLATED;
pub const ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH = WIN32_ERROR.ERROR_TRANSACTIONMANAGER_IDENTITY_MISMATCH;
pub const ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT = WIN32_ERROR.ERROR_RM_CANNOT_BE_FROZEN_FOR_SNAPSHOT;
pub const ERROR_TRANSACTION_MUST_WRITETHROUGH = WIN32_ERROR.ERROR_TRANSACTION_MUST_WRITETHROUGH;
pub const ERROR_TRANSACTION_NO_SUPERIOR = WIN32_ERROR.ERROR_TRANSACTION_NO_SUPERIOR;
pub const ERROR_HEURISTIC_DAMAGE_POSSIBLE = WIN32_ERROR.ERROR_HEURISTIC_DAMAGE_POSSIBLE;
pub const ERROR_TRANSACTIONAL_CONFLICT = WIN32_ERROR.ERROR_TRANSACTIONAL_CONFLICT;
pub const ERROR_RM_NOT_ACTIVE = WIN32_ERROR.ERROR_RM_NOT_ACTIVE;
pub const ERROR_RM_METADATA_CORRUPT = WIN32_ERROR.ERROR_RM_METADATA_CORRUPT;
pub const ERROR_DIRECTORY_NOT_RM = WIN32_ERROR.ERROR_DIRECTORY_NOT_RM;
pub const ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE = WIN32_ERROR.ERROR_TRANSACTIONS_UNSUPPORTED_REMOTE;
pub const ERROR_LOG_RESIZE_INVALID_SIZE = WIN32_ERROR.ERROR_LOG_RESIZE_INVALID_SIZE;
pub const ERROR_OBJECT_NO_LONGER_EXISTS = WIN32_ERROR.ERROR_OBJECT_NO_LONGER_EXISTS;
pub const ERROR_STREAM_MINIVERSION_NOT_FOUND = WIN32_ERROR.ERROR_STREAM_MINIVERSION_NOT_FOUND;
pub const ERROR_STREAM_MINIVERSION_NOT_VALID = WIN32_ERROR.ERROR_STREAM_MINIVERSION_NOT_VALID;
pub const ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION = WIN32_ERROR.ERROR_MINIVERSION_INACCESSIBLE_FROM_SPECIFIED_TRANSACTION;
pub const ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT = WIN32_ERROR.ERROR_CANT_OPEN_MINIVERSION_WITH_MODIFY_INTENT;
pub const ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS = WIN32_ERROR.ERROR_CANT_CREATE_MORE_STREAM_MINIVERSIONS;
pub const ERROR_REMOTE_FILE_VERSION_MISMATCH = WIN32_ERROR.ERROR_REMOTE_FILE_VERSION_MISMATCH;
pub const ERROR_HANDLE_NO_LONGER_VALID = WIN32_ERROR.ERROR_HANDLE_NO_LONGER_VALID;
pub const ERROR_NO_TXF_METADATA = WIN32_ERROR.ERROR_NO_TXF_METADATA;
pub const ERROR_LOG_CORRUPTION_DETECTED = WIN32_ERROR.ERROR_LOG_CORRUPTION_DETECTED;
pub const ERROR_CANT_RECOVER_WITH_HANDLE_OPEN = WIN32_ERROR.ERROR_CANT_RECOVER_WITH_HANDLE_OPEN;
pub const ERROR_RM_DISCONNECTED = WIN32_ERROR.ERROR_RM_DISCONNECTED;
pub const ERROR_ENLISTMENT_NOT_SUPERIOR = WIN32_ERROR.ERROR_ENLISTMENT_NOT_SUPERIOR;
pub const ERROR_RECOVERY_NOT_NEEDED = WIN32_ERROR.ERROR_RECOVERY_NOT_NEEDED;
pub const ERROR_RM_ALREADY_STARTED = WIN32_ERROR.ERROR_RM_ALREADY_STARTED;
pub const ERROR_FILE_IDENTITY_NOT_PERSISTENT = WIN32_ERROR.ERROR_FILE_IDENTITY_NOT_PERSISTENT;
pub const ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY = WIN32_ERROR.ERROR_CANT_BREAK_TRANSACTIONAL_DEPENDENCY;
pub const ERROR_CANT_CROSS_RM_BOUNDARY = WIN32_ERROR.ERROR_CANT_CROSS_RM_BOUNDARY;
pub const ERROR_TXF_DIR_NOT_EMPTY = WIN32_ERROR.ERROR_TXF_DIR_NOT_EMPTY;
pub const ERROR_INDOUBT_TRANSACTIONS_EXIST = WIN32_ERROR.ERROR_INDOUBT_TRANSACTIONS_EXIST;
pub const ERROR_TM_VOLATILE = WIN32_ERROR.ERROR_TM_VOLATILE;
pub const ERROR_ROLLBACK_TIMER_EXPIRED = WIN32_ERROR.ERROR_ROLLBACK_TIMER_EXPIRED;
pub const ERROR_TXF_ATTRIBUTE_CORRUPT = WIN32_ERROR.ERROR_TXF_ATTRIBUTE_CORRUPT;
pub const ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION = WIN32_ERROR.ERROR_EFS_NOT_ALLOWED_IN_TRANSACTION;
pub const ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED = WIN32_ERROR.ERROR_TRANSACTIONAL_OPEN_NOT_ALLOWED;
pub const ERROR_LOG_GROWTH_FAILED = WIN32_ERROR.ERROR_LOG_GROWTH_FAILED;
pub const ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE = WIN32_ERROR.ERROR_TRANSACTED_MAPPING_UNSUPPORTED_REMOTE;
pub const ERROR_TXF_METADATA_ALREADY_PRESENT = WIN32_ERROR.ERROR_TXF_METADATA_ALREADY_PRESENT;
pub const ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET = WIN32_ERROR.ERROR_TRANSACTION_SCOPE_CALLBACKS_NOT_SET;
pub const ERROR_TRANSACTION_REQUIRED_PROMOTION = WIN32_ERROR.ERROR_TRANSACTION_REQUIRED_PROMOTION;
pub const ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION = WIN32_ERROR.ERROR_CANNOT_EXECUTE_FILE_IN_TRANSACTION;
pub const ERROR_TRANSACTIONS_NOT_FROZEN = WIN32_ERROR.ERROR_TRANSACTIONS_NOT_FROZEN;
pub const ERROR_TRANSACTION_FREEZE_IN_PROGRESS = WIN32_ERROR.ERROR_TRANSACTION_FREEZE_IN_PROGRESS;
pub const ERROR_NOT_SNAPSHOT_VOLUME = WIN32_ERROR.ERROR_NOT_SNAPSHOT_VOLUME;
pub const ERROR_NO_SAVEPOINT_WITH_OPEN_FILES = WIN32_ERROR.ERROR_NO_SAVEPOINT_WITH_OPEN_FILES;
pub const ERROR_DATA_LOST_REPAIR = WIN32_ERROR.ERROR_DATA_LOST_REPAIR;
pub const ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION = WIN32_ERROR.ERROR_SPARSE_NOT_ALLOWED_IN_TRANSACTION;
pub const ERROR_TM_IDENTITY_MISMATCH = WIN32_ERROR.ERROR_TM_IDENTITY_MISMATCH;
pub const ERROR_FLOATED_SECTION = WIN32_ERROR.ERROR_FLOATED_SECTION;
pub const ERROR_CANNOT_ACCEPT_TRANSACTED_WORK = WIN32_ERROR.ERROR_CANNOT_ACCEPT_TRANSACTED_WORK;
pub const ERROR_CANNOT_ABORT_TRANSACTIONS = WIN32_ERROR.ERROR_CANNOT_ABORT_TRANSACTIONS;
pub const ERROR_BAD_CLUSTERS = WIN32_ERROR.ERROR_BAD_CLUSTERS;
pub const ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION = WIN32_ERROR.ERROR_COMPRESSION_NOT_ALLOWED_IN_TRANSACTION;
pub const ERROR_VOLUME_DIRTY = WIN32_ERROR.ERROR_VOLUME_DIRTY;
pub const ERROR_NO_LINK_TRACKING_IN_TRANSACTION = WIN32_ERROR.ERROR_NO_LINK_TRACKING_IN_TRANSACTION;
pub const ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION = WIN32_ERROR.ERROR_OPERATION_NOT_SUPPORTED_IN_TRANSACTION;
pub const ERROR_EXPIRED_HANDLE = WIN32_ERROR.ERROR_EXPIRED_HANDLE;
pub const ERROR_TRANSACTION_NOT_ENLISTED = WIN32_ERROR.ERROR_TRANSACTION_NOT_ENLISTED;
pub const ERROR_CTX_WINSTATION_NAME_INVALID = WIN32_ERROR.ERROR_CTX_WINSTATION_NAME_INVALID;
pub const ERROR_CTX_INVALID_PD = WIN32_ERROR.ERROR_CTX_INVALID_PD;
pub const ERROR_CTX_PD_NOT_FOUND = WIN32_ERROR.ERROR_CTX_PD_NOT_FOUND;
pub const ERROR_CTX_WD_NOT_FOUND = WIN32_ERROR.ERROR_CTX_WD_NOT_FOUND;
pub const ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY = WIN32_ERROR.ERROR_CTX_CANNOT_MAKE_EVENTLOG_ENTRY;
pub const ERROR_CTX_SERVICE_NAME_COLLISION = WIN32_ERROR.ERROR_CTX_SERVICE_NAME_COLLISION;
pub const ERROR_CTX_CLOSE_PENDING = WIN32_ERROR.ERROR_CTX_CLOSE_PENDING;
pub const ERROR_CTX_NO_OUTBUF = WIN32_ERROR.ERROR_CTX_NO_OUTBUF;
pub const ERROR_CTX_MODEM_INF_NOT_FOUND = WIN32_ERROR.ERROR_CTX_MODEM_INF_NOT_FOUND;
pub const ERROR_CTX_INVALID_MODEMNAME = WIN32_ERROR.ERROR_CTX_INVALID_MODEMNAME;
pub const ERROR_CTX_MODEM_RESPONSE_ERROR = WIN32_ERROR.ERROR_CTX_MODEM_RESPONSE_ERROR;
pub const ERROR_CTX_MODEM_RESPONSE_TIMEOUT = WIN32_ERROR.ERROR_CTX_MODEM_RESPONSE_TIMEOUT;
pub const ERROR_CTX_MODEM_RESPONSE_NO_CARRIER = WIN32_ERROR.ERROR_CTX_MODEM_RESPONSE_NO_CARRIER;
pub const ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE = WIN32_ERROR.ERROR_CTX_MODEM_RESPONSE_NO_DIALTONE;
pub const ERROR_CTX_MODEM_RESPONSE_BUSY = WIN32_ERROR.ERROR_CTX_MODEM_RESPONSE_BUSY;
pub const ERROR_CTX_MODEM_RESPONSE_VOICE = WIN32_ERROR.ERROR_CTX_MODEM_RESPONSE_VOICE;
pub const ERROR_CTX_TD_ERROR = WIN32_ERROR.ERROR_CTX_TD_ERROR;
pub const ERROR_CTX_WINSTATION_NOT_FOUND = WIN32_ERROR.ERROR_CTX_WINSTATION_NOT_FOUND;
pub const ERROR_CTX_WINSTATION_ALREADY_EXISTS = WIN32_ERROR.ERROR_CTX_WINSTATION_ALREADY_EXISTS;
pub const ERROR_CTX_WINSTATION_BUSY = WIN32_ERROR.ERROR_CTX_WINSTATION_BUSY;
pub const ERROR_CTX_BAD_VIDEO_MODE = WIN32_ERROR.ERROR_CTX_BAD_VIDEO_MODE;
pub const ERROR_CTX_GRAPHICS_INVALID = WIN32_ERROR.ERROR_CTX_GRAPHICS_INVALID;
pub const ERROR_CTX_LOGON_DISABLED = WIN32_ERROR.ERROR_CTX_LOGON_DISABLED;
pub const ERROR_CTX_NOT_CONSOLE = WIN32_ERROR.ERROR_CTX_NOT_CONSOLE;
pub const ERROR_CTX_CLIENT_QUERY_TIMEOUT = WIN32_ERROR.ERROR_CTX_CLIENT_QUERY_TIMEOUT;
pub const ERROR_CTX_CONSOLE_DISCONNECT = WIN32_ERROR.ERROR_CTX_CONSOLE_DISCONNECT;
pub const ERROR_CTX_CONSOLE_CONNECT = WIN32_ERROR.ERROR_CTX_CONSOLE_CONNECT;
pub const ERROR_CTX_SHADOW_DENIED = WIN32_ERROR.ERROR_CTX_SHADOW_DENIED;
pub const ERROR_CTX_WINSTATION_ACCESS_DENIED = WIN32_ERROR.ERROR_CTX_WINSTATION_ACCESS_DENIED;
pub const ERROR_CTX_INVALID_WD = WIN32_ERROR.ERROR_CTX_INVALID_WD;
pub const ERROR_CTX_SHADOW_INVALID = WIN32_ERROR.ERROR_CTX_SHADOW_INVALID;
pub const ERROR_CTX_SHADOW_DISABLED = WIN32_ERROR.ERROR_CTX_SHADOW_DISABLED;
pub const ERROR_CTX_CLIENT_LICENSE_IN_USE = WIN32_ERROR.ERROR_CTX_CLIENT_LICENSE_IN_USE;
pub const ERROR_CTX_CLIENT_LICENSE_NOT_SET = WIN32_ERROR.ERROR_CTX_CLIENT_LICENSE_NOT_SET;
pub const ERROR_CTX_LICENSE_NOT_AVAILABLE = WIN32_ERROR.ERROR_CTX_LICENSE_NOT_AVAILABLE;
pub const ERROR_CTX_LICENSE_CLIENT_INVALID = WIN32_ERROR.ERROR_CTX_LICENSE_CLIENT_INVALID;
pub const ERROR_CTX_LICENSE_EXPIRED = WIN32_ERROR.ERROR_CTX_LICENSE_EXPIRED;
pub const ERROR_CTX_SHADOW_NOT_RUNNING = WIN32_ERROR.ERROR_CTX_SHADOW_NOT_RUNNING;
pub const ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE = WIN32_ERROR.ERROR_CTX_SHADOW_ENDED_BY_MODE_CHANGE;
pub const ERROR_ACTIVATION_COUNT_EXCEEDED = WIN32_ERROR.ERROR_ACTIVATION_COUNT_EXCEEDED;
pub const ERROR_CTX_WINSTATIONS_DISABLED = WIN32_ERROR.ERROR_CTX_WINSTATIONS_DISABLED;
pub const ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED = WIN32_ERROR.ERROR_CTX_ENCRYPTION_LEVEL_REQUIRED;
pub const ERROR_CTX_SESSION_IN_USE = WIN32_ERROR.ERROR_CTX_SESSION_IN_USE;
pub const ERROR_CTX_NO_FORCE_LOGOFF = WIN32_ERROR.ERROR_CTX_NO_FORCE_LOGOFF;
pub const ERROR_CTX_ACCOUNT_RESTRICTION = WIN32_ERROR.ERROR_CTX_ACCOUNT_RESTRICTION;
pub const ERROR_RDP_PROTOCOL_ERROR = WIN32_ERROR.ERROR_RDP_PROTOCOL_ERROR;
pub const ERROR_CTX_CDM_CONNECT = WIN32_ERROR.ERROR_CTX_CDM_CONNECT;
pub const ERROR_CTX_CDM_DISCONNECT = WIN32_ERROR.ERROR_CTX_CDM_DISCONNECT;
pub const ERROR_CTX_SECURITY_LAYER_ERROR = WIN32_ERROR.ERROR_CTX_SECURITY_LAYER_ERROR;
pub const ERROR_TS_INCOMPATIBLE_SESSIONS = WIN32_ERROR.ERROR_TS_INCOMPATIBLE_SESSIONS;
pub const ERROR_TS_VIDEO_SUBSYSTEM_ERROR = WIN32_ERROR.ERROR_TS_VIDEO_SUBSYSTEM_ERROR;
pub const ERROR_DS_NOT_INSTALLED = WIN32_ERROR.ERROR_DS_NOT_INSTALLED;
pub const ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY = WIN32_ERROR.ERROR_DS_MEMBERSHIP_EVALUATED_LOCALLY;
pub const ERROR_DS_NO_ATTRIBUTE_OR_VALUE = WIN32_ERROR.ERROR_DS_NO_ATTRIBUTE_OR_VALUE;
pub const ERROR_DS_INVALID_ATTRIBUTE_SYNTAX = WIN32_ERROR.ERROR_DS_INVALID_ATTRIBUTE_SYNTAX;
pub const ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED = WIN32_ERROR.ERROR_DS_ATTRIBUTE_TYPE_UNDEFINED;
pub const ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS = WIN32_ERROR.ERROR_DS_ATTRIBUTE_OR_VALUE_EXISTS;
pub const ERROR_DS_BUSY = WIN32_ERROR.ERROR_DS_BUSY;
pub const ERROR_DS_UNAVAILABLE = WIN32_ERROR.ERROR_DS_UNAVAILABLE;
pub const ERROR_DS_NO_RIDS_ALLOCATED = WIN32_ERROR.ERROR_DS_NO_RIDS_ALLOCATED;
pub const ERROR_DS_NO_MORE_RIDS = WIN32_ERROR.ERROR_DS_NO_MORE_RIDS;
pub const ERROR_DS_INCORRECT_ROLE_OWNER = WIN32_ERROR.ERROR_DS_INCORRECT_ROLE_OWNER;
pub const ERROR_DS_RIDMGR_INIT_ERROR = WIN32_ERROR.ERROR_DS_RIDMGR_INIT_ERROR;
pub const ERROR_DS_OBJ_CLASS_VIOLATION = WIN32_ERROR.ERROR_DS_OBJ_CLASS_VIOLATION;
pub const ERROR_DS_CANT_ON_NON_LEAF = WIN32_ERROR.ERROR_DS_CANT_ON_NON_LEAF;
pub const ERROR_DS_CANT_ON_RDN = WIN32_ERROR.ERROR_DS_CANT_ON_RDN;
pub const ERROR_DS_CANT_MOD_OBJ_CLASS = WIN32_ERROR.ERROR_DS_CANT_MOD_OBJ_CLASS;
pub const ERROR_DS_CROSS_DOM_MOVE_ERROR = WIN32_ERROR.ERROR_DS_CROSS_DOM_MOVE_ERROR;
pub const ERROR_DS_GC_NOT_AVAILABLE = WIN32_ERROR.ERROR_DS_GC_NOT_AVAILABLE;
pub const ERROR_SHARED_POLICY = WIN32_ERROR.ERROR_SHARED_POLICY;
pub const ERROR_POLICY_OBJECT_NOT_FOUND = WIN32_ERROR.ERROR_POLICY_OBJECT_NOT_FOUND;
pub const ERROR_POLICY_ONLY_IN_DS = WIN32_ERROR.ERROR_POLICY_ONLY_IN_DS;
pub const ERROR_PROMOTION_ACTIVE = WIN32_ERROR.ERROR_PROMOTION_ACTIVE;
pub const ERROR_NO_PROMOTION_ACTIVE = WIN32_ERROR.ERROR_NO_PROMOTION_ACTIVE;
pub const ERROR_DS_OPERATIONS_ERROR = WIN32_ERROR.ERROR_DS_OPERATIONS_ERROR;
pub const ERROR_DS_PROTOCOL_ERROR = WIN32_ERROR.ERROR_DS_PROTOCOL_ERROR;
pub const ERROR_DS_TIMELIMIT_EXCEEDED = WIN32_ERROR.ERROR_DS_TIMELIMIT_EXCEEDED;
pub const ERROR_DS_SIZELIMIT_EXCEEDED = WIN32_ERROR.ERROR_DS_SIZELIMIT_EXCEEDED;
pub const ERROR_DS_ADMIN_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_DS_ADMIN_LIMIT_EXCEEDED;
pub const ERROR_DS_COMPARE_FALSE = WIN32_ERROR.ERROR_DS_COMPARE_FALSE;
pub const ERROR_DS_COMPARE_TRUE = WIN32_ERROR.ERROR_DS_COMPARE_TRUE;
pub const ERROR_DS_AUTH_METHOD_NOT_SUPPORTED = WIN32_ERROR.ERROR_DS_AUTH_METHOD_NOT_SUPPORTED;
pub const ERROR_DS_STRONG_AUTH_REQUIRED = WIN32_ERROR.ERROR_DS_STRONG_AUTH_REQUIRED;
pub const ERROR_DS_INAPPROPRIATE_AUTH = WIN32_ERROR.ERROR_DS_INAPPROPRIATE_AUTH;
pub const ERROR_DS_AUTH_UNKNOWN = WIN32_ERROR.ERROR_DS_AUTH_UNKNOWN;
pub const ERROR_DS_REFERRAL = WIN32_ERROR.ERROR_DS_REFERRAL;
pub const ERROR_DS_UNAVAILABLE_CRIT_EXTENSION = WIN32_ERROR.ERROR_DS_UNAVAILABLE_CRIT_EXTENSION;
pub const ERROR_DS_CONFIDENTIALITY_REQUIRED = WIN32_ERROR.ERROR_DS_CONFIDENTIALITY_REQUIRED;
pub const ERROR_DS_INAPPROPRIATE_MATCHING = WIN32_ERROR.ERROR_DS_INAPPROPRIATE_MATCHING;
pub const ERROR_DS_CONSTRAINT_VIOLATION = WIN32_ERROR.ERROR_DS_CONSTRAINT_VIOLATION;
pub const ERROR_DS_NO_SUCH_OBJECT = WIN32_ERROR.ERROR_DS_NO_SUCH_OBJECT;
pub const ERROR_DS_ALIAS_PROBLEM = WIN32_ERROR.ERROR_DS_ALIAS_PROBLEM;
pub const ERROR_DS_INVALID_DN_SYNTAX = WIN32_ERROR.ERROR_DS_INVALID_DN_SYNTAX;
pub const ERROR_DS_IS_LEAF = WIN32_ERROR.ERROR_DS_IS_LEAF;
pub const ERROR_DS_ALIAS_DEREF_PROBLEM = WIN32_ERROR.ERROR_DS_ALIAS_DEREF_PROBLEM;
pub const ERROR_DS_UNWILLING_TO_PERFORM = WIN32_ERROR.ERROR_DS_UNWILLING_TO_PERFORM;
pub const ERROR_DS_LOOP_DETECT = WIN32_ERROR.ERROR_DS_LOOP_DETECT;
pub const ERROR_DS_NAMING_VIOLATION = WIN32_ERROR.ERROR_DS_NAMING_VIOLATION;
pub const ERROR_DS_OBJECT_RESULTS_TOO_LARGE = WIN32_ERROR.ERROR_DS_OBJECT_RESULTS_TOO_LARGE;
pub const ERROR_DS_AFFECTS_MULTIPLE_DSAS = WIN32_ERROR.ERROR_DS_AFFECTS_MULTIPLE_DSAS;
pub const ERROR_DS_SERVER_DOWN = WIN32_ERROR.ERROR_DS_SERVER_DOWN;
pub const ERROR_DS_LOCAL_ERROR = WIN32_ERROR.ERROR_DS_LOCAL_ERROR;
pub const ERROR_DS_ENCODING_ERROR = WIN32_ERROR.ERROR_DS_ENCODING_ERROR;
pub const ERROR_DS_DECODING_ERROR = WIN32_ERROR.ERROR_DS_DECODING_ERROR;
pub const ERROR_DS_FILTER_UNKNOWN = WIN32_ERROR.ERROR_DS_FILTER_UNKNOWN;
pub const ERROR_DS_PARAM_ERROR = WIN32_ERROR.ERROR_DS_PARAM_ERROR;
pub const ERROR_DS_NOT_SUPPORTED = WIN32_ERROR.ERROR_DS_NOT_SUPPORTED;
pub const ERROR_DS_NO_RESULTS_RETURNED = WIN32_ERROR.ERROR_DS_NO_RESULTS_RETURNED;
pub const ERROR_DS_CONTROL_NOT_FOUND = WIN32_ERROR.ERROR_DS_CONTROL_NOT_FOUND;
pub const ERROR_DS_CLIENT_LOOP = WIN32_ERROR.ERROR_DS_CLIENT_LOOP;
pub const ERROR_DS_REFERRAL_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_DS_REFERRAL_LIMIT_EXCEEDED;
pub const ERROR_DS_SORT_CONTROL_MISSING = WIN32_ERROR.ERROR_DS_SORT_CONTROL_MISSING;
pub const ERROR_DS_OFFSET_RANGE_ERROR = WIN32_ERROR.ERROR_DS_OFFSET_RANGE_ERROR;
pub const ERROR_DS_RIDMGR_DISABLED = WIN32_ERROR.ERROR_DS_RIDMGR_DISABLED;
pub const ERROR_DS_ROOT_MUST_BE_NC = WIN32_ERROR.ERROR_DS_ROOT_MUST_BE_NC;
pub const ERROR_DS_ADD_REPLICA_INHIBITED = WIN32_ERROR.ERROR_DS_ADD_REPLICA_INHIBITED;
pub const ERROR_DS_ATT_NOT_DEF_IN_SCHEMA = WIN32_ERROR.ERROR_DS_ATT_NOT_DEF_IN_SCHEMA;
pub const ERROR_DS_MAX_OBJ_SIZE_EXCEEDED = WIN32_ERROR.ERROR_DS_MAX_OBJ_SIZE_EXCEEDED;
pub const ERROR_DS_OBJ_STRING_NAME_EXISTS = WIN32_ERROR.ERROR_DS_OBJ_STRING_NAME_EXISTS;
pub const ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA = WIN32_ERROR.ERROR_DS_NO_RDN_DEFINED_IN_SCHEMA;
pub const ERROR_DS_RDN_DOESNT_MATCH_SCHEMA = WIN32_ERROR.ERROR_DS_RDN_DOESNT_MATCH_SCHEMA;
pub const ERROR_DS_NO_REQUESTED_ATTS_FOUND = WIN32_ERROR.ERROR_DS_NO_REQUESTED_ATTS_FOUND;
pub const ERROR_DS_USER_BUFFER_TO_SMALL = WIN32_ERROR.ERROR_DS_USER_BUFFER_TO_SMALL;
pub const ERROR_DS_ATT_IS_NOT_ON_OBJ = WIN32_ERROR.ERROR_DS_ATT_IS_NOT_ON_OBJ;
pub const ERROR_DS_ILLEGAL_MOD_OPERATION = WIN32_ERROR.ERROR_DS_ILLEGAL_MOD_OPERATION;
pub const ERROR_DS_OBJ_TOO_LARGE = WIN32_ERROR.ERROR_DS_OBJ_TOO_LARGE;
pub const ERROR_DS_BAD_INSTANCE_TYPE = WIN32_ERROR.ERROR_DS_BAD_INSTANCE_TYPE;
pub const ERROR_DS_MASTERDSA_REQUIRED = WIN32_ERROR.ERROR_DS_MASTERDSA_REQUIRED;
pub const ERROR_DS_OBJECT_CLASS_REQUIRED = WIN32_ERROR.ERROR_DS_OBJECT_CLASS_REQUIRED;
pub const ERROR_DS_MISSING_REQUIRED_ATT = WIN32_ERROR.ERROR_DS_MISSING_REQUIRED_ATT;
pub const ERROR_DS_ATT_NOT_DEF_FOR_CLASS = WIN32_ERROR.ERROR_DS_ATT_NOT_DEF_FOR_CLASS;
pub const ERROR_DS_ATT_ALREADY_EXISTS = WIN32_ERROR.ERROR_DS_ATT_ALREADY_EXISTS;
pub const ERROR_DS_CANT_ADD_ATT_VALUES = WIN32_ERROR.ERROR_DS_CANT_ADD_ATT_VALUES;
pub const ERROR_DS_SINGLE_VALUE_CONSTRAINT = WIN32_ERROR.ERROR_DS_SINGLE_VALUE_CONSTRAINT;
pub const ERROR_DS_RANGE_CONSTRAINT = WIN32_ERROR.ERROR_DS_RANGE_CONSTRAINT;
pub const ERROR_DS_ATT_VAL_ALREADY_EXISTS = WIN32_ERROR.ERROR_DS_ATT_VAL_ALREADY_EXISTS;
pub const ERROR_DS_CANT_REM_MISSING_ATT = WIN32_ERROR.ERROR_DS_CANT_REM_MISSING_ATT;
pub const ERROR_DS_CANT_REM_MISSING_ATT_VAL = WIN32_ERROR.ERROR_DS_CANT_REM_MISSING_ATT_VAL;
pub const ERROR_DS_ROOT_CANT_BE_SUBREF = WIN32_ERROR.ERROR_DS_ROOT_CANT_BE_SUBREF;
pub const ERROR_DS_NO_CHAINING = WIN32_ERROR.ERROR_DS_NO_CHAINING;
pub const ERROR_DS_NO_CHAINED_EVAL = WIN32_ERROR.ERROR_DS_NO_CHAINED_EVAL;
pub const ERROR_DS_NO_PARENT_OBJECT = WIN32_ERROR.ERROR_DS_NO_PARENT_OBJECT;
pub const ERROR_DS_PARENT_IS_AN_ALIAS = WIN32_ERROR.ERROR_DS_PARENT_IS_AN_ALIAS;
pub const ERROR_DS_CANT_MIX_MASTER_AND_REPS = WIN32_ERROR.ERROR_DS_CANT_MIX_MASTER_AND_REPS;
pub const ERROR_DS_CHILDREN_EXIST = WIN32_ERROR.ERROR_DS_CHILDREN_EXIST;
pub const ERROR_DS_OBJ_NOT_FOUND = WIN32_ERROR.ERROR_DS_OBJ_NOT_FOUND;
pub const ERROR_DS_ALIASED_OBJ_MISSING = WIN32_ERROR.ERROR_DS_ALIASED_OBJ_MISSING;
pub const ERROR_DS_BAD_NAME_SYNTAX = WIN32_ERROR.ERROR_DS_BAD_NAME_SYNTAX;
pub const ERROR_DS_ALIAS_POINTS_TO_ALIAS = WIN32_ERROR.ERROR_DS_ALIAS_POINTS_TO_ALIAS;
pub const ERROR_DS_CANT_DEREF_ALIAS = WIN32_ERROR.ERROR_DS_CANT_DEREF_ALIAS;
pub const ERROR_DS_OUT_OF_SCOPE = WIN32_ERROR.ERROR_DS_OUT_OF_SCOPE;
pub const ERROR_DS_OBJECT_BEING_REMOVED = WIN32_ERROR.ERROR_DS_OBJECT_BEING_REMOVED;
pub const ERROR_DS_CANT_DELETE_DSA_OBJ = WIN32_ERROR.ERROR_DS_CANT_DELETE_DSA_OBJ;
pub const ERROR_DS_GENERIC_ERROR = WIN32_ERROR.ERROR_DS_GENERIC_ERROR;
pub const ERROR_DS_DSA_MUST_BE_INT_MASTER = WIN32_ERROR.ERROR_DS_DSA_MUST_BE_INT_MASTER;
pub const ERROR_DS_CLASS_NOT_DSA = WIN32_ERROR.ERROR_DS_CLASS_NOT_DSA;
pub const ERROR_DS_INSUFF_ACCESS_RIGHTS = WIN32_ERROR.ERROR_DS_INSUFF_ACCESS_RIGHTS;
pub const ERROR_DS_ILLEGAL_SUPERIOR = WIN32_ERROR.ERROR_DS_ILLEGAL_SUPERIOR;
pub const ERROR_DS_ATTRIBUTE_OWNED_BY_SAM = WIN32_ERROR.ERROR_DS_ATTRIBUTE_OWNED_BY_SAM;
pub const ERROR_DS_NAME_TOO_MANY_PARTS = WIN32_ERROR.ERROR_DS_NAME_TOO_MANY_PARTS;
pub const ERROR_DS_NAME_TOO_LONG = WIN32_ERROR.ERROR_DS_NAME_TOO_LONG;
pub const ERROR_DS_NAME_VALUE_TOO_LONG = WIN32_ERROR.ERROR_DS_NAME_VALUE_TOO_LONG;
pub const ERROR_DS_NAME_UNPARSEABLE = WIN32_ERROR.ERROR_DS_NAME_UNPARSEABLE;
pub const ERROR_DS_NAME_TYPE_UNKNOWN = WIN32_ERROR.ERROR_DS_NAME_TYPE_UNKNOWN;
pub const ERROR_DS_NOT_AN_OBJECT = WIN32_ERROR.ERROR_DS_NOT_AN_OBJECT;
pub const ERROR_DS_SEC_DESC_TOO_SHORT = WIN32_ERROR.ERROR_DS_SEC_DESC_TOO_SHORT;
pub const ERROR_DS_SEC_DESC_INVALID = WIN32_ERROR.ERROR_DS_SEC_DESC_INVALID;
pub const ERROR_DS_NO_DELETED_NAME = WIN32_ERROR.ERROR_DS_NO_DELETED_NAME;
pub const ERROR_DS_SUBREF_MUST_HAVE_PARENT = WIN32_ERROR.ERROR_DS_SUBREF_MUST_HAVE_PARENT;
pub const ERROR_DS_NCNAME_MUST_BE_NC = WIN32_ERROR.ERROR_DS_NCNAME_MUST_BE_NC;
pub const ERROR_DS_CANT_ADD_SYSTEM_ONLY = WIN32_ERROR.ERROR_DS_CANT_ADD_SYSTEM_ONLY;
pub const ERROR_DS_CLASS_MUST_BE_CONCRETE = WIN32_ERROR.ERROR_DS_CLASS_MUST_BE_CONCRETE;
pub const ERROR_DS_INVALID_DMD = WIN32_ERROR.ERROR_DS_INVALID_DMD;
pub const ERROR_DS_OBJ_GUID_EXISTS = WIN32_ERROR.ERROR_DS_OBJ_GUID_EXISTS;
pub const ERROR_DS_NOT_ON_BACKLINK = WIN32_ERROR.ERROR_DS_NOT_ON_BACKLINK;
pub const ERROR_DS_NO_CROSSREF_FOR_NC = WIN32_ERROR.ERROR_DS_NO_CROSSREF_FOR_NC;
pub const ERROR_DS_SHUTTING_DOWN = WIN32_ERROR.ERROR_DS_SHUTTING_DOWN;
pub const ERROR_DS_UNKNOWN_OPERATION = WIN32_ERROR.ERROR_DS_UNKNOWN_OPERATION;
pub const ERROR_DS_INVALID_ROLE_OWNER = WIN32_ERROR.ERROR_DS_INVALID_ROLE_OWNER;
pub const ERROR_DS_COULDNT_CONTACT_FSMO = WIN32_ERROR.ERROR_DS_COULDNT_CONTACT_FSMO;
pub const ERROR_DS_CROSS_NC_DN_RENAME = WIN32_ERROR.ERROR_DS_CROSS_NC_DN_RENAME;
pub const ERROR_DS_CANT_MOD_SYSTEM_ONLY = WIN32_ERROR.ERROR_DS_CANT_MOD_SYSTEM_ONLY;
pub const ERROR_DS_REPLICATOR_ONLY = WIN32_ERROR.ERROR_DS_REPLICATOR_ONLY;
pub const ERROR_DS_OBJ_CLASS_NOT_DEFINED = WIN32_ERROR.ERROR_DS_OBJ_CLASS_NOT_DEFINED;
pub const ERROR_DS_OBJ_CLASS_NOT_SUBCLASS = WIN32_ERROR.ERROR_DS_OBJ_CLASS_NOT_SUBCLASS;
pub const ERROR_DS_NAME_REFERENCE_INVALID = WIN32_ERROR.ERROR_DS_NAME_REFERENCE_INVALID;
pub const ERROR_DS_CROSS_REF_EXISTS = WIN32_ERROR.ERROR_DS_CROSS_REF_EXISTS;
pub const ERROR_DS_CANT_DEL_MASTER_CROSSREF = WIN32_ERROR.ERROR_DS_CANT_DEL_MASTER_CROSSREF;
pub const ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD = WIN32_ERROR.ERROR_DS_SUBTREE_NOTIFY_NOT_NC_HEAD;
pub const ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX = WIN32_ERROR.ERROR_DS_NOTIFY_FILTER_TOO_COMPLEX;
pub const ERROR_DS_DUP_RDN = WIN32_ERROR.ERROR_DS_DUP_RDN;
pub const ERROR_DS_DUP_OID = WIN32_ERROR.ERROR_DS_DUP_OID;
pub const ERROR_DS_DUP_MAPI_ID = WIN32_ERROR.ERROR_DS_DUP_MAPI_ID;
pub const ERROR_DS_DUP_SCHEMA_ID_GUID = WIN32_ERROR.ERROR_DS_DUP_SCHEMA_ID_GUID;
pub const ERROR_DS_DUP_LDAP_DISPLAY_NAME = WIN32_ERROR.ERROR_DS_DUP_LDAP_DISPLAY_NAME;
pub const ERROR_DS_SEMANTIC_ATT_TEST = WIN32_ERROR.ERROR_DS_SEMANTIC_ATT_TEST;
pub const ERROR_DS_SYNTAX_MISMATCH = WIN32_ERROR.ERROR_DS_SYNTAX_MISMATCH;
pub const ERROR_DS_EXISTS_IN_MUST_HAVE = WIN32_ERROR.ERROR_DS_EXISTS_IN_MUST_HAVE;
pub const ERROR_DS_EXISTS_IN_MAY_HAVE = WIN32_ERROR.ERROR_DS_EXISTS_IN_MAY_HAVE;
pub const ERROR_DS_NONEXISTENT_MAY_HAVE = WIN32_ERROR.ERROR_DS_NONEXISTENT_MAY_HAVE;
pub const ERROR_DS_NONEXISTENT_MUST_HAVE = WIN32_ERROR.ERROR_DS_NONEXISTENT_MUST_HAVE;
pub const ERROR_DS_AUX_CLS_TEST_FAIL = WIN32_ERROR.ERROR_DS_AUX_CLS_TEST_FAIL;
pub const ERROR_DS_NONEXISTENT_POSS_SUP = WIN32_ERROR.ERROR_DS_NONEXISTENT_POSS_SUP;
pub const ERROR_DS_SUB_CLS_TEST_FAIL = WIN32_ERROR.ERROR_DS_SUB_CLS_TEST_FAIL;
pub const ERROR_DS_BAD_RDN_ATT_ID_SYNTAX = WIN32_ERROR.ERROR_DS_BAD_RDN_ATT_ID_SYNTAX;
pub const ERROR_DS_EXISTS_IN_AUX_CLS = WIN32_ERROR.ERROR_DS_EXISTS_IN_AUX_CLS;
pub const ERROR_DS_EXISTS_IN_SUB_CLS = WIN32_ERROR.ERROR_DS_EXISTS_IN_SUB_CLS;
pub const ERROR_DS_EXISTS_IN_POSS_SUP = WIN32_ERROR.ERROR_DS_EXISTS_IN_POSS_SUP;
pub const ERROR_DS_RECALCSCHEMA_FAILED = WIN32_ERROR.ERROR_DS_RECALCSCHEMA_FAILED;
pub const ERROR_DS_TREE_DELETE_NOT_FINISHED = WIN32_ERROR.ERROR_DS_TREE_DELETE_NOT_FINISHED;
pub const ERROR_DS_CANT_DELETE = WIN32_ERROR.ERROR_DS_CANT_DELETE;
pub const ERROR_DS_ATT_SCHEMA_REQ_ID = WIN32_ERROR.ERROR_DS_ATT_SCHEMA_REQ_ID;
pub const ERROR_DS_BAD_ATT_SCHEMA_SYNTAX = WIN32_ERROR.ERROR_DS_BAD_ATT_SCHEMA_SYNTAX;
pub const ERROR_DS_CANT_CACHE_ATT = WIN32_ERROR.ERROR_DS_CANT_CACHE_ATT;
pub const ERROR_DS_CANT_CACHE_CLASS = WIN32_ERROR.ERROR_DS_CANT_CACHE_CLASS;
pub const ERROR_DS_CANT_REMOVE_ATT_CACHE = WIN32_ERROR.ERROR_DS_CANT_REMOVE_ATT_CACHE;
pub const ERROR_DS_CANT_REMOVE_CLASS_CACHE = WIN32_ERROR.ERROR_DS_CANT_REMOVE_CLASS_CACHE;
pub const ERROR_DS_CANT_RETRIEVE_DN = WIN32_ERROR.ERROR_DS_CANT_RETRIEVE_DN;
pub const ERROR_DS_MISSING_SUPREF = WIN32_ERROR.ERROR_DS_MISSING_SUPREF;
pub const ERROR_DS_CANT_RETRIEVE_INSTANCE = WIN32_ERROR.ERROR_DS_CANT_RETRIEVE_INSTANCE;
pub const ERROR_DS_CODE_INCONSISTENCY = WIN32_ERROR.ERROR_DS_CODE_INCONSISTENCY;
pub const ERROR_DS_DATABASE_ERROR = WIN32_ERROR.ERROR_DS_DATABASE_ERROR;
pub const ERROR_DS_GOVERNSID_MISSING = WIN32_ERROR.ERROR_DS_GOVERNSID_MISSING;
pub const ERROR_DS_MISSING_EXPECTED_ATT = WIN32_ERROR.ERROR_DS_MISSING_EXPECTED_ATT;
pub const ERROR_DS_NCNAME_MISSING_CR_REF = WIN32_ERROR.ERROR_DS_NCNAME_MISSING_CR_REF;
pub const ERROR_DS_SECURITY_CHECKING_ERROR = WIN32_ERROR.ERROR_DS_SECURITY_CHECKING_ERROR;
pub const ERROR_DS_SCHEMA_NOT_LOADED = WIN32_ERROR.ERROR_DS_SCHEMA_NOT_LOADED;
pub const ERROR_DS_SCHEMA_ALLOC_FAILED = WIN32_ERROR.ERROR_DS_SCHEMA_ALLOC_FAILED;
pub const ERROR_DS_ATT_SCHEMA_REQ_SYNTAX = WIN32_ERROR.ERROR_DS_ATT_SCHEMA_REQ_SYNTAX;
pub const ERROR_DS_GCVERIFY_ERROR = WIN32_ERROR.ERROR_DS_GCVERIFY_ERROR;
pub const ERROR_DS_DRA_SCHEMA_MISMATCH = WIN32_ERROR.ERROR_DS_DRA_SCHEMA_MISMATCH;
pub const ERROR_DS_CANT_FIND_DSA_OBJ = WIN32_ERROR.ERROR_DS_CANT_FIND_DSA_OBJ;
pub const ERROR_DS_CANT_FIND_EXPECTED_NC = WIN32_ERROR.ERROR_DS_CANT_FIND_EXPECTED_NC;
pub const ERROR_DS_CANT_FIND_NC_IN_CACHE = WIN32_ERROR.ERROR_DS_CANT_FIND_NC_IN_CACHE;
pub const ERROR_DS_CANT_RETRIEVE_CHILD = WIN32_ERROR.ERROR_DS_CANT_RETRIEVE_CHILD;
pub const ERROR_DS_SECURITY_ILLEGAL_MODIFY = WIN32_ERROR.ERROR_DS_SECURITY_ILLEGAL_MODIFY;
pub const ERROR_DS_CANT_REPLACE_HIDDEN_REC = WIN32_ERROR.ERROR_DS_CANT_REPLACE_HIDDEN_REC;
pub const ERROR_DS_BAD_HIERARCHY_FILE = WIN32_ERROR.ERROR_DS_BAD_HIERARCHY_FILE;
pub const ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED = WIN32_ERROR.ERROR_DS_BUILD_HIERARCHY_TABLE_FAILED;
pub const ERROR_DS_CONFIG_PARAM_MISSING = WIN32_ERROR.ERROR_DS_CONFIG_PARAM_MISSING;
pub const ERROR_DS_COUNTING_AB_INDICES_FAILED = WIN32_ERROR.ERROR_DS_COUNTING_AB_INDICES_FAILED;
pub const ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED = WIN32_ERROR.ERROR_DS_HIERARCHY_TABLE_MALLOC_FAILED;
pub const ERROR_DS_INTERNAL_FAILURE = WIN32_ERROR.ERROR_DS_INTERNAL_FAILURE;
pub const ERROR_DS_UNKNOWN_ERROR = WIN32_ERROR.ERROR_DS_UNKNOWN_ERROR;
pub const ERROR_DS_ROOT_REQUIRES_CLASS_TOP = WIN32_ERROR.ERROR_DS_ROOT_REQUIRES_CLASS_TOP;
pub const ERROR_DS_REFUSING_FSMO_ROLES = WIN32_ERROR.ERROR_DS_REFUSING_FSMO_ROLES;
pub const ERROR_DS_MISSING_FSMO_SETTINGS = WIN32_ERROR.ERROR_DS_MISSING_FSMO_SETTINGS;
pub const ERROR_DS_UNABLE_TO_SURRENDER_ROLES = WIN32_ERROR.ERROR_DS_UNABLE_TO_SURRENDER_ROLES;
pub const ERROR_DS_DRA_GENERIC = WIN32_ERROR.ERROR_DS_DRA_GENERIC;
pub const ERROR_DS_DRA_INVALID_PARAMETER = WIN32_ERROR.ERROR_DS_DRA_INVALID_PARAMETER;
pub const ERROR_DS_DRA_BUSY = WIN32_ERROR.ERROR_DS_DRA_BUSY;
pub const ERROR_DS_DRA_BAD_DN = WIN32_ERROR.ERROR_DS_DRA_BAD_DN;
pub const ERROR_DS_DRA_BAD_NC = WIN32_ERROR.ERROR_DS_DRA_BAD_NC;
pub const ERROR_DS_DRA_DN_EXISTS = WIN32_ERROR.ERROR_DS_DRA_DN_EXISTS;
pub const ERROR_DS_DRA_INTERNAL_ERROR = WIN32_ERROR.ERROR_DS_DRA_INTERNAL_ERROR;
pub const ERROR_DS_DRA_INCONSISTENT_DIT = WIN32_ERROR.ERROR_DS_DRA_INCONSISTENT_DIT;
pub const ERROR_DS_DRA_CONNECTION_FAILED = WIN32_ERROR.ERROR_DS_DRA_CONNECTION_FAILED;
pub const ERROR_DS_DRA_BAD_INSTANCE_TYPE = WIN32_ERROR.ERROR_DS_DRA_BAD_INSTANCE_TYPE;
pub const ERROR_DS_DRA_OUT_OF_MEM = WIN32_ERROR.ERROR_DS_DRA_OUT_OF_MEM;
pub const ERROR_DS_DRA_MAIL_PROBLEM = WIN32_ERROR.ERROR_DS_DRA_MAIL_PROBLEM;
pub const ERROR_DS_DRA_REF_ALREADY_EXISTS = WIN32_ERROR.ERROR_DS_DRA_REF_ALREADY_EXISTS;
pub const ERROR_DS_DRA_REF_NOT_FOUND = WIN32_ERROR.ERROR_DS_DRA_REF_NOT_FOUND;
pub const ERROR_DS_DRA_OBJ_IS_REP_SOURCE = WIN32_ERROR.ERROR_DS_DRA_OBJ_IS_REP_SOURCE;
pub const ERROR_DS_DRA_DB_ERROR = WIN32_ERROR.ERROR_DS_DRA_DB_ERROR;
pub const ERROR_DS_DRA_NO_REPLICA = WIN32_ERROR.ERROR_DS_DRA_NO_REPLICA;
pub const ERROR_DS_DRA_ACCESS_DENIED = WIN32_ERROR.ERROR_DS_DRA_ACCESS_DENIED;
pub const ERROR_DS_DRA_NOT_SUPPORTED = WIN32_ERROR.ERROR_DS_DRA_NOT_SUPPORTED;
pub const ERROR_DS_DRA_RPC_CANCELLED = WIN32_ERROR.ERROR_DS_DRA_RPC_CANCELLED;
pub const ERROR_DS_DRA_SOURCE_DISABLED = WIN32_ERROR.ERROR_DS_DRA_SOURCE_DISABLED;
pub const ERROR_DS_DRA_SINK_DISABLED = WIN32_ERROR.ERROR_DS_DRA_SINK_DISABLED;
pub const ERROR_DS_DRA_NAME_COLLISION = WIN32_ERROR.ERROR_DS_DRA_NAME_COLLISION;
pub const ERROR_DS_DRA_SOURCE_REINSTALLED = WIN32_ERROR.ERROR_DS_DRA_SOURCE_REINSTALLED;
pub const ERROR_DS_DRA_MISSING_PARENT = WIN32_ERROR.ERROR_DS_DRA_MISSING_PARENT;
pub const ERROR_DS_DRA_PREEMPTED = WIN32_ERROR.ERROR_DS_DRA_PREEMPTED;
pub const ERROR_DS_DRA_ABANDON_SYNC = WIN32_ERROR.ERROR_DS_DRA_ABANDON_SYNC;
pub const ERROR_DS_DRA_SHUTDOWN = WIN32_ERROR.ERROR_DS_DRA_SHUTDOWN;
pub const ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET = WIN32_ERROR.ERROR_DS_DRA_INCOMPATIBLE_PARTIAL_SET;
pub const ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA = WIN32_ERROR.ERROR_DS_DRA_SOURCE_IS_PARTIAL_REPLICA;
pub const ERROR_DS_DRA_EXTN_CONNECTION_FAILED = WIN32_ERROR.ERROR_DS_DRA_EXTN_CONNECTION_FAILED;
pub const ERROR_DS_INSTALL_SCHEMA_MISMATCH = WIN32_ERROR.ERROR_DS_INSTALL_SCHEMA_MISMATCH;
pub const ERROR_DS_DUP_LINK_ID = WIN32_ERROR.ERROR_DS_DUP_LINK_ID;
pub const ERROR_DS_NAME_ERROR_RESOLVING = WIN32_ERROR.ERROR_DS_NAME_ERROR_RESOLVING;
pub const ERROR_DS_NAME_ERROR_NOT_FOUND = WIN32_ERROR.ERROR_DS_NAME_ERROR_NOT_FOUND;
pub const ERROR_DS_NAME_ERROR_NOT_UNIQUE = WIN32_ERROR.ERROR_DS_NAME_ERROR_NOT_UNIQUE;
pub const ERROR_DS_NAME_ERROR_NO_MAPPING = WIN32_ERROR.ERROR_DS_NAME_ERROR_NO_MAPPING;
pub const ERROR_DS_NAME_ERROR_DOMAIN_ONLY = WIN32_ERROR.ERROR_DS_NAME_ERROR_DOMAIN_ONLY;
pub const ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING = WIN32_ERROR.ERROR_DS_NAME_ERROR_NO_SYNTACTICAL_MAPPING;
pub const ERROR_DS_CONSTRUCTED_ATT_MOD = WIN32_ERROR.ERROR_DS_CONSTRUCTED_ATT_MOD;
pub const ERROR_DS_WRONG_OM_OBJ_CLASS = WIN32_ERROR.ERROR_DS_WRONG_OM_OBJ_CLASS;
pub const ERROR_DS_DRA_REPL_PENDING = WIN32_ERROR.ERROR_DS_DRA_REPL_PENDING;
pub const ERROR_DS_DS_REQUIRED = WIN32_ERROR.ERROR_DS_DS_REQUIRED;
pub const ERROR_DS_INVALID_LDAP_DISPLAY_NAME = WIN32_ERROR.ERROR_DS_INVALID_LDAP_DISPLAY_NAME;
pub const ERROR_DS_NON_BASE_SEARCH = WIN32_ERROR.ERROR_DS_NON_BASE_SEARCH;
pub const ERROR_DS_CANT_RETRIEVE_ATTS = WIN32_ERROR.ERROR_DS_CANT_RETRIEVE_ATTS;
pub const ERROR_DS_BACKLINK_WITHOUT_LINK = WIN32_ERROR.ERROR_DS_BACKLINK_WITHOUT_LINK;
pub const ERROR_DS_EPOCH_MISMATCH = WIN32_ERROR.ERROR_DS_EPOCH_MISMATCH;
pub const ERROR_DS_SRC_NAME_MISMATCH = WIN32_ERROR.ERROR_DS_SRC_NAME_MISMATCH;
pub const ERROR_DS_SRC_AND_DST_NC_IDENTICAL = WIN32_ERROR.ERROR_DS_SRC_AND_DST_NC_IDENTICAL;
pub const ERROR_DS_DST_NC_MISMATCH = WIN32_ERROR.ERROR_DS_DST_NC_MISMATCH;
pub const ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC = WIN32_ERROR.ERROR_DS_NOT_AUTHORITIVE_FOR_DST_NC;
pub const ERROR_DS_SRC_GUID_MISMATCH = WIN32_ERROR.ERROR_DS_SRC_GUID_MISMATCH;
pub const ERROR_DS_CANT_MOVE_DELETED_OBJECT = WIN32_ERROR.ERROR_DS_CANT_MOVE_DELETED_OBJECT;
pub const ERROR_DS_PDC_OPERATION_IN_PROGRESS = WIN32_ERROR.ERROR_DS_PDC_OPERATION_IN_PROGRESS;
pub const ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD = WIN32_ERROR.ERROR_DS_CROSS_DOMAIN_CLEANUP_REQD;
pub const ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION = WIN32_ERROR.ERROR_DS_ILLEGAL_XDOM_MOVE_OPERATION;
pub const ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS = WIN32_ERROR.ERROR_DS_CANT_WITH_ACCT_GROUP_MEMBERSHPS;
pub const ERROR_DS_NC_MUST_HAVE_NC_PARENT = WIN32_ERROR.ERROR_DS_NC_MUST_HAVE_NC_PARENT;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE = WIN32_ERROR.ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE;
pub const ERROR_DS_DST_DOMAIN_NOT_NATIVE = WIN32_ERROR.ERROR_DS_DST_DOMAIN_NOT_NATIVE;
pub const ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER = WIN32_ERROR.ERROR_DS_MISSING_INFRASTRUCTURE_CONTAINER;
pub const ERROR_DS_CANT_MOVE_ACCOUNT_GROUP = WIN32_ERROR.ERROR_DS_CANT_MOVE_ACCOUNT_GROUP;
pub const ERROR_DS_CANT_MOVE_RESOURCE_GROUP = WIN32_ERROR.ERROR_DS_CANT_MOVE_RESOURCE_GROUP;
pub const ERROR_DS_INVALID_SEARCH_FLAG = WIN32_ERROR.ERROR_DS_INVALID_SEARCH_FLAG;
pub const ERROR_DS_NO_TREE_DELETE_ABOVE_NC = WIN32_ERROR.ERROR_DS_NO_TREE_DELETE_ABOVE_NC;
pub const ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE = WIN32_ERROR.ERROR_DS_COULDNT_LOCK_TREE_FOR_DELETE;
pub const ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE = WIN32_ERROR.ERROR_DS_COULDNT_IDENTIFY_OBJECTS_FOR_TREE_DELETE;
pub const ERROR_DS_SAM_INIT_FAILURE = WIN32_ERROR.ERROR_DS_SAM_INIT_FAILURE;
pub const ERROR_DS_SENSITIVE_GROUP_VIOLATION = WIN32_ERROR.ERROR_DS_SENSITIVE_GROUP_VIOLATION;
pub const ERROR_DS_CANT_MOD_PRIMARYGROUPID = WIN32_ERROR.ERROR_DS_CANT_MOD_PRIMARYGROUPID;
pub const ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD = WIN32_ERROR.ERROR_DS_ILLEGAL_BASE_SCHEMA_MOD;
pub const ERROR_DS_NONSAFE_SCHEMA_CHANGE = WIN32_ERROR.ERROR_DS_NONSAFE_SCHEMA_CHANGE;
pub const ERROR_DS_SCHEMA_UPDATE_DISALLOWED = WIN32_ERROR.ERROR_DS_SCHEMA_UPDATE_DISALLOWED;
pub const ERROR_DS_CANT_CREATE_UNDER_SCHEMA = WIN32_ERROR.ERROR_DS_CANT_CREATE_UNDER_SCHEMA;
pub const ERROR_DS_INSTALL_NO_SRC_SCH_VERSION = WIN32_ERROR.ERROR_DS_INSTALL_NO_SRC_SCH_VERSION;
pub const ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE = WIN32_ERROR.ERROR_DS_INSTALL_NO_SCH_VERSION_IN_INIFILE;
pub const ERROR_DS_INVALID_GROUP_TYPE = WIN32_ERROR.ERROR_DS_INVALID_GROUP_TYPE;
pub const ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN = WIN32_ERROR.ERROR_DS_NO_NEST_GLOBALGROUP_IN_MIXEDDOMAIN;
pub const ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN = WIN32_ERROR.ERROR_DS_NO_NEST_LOCALGROUP_IN_MIXEDDOMAIN;
pub const ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER = WIN32_ERROR.ERROR_DS_GLOBAL_CANT_HAVE_LOCAL_MEMBER;
pub const ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER = WIN32_ERROR.ERROR_DS_GLOBAL_CANT_HAVE_UNIVERSAL_MEMBER;
pub const ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER = WIN32_ERROR.ERROR_DS_UNIVERSAL_CANT_HAVE_LOCAL_MEMBER;
pub const ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER = WIN32_ERROR.ERROR_DS_GLOBAL_CANT_HAVE_CROSSDOMAIN_MEMBER;
pub const ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER = WIN32_ERROR.ERROR_DS_LOCAL_CANT_HAVE_CROSSDOMAIN_LOCAL_MEMBER;
pub const ERROR_DS_HAVE_PRIMARY_MEMBERS = WIN32_ERROR.ERROR_DS_HAVE_PRIMARY_MEMBERS;
pub const ERROR_DS_STRING_SD_CONVERSION_FAILED = WIN32_ERROR.ERROR_DS_STRING_SD_CONVERSION_FAILED;
pub const ERROR_DS_NAMING_MASTER_GC = WIN32_ERROR.ERROR_DS_NAMING_MASTER_GC;
pub const ERROR_DS_DNS_LOOKUP_FAILURE = WIN32_ERROR.ERROR_DS_DNS_LOOKUP_FAILURE;
pub const ERROR_DS_COULDNT_UPDATE_SPNS = WIN32_ERROR.ERROR_DS_COULDNT_UPDATE_SPNS;
pub const ERROR_DS_CANT_RETRIEVE_SD = WIN32_ERROR.ERROR_DS_CANT_RETRIEVE_SD;
pub const ERROR_DS_KEY_NOT_UNIQUE = WIN32_ERROR.ERROR_DS_KEY_NOT_UNIQUE;
pub const ERROR_DS_WRONG_LINKED_ATT_SYNTAX = WIN32_ERROR.ERROR_DS_WRONG_LINKED_ATT_SYNTAX;
pub const ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD = WIN32_ERROR.ERROR_DS_SAM_NEED_BOOTKEY_PASSWORD;
pub const ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY = WIN32_ERROR.ERROR_DS_SAM_NEED_BOOTKEY_FLOPPY;
pub const ERROR_DS_CANT_START = WIN32_ERROR.ERROR_DS_CANT_START;
pub const ERROR_DS_INIT_FAILURE = WIN32_ERROR.ERROR_DS_INIT_FAILURE;
pub const ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION = WIN32_ERROR.ERROR_DS_NO_PKT_PRIVACY_ON_CONNECTION;
pub const ERROR_DS_SOURCE_DOMAIN_IN_FOREST = WIN32_ERROR.ERROR_DS_SOURCE_DOMAIN_IN_FOREST;
pub const ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST = WIN32_ERROR.ERROR_DS_DESTINATION_DOMAIN_NOT_IN_FOREST;
pub const ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED = WIN32_ERROR.ERROR_DS_DESTINATION_AUDITING_NOT_ENABLED;
pub const ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN = WIN32_ERROR.ERROR_DS_CANT_FIND_DC_FOR_SRC_DOMAIN;
pub const ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER = WIN32_ERROR.ERROR_DS_SRC_OBJ_NOT_GROUP_OR_USER;
pub const ERROR_DS_SRC_SID_EXISTS_IN_FOREST = WIN32_ERROR.ERROR_DS_SRC_SID_EXISTS_IN_FOREST;
pub const ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH = WIN32_ERROR.ERROR_DS_SRC_AND_DST_OBJECT_CLASS_MISMATCH;
pub const ERROR_SAM_INIT_FAILURE = WIN32_ERROR.ERROR_SAM_INIT_FAILURE;
pub const ERROR_DS_DRA_SCHEMA_INFO_SHIP = WIN32_ERROR.ERROR_DS_DRA_SCHEMA_INFO_SHIP;
pub const ERROR_DS_DRA_SCHEMA_CONFLICT = WIN32_ERROR.ERROR_DS_DRA_SCHEMA_CONFLICT;
pub const ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT = WIN32_ERROR.ERROR_DS_DRA_EARLIER_SCHEMA_CONFLICT;
pub const ERROR_DS_DRA_OBJ_NC_MISMATCH = WIN32_ERROR.ERROR_DS_DRA_OBJ_NC_MISMATCH;
pub const ERROR_DS_NC_STILL_HAS_DSAS = WIN32_ERROR.ERROR_DS_NC_STILL_HAS_DSAS;
pub const ERROR_DS_GC_REQUIRED = WIN32_ERROR.ERROR_DS_GC_REQUIRED;
pub const ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY = WIN32_ERROR.ERROR_DS_LOCAL_MEMBER_OF_LOCAL_ONLY;
pub const ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS = WIN32_ERROR.ERROR_DS_NO_FPO_IN_UNIVERSAL_GROUPS;
pub const ERROR_DS_CANT_ADD_TO_GC = WIN32_ERROR.ERROR_DS_CANT_ADD_TO_GC;
pub const ERROR_DS_NO_CHECKPOINT_WITH_PDC = WIN32_ERROR.ERROR_DS_NO_CHECKPOINT_WITH_PDC;
pub const ERROR_DS_SOURCE_AUDITING_NOT_ENABLED = WIN32_ERROR.ERROR_DS_SOURCE_AUDITING_NOT_ENABLED;
pub const ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC = WIN32_ERROR.ERROR_DS_CANT_CREATE_IN_NONDOMAIN_NC;
pub const ERROR_DS_INVALID_NAME_FOR_SPN = WIN32_ERROR.ERROR_DS_INVALID_NAME_FOR_SPN;
pub const ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS = WIN32_ERROR.ERROR_DS_FILTER_USES_CONTRUCTED_ATTRS;
pub const ERROR_DS_UNICODEPWD_NOT_IN_QUOTES = WIN32_ERROR.ERROR_DS_UNICODEPWD_NOT_IN_QUOTES;
pub const ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED = WIN32_ERROR.ERROR_DS_MACHINE_ACCOUNT_QUOTA_EXCEEDED;
pub const ERROR_DS_MUST_BE_RUN_ON_DST_DC = WIN32_ERROR.ERROR_DS_MUST_BE_RUN_ON_DST_DC;
pub const ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER = WIN32_ERROR.ERROR_DS_SRC_DC_MUST_BE_SP4_OR_GREATER;
pub const ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ = WIN32_ERROR.ERROR_DS_CANT_TREE_DELETE_CRITICAL_OBJ;
pub const ERROR_DS_INIT_FAILURE_CONSOLE = WIN32_ERROR.ERROR_DS_INIT_FAILURE_CONSOLE;
pub const ERROR_DS_SAM_INIT_FAILURE_CONSOLE = WIN32_ERROR.ERROR_DS_SAM_INIT_FAILURE_CONSOLE;
pub const ERROR_DS_FOREST_VERSION_TOO_HIGH = WIN32_ERROR.ERROR_DS_FOREST_VERSION_TOO_HIGH;
pub const ERROR_DS_DOMAIN_VERSION_TOO_HIGH = WIN32_ERROR.ERROR_DS_DOMAIN_VERSION_TOO_HIGH;
pub const ERROR_DS_FOREST_VERSION_TOO_LOW = WIN32_ERROR.ERROR_DS_FOREST_VERSION_TOO_LOW;
pub const ERROR_DS_DOMAIN_VERSION_TOO_LOW = WIN32_ERROR.ERROR_DS_DOMAIN_VERSION_TOO_LOW;
pub const ERROR_DS_INCOMPATIBLE_VERSION = WIN32_ERROR.ERROR_DS_INCOMPATIBLE_VERSION;
pub const ERROR_DS_LOW_DSA_VERSION = WIN32_ERROR.ERROR_DS_LOW_DSA_VERSION;
pub const ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN = WIN32_ERROR.ERROR_DS_NO_BEHAVIOR_VERSION_IN_MIXEDDOMAIN;
pub const ERROR_DS_NOT_SUPPORTED_SORT_ORDER = WIN32_ERROR.ERROR_DS_NOT_SUPPORTED_SORT_ORDER;
pub const ERROR_DS_NAME_NOT_UNIQUE = WIN32_ERROR.ERROR_DS_NAME_NOT_UNIQUE;
pub const ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4 = WIN32_ERROR.ERROR_DS_MACHINE_ACCOUNT_CREATED_PRENT4;
pub const ERROR_DS_OUT_OF_VERSION_STORE = WIN32_ERROR.ERROR_DS_OUT_OF_VERSION_STORE;
pub const ERROR_DS_INCOMPATIBLE_CONTROLS_USED = WIN32_ERROR.ERROR_DS_INCOMPATIBLE_CONTROLS_USED;
pub const ERROR_DS_NO_REF_DOMAIN = WIN32_ERROR.ERROR_DS_NO_REF_DOMAIN;
pub const ERROR_DS_RESERVED_LINK_ID = WIN32_ERROR.ERROR_DS_RESERVED_LINK_ID;
pub const ERROR_DS_LINK_ID_NOT_AVAILABLE = WIN32_ERROR.ERROR_DS_LINK_ID_NOT_AVAILABLE;
pub const ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER = WIN32_ERROR.ERROR_DS_AG_CANT_HAVE_UNIVERSAL_MEMBER;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE = WIN32_ERROR.ERROR_DS_MODIFYDN_DISALLOWED_BY_INSTANCE_TYPE;
pub const ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC = WIN32_ERROR.ERROR_DS_NO_OBJECT_MOVE_IN_SCHEMA_NC;
pub const ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG = WIN32_ERROR.ERROR_DS_MODIFYDN_DISALLOWED_BY_FLAG;
pub const ERROR_DS_MODIFYDN_WRONG_GRANDPARENT = WIN32_ERROR.ERROR_DS_MODIFYDN_WRONG_GRANDPARENT;
pub const ERROR_DS_NAME_ERROR_TRUST_REFERRAL = WIN32_ERROR.ERROR_DS_NAME_ERROR_TRUST_REFERRAL;
pub const ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER = WIN32_ERROR.ERROR_NOT_SUPPORTED_ON_STANDARD_SERVER;
pub const ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD = WIN32_ERROR.ERROR_DS_CANT_ACCESS_REMOTE_PART_OF_AD;
pub const ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2 = WIN32_ERROR.ERROR_DS_CR_IMPOSSIBLE_TO_VALIDATE_V2;
pub const ERROR_DS_THREAD_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_DS_THREAD_LIMIT_EXCEEDED;
pub const ERROR_DS_NOT_CLOSEST = WIN32_ERROR.ERROR_DS_NOT_CLOSEST;
pub const ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF = WIN32_ERROR.ERROR_DS_CANT_DERIVE_SPN_WITHOUT_SERVER_REF;
pub const ERROR_DS_SINGLE_USER_MODE_FAILED = WIN32_ERROR.ERROR_DS_SINGLE_USER_MODE_FAILED;
pub const ERROR_DS_NTDSCRIPT_SYNTAX_ERROR = WIN32_ERROR.ERROR_DS_NTDSCRIPT_SYNTAX_ERROR;
pub const ERROR_DS_NTDSCRIPT_PROCESS_ERROR = WIN32_ERROR.ERROR_DS_NTDSCRIPT_PROCESS_ERROR;
pub const ERROR_DS_DIFFERENT_REPL_EPOCHS = WIN32_ERROR.ERROR_DS_DIFFERENT_REPL_EPOCHS;
pub const ERROR_DS_DRS_EXTENSIONS_CHANGED = WIN32_ERROR.ERROR_DS_DRS_EXTENSIONS_CHANGED;
pub const ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR = WIN32_ERROR.ERROR_DS_REPLICA_SET_CHANGE_NOT_ALLOWED_ON_DISABLED_CR;
pub const ERROR_DS_NO_MSDS_INTID = WIN32_ERROR.ERROR_DS_NO_MSDS_INTID;
pub const ERROR_DS_DUP_MSDS_INTID = WIN32_ERROR.ERROR_DS_DUP_MSDS_INTID;
pub const ERROR_DS_EXISTS_IN_RDNATTID = WIN32_ERROR.ERROR_DS_EXISTS_IN_RDNATTID;
pub const ERROR_DS_AUTHORIZATION_FAILED = WIN32_ERROR.ERROR_DS_AUTHORIZATION_FAILED;
pub const ERROR_DS_INVALID_SCRIPT = WIN32_ERROR.ERROR_DS_INVALID_SCRIPT;
pub const ERROR_DS_REMOTE_CROSSREF_OP_FAILED = WIN32_ERROR.ERROR_DS_REMOTE_CROSSREF_OP_FAILED;
pub const ERROR_DS_CROSS_REF_BUSY = WIN32_ERROR.ERROR_DS_CROSS_REF_BUSY;
pub const ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN = WIN32_ERROR.ERROR_DS_CANT_DERIVE_SPN_FOR_DELETED_DOMAIN;
pub const ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC = WIN32_ERROR.ERROR_DS_CANT_DEMOTE_WITH_WRITEABLE_NC;
pub const ERROR_DS_DUPLICATE_ID_FOUND = WIN32_ERROR.ERROR_DS_DUPLICATE_ID_FOUND;
pub const ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT = WIN32_ERROR.ERROR_DS_INSUFFICIENT_ATTR_TO_CREATE_OBJECT;
pub const ERROR_DS_GROUP_CONVERSION_ERROR = WIN32_ERROR.ERROR_DS_GROUP_CONVERSION_ERROR;
pub const ERROR_DS_CANT_MOVE_APP_BASIC_GROUP = WIN32_ERROR.ERROR_DS_CANT_MOVE_APP_BASIC_GROUP;
pub const ERROR_DS_CANT_MOVE_APP_QUERY_GROUP = WIN32_ERROR.ERROR_DS_CANT_MOVE_APP_QUERY_GROUP;
pub const ERROR_DS_ROLE_NOT_VERIFIED = WIN32_ERROR.ERROR_DS_ROLE_NOT_VERIFIED;
pub const ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL = WIN32_ERROR.ERROR_DS_WKO_CONTAINER_CANNOT_BE_SPECIAL;
pub const ERROR_DS_DOMAIN_RENAME_IN_PROGRESS = WIN32_ERROR.ERROR_DS_DOMAIN_RENAME_IN_PROGRESS;
pub const ERROR_DS_EXISTING_AD_CHILD_NC = WIN32_ERROR.ERROR_DS_EXISTING_AD_CHILD_NC;
pub const ERROR_DS_REPL_LIFETIME_EXCEEDED = WIN32_ERROR.ERROR_DS_REPL_LIFETIME_EXCEEDED;
pub const ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER = WIN32_ERROR.ERROR_DS_DISALLOWED_IN_SYSTEM_CONTAINER;
pub const ERROR_DS_LDAP_SEND_QUEUE_FULL = WIN32_ERROR.ERROR_DS_LDAP_SEND_QUEUE_FULL;
pub const ERROR_DS_DRA_OUT_SCHEDULE_WINDOW = WIN32_ERROR.ERROR_DS_DRA_OUT_SCHEDULE_WINDOW;
pub const ERROR_DS_POLICY_NOT_KNOWN = WIN32_ERROR.ERROR_DS_POLICY_NOT_KNOWN;
pub const ERROR_NO_SITE_SETTINGS_OBJECT = WIN32_ERROR.ERROR_NO_SITE_SETTINGS_OBJECT;
pub const ERROR_NO_SECRETS = WIN32_ERROR.ERROR_NO_SECRETS;
pub const ERROR_NO_WRITABLE_DC_FOUND = WIN32_ERROR.ERROR_NO_WRITABLE_DC_FOUND;
pub const ERROR_DS_NO_SERVER_OBJECT = WIN32_ERROR.ERROR_DS_NO_SERVER_OBJECT;
pub const ERROR_DS_NO_NTDSA_OBJECT = WIN32_ERROR.ERROR_DS_NO_NTDSA_OBJECT;
pub const ERROR_DS_NON_ASQ_SEARCH = WIN32_ERROR.ERROR_DS_NON_ASQ_SEARCH;
pub const ERROR_DS_AUDIT_FAILURE = WIN32_ERROR.ERROR_DS_AUDIT_FAILURE;
pub const ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE = WIN32_ERROR.ERROR_DS_INVALID_SEARCH_FLAG_SUBTREE;
pub const ERROR_DS_INVALID_SEARCH_FLAG_TUPLE = WIN32_ERROR.ERROR_DS_INVALID_SEARCH_FLAG_TUPLE;
pub const ERROR_DS_HIERARCHY_TABLE_TOO_DEEP = WIN32_ERROR.ERROR_DS_HIERARCHY_TABLE_TOO_DEEP;
pub const ERROR_DS_DRA_CORRUPT_UTD_VECTOR = WIN32_ERROR.ERROR_DS_DRA_CORRUPT_UTD_VECTOR;
pub const ERROR_DS_DRA_SECRETS_DENIED = WIN32_ERROR.ERROR_DS_DRA_SECRETS_DENIED;
pub const ERROR_DS_RESERVED_MAPI_ID = WIN32_ERROR.ERROR_DS_RESERVED_MAPI_ID;
pub const ERROR_DS_MAPI_ID_NOT_AVAILABLE = WIN32_ERROR.ERROR_DS_MAPI_ID_NOT_AVAILABLE;
pub const ERROR_DS_DRA_MISSING_KRBTGT_SECRET = WIN32_ERROR.ERROR_DS_DRA_MISSING_KRBTGT_SECRET;
pub const ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST = WIN32_ERROR.ERROR_DS_DOMAIN_NAME_EXISTS_IN_FOREST;
pub const ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST = WIN32_ERROR.ERROR_DS_FLAT_NAME_EXISTS_IN_FOREST;
pub const ERROR_INVALID_USER_PRINCIPAL_NAME = WIN32_ERROR.ERROR_INVALID_USER_PRINCIPAL_NAME;
pub const ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS = WIN32_ERROR.ERROR_DS_OID_MAPPED_GROUP_CANT_HAVE_MEMBERS;
pub const ERROR_DS_OID_NOT_FOUND = WIN32_ERROR.ERROR_DS_OID_NOT_FOUND;
pub const ERROR_DS_DRA_RECYCLED_TARGET = WIN32_ERROR.ERROR_DS_DRA_RECYCLED_TARGET;
pub const ERROR_DS_DISALLOWED_NC_REDIRECT = WIN32_ERROR.ERROR_DS_DISALLOWED_NC_REDIRECT;
pub const ERROR_DS_HIGH_ADLDS_FFL = WIN32_ERROR.ERROR_DS_HIGH_ADLDS_FFL;
pub const ERROR_DS_HIGH_DSA_VERSION = WIN32_ERROR.ERROR_DS_HIGH_DSA_VERSION;
pub const ERROR_DS_LOW_ADLDS_FFL = WIN32_ERROR.ERROR_DS_LOW_ADLDS_FFL;
pub const ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION = WIN32_ERROR.ERROR_DOMAIN_SID_SAME_AS_LOCAL_WORKSTATION;
pub const ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED = WIN32_ERROR.ERROR_DS_UNDELETE_SAM_VALIDATION_FAILED;
pub const ERROR_INCORRECT_ACCOUNT_TYPE = WIN32_ERROR.ERROR_INCORRECT_ACCOUNT_TYPE;
pub const ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST = WIN32_ERROR.ERROR_DS_SPN_VALUE_NOT_UNIQUE_IN_FOREST;
pub const ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST = WIN32_ERROR.ERROR_DS_UPN_VALUE_NOT_UNIQUE_IN_FOREST;
pub const ERROR_DS_MISSING_FOREST_TRUST = WIN32_ERROR.ERROR_DS_MISSING_FOREST_TRUST;
pub const ERROR_DS_VALUE_KEY_NOT_UNIQUE = WIN32_ERROR.ERROR_DS_VALUE_KEY_NOT_UNIQUE;
pub const DNS_ERROR_RESPONSE_CODES_BASE = WIN32_ERROR.DNS_ERROR_RESPONSE_CODES_BASE;
pub const DNS_ERROR_RCODE_NO_ERROR = WIN32_ERROR.NO_ERROR;
pub const DNS_ERROR_MASK = WIN32_ERROR.DNS_ERROR_RESPONSE_CODES_BASE;
pub const DNS_ERROR_RCODE_FORMAT_ERROR = WIN32_ERROR.DNS_ERROR_RCODE_FORMAT_ERROR;
pub const DNS_ERROR_RCODE_SERVER_FAILURE = WIN32_ERROR.DNS_ERROR_RCODE_SERVER_FAILURE;
pub const DNS_ERROR_RCODE_NAME_ERROR = WIN32_ERROR.DNS_ERROR_RCODE_NAME_ERROR;
pub const DNS_ERROR_RCODE_NOT_IMPLEMENTED = WIN32_ERROR.DNS_ERROR_RCODE_NOT_IMPLEMENTED;
pub const DNS_ERROR_RCODE_REFUSED = WIN32_ERROR.DNS_ERROR_RCODE_REFUSED;
pub const DNS_ERROR_RCODE_YXDOMAIN = WIN32_ERROR.DNS_ERROR_RCODE_YXDOMAIN;
pub const DNS_ERROR_RCODE_YXRRSET = WIN32_ERROR.DNS_ERROR_RCODE_YXRRSET;
pub const DNS_ERROR_RCODE_NXRRSET = WIN32_ERROR.DNS_ERROR_RCODE_NXRRSET;
pub const DNS_ERROR_RCODE_NOTAUTH = WIN32_ERROR.DNS_ERROR_RCODE_NOTAUTH;
pub const DNS_ERROR_RCODE_NOTZONE = WIN32_ERROR.DNS_ERROR_RCODE_NOTZONE;
pub const DNS_ERROR_RCODE_BADSIG = WIN32_ERROR.DNS_ERROR_RCODE_BADSIG;
pub const DNS_ERROR_RCODE_BADKEY = WIN32_ERROR.DNS_ERROR_RCODE_BADKEY;
pub const DNS_ERROR_RCODE_BADTIME = WIN32_ERROR.DNS_ERROR_RCODE_BADTIME;
pub const DNS_ERROR_RCODE_LAST = WIN32_ERROR.DNS_ERROR_RCODE_BADTIME;
pub const DNS_ERROR_DNSSEC_BASE = WIN32_ERROR.DNS_ERROR_DNSSEC_BASE;
pub const DNS_ERROR_KEYMASTER_REQUIRED = WIN32_ERROR.DNS_ERROR_KEYMASTER_REQUIRED;
pub const DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_ON_SIGNED_ZONE;
pub const DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1 = WIN32_ERROR.DNS_ERROR_NSEC3_INCOMPATIBLE_WITH_RSA_SHA1;
pub const DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS = WIN32_ERROR.DNS_ERROR_NOT_ENOUGH_SIGNING_KEY_DESCRIPTORS;
pub const DNS_ERROR_UNSUPPORTED_ALGORITHM = WIN32_ERROR.DNS_ERROR_UNSUPPORTED_ALGORITHM;
pub const DNS_ERROR_INVALID_KEY_SIZE = WIN32_ERROR.DNS_ERROR_INVALID_KEY_SIZE;
pub const DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE = WIN32_ERROR.DNS_ERROR_SIGNING_KEY_NOT_ACCESSIBLE;
pub const DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION = WIN32_ERROR.DNS_ERROR_KSP_DOES_NOT_SUPPORT_PROTECTION;
pub const DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR = WIN32_ERROR.DNS_ERROR_UNEXPECTED_DATA_PROTECTION_ERROR;
pub const DNS_ERROR_UNEXPECTED_CNG_ERROR = WIN32_ERROR.DNS_ERROR_UNEXPECTED_CNG_ERROR;
pub const DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION = WIN32_ERROR.DNS_ERROR_UNKNOWN_SIGNING_PARAMETER_VERSION;
pub const DNS_ERROR_KSP_NOT_ACCESSIBLE = WIN32_ERROR.DNS_ERROR_KSP_NOT_ACCESSIBLE;
pub const DNS_ERROR_TOO_MANY_SKDS = WIN32_ERROR.DNS_ERROR_TOO_MANY_SKDS;
pub const DNS_ERROR_INVALID_ROLLOVER_PERIOD = WIN32_ERROR.DNS_ERROR_INVALID_ROLLOVER_PERIOD;
pub const DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET = WIN32_ERROR.DNS_ERROR_INVALID_INITIAL_ROLLOVER_OFFSET;
pub const DNS_ERROR_ROLLOVER_IN_PROGRESS = WIN32_ERROR.DNS_ERROR_ROLLOVER_IN_PROGRESS;
pub const DNS_ERROR_STANDBY_KEY_NOT_PRESENT = WIN32_ERROR.DNS_ERROR_STANDBY_KEY_NOT_PRESENT;
pub const DNS_ERROR_NOT_ALLOWED_ON_ZSK = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_ON_ZSK;
pub const DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_ON_ACTIVE_SKD;
pub const DNS_ERROR_ROLLOVER_ALREADY_QUEUED = WIN32_ERROR.DNS_ERROR_ROLLOVER_ALREADY_QUEUED;
pub const DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_ON_UNSIGNED_ZONE;
pub const DNS_ERROR_BAD_KEYMASTER = WIN32_ERROR.DNS_ERROR_BAD_KEYMASTER;
pub const DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD = WIN32_ERROR.DNS_ERROR_INVALID_SIGNATURE_VALIDITY_PERIOD;
pub const DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT = WIN32_ERROR.DNS_ERROR_INVALID_NSEC3_ITERATION_COUNT;
pub const DNS_ERROR_DNSSEC_IS_DISABLED = WIN32_ERROR.DNS_ERROR_DNSSEC_IS_DISABLED;
pub const DNS_ERROR_INVALID_XML = WIN32_ERROR.DNS_ERROR_INVALID_XML;
pub const DNS_ERROR_NO_VALID_TRUST_ANCHORS = WIN32_ERROR.DNS_ERROR_NO_VALID_TRUST_ANCHORS;
pub const DNS_ERROR_ROLLOVER_NOT_POKEABLE = WIN32_ERROR.DNS_ERROR_ROLLOVER_NOT_POKEABLE;
pub const DNS_ERROR_NSEC3_NAME_COLLISION = WIN32_ERROR.DNS_ERROR_NSEC3_NAME_COLLISION;
pub const DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1 = WIN32_ERROR.DNS_ERROR_NSEC_INCOMPATIBLE_WITH_NSEC3_RSA_SHA1;
pub const DNS_ERROR_PACKET_FMT_BASE = WIN32_ERROR.DNS_ERROR_PACKET_FMT_BASE;
pub const DNS_ERROR_BAD_PACKET = WIN32_ERROR.DNS_ERROR_BAD_PACKET;
pub const DNS_ERROR_NO_PACKET = WIN32_ERROR.DNS_ERROR_NO_PACKET;
pub const DNS_ERROR_RCODE = WIN32_ERROR.DNS_ERROR_RCODE;
pub const DNS_ERROR_UNSECURE_PACKET = WIN32_ERROR.DNS_ERROR_UNSECURE_PACKET;
pub const DNS_ERROR_NO_MEMORY = WIN32_ERROR.ERROR_OUTOFMEMORY;
pub const DNS_ERROR_INVALID_NAME = WIN32_ERROR.ERROR_INVALID_NAME;
pub const DNS_ERROR_INVALID_DATA = WIN32_ERROR.ERROR_INVALID_DATA;
pub const DNS_ERROR_GENERAL_API_BASE = WIN32_ERROR.DNS_ERROR_GENERAL_API_BASE;
pub const DNS_ERROR_INVALID_TYPE = WIN32_ERROR.DNS_ERROR_INVALID_TYPE;
pub const DNS_ERROR_INVALID_IP_ADDRESS = WIN32_ERROR.DNS_ERROR_INVALID_IP_ADDRESS;
pub const DNS_ERROR_INVALID_PROPERTY = WIN32_ERROR.DNS_ERROR_INVALID_PROPERTY;
pub const DNS_ERROR_TRY_AGAIN_LATER = WIN32_ERROR.DNS_ERROR_TRY_AGAIN_LATER;
pub const DNS_ERROR_NOT_UNIQUE = WIN32_ERROR.DNS_ERROR_NOT_UNIQUE;
pub const DNS_ERROR_NON_RFC_NAME = WIN32_ERROR.DNS_ERROR_NON_RFC_NAME;
pub const DNS_ERROR_INVALID_NAME_CHAR = WIN32_ERROR.DNS_ERROR_INVALID_NAME_CHAR;
pub const DNS_ERROR_NUMERIC_NAME = WIN32_ERROR.DNS_ERROR_NUMERIC_NAME;
pub const DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_ON_ROOT_SERVER;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_UNDER_DELEGATION;
pub const DNS_ERROR_CANNOT_FIND_ROOT_HINTS = WIN32_ERROR.DNS_ERROR_CANNOT_FIND_ROOT_HINTS;
pub const DNS_ERROR_INCONSISTENT_ROOT_HINTS = WIN32_ERROR.DNS_ERROR_INCONSISTENT_ROOT_HINTS;
pub const DNS_ERROR_DWORD_VALUE_TOO_SMALL = WIN32_ERROR.DNS_ERROR_DWORD_VALUE_TOO_SMALL;
pub const DNS_ERROR_DWORD_VALUE_TOO_LARGE = WIN32_ERROR.DNS_ERROR_DWORD_VALUE_TOO_LARGE;
pub const DNS_ERROR_BACKGROUND_LOADING = WIN32_ERROR.DNS_ERROR_BACKGROUND_LOADING;
pub const DNS_ERROR_NOT_ALLOWED_ON_RODC = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_ON_RODC;
pub const DNS_ERROR_NOT_ALLOWED_UNDER_DNAME = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_UNDER_DNAME;
pub const DNS_ERROR_DELEGATION_REQUIRED = WIN32_ERROR.DNS_ERROR_DELEGATION_REQUIRED;
pub const DNS_ERROR_INVALID_POLICY_TABLE = WIN32_ERROR.DNS_ERROR_INVALID_POLICY_TABLE;
pub const DNS_ERROR_ADDRESS_REQUIRED = WIN32_ERROR.DNS_ERROR_ADDRESS_REQUIRED;
pub const DNS_ERROR_ZONE_BASE = WIN32_ERROR.DNS_ERROR_ZONE_BASE;
pub const DNS_ERROR_ZONE_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_ZONE_DOES_NOT_EXIST;
pub const DNS_ERROR_NO_ZONE_INFO = WIN32_ERROR.DNS_ERROR_NO_ZONE_INFO;
pub const DNS_ERROR_INVALID_ZONE_OPERATION = WIN32_ERROR.DNS_ERROR_INVALID_ZONE_OPERATION;
pub const DNS_ERROR_ZONE_CONFIGURATION_ERROR = WIN32_ERROR.DNS_ERROR_ZONE_CONFIGURATION_ERROR;
pub const DNS_ERROR_ZONE_HAS_NO_SOA_RECORD = WIN32_ERROR.DNS_ERROR_ZONE_HAS_NO_SOA_RECORD;
pub const DNS_ERROR_ZONE_HAS_NO_NS_RECORDS = WIN32_ERROR.DNS_ERROR_ZONE_HAS_NO_NS_RECORDS;
pub const DNS_ERROR_ZONE_LOCKED = WIN32_ERROR.DNS_ERROR_ZONE_LOCKED;
pub const DNS_ERROR_ZONE_CREATION_FAILED = WIN32_ERROR.DNS_ERROR_ZONE_CREATION_FAILED;
pub const DNS_ERROR_ZONE_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_ZONE_ALREADY_EXISTS;
pub const DNS_ERROR_AUTOZONE_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_AUTOZONE_ALREADY_EXISTS;
pub const DNS_ERROR_INVALID_ZONE_TYPE = WIN32_ERROR.DNS_ERROR_INVALID_ZONE_TYPE;
pub const DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP = WIN32_ERROR.DNS_ERROR_SECONDARY_REQUIRES_MASTER_IP;
pub const DNS_ERROR_ZONE_NOT_SECONDARY = WIN32_ERROR.DNS_ERROR_ZONE_NOT_SECONDARY;
pub const DNS_ERROR_NEED_SECONDARY_ADDRESSES = WIN32_ERROR.DNS_ERROR_NEED_SECONDARY_ADDRESSES;
pub const DNS_ERROR_WINS_INIT_FAILED = WIN32_ERROR.DNS_ERROR_WINS_INIT_FAILED;
pub const DNS_ERROR_NEED_WINS_SERVERS = WIN32_ERROR.DNS_ERROR_NEED_WINS_SERVERS;
pub const DNS_ERROR_NBSTAT_INIT_FAILED = WIN32_ERROR.DNS_ERROR_NBSTAT_INIT_FAILED;
pub const DNS_ERROR_SOA_DELETE_INVALID = WIN32_ERROR.DNS_ERROR_SOA_DELETE_INVALID;
pub const DNS_ERROR_FORWARDER_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_FORWARDER_ALREADY_EXISTS;
pub const DNS_ERROR_ZONE_REQUIRES_MASTER_IP = WIN32_ERROR.DNS_ERROR_ZONE_REQUIRES_MASTER_IP;
pub const DNS_ERROR_ZONE_IS_SHUTDOWN = WIN32_ERROR.DNS_ERROR_ZONE_IS_SHUTDOWN;
pub const DNS_ERROR_ZONE_LOCKED_FOR_SIGNING = WIN32_ERROR.DNS_ERROR_ZONE_LOCKED_FOR_SIGNING;
pub const DNS_ERROR_DATAFILE_BASE = WIN32_ERROR.DNS_ERROR_DATAFILE_BASE;
pub const DNS_ERROR_PRIMARY_REQUIRES_DATAFILE = WIN32_ERROR.DNS_ERROR_PRIMARY_REQUIRES_DATAFILE;
pub const DNS_ERROR_INVALID_DATAFILE_NAME = WIN32_ERROR.DNS_ERROR_INVALID_DATAFILE_NAME;
pub const DNS_ERROR_DATAFILE_OPEN_FAILURE = WIN32_ERROR.DNS_ERROR_DATAFILE_OPEN_FAILURE;
pub const DNS_ERROR_FILE_WRITEBACK_FAILED = WIN32_ERROR.DNS_ERROR_FILE_WRITEBACK_FAILED;
pub const DNS_ERROR_DATAFILE_PARSING = WIN32_ERROR.DNS_ERROR_DATAFILE_PARSING;
pub const DNS_ERROR_DATABASE_BASE = WIN32_ERROR.DNS_ERROR_DATABASE_BASE;
pub const DNS_ERROR_RECORD_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_RECORD_DOES_NOT_EXIST;
pub const DNS_ERROR_RECORD_FORMAT = WIN32_ERROR.DNS_ERROR_RECORD_FORMAT;
pub const DNS_ERROR_NODE_CREATION_FAILED = WIN32_ERROR.DNS_ERROR_NODE_CREATION_FAILED;
pub const DNS_ERROR_UNKNOWN_RECORD_TYPE = WIN32_ERROR.DNS_ERROR_UNKNOWN_RECORD_TYPE;
pub const DNS_ERROR_RECORD_TIMED_OUT = WIN32_ERROR.DNS_ERROR_RECORD_TIMED_OUT;
pub const DNS_ERROR_NAME_NOT_IN_ZONE = WIN32_ERROR.DNS_ERROR_NAME_NOT_IN_ZONE;
pub const DNS_ERROR_CNAME_LOOP = WIN32_ERROR.DNS_ERROR_CNAME_LOOP;
pub const DNS_ERROR_NODE_IS_CNAME = WIN32_ERROR.DNS_ERROR_NODE_IS_CNAME;
pub const DNS_ERROR_CNAME_COLLISION = WIN32_ERROR.DNS_ERROR_CNAME_COLLISION;
pub const DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT = WIN32_ERROR.DNS_ERROR_RECORD_ONLY_AT_ZONE_ROOT;
pub const DNS_ERROR_RECORD_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_RECORD_ALREADY_EXISTS;
pub const DNS_ERROR_SECONDARY_DATA = WIN32_ERROR.DNS_ERROR_SECONDARY_DATA;
pub const DNS_ERROR_NO_CREATE_CACHE_DATA = WIN32_ERROR.DNS_ERROR_NO_CREATE_CACHE_DATA;
pub const DNS_ERROR_NAME_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_NAME_DOES_NOT_EXIST;
pub const DNS_ERROR_DS_UNAVAILABLE = WIN32_ERROR.DNS_ERROR_DS_UNAVAILABLE;
pub const DNS_ERROR_DS_ZONE_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_DS_ZONE_ALREADY_EXISTS;
pub const DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE = WIN32_ERROR.DNS_ERROR_NO_BOOTFILE_IF_DS_ZONE;
pub const DNS_ERROR_NODE_IS_DNAME = WIN32_ERROR.DNS_ERROR_NODE_IS_DNAME;
pub const DNS_ERROR_DNAME_COLLISION = WIN32_ERROR.DNS_ERROR_DNAME_COLLISION;
pub const DNS_ERROR_ALIAS_LOOP = WIN32_ERROR.DNS_ERROR_ALIAS_LOOP;
pub const DNS_ERROR_OPERATION_BASE = WIN32_ERROR.DNS_ERROR_OPERATION_BASE;
pub const DNS_ERROR_AXFR = WIN32_ERROR.DNS_ERROR_AXFR;
pub const DNS_ERROR_SECURE_BASE = WIN32_ERROR.DNS_ERROR_SECURE_BASE;
pub const DNS_ERROR_SETUP_BASE = WIN32_ERROR.DNS_ERROR_SETUP_BASE;
pub const DNS_ERROR_NO_TCPIP = WIN32_ERROR.DNS_ERROR_NO_TCPIP;
pub const DNS_ERROR_NO_DNS_SERVERS = WIN32_ERROR.DNS_ERROR_NO_DNS_SERVERS;
pub const DNS_ERROR_DP_BASE = WIN32_ERROR.DNS_ERROR_DP_BASE;
pub const DNS_ERROR_DP_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_DP_DOES_NOT_EXIST;
pub const DNS_ERROR_DP_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_DP_ALREADY_EXISTS;
pub const DNS_ERROR_DP_NOT_ENLISTED = WIN32_ERROR.DNS_ERROR_DP_NOT_ENLISTED;
pub const DNS_ERROR_DP_ALREADY_ENLISTED = WIN32_ERROR.DNS_ERROR_DP_ALREADY_ENLISTED;
pub const DNS_ERROR_DP_NOT_AVAILABLE = WIN32_ERROR.DNS_ERROR_DP_NOT_AVAILABLE;
pub const DNS_ERROR_DP_FSMO_ERROR = WIN32_ERROR.DNS_ERROR_DP_FSMO_ERROR;
pub const DNS_ERROR_RRL_NOT_ENABLED = WIN32_ERROR.DNS_ERROR_RRL_NOT_ENABLED;
pub const DNS_ERROR_RRL_INVALID_WINDOW_SIZE = WIN32_ERROR.DNS_ERROR_RRL_INVALID_WINDOW_SIZE;
pub const DNS_ERROR_RRL_INVALID_IPV4_PREFIX = WIN32_ERROR.DNS_ERROR_RRL_INVALID_IPV4_PREFIX;
pub const DNS_ERROR_RRL_INVALID_IPV6_PREFIX = WIN32_ERROR.DNS_ERROR_RRL_INVALID_IPV6_PREFIX;
pub const DNS_ERROR_RRL_INVALID_TC_RATE = WIN32_ERROR.DNS_ERROR_RRL_INVALID_TC_RATE;
pub const DNS_ERROR_RRL_INVALID_LEAK_RATE = WIN32_ERROR.DNS_ERROR_RRL_INVALID_LEAK_RATE;
pub const DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE = WIN32_ERROR.DNS_ERROR_RRL_LEAK_RATE_LESSTHAN_TC_RATE;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_VIRTUALIZATION_INSTANCE_ALREADY_EXISTS;
pub const DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_VIRTUALIZATION_INSTANCE_DOES_NOT_EXIST;
pub const DNS_ERROR_VIRTUALIZATION_TREE_LOCKED = WIN32_ERROR.DNS_ERROR_VIRTUALIZATION_TREE_LOCKED;
pub const DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME = WIN32_ERROR.DNS_ERROR_INVAILD_VIRTUALIZATION_INSTANCE_NAME;
pub const DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE = WIN32_ERROR.DNS_ERROR_DEFAULT_VIRTUALIZATION_INSTANCE;
pub const DNS_ERROR_ZONESCOPE_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_ZONESCOPE_ALREADY_EXISTS;
pub const DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_ZONESCOPE_DOES_NOT_EXIST;
pub const DNS_ERROR_DEFAULT_ZONESCOPE = WIN32_ERROR.DNS_ERROR_DEFAULT_ZONESCOPE;
pub const DNS_ERROR_INVALID_ZONESCOPE_NAME = WIN32_ERROR.DNS_ERROR_INVALID_ZONESCOPE_NAME;
pub const DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES = WIN32_ERROR.DNS_ERROR_NOT_ALLOWED_WITH_ZONESCOPES;
pub const DNS_ERROR_LOAD_ZONESCOPE_FAILED = WIN32_ERROR.DNS_ERROR_LOAD_ZONESCOPE_FAILED;
pub const DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED = WIN32_ERROR.DNS_ERROR_ZONESCOPE_FILE_WRITEBACK_FAILED;
pub const DNS_ERROR_INVALID_SCOPE_NAME = WIN32_ERROR.DNS_ERROR_INVALID_SCOPE_NAME;
pub const DNS_ERROR_SCOPE_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_SCOPE_DOES_NOT_EXIST;
pub const DNS_ERROR_DEFAULT_SCOPE = WIN32_ERROR.DNS_ERROR_DEFAULT_SCOPE;
pub const DNS_ERROR_INVALID_SCOPE_OPERATION = WIN32_ERROR.DNS_ERROR_INVALID_SCOPE_OPERATION;
pub const DNS_ERROR_SCOPE_LOCKED = WIN32_ERROR.DNS_ERROR_SCOPE_LOCKED;
pub const DNS_ERROR_SCOPE_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_SCOPE_ALREADY_EXISTS;
pub const DNS_ERROR_POLICY_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_POLICY_ALREADY_EXISTS;
pub const DNS_ERROR_POLICY_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_POLICY_DOES_NOT_EXIST;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_CRITERIA;
pub const DNS_ERROR_POLICY_INVALID_SETTINGS = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_SETTINGS;
pub const DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED = WIN32_ERROR.DNS_ERROR_CLIENT_SUBNET_IS_ACCESSED;
pub const DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_CLIENT_SUBNET_DOES_NOT_EXIST;
pub const DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_CLIENT_SUBNET_ALREADY_EXISTS;
pub const DNS_ERROR_SUBNET_DOES_NOT_EXIST = WIN32_ERROR.DNS_ERROR_SUBNET_DOES_NOT_EXIST;
pub const DNS_ERROR_SUBNET_ALREADY_EXISTS = WIN32_ERROR.DNS_ERROR_SUBNET_ALREADY_EXISTS;
pub const DNS_ERROR_POLICY_LOCKED = WIN32_ERROR.DNS_ERROR_POLICY_LOCKED;
pub const DNS_ERROR_POLICY_INVALID_WEIGHT = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_WEIGHT;
pub const DNS_ERROR_POLICY_INVALID_NAME = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_NAME;
pub const DNS_ERROR_POLICY_MISSING_CRITERIA = WIN32_ERROR.DNS_ERROR_POLICY_MISSING_CRITERIA;
pub const DNS_ERROR_INVALID_CLIENT_SUBNET_NAME = WIN32_ERROR.DNS_ERROR_INVALID_CLIENT_SUBNET_NAME;
pub const DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID = WIN32_ERROR.DNS_ERROR_POLICY_PROCESSING_ORDER_INVALID;
pub const DNS_ERROR_POLICY_SCOPE_MISSING = WIN32_ERROR.DNS_ERROR_POLICY_SCOPE_MISSING;
pub const DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED = WIN32_ERROR.DNS_ERROR_POLICY_SCOPE_NOT_ALLOWED;
pub const DNS_ERROR_SERVERSCOPE_IS_REFERENCED = WIN32_ERROR.DNS_ERROR_SERVERSCOPE_IS_REFERENCED;
pub const DNS_ERROR_ZONESCOPE_IS_REFERENCED = WIN32_ERROR.DNS_ERROR_ZONESCOPE_IS_REFERENCED;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_CRITERIA_CLIENT_SUBNET;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_CRITERIA_TRANSPORT_PROTOCOL;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_CRITERIA_NETWORK_PROTOCOL;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_CRITERIA_INTERFACE;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_CRITERIA_FQDN;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_CRITERIA_QUERY_TYPE;
pub const DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY = WIN32_ERROR.DNS_ERROR_POLICY_INVALID_CRITERIA_TIME_OF_DAY;
pub const ERROR_IPSEC_QM_POLICY_EXISTS = WIN32_ERROR.ERROR_IPSEC_QM_POLICY_EXISTS;
pub const ERROR_IPSEC_QM_POLICY_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_QM_POLICY_NOT_FOUND;
pub const ERROR_IPSEC_QM_POLICY_IN_USE = WIN32_ERROR.ERROR_IPSEC_QM_POLICY_IN_USE;
pub const ERROR_IPSEC_MM_POLICY_EXISTS = WIN32_ERROR.ERROR_IPSEC_MM_POLICY_EXISTS;
pub const ERROR_IPSEC_MM_POLICY_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_MM_POLICY_NOT_FOUND;
pub const ERROR_IPSEC_MM_POLICY_IN_USE = WIN32_ERROR.ERROR_IPSEC_MM_POLICY_IN_USE;
pub const ERROR_IPSEC_MM_FILTER_EXISTS = WIN32_ERROR.ERROR_IPSEC_MM_FILTER_EXISTS;
pub const ERROR_IPSEC_MM_FILTER_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_MM_FILTER_NOT_FOUND;
pub const ERROR_IPSEC_TRANSPORT_FILTER_EXISTS = WIN32_ERROR.ERROR_IPSEC_TRANSPORT_FILTER_EXISTS;
pub const ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_TRANSPORT_FILTER_NOT_FOUND;
pub const ERROR_IPSEC_MM_AUTH_EXISTS = WIN32_ERROR.ERROR_IPSEC_MM_AUTH_EXISTS;
pub const ERROR_IPSEC_MM_AUTH_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_MM_AUTH_NOT_FOUND;
pub const ERROR_IPSEC_MM_AUTH_IN_USE = WIN32_ERROR.ERROR_IPSEC_MM_AUTH_IN_USE;
pub const ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_DEFAULT_MM_POLICY_NOT_FOUND;
pub const ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_DEFAULT_MM_AUTH_NOT_FOUND;
pub const ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_DEFAULT_QM_POLICY_NOT_FOUND;
pub const ERROR_IPSEC_TUNNEL_FILTER_EXISTS = WIN32_ERROR.ERROR_IPSEC_TUNNEL_FILTER_EXISTS;
pub const ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND = WIN32_ERROR.ERROR_IPSEC_TUNNEL_FILTER_NOT_FOUND;
pub const ERROR_IPSEC_MM_FILTER_PENDING_DELETION = WIN32_ERROR.ERROR_IPSEC_MM_FILTER_PENDING_DELETION;
pub const ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION = WIN32_ERROR.ERROR_IPSEC_TRANSPORT_FILTER_PENDING_DELETION;
pub const ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION = WIN32_ERROR.ERROR_IPSEC_TUNNEL_FILTER_PENDING_DELETION;
pub const ERROR_IPSEC_MM_POLICY_PENDING_DELETION = WIN32_ERROR.ERROR_IPSEC_MM_POLICY_PENDING_DELETION;
pub const ERROR_IPSEC_MM_AUTH_PENDING_DELETION = WIN32_ERROR.ERROR_IPSEC_MM_AUTH_PENDING_DELETION;
pub const ERROR_IPSEC_QM_POLICY_PENDING_DELETION = WIN32_ERROR.ERROR_IPSEC_QM_POLICY_PENDING_DELETION;
pub const ERROR_IPSEC_IKE_NEG_STATUS_BEGIN = WIN32_ERROR.ERROR_IPSEC_IKE_NEG_STATUS_BEGIN;
pub const ERROR_IPSEC_IKE_AUTH_FAIL = WIN32_ERROR.ERROR_IPSEC_IKE_AUTH_FAIL;
pub const ERROR_IPSEC_IKE_ATTRIB_FAIL = WIN32_ERROR.ERROR_IPSEC_IKE_ATTRIB_FAIL;
pub const ERROR_IPSEC_IKE_NEGOTIATION_PENDING = WIN32_ERROR.ERROR_IPSEC_IKE_NEGOTIATION_PENDING;
pub const ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR = WIN32_ERROR.ERROR_IPSEC_IKE_GENERAL_PROCESSING_ERROR;
pub const ERROR_IPSEC_IKE_TIMED_OUT = WIN32_ERROR.ERROR_IPSEC_IKE_TIMED_OUT;
pub const ERROR_IPSEC_IKE_NO_CERT = WIN32_ERROR.ERROR_IPSEC_IKE_NO_CERT;
pub const ERROR_IPSEC_IKE_SA_DELETED = WIN32_ERROR.ERROR_IPSEC_IKE_SA_DELETED;
pub const ERROR_IPSEC_IKE_SA_REAPED = WIN32_ERROR.ERROR_IPSEC_IKE_SA_REAPED;
pub const ERROR_IPSEC_IKE_MM_ACQUIRE_DROP = WIN32_ERROR.ERROR_IPSEC_IKE_MM_ACQUIRE_DROP;
pub const ERROR_IPSEC_IKE_QM_ACQUIRE_DROP = WIN32_ERROR.ERROR_IPSEC_IKE_QM_ACQUIRE_DROP;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_MM = WIN32_ERROR.ERROR_IPSEC_IKE_QUEUE_DROP_MM;
pub const ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM = WIN32_ERROR.ERROR_IPSEC_IKE_QUEUE_DROP_NO_MM;
pub const ERROR_IPSEC_IKE_DROP_NO_RESPONSE = WIN32_ERROR.ERROR_IPSEC_IKE_DROP_NO_RESPONSE;
pub const ERROR_IPSEC_IKE_MM_DELAY_DROP = WIN32_ERROR.ERROR_IPSEC_IKE_MM_DELAY_DROP;
pub const ERROR_IPSEC_IKE_QM_DELAY_DROP = WIN32_ERROR.ERROR_IPSEC_IKE_QM_DELAY_DROP;
pub const ERROR_IPSEC_IKE_ERROR = WIN32_ERROR.ERROR_IPSEC_IKE_ERROR;
pub const ERROR_IPSEC_IKE_CRL_FAILED = WIN32_ERROR.ERROR_IPSEC_IKE_CRL_FAILED;
pub const ERROR_IPSEC_IKE_INVALID_KEY_USAGE = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_KEY_USAGE;
pub const ERROR_IPSEC_IKE_INVALID_CERT_TYPE = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_CERT_TYPE;
pub const ERROR_IPSEC_IKE_NO_PRIVATE_KEY = WIN32_ERROR.ERROR_IPSEC_IKE_NO_PRIVATE_KEY;
pub const ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY = WIN32_ERROR.ERROR_IPSEC_IKE_SIMULTANEOUS_REKEY;
pub const ERROR_IPSEC_IKE_DH_FAIL = WIN32_ERROR.ERROR_IPSEC_IKE_DH_FAIL;
pub const ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED = WIN32_ERROR.ERROR_IPSEC_IKE_CRITICAL_PAYLOAD_NOT_RECOGNIZED;
pub const ERROR_IPSEC_IKE_INVALID_HEADER = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_HEADER;
pub const ERROR_IPSEC_IKE_NO_POLICY = WIN32_ERROR.ERROR_IPSEC_IKE_NO_POLICY;
pub const ERROR_IPSEC_IKE_INVALID_SIGNATURE = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_SIGNATURE;
pub const ERROR_IPSEC_IKE_KERBEROS_ERROR = WIN32_ERROR.ERROR_IPSEC_IKE_KERBEROS_ERROR;
pub const ERROR_IPSEC_IKE_NO_PUBLIC_KEY = WIN32_ERROR.ERROR_IPSEC_IKE_NO_PUBLIC_KEY;
pub const ERROR_IPSEC_IKE_PROCESS_ERR = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SA = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_SA;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_PROP = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_PROP;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_TRANS = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_TRANS;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_KE = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_KE;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_ID = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_ID;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_CERT;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_CERT_REQ;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_HASH = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_HASH;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_SIG = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_SIG;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NONCE = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_NONCE;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_NOTIFY;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_DELETE = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_DELETE;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_VENDOR;
pub const ERROR_IPSEC_IKE_INVALID_PAYLOAD = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_PAYLOAD;
pub const ERROR_IPSEC_IKE_LOAD_SOFT_SA = WIN32_ERROR.ERROR_IPSEC_IKE_LOAD_SOFT_SA;
pub const ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN = WIN32_ERROR.ERROR_IPSEC_IKE_SOFT_SA_TORN_DOWN;
pub const ERROR_IPSEC_IKE_INVALID_COOKIE = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_COOKIE;
pub const ERROR_IPSEC_IKE_NO_PEER_CERT = WIN32_ERROR.ERROR_IPSEC_IKE_NO_PEER_CERT;
pub const ERROR_IPSEC_IKE_PEER_CRL_FAILED = WIN32_ERROR.ERROR_IPSEC_IKE_PEER_CRL_FAILED;
pub const ERROR_IPSEC_IKE_POLICY_CHANGE = WIN32_ERROR.ERROR_IPSEC_IKE_POLICY_CHANGE;
pub const ERROR_IPSEC_IKE_NO_MM_POLICY = WIN32_ERROR.ERROR_IPSEC_IKE_NO_MM_POLICY;
pub const ERROR_IPSEC_IKE_NOTCBPRIV = WIN32_ERROR.ERROR_IPSEC_IKE_NOTCBPRIV;
pub const ERROR_IPSEC_IKE_SECLOADFAIL = WIN32_ERROR.ERROR_IPSEC_IKE_SECLOADFAIL;
pub const ERROR_IPSEC_IKE_FAILSSPINIT = WIN32_ERROR.ERROR_IPSEC_IKE_FAILSSPINIT;
pub const ERROR_IPSEC_IKE_FAILQUERYSSP = WIN32_ERROR.ERROR_IPSEC_IKE_FAILQUERYSSP;
pub const ERROR_IPSEC_IKE_SRVACQFAIL = WIN32_ERROR.ERROR_IPSEC_IKE_SRVACQFAIL;
pub const ERROR_IPSEC_IKE_SRVQUERYCRED = WIN32_ERROR.ERROR_IPSEC_IKE_SRVQUERYCRED;
pub const ERROR_IPSEC_IKE_GETSPIFAIL = WIN32_ERROR.ERROR_IPSEC_IKE_GETSPIFAIL;
pub const ERROR_IPSEC_IKE_INVALID_FILTER = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_FILTER;
pub const ERROR_IPSEC_IKE_OUT_OF_MEMORY = WIN32_ERROR.ERROR_IPSEC_IKE_OUT_OF_MEMORY;
pub const ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED = WIN32_ERROR.ERROR_IPSEC_IKE_ADD_UPDATE_KEY_FAILED;
pub const ERROR_IPSEC_IKE_INVALID_POLICY = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_POLICY;
pub const ERROR_IPSEC_IKE_UNKNOWN_DOI = WIN32_ERROR.ERROR_IPSEC_IKE_UNKNOWN_DOI;
pub const ERROR_IPSEC_IKE_INVALID_SITUATION = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_SITUATION;
pub const ERROR_IPSEC_IKE_DH_FAILURE = WIN32_ERROR.ERROR_IPSEC_IKE_DH_FAILURE;
pub const ERROR_IPSEC_IKE_INVALID_GROUP = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_GROUP;
pub const ERROR_IPSEC_IKE_ENCRYPT = WIN32_ERROR.ERROR_IPSEC_IKE_ENCRYPT;
pub const ERROR_IPSEC_IKE_DECRYPT = WIN32_ERROR.ERROR_IPSEC_IKE_DECRYPT;
pub const ERROR_IPSEC_IKE_POLICY_MATCH = WIN32_ERROR.ERROR_IPSEC_IKE_POLICY_MATCH;
pub const ERROR_IPSEC_IKE_UNSUPPORTED_ID = WIN32_ERROR.ERROR_IPSEC_IKE_UNSUPPORTED_ID;
pub const ERROR_IPSEC_IKE_INVALID_HASH = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_HASH;
pub const ERROR_IPSEC_IKE_INVALID_HASH_ALG = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_HASH_ALG;
pub const ERROR_IPSEC_IKE_INVALID_HASH_SIZE = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_HASH_SIZE;
pub const ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_ENCRYPT_ALG;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_ALG = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_AUTH_ALG;
pub const ERROR_IPSEC_IKE_INVALID_SIG = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_SIG;
pub const ERROR_IPSEC_IKE_LOAD_FAILED = WIN32_ERROR.ERROR_IPSEC_IKE_LOAD_FAILED;
pub const ERROR_IPSEC_IKE_RPC_DELETE = WIN32_ERROR.ERROR_IPSEC_IKE_RPC_DELETE;
pub const ERROR_IPSEC_IKE_BENIGN_REINIT = WIN32_ERROR.ERROR_IPSEC_IKE_BENIGN_REINIT;
pub const ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_RESPONDER_LIFETIME_NOTIFY;
pub const ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_MAJOR_VERSION;
pub const ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_CERT_KEYLEN;
pub const ERROR_IPSEC_IKE_MM_LIMIT = WIN32_ERROR.ERROR_IPSEC_IKE_MM_LIMIT;
pub const ERROR_IPSEC_IKE_NEGOTIATION_DISABLED = WIN32_ERROR.ERROR_IPSEC_IKE_NEGOTIATION_DISABLED;
pub const ERROR_IPSEC_IKE_QM_LIMIT = WIN32_ERROR.ERROR_IPSEC_IKE_QM_LIMIT;
pub const ERROR_IPSEC_IKE_MM_EXPIRED = WIN32_ERROR.ERROR_IPSEC_IKE_MM_EXPIRED;
pub const ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID = WIN32_ERROR.ERROR_IPSEC_IKE_PEER_MM_ASSUMED_INVALID;
pub const ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH = WIN32_ERROR.ERROR_IPSEC_IKE_CERT_CHAIN_POLICY_MISMATCH;
pub const ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID = WIN32_ERROR.ERROR_IPSEC_IKE_UNEXPECTED_MESSAGE_ID;
pub const ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_AUTH_PAYLOAD;
pub const ERROR_IPSEC_IKE_DOS_COOKIE_SENT = WIN32_ERROR.ERROR_IPSEC_IKE_DOS_COOKIE_SENT;
pub const ERROR_IPSEC_IKE_SHUTTING_DOWN = WIN32_ERROR.ERROR_IPSEC_IKE_SHUTTING_DOWN;
pub const ERROR_IPSEC_IKE_CGA_AUTH_FAILED = WIN32_ERROR.ERROR_IPSEC_IKE_CGA_AUTH_FAILED;
pub const ERROR_IPSEC_IKE_PROCESS_ERR_NATOA = WIN32_ERROR.ERROR_IPSEC_IKE_PROCESS_ERR_NATOA;
pub const ERROR_IPSEC_IKE_INVALID_MM_FOR_QM = WIN32_ERROR.ERROR_IPSEC_IKE_INVALID_MM_FOR_QM;
pub const ERROR_IPSEC_IKE_QM_EXPIRED = WIN32_ERROR.ERROR_IPSEC_IKE_QM_EXPIRED;
pub const ERROR_IPSEC_IKE_TOO_MANY_FILTERS = WIN32_ERROR.ERROR_IPSEC_IKE_TOO_MANY_FILTERS;
pub const ERROR_IPSEC_IKE_NEG_STATUS_END = WIN32_ERROR.ERROR_IPSEC_IKE_NEG_STATUS_END;
pub const ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL = WIN32_ERROR.ERROR_IPSEC_IKE_KILL_DUMMY_NAP_TUNNEL;
pub const ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE = WIN32_ERROR.ERROR_IPSEC_IKE_INNER_IP_ASSIGNMENT_FAILURE;
pub const ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING = WIN32_ERROR.ERROR_IPSEC_IKE_REQUIRE_CP_PAYLOAD_MISSING;
pub const ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING = WIN32_ERROR.ERROR_IPSEC_KEY_MODULE_IMPERSONATION_NEGOTIATION_PENDING;
pub const ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS = WIN32_ERROR.ERROR_IPSEC_IKE_COEXISTENCE_SUPPRESS;
pub const ERROR_IPSEC_IKE_RATELIMIT_DROP = WIN32_ERROR.ERROR_IPSEC_IKE_RATELIMIT_DROP;
pub const ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE = WIN32_ERROR.ERROR_IPSEC_IKE_PEER_DOESNT_SUPPORT_MOBIKE;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE = WIN32_ERROR.ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE = WIN32_ERROR.ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_FAILURE;
pub const ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY = WIN32_ERROR.ERROR_IPSEC_IKE_AUTHORIZATION_FAILURE_WITH_OPTIONAL_RETRY;
pub const ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE = WIN32_ERROR.ERROR_IPSEC_IKE_STRONG_CRED_AUTHORIZATION_AND_CERTMAP_FAILURE;
pub const ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END = WIN32_ERROR.ERROR_IPSEC_IKE_NEG_STATUS_EXTENDED_END;
pub const ERROR_IPSEC_BAD_SPI = WIN32_ERROR.ERROR_IPSEC_BAD_SPI;
pub const ERROR_IPSEC_SA_LIFETIME_EXPIRED = WIN32_ERROR.ERROR_IPSEC_SA_LIFETIME_EXPIRED;
pub const ERROR_IPSEC_WRONG_SA = WIN32_ERROR.ERROR_IPSEC_WRONG_SA;
pub const ERROR_IPSEC_REPLAY_CHECK_FAILED = WIN32_ERROR.ERROR_IPSEC_REPLAY_CHECK_FAILED;
pub const ERROR_IPSEC_INVALID_PACKET = WIN32_ERROR.ERROR_IPSEC_INVALID_PACKET;
pub const ERROR_IPSEC_INTEGRITY_CHECK_FAILED = WIN32_ERROR.ERROR_IPSEC_INTEGRITY_CHECK_FAILED;
pub const ERROR_IPSEC_CLEAR_TEXT_DROP = WIN32_ERROR.ERROR_IPSEC_CLEAR_TEXT_DROP;
pub const ERROR_IPSEC_AUTH_FIREWALL_DROP = WIN32_ERROR.ERROR_IPSEC_AUTH_FIREWALL_DROP;
pub const ERROR_IPSEC_THROTTLE_DROP = WIN32_ERROR.ERROR_IPSEC_THROTTLE_DROP;
pub const ERROR_IPSEC_DOSP_BLOCK = WIN32_ERROR.ERROR_IPSEC_DOSP_BLOCK;
pub const ERROR_IPSEC_DOSP_RECEIVED_MULTICAST = WIN32_ERROR.ERROR_IPSEC_DOSP_RECEIVED_MULTICAST;
pub const ERROR_IPSEC_DOSP_INVALID_PACKET = WIN32_ERROR.ERROR_IPSEC_DOSP_INVALID_PACKET;
pub const ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED = WIN32_ERROR.ERROR_IPSEC_DOSP_STATE_LOOKUP_FAILED;
pub const ERROR_IPSEC_DOSP_MAX_ENTRIES = WIN32_ERROR.ERROR_IPSEC_DOSP_MAX_ENTRIES;
pub const ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED = WIN32_ERROR.ERROR_IPSEC_DOSP_KEYMOD_NOT_ALLOWED;
pub const ERROR_IPSEC_DOSP_NOT_INSTALLED = WIN32_ERROR.ERROR_IPSEC_DOSP_NOT_INSTALLED;
pub const ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES = WIN32_ERROR.ERROR_IPSEC_DOSP_MAX_PER_IP_RATELIMIT_QUEUES;
pub const ERROR_SXS_SECTION_NOT_FOUND = WIN32_ERROR.ERROR_SXS_SECTION_NOT_FOUND;
pub const ERROR_SXS_CANT_GEN_ACTCTX = WIN32_ERROR.ERROR_SXS_CANT_GEN_ACTCTX;
pub const ERROR_SXS_INVALID_ACTCTXDATA_FORMAT = WIN32_ERROR.ERROR_SXS_INVALID_ACTCTXDATA_FORMAT;
pub const ERROR_SXS_ASSEMBLY_NOT_FOUND = WIN32_ERROR.ERROR_SXS_ASSEMBLY_NOT_FOUND;
pub const ERROR_SXS_MANIFEST_FORMAT_ERROR = WIN32_ERROR.ERROR_SXS_MANIFEST_FORMAT_ERROR;
pub const ERROR_SXS_MANIFEST_PARSE_ERROR = WIN32_ERROR.ERROR_SXS_MANIFEST_PARSE_ERROR;
pub const ERROR_SXS_ACTIVATION_CONTEXT_DISABLED = WIN32_ERROR.ERROR_SXS_ACTIVATION_CONTEXT_DISABLED;
pub const ERROR_SXS_KEY_NOT_FOUND = WIN32_ERROR.ERROR_SXS_KEY_NOT_FOUND;
pub const ERROR_SXS_VERSION_CONFLICT = WIN32_ERROR.ERROR_SXS_VERSION_CONFLICT;
pub const ERROR_SXS_WRONG_SECTION_TYPE = WIN32_ERROR.ERROR_SXS_WRONG_SECTION_TYPE;
pub const ERROR_SXS_THREAD_QUERIES_DISABLED = WIN32_ERROR.ERROR_SXS_THREAD_QUERIES_DISABLED;
pub const ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET = WIN32_ERROR.ERROR_SXS_PROCESS_DEFAULT_ALREADY_SET;
pub const ERROR_SXS_UNKNOWN_ENCODING_GROUP = WIN32_ERROR.ERROR_SXS_UNKNOWN_ENCODING_GROUP;
pub const ERROR_SXS_UNKNOWN_ENCODING = WIN32_ERROR.ERROR_SXS_UNKNOWN_ENCODING;
pub const ERROR_SXS_INVALID_XML_NAMESPACE_URI = WIN32_ERROR.ERROR_SXS_INVALID_XML_NAMESPACE_URI;
pub const ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED = WIN32_ERROR.ERROR_SXS_ROOT_MANIFEST_DEPENDENCY_NOT_INSTALLED;
pub const ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED = WIN32_ERROR.ERROR_SXS_LEAF_MANIFEST_DEPENDENCY_NOT_INSTALLED;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE = WIN32_ERROR.ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE;
pub const ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE = WIN32_ERROR.ERROR_SXS_MANIFEST_MISSING_REQUIRED_DEFAULT_NAMESPACE;
pub const ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE = WIN32_ERROR.ERROR_SXS_MANIFEST_INVALID_REQUIRED_DEFAULT_NAMESPACE;
pub const ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT = WIN32_ERROR.ERROR_SXS_PRIVATE_MANIFEST_CROSS_PATH_WITH_REPARSE_POINT;
pub const ERROR_SXS_DUPLICATE_DLL_NAME = WIN32_ERROR.ERROR_SXS_DUPLICATE_DLL_NAME;
pub const ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME = WIN32_ERROR.ERROR_SXS_DUPLICATE_WINDOWCLASS_NAME;
pub const ERROR_SXS_DUPLICATE_CLSID = WIN32_ERROR.ERROR_SXS_DUPLICATE_CLSID;
pub const ERROR_SXS_DUPLICATE_IID = WIN32_ERROR.ERROR_SXS_DUPLICATE_IID;
pub const ERROR_SXS_DUPLICATE_TLBID = WIN32_ERROR.ERROR_SXS_DUPLICATE_TLBID;
pub const ERROR_SXS_DUPLICATE_PROGID = WIN32_ERROR.ERROR_SXS_DUPLICATE_PROGID;
pub const ERROR_SXS_DUPLICATE_ASSEMBLY_NAME = WIN32_ERROR.ERROR_SXS_DUPLICATE_ASSEMBLY_NAME;
pub const ERROR_SXS_FILE_HASH_MISMATCH = WIN32_ERROR.ERROR_SXS_FILE_HASH_MISMATCH;
pub const ERROR_SXS_POLICY_PARSE_ERROR = WIN32_ERROR.ERROR_SXS_POLICY_PARSE_ERROR;
pub const ERROR_SXS_XML_E_MISSINGQUOTE = WIN32_ERROR.ERROR_SXS_XML_E_MISSINGQUOTE;
pub const ERROR_SXS_XML_E_COMMENTSYNTAX = WIN32_ERROR.ERROR_SXS_XML_E_COMMENTSYNTAX;
pub const ERROR_SXS_XML_E_BADSTARTNAMECHAR = WIN32_ERROR.ERROR_SXS_XML_E_BADSTARTNAMECHAR;
pub const ERROR_SXS_XML_E_BADNAMECHAR = WIN32_ERROR.ERROR_SXS_XML_E_BADNAMECHAR;
pub const ERROR_SXS_XML_E_BADCHARINSTRING = WIN32_ERROR.ERROR_SXS_XML_E_BADCHARINSTRING;
pub const ERROR_SXS_XML_E_XMLDECLSYNTAX = WIN32_ERROR.ERROR_SXS_XML_E_XMLDECLSYNTAX;
pub const ERROR_SXS_XML_E_BADCHARDATA = WIN32_ERROR.ERROR_SXS_XML_E_BADCHARDATA;
pub const ERROR_SXS_XML_E_MISSINGWHITESPACE = WIN32_ERROR.ERROR_SXS_XML_E_MISSINGWHITESPACE;
pub const ERROR_SXS_XML_E_EXPECTINGTAGEND = WIN32_ERROR.ERROR_SXS_XML_E_EXPECTINGTAGEND;
pub const ERROR_SXS_XML_E_MISSINGSEMICOLON = WIN32_ERROR.ERROR_SXS_XML_E_MISSINGSEMICOLON;
pub const ERROR_SXS_XML_E_UNBALANCEDPAREN = WIN32_ERROR.ERROR_SXS_XML_E_UNBALANCEDPAREN;
pub const ERROR_SXS_XML_E_INTERNALERROR = WIN32_ERROR.ERROR_SXS_XML_E_INTERNALERROR;
pub const ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE = WIN32_ERROR.ERROR_SXS_XML_E_UNEXPECTED_WHITESPACE;
pub const ERROR_SXS_XML_E_INCOMPLETE_ENCODING = WIN32_ERROR.ERROR_SXS_XML_E_INCOMPLETE_ENCODING;
pub const ERROR_SXS_XML_E_MISSING_PAREN = WIN32_ERROR.ERROR_SXS_XML_E_MISSING_PAREN;
pub const ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE = WIN32_ERROR.ERROR_SXS_XML_E_EXPECTINGCLOSEQUOTE;
pub const ERROR_SXS_XML_E_MULTIPLE_COLONS = WIN32_ERROR.ERROR_SXS_XML_E_MULTIPLE_COLONS;
pub const ERROR_SXS_XML_E_INVALID_DECIMAL = WIN32_ERROR.ERROR_SXS_XML_E_INVALID_DECIMAL;
pub const ERROR_SXS_XML_E_INVALID_HEXIDECIMAL = WIN32_ERROR.ERROR_SXS_XML_E_INVALID_HEXIDECIMAL;
pub const ERROR_SXS_XML_E_INVALID_UNICODE = WIN32_ERROR.ERROR_SXS_XML_E_INVALID_UNICODE;
pub const ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK = WIN32_ERROR.ERROR_SXS_XML_E_WHITESPACEORQUESTIONMARK;
pub const ERROR_SXS_XML_E_UNEXPECTEDENDTAG = WIN32_ERROR.ERROR_SXS_XML_E_UNEXPECTEDENDTAG;
pub const ERROR_SXS_XML_E_UNCLOSEDTAG = WIN32_ERROR.ERROR_SXS_XML_E_UNCLOSEDTAG;
pub const ERROR_SXS_XML_E_DUPLICATEATTRIBUTE = WIN32_ERROR.ERROR_SXS_XML_E_DUPLICATEATTRIBUTE;
pub const ERROR_SXS_XML_E_MULTIPLEROOTS = WIN32_ERROR.ERROR_SXS_XML_E_MULTIPLEROOTS;
pub const ERROR_SXS_XML_E_INVALIDATROOTLEVEL = WIN32_ERROR.ERROR_SXS_XML_E_INVALIDATROOTLEVEL;
pub const ERROR_SXS_XML_E_BADXMLDECL = WIN32_ERROR.ERROR_SXS_XML_E_BADXMLDECL;
pub const ERROR_SXS_XML_E_MISSINGROOT = WIN32_ERROR.ERROR_SXS_XML_E_MISSINGROOT;
pub const ERROR_SXS_XML_E_UNEXPECTEDEOF = WIN32_ERROR.ERROR_SXS_XML_E_UNEXPECTEDEOF;
pub const ERROR_SXS_XML_E_BADPEREFINSUBSET = WIN32_ERROR.ERROR_SXS_XML_E_BADPEREFINSUBSET;
pub const ERROR_SXS_XML_E_UNCLOSEDSTARTTAG = WIN32_ERROR.ERROR_SXS_XML_E_UNCLOSEDSTARTTAG;
pub const ERROR_SXS_XML_E_UNCLOSEDENDTAG = WIN32_ERROR.ERROR_SXS_XML_E_UNCLOSEDENDTAG;
pub const ERROR_SXS_XML_E_UNCLOSEDSTRING = WIN32_ERROR.ERROR_SXS_XML_E_UNCLOSEDSTRING;
pub const ERROR_SXS_XML_E_UNCLOSEDCOMMENT = WIN32_ERROR.ERROR_SXS_XML_E_UNCLOSEDCOMMENT;
pub const ERROR_SXS_XML_E_UNCLOSEDDECL = WIN32_ERROR.ERROR_SXS_XML_E_UNCLOSEDDECL;
pub const ERROR_SXS_XML_E_UNCLOSEDCDATA = WIN32_ERROR.ERROR_SXS_XML_E_UNCLOSEDCDATA;
pub const ERROR_SXS_XML_E_RESERVEDNAMESPACE = WIN32_ERROR.ERROR_SXS_XML_E_RESERVEDNAMESPACE;
pub const ERROR_SXS_XML_E_INVALIDENCODING = WIN32_ERROR.ERROR_SXS_XML_E_INVALIDENCODING;
pub const ERROR_SXS_XML_E_INVALIDSWITCH = WIN32_ERROR.ERROR_SXS_XML_E_INVALIDSWITCH;
pub const ERROR_SXS_XML_E_BADXMLCASE = WIN32_ERROR.ERROR_SXS_XML_E_BADXMLCASE;
pub const ERROR_SXS_XML_E_INVALID_STANDALONE = WIN32_ERROR.ERROR_SXS_XML_E_INVALID_STANDALONE;
pub const ERROR_SXS_XML_E_UNEXPECTED_STANDALONE = WIN32_ERROR.ERROR_SXS_XML_E_UNEXPECTED_STANDALONE;
pub const ERROR_SXS_XML_E_INVALID_VERSION = WIN32_ERROR.ERROR_SXS_XML_E_INVALID_VERSION;
pub const ERROR_SXS_XML_E_MISSINGEQUALS = WIN32_ERROR.ERROR_SXS_XML_E_MISSINGEQUALS;
pub const ERROR_SXS_PROTECTION_RECOVERY_FAILED = WIN32_ERROR.ERROR_SXS_PROTECTION_RECOVERY_FAILED;
pub const ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT = WIN32_ERROR.ERROR_SXS_PROTECTION_PUBLIC_KEY_TOO_SHORT;
pub const ERROR_SXS_PROTECTION_CATALOG_NOT_VALID = WIN32_ERROR.ERROR_SXS_PROTECTION_CATALOG_NOT_VALID;
pub const ERROR_SXS_UNTRANSLATABLE_HRESULT = WIN32_ERROR.ERROR_SXS_UNTRANSLATABLE_HRESULT;
pub const ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING = WIN32_ERROR.ERROR_SXS_PROTECTION_CATALOG_FILE_MISSING;
pub const ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE = WIN32_ERROR.ERROR_SXS_MISSING_ASSEMBLY_IDENTITY_ATTRIBUTE;
pub const ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME = WIN32_ERROR.ERROR_SXS_INVALID_ASSEMBLY_IDENTITY_ATTRIBUTE_NAME;
pub const ERROR_SXS_ASSEMBLY_MISSING = WIN32_ERROR.ERROR_SXS_ASSEMBLY_MISSING;
pub const ERROR_SXS_CORRUPT_ACTIVATION_STACK = WIN32_ERROR.ERROR_SXS_CORRUPT_ACTIVATION_STACK;
pub const ERROR_SXS_CORRUPTION = WIN32_ERROR.ERROR_SXS_CORRUPTION;
pub const ERROR_SXS_EARLY_DEACTIVATION = WIN32_ERROR.ERROR_SXS_EARLY_DEACTIVATION;
pub const ERROR_SXS_INVALID_DEACTIVATION = WIN32_ERROR.ERROR_SXS_INVALID_DEACTIVATION;
pub const ERROR_SXS_MULTIPLE_DEACTIVATION = WIN32_ERROR.ERROR_SXS_MULTIPLE_DEACTIVATION;
pub const ERROR_SXS_PROCESS_TERMINATION_REQUESTED = WIN32_ERROR.ERROR_SXS_PROCESS_TERMINATION_REQUESTED;
pub const ERROR_SXS_RELEASE_ACTIVATION_CONTEXT = WIN32_ERROR.ERROR_SXS_RELEASE_ACTIVATION_CONTEXT;
pub const ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY = WIN32_ERROR.ERROR_SXS_SYSTEM_DEFAULT_ACTIVATION_CONTEXT_EMPTY;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE = WIN32_ERROR.ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_VALUE;
pub const ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME = WIN32_ERROR.ERROR_SXS_INVALID_IDENTITY_ATTRIBUTE_NAME;
pub const ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE = WIN32_ERROR.ERROR_SXS_IDENTITY_DUPLICATE_ATTRIBUTE;
pub const ERROR_SXS_IDENTITY_PARSE_ERROR = WIN32_ERROR.ERROR_SXS_IDENTITY_PARSE_ERROR;
pub const ERROR_MALFORMED_SUBSTITUTION_STRING = WIN32_ERROR.ERROR_MALFORMED_SUBSTITUTION_STRING;
pub const ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN = WIN32_ERROR.ERROR_SXS_INCORRECT_PUBLIC_KEY_TOKEN;
pub const ERROR_UNMAPPED_SUBSTITUTION_STRING = WIN32_ERROR.ERROR_UNMAPPED_SUBSTITUTION_STRING;
pub const ERROR_SXS_ASSEMBLY_NOT_LOCKED = WIN32_ERROR.ERROR_SXS_ASSEMBLY_NOT_LOCKED;
pub const ERROR_SXS_COMPONENT_STORE_CORRUPT = WIN32_ERROR.ERROR_SXS_COMPONENT_STORE_CORRUPT;
pub const ERROR_ADVANCED_INSTALLER_FAILED = WIN32_ERROR.ERROR_ADVANCED_INSTALLER_FAILED;
pub const ERROR_XML_ENCODING_MISMATCH = WIN32_ERROR.ERROR_XML_ENCODING_MISMATCH;
pub const ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT = WIN32_ERROR.ERROR_SXS_MANIFEST_IDENTITY_SAME_BUT_CONTENTS_DIFFERENT;
pub const ERROR_SXS_IDENTITIES_DIFFERENT = WIN32_ERROR.ERROR_SXS_IDENTITIES_DIFFERENT;
pub const ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT = WIN32_ERROR.ERROR_SXS_ASSEMBLY_IS_NOT_A_DEPLOYMENT;
pub const ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY = WIN32_ERROR.ERROR_SXS_FILE_NOT_PART_OF_ASSEMBLY;
pub const ERROR_SXS_MANIFEST_TOO_BIG = WIN32_ERROR.ERROR_SXS_MANIFEST_TOO_BIG;
pub const ERROR_SXS_SETTING_NOT_REGISTERED = WIN32_ERROR.ERROR_SXS_SETTING_NOT_REGISTERED;
pub const ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE = WIN32_ERROR.ERROR_SXS_TRANSACTION_CLOSURE_INCOMPLETE;
pub const ERROR_SMI_PRIMITIVE_INSTALLER_FAILED = WIN32_ERROR.ERROR_SMI_PRIMITIVE_INSTALLER_FAILED;
pub const ERROR_GENERIC_COMMAND_FAILED = WIN32_ERROR.ERROR_GENERIC_COMMAND_FAILED;
pub const ERROR_SXS_FILE_HASH_MISSING = WIN32_ERROR.ERROR_SXS_FILE_HASH_MISSING;
pub const ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS = WIN32_ERROR.ERROR_SXS_DUPLICATE_ACTIVATABLE_CLASS;
pub const ERROR_EVT_INVALID_CHANNEL_PATH = WIN32_ERROR.ERROR_EVT_INVALID_CHANNEL_PATH;
pub const ERROR_EVT_INVALID_QUERY = WIN32_ERROR.ERROR_EVT_INVALID_QUERY;
pub const ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND = WIN32_ERROR.ERROR_EVT_PUBLISHER_METADATA_NOT_FOUND;
pub const ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND = WIN32_ERROR.ERROR_EVT_EVENT_TEMPLATE_NOT_FOUND;
pub const ERROR_EVT_INVALID_PUBLISHER_NAME = WIN32_ERROR.ERROR_EVT_INVALID_PUBLISHER_NAME;
pub const ERROR_EVT_INVALID_EVENT_DATA = WIN32_ERROR.ERROR_EVT_INVALID_EVENT_DATA;
pub const ERROR_EVT_CHANNEL_NOT_FOUND = WIN32_ERROR.ERROR_EVT_CHANNEL_NOT_FOUND;
pub const ERROR_EVT_MALFORMED_XML_TEXT = WIN32_ERROR.ERROR_EVT_MALFORMED_XML_TEXT;
pub const ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL = WIN32_ERROR.ERROR_EVT_SUBSCRIPTION_TO_DIRECT_CHANNEL;
pub const ERROR_EVT_CONFIGURATION_ERROR = WIN32_ERROR.ERROR_EVT_CONFIGURATION_ERROR;
pub const ERROR_EVT_QUERY_RESULT_STALE = WIN32_ERROR.ERROR_EVT_QUERY_RESULT_STALE;
pub const ERROR_EVT_QUERY_RESULT_INVALID_POSITION = WIN32_ERROR.ERROR_EVT_QUERY_RESULT_INVALID_POSITION;
pub const ERROR_EVT_NON_VALIDATING_MSXML = WIN32_ERROR.ERROR_EVT_NON_VALIDATING_MSXML;
pub const ERROR_EVT_FILTER_ALREADYSCOPED = WIN32_ERROR.ERROR_EVT_FILTER_ALREADYSCOPED;
pub const ERROR_EVT_FILTER_NOTELTSET = WIN32_ERROR.ERROR_EVT_FILTER_NOTELTSET;
pub const ERROR_EVT_FILTER_INVARG = WIN32_ERROR.ERROR_EVT_FILTER_INVARG;
pub const ERROR_EVT_FILTER_INVTEST = WIN32_ERROR.ERROR_EVT_FILTER_INVTEST;
pub const ERROR_EVT_FILTER_INVTYPE = WIN32_ERROR.ERROR_EVT_FILTER_INVTYPE;
pub const ERROR_EVT_FILTER_PARSEERR = WIN32_ERROR.ERROR_EVT_FILTER_PARSEERR;
pub const ERROR_EVT_FILTER_UNSUPPORTEDOP = WIN32_ERROR.ERROR_EVT_FILTER_UNSUPPORTEDOP;
pub const ERROR_EVT_FILTER_UNEXPECTEDTOKEN = WIN32_ERROR.ERROR_EVT_FILTER_UNEXPECTEDTOKEN;
pub const ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL = WIN32_ERROR.ERROR_EVT_INVALID_OPERATION_OVER_ENABLED_DIRECT_CHANNEL;
pub const ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE = WIN32_ERROR.ERROR_EVT_INVALID_CHANNEL_PROPERTY_VALUE;
pub const ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE = WIN32_ERROR.ERROR_EVT_INVALID_PUBLISHER_PROPERTY_VALUE;
pub const ERROR_EVT_CHANNEL_CANNOT_ACTIVATE = WIN32_ERROR.ERROR_EVT_CHANNEL_CANNOT_ACTIVATE;
pub const ERROR_EVT_FILTER_TOO_COMPLEX = WIN32_ERROR.ERROR_EVT_FILTER_TOO_COMPLEX;
pub const ERROR_EVT_MESSAGE_NOT_FOUND = WIN32_ERROR.ERROR_EVT_MESSAGE_NOT_FOUND;
pub const ERROR_EVT_MESSAGE_ID_NOT_FOUND = WIN32_ERROR.ERROR_EVT_MESSAGE_ID_NOT_FOUND;
pub const ERROR_EVT_UNRESOLVED_VALUE_INSERT = WIN32_ERROR.ERROR_EVT_UNRESOLVED_VALUE_INSERT;
pub const ERROR_EVT_UNRESOLVED_PARAMETER_INSERT = WIN32_ERROR.ERROR_EVT_UNRESOLVED_PARAMETER_INSERT;
pub const ERROR_EVT_MAX_INSERTS_REACHED = WIN32_ERROR.ERROR_EVT_MAX_INSERTS_REACHED;
pub const ERROR_EVT_EVENT_DEFINITION_NOT_FOUND = WIN32_ERROR.ERROR_EVT_EVENT_DEFINITION_NOT_FOUND;
pub const ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND = WIN32_ERROR.ERROR_EVT_MESSAGE_LOCALE_NOT_FOUND;
pub const ERROR_EVT_VERSION_TOO_OLD = WIN32_ERROR.ERROR_EVT_VERSION_TOO_OLD;
pub const ERROR_EVT_VERSION_TOO_NEW = WIN32_ERROR.ERROR_EVT_VERSION_TOO_NEW;
pub const ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY = WIN32_ERROR.ERROR_EVT_CANNOT_OPEN_CHANNEL_OF_QUERY;
pub const ERROR_EVT_PUBLISHER_DISABLED = WIN32_ERROR.ERROR_EVT_PUBLISHER_DISABLED;
pub const ERROR_EVT_FILTER_OUT_OF_RANGE = WIN32_ERROR.ERROR_EVT_FILTER_OUT_OF_RANGE;
pub const ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE = WIN32_ERROR.ERROR_EC_SUBSCRIPTION_CANNOT_ACTIVATE;
pub const ERROR_EC_LOG_DISABLED = WIN32_ERROR.ERROR_EC_LOG_DISABLED;
pub const ERROR_EC_CIRCULAR_FORWARDING = WIN32_ERROR.ERROR_EC_CIRCULAR_FORWARDING;
pub const ERROR_EC_CREDSTORE_FULL = WIN32_ERROR.ERROR_EC_CREDSTORE_FULL;
pub const ERROR_EC_CRED_NOT_FOUND = WIN32_ERROR.ERROR_EC_CRED_NOT_FOUND;
pub const ERROR_EC_NO_ACTIVE_CHANNEL = WIN32_ERROR.ERROR_EC_NO_ACTIVE_CHANNEL;
pub const ERROR_MUI_FILE_NOT_FOUND = WIN32_ERROR.ERROR_MUI_FILE_NOT_FOUND;
pub const ERROR_MUI_INVALID_FILE = WIN32_ERROR.ERROR_MUI_INVALID_FILE;
pub const ERROR_MUI_INVALID_RC_CONFIG = WIN32_ERROR.ERROR_MUI_INVALID_RC_CONFIG;
pub const ERROR_MUI_INVALID_LOCALE_NAME = WIN32_ERROR.ERROR_MUI_INVALID_LOCALE_NAME;
pub const ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME = WIN32_ERROR.ERROR_MUI_INVALID_ULTIMATEFALLBACK_NAME;
pub const ERROR_MUI_FILE_NOT_LOADED = WIN32_ERROR.ERROR_MUI_FILE_NOT_LOADED;
pub const ERROR_RESOURCE_ENUM_USER_STOP = WIN32_ERROR.ERROR_RESOURCE_ENUM_USER_STOP;
pub const ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED = WIN32_ERROR.ERROR_MUI_INTLSETTINGS_UILANG_NOT_INSTALLED;
pub const ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME = WIN32_ERROR.ERROR_MUI_INTLSETTINGS_INVALID_LOCALE_NAME;
pub const ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE = WIN32_ERROR.ERROR_MRM_RUNTIME_NO_DEFAULT_OR_NEUTRAL_RESOURCE;
pub const ERROR_MRM_INVALID_PRICONFIG = WIN32_ERROR.ERROR_MRM_INVALID_PRICONFIG;
pub const ERROR_MRM_INVALID_FILE_TYPE = WIN32_ERROR.ERROR_MRM_INVALID_FILE_TYPE;
pub const ERROR_MRM_UNKNOWN_QUALIFIER = WIN32_ERROR.ERROR_MRM_UNKNOWN_QUALIFIER;
pub const ERROR_MRM_INVALID_QUALIFIER_VALUE = WIN32_ERROR.ERROR_MRM_INVALID_QUALIFIER_VALUE;
pub const ERROR_MRM_NO_CANDIDATE = WIN32_ERROR.ERROR_MRM_NO_CANDIDATE;
pub const ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE = WIN32_ERROR.ERROR_MRM_NO_MATCH_OR_DEFAULT_CANDIDATE;
pub const ERROR_MRM_RESOURCE_TYPE_MISMATCH = WIN32_ERROR.ERROR_MRM_RESOURCE_TYPE_MISMATCH;
pub const ERROR_MRM_DUPLICATE_MAP_NAME = WIN32_ERROR.ERROR_MRM_DUPLICATE_MAP_NAME;
pub const ERROR_MRM_DUPLICATE_ENTRY = WIN32_ERROR.ERROR_MRM_DUPLICATE_ENTRY;
pub const ERROR_MRM_INVALID_RESOURCE_IDENTIFIER = WIN32_ERROR.ERROR_MRM_INVALID_RESOURCE_IDENTIFIER;
pub const ERROR_MRM_FILEPATH_TOO_LONG = WIN32_ERROR.ERROR_MRM_FILEPATH_TOO_LONG;
pub const ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE = WIN32_ERROR.ERROR_MRM_UNSUPPORTED_DIRECTORY_TYPE;
pub const ERROR_MRM_INVALID_PRI_FILE = WIN32_ERROR.ERROR_MRM_INVALID_PRI_FILE;
pub const ERROR_MRM_NAMED_RESOURCE_NOT_FOUND = WIN32_ERROR.ERROR_MRM_NAMED_RESOURCE_NOT_FOUND;
pub const ERROR_MRM_MAP_NOT_FOUND = WIN32_ERROR.ERROR_MRM_MAP_NOT_FOUND;
pub const ERROR_MRM_UNSUPPORTED_PROFILE_TYPE = WIN32_ERROR.ERROR_MRM_UNSUPPORTED_PROFILE_TYPE;
pub const ERROR_MRM_INVALID_QUALIFIER_OPERATOR = WIN32_ERROR.ERROR_MRM_INVALID_QUALIFIER_OPERATOR;
pub const ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE = WIN32_ERROR.ERROR_MRM_INDETERMINATE_QUALIFIER_VALUE;
pub const ERROR_MRM_AUTOMERGE_ENABLED = WIN32_ERROR.ERROR_MRM_AUTOMERGE_ENABLED;
pub const ERROR_MRM_TOO_MANY_RESOURCES = WIN32_ERROR.ERROR_MRM_TOO_MANY_RESOURCES;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE = WIN32_ERROR.ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_MERGE;
pub const ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE = WIN32_ERROR.ERROR_MRM_UNSUPPORTED_FILE_TYPE_FOR_LOAD_UNLOAD_PRI_FILE;
pub const ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD = WIN32_ERROR.ERROR_MRM_NO_CURRENT_VIEW_ON_THREAD;
pub const ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST = WIN32_ERROR.ERROR_DIFFERENT_PROFILE_RESOURCE_MANAGER_EXIST;
pub const ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT = WIN32_ERROR.ERROR_OPERATION_NOT_ALLOWED_FROM_SYSTEM_COMPONENT;
pub const ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE = WIN32_ERROR.ERROR_MRM_DIRECT_REF_TO_NON_DEFAULT_RESOURCE;
pub const ERROR_MRM_GENERATION_COUNT_MISMATCH = WIN32_ERROR.ERROR_MRM_GENERATION_COUNT_MISMATCH;
pub const ERROR_PRI_MERGE_VERSION_MISMATCH = WIN32_ERROR.ERROR_PRI_MERGE_VERSION_MISMATCH;
pub const ERROR_PRI_MERGE_MISSING_SCHEMA = WIN32_ERROR.ERROR_PRI_MERGE_MISSING_SCHEMA;
pub const ERROR_PRI_MERGE_LOAD_FILE_FAILED = WIN32_ERROR.ERROR_PRI_MERGE_LOAD_FILE_FAILED;
pub const ERROR_PRI_MERGE_ADD_FILE_FAILED = WIN32_ERROR.ERROR_PRI_MERGE_ADD_FILE_FAILED;
pub const ERROR_PRI_MERGE_WRITE_FILE_FAILED = WIN32_ERROR.ERROR_PRI_MERGE_WRITE_FILE_FAILED;
pub const ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED = WIN32_ERROR.ERROR_PRI_MERGE_MULTIPLE_PACKAGE_FAMILIES_NOT_ALLOWED;
pub const ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED = WIN32_ERROR.ERROR_PRI_MERGE_MULTIPLE_MAIN_PACKAGES_NOT_ALLOWED;
pub const ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED = WIN32_ERROR.ERROR_PRI_MERGE_BUNDLE_PACKAGES_NOT_ALLOWED;
pub const ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED = WIN32_ERROR.ERROR_PRI_MERGE_MAIN_PACKAGE_REQUIRED;
pub const ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED = WIN32_ERROR.ERROR_PRI_MERGE_RESOURCE_PACKAGE_REQUIRED;
pub const ERROR_PRI_MERGE_INVALID_FILE_NAME = WIN32_ERROR.ERROR_PRI_MERGE_INVALID_FILE_NAME;
pub const ERROR_MRM_PACKAGE_NOT_FOUND = WIN32_ERROR.ERROR_MRM_PACKAGE_NOT_FOUND;
pub const ERROR_MRM_MISSING_DEFAULT_LANGUAGE = WIN32_ERROR.ERROR_MRM_MISSING_DEFAULT_LANGUAGE;
pub const ERROR_MCA_INVALID_CAPABILITIES_STRING = WIN32_ERROR.ERROR_MCA_INVALID_CAPABILITIES_STRING;
pub const ERROR_MCA_INVALID_VCP_VERSION = WIN32_ERROR.ERROR_MCA_INVALID_VCP_VERSION;
pub const ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION = WIN32_ERROR.ERROR_MCA_MONITOR_VIOLATES_MCCS_SPECIFICATION;
pub const ERROR_MCA_MCCS_VERSION_MISMATCH = WIN32_ERROR.ERROR_MCA_MCCS_VERSION_MISMATCH;
pub const ERROR_MCA_UNSUPPORTED_MCCS_VERSION = WIN32_ERROR.ERROR_MCA_UNSUPPORTED_MCCS_VERSION;
pub const ERROR_MCA_INTERNAL_ERROR = WIN32_ERROR.ERROR_MCA_INTERNAL_ERROR;
pub const ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED = WIN32_ERROR.ERROR_MCA_INVALID_TECHNOLOGY_TYPE_RETURNED;
pub const ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE = WIN32_ERROR.ERROR_MCA_UNSUPPORTED_COLOR_TEMPERATURE;
pub const ERROR_AMBIGUOUS_SYSTEM_DEVICE = WIN32_ERROR.ERROR_AMBIGUOUS_SYSTEM_DEVICE;
pub const ERROR_SYSTEM_DEVICE_NOT_FOUND = WIN32_ERROR.ERROR_SYSTEM_DEVICE_NOT_FOUND;
pub const ERROR_HASH_NOT_SUPPORTED = WIN32_ERROR.ERROR_HASH_NOT_SUPPORTED;
pub const ERROR_HASH_NOT_PRESENT = WIN32_ERROR.ERROR_HASH_NOT_PRESENT;
pub const ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED = WIN32_ERROR.ERROR_SECONDARY_IC_PROVIDER_NOT_REGISTERED;
pub const ERROR_GPIO_CLIENT_INFORMATION_INVALID = WIN32_ERROR.ERROR_GPIO_CLIENT_INFORMATION_INVALID;
pub const ERROR_GPIO_VERSION_NOT_SUPPORTED = WIN32_ERROR.ERROR_GPIO_VERSION_NOT_SUPPORTED;
pub const ERROR_GPIO_INVALID_REGISTRATION_PACKET = WIN32_ERROR.ERROR_GPIO_INVALID_REGISTRATION_PACKET;
pub const ERROR_GPIO_OPERATION_DENIED = WIN32_ERROR.ERROR_GPIO_OPERATION_DENIED;
pub const ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE = WIN32_ERROR.ERROR_GPIO_INCOMPATIBLE_CONNECT_MODE;
pub const ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED = WIN32_ERROR.ERROR_GPIO_INTERRUPT_ALREADY_UNMASKED;
pub const ERROR_CANNOT_SWITCH_RUNLEVEL = WIN32_ERROR.ERROR_CANNOT_SWITCH_RUNLEVEL;
pub const ERROR_INVALID_RUNLEVEL_SETTING = WIN32_ERROR.ERROR_INVALID_RUNLEVEL_SETTING;
pub const ERROR_RUNLEVEL_SWITCH_TIMEOUT = WIN32_ERROR.ERROR_RUNLEVEL_SWITCH_TIMEOUT;
pub const ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT = WIN32_ERROR.ERROR_RUNLEVEL_SWITCH_AGENT_TIMEOUT;
pub const ERROR_RUNLEVEL_SWITCH_IN_PROGRESS = WIN32_ERROR.ERROR_RUNLEVEL_SWITCH_IN_PROGRESS;
pub const ERROR_SERVICES_FAILED_AUTOSTART = WIN32_ERROR.ERROR_SERVICES_FAILED_AUTOSTART;
pub const ERROR_COM_TASK_STOP_PENDING = WIN32_ERROR.ERROR_COM_TASK_STOP_PENDING;
pub const ERROR_INSTALL_OPEN_PACKAGE_FAILED = WIN32_ERROR.ERROR_INSTALL_OPEN_PACKAGE_FAILED;
pub const ERROR_INSTALL_PACKAGE_NOT_FOUND = WIN32_ERROR.ERROR_INSTALL_PACKAGE_NOT_FOUND;
pub const ERROR_INSTALL_INVALID_PACKAGE = WIN32_ERROR.ERROR_INSTALL_INVALID_PACKAGE;
pub const ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED = WIN32_ERROR.ERROR_INSTALL_RESOLVE_DEPENDENCY_FAILED;
pub const ERROR_INSTALL_OUT_OF_DISK_SPACE = WIN32_ERROR.ERROR_INSTALL_OUT_OF_DISK_SPACE;
pub const ERROR_INSTALL_NETWORK_FAILURE = WIN32_ERROR.ERROR_INSTALL_NETWORK_FAILURE;
pub const ERROR_INSTALL_REGISTRATION_FAILURE = WIN32_ERROR.ERROR_INSTALL_REGISTRATION_FAILURE;
pub const ERROR_INSTALL_DEREGISTRATION_FAILURE = WIN32_ERROR.ERROR_INSTALL_DEREGISTRATION_FAILURE;
pub const ERROR_INSTALL_CANCEL = WIN32_ERROR.ERROR_INSTALL_CANCEL;
pub const ERROR_INSTALL_FAILED = WIN32_ERROR.ERROR_INSTALL_FAILED;
pub const ERROR_REMOVE_FAILED = WIN32_ERROR.ERROR_REMOVE_FAILED;
pub const ERROR_PACKAGE_ALREADY_EXISTS = WIN32_ERROR.ERROR_PACKAGE_ALREADY_EXISTS;
pub const ERROR_NEEDS_REMEDIATION = WIN32_ERROR.ERROR_NEEDS_REMEDIATION;
pub const ERROR_INSTALL_PREREQUISITE_FAILED = WIN32_ERROR.ERROR_INSTALL_PREREQUISITE_FAILED;
pub const ERROR_PACKAGE_REPOSITORY_CORRUPTED = WIN32_ERROR.ERROR_PACKAGE_REPOSITORY_CORRUPTED;
pub const ERROR_INSTALL_POLICY_FAILURE = WIN32_ERROR.ERROR_INSTALL_POLICY_FAILURE;
pub const ERROR_PACKAGE_UPDATING = WIN32_ERROR.ERROR_PACKAGE_UPDATING;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_POLICY = WIN32_ERROR.ERROR_DEPLOYMENT_BLOCKED_BY_POLICY;
pub const ERROR_PACKAGES_IN_USE = WIN32_ERROR.ERROR_PACKAGES_IN_USE;
pub const ERROR_RECOVERY_FILE_CORRUPT = WIN32_ERROR.ERROR_RECOVERY_FILE_CORRUPT;
pub const ERROR_INVALID_STAGED_SIGNATURE = WIN32_ERROR.ERROR_INVALID_STAGED_SIGNATURE;
pub const ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED = WIN32_ERROR.ERROR_DELETING_EXISTING_APPLICATIONDATA_STORE_FAILED;
pub const ERROR_INSTALL_PACKAGE_DOWNGRADE = WIN32_ERROR.ERROR_INSTALL_PACKAGE_DOWNGRADE;
pub const ERROR_SYSTEM_NEEDS_REMEDIATION = WIN32_ERROR.ERROR_SYSTEM_NEEDS_REMEDIATION;
pub const ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN = WIN32_ERROR.ERROR_APPX_INTEGRITY_FAILURE_CLR_NGEN;
pub const ERROR_RESILIENCY_FILE_CORRUPT = WIN32_ERROR.ERROR_RESILIENCY_FILE_CORRUPT;
pub const ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING = WIN32_ERROR.ERROR_INSTALL_FIREWALL_SERVICE_NOT_RUNNING;
pub const ERROR_PACKAGE_MOVE_FAILED = WIN32_ERROR.ERROR_PACKAGE_MOVE_FAILED;
pub const ERROR_INSTALL_VOLUME_NOT_EMPTY = WIN32_ERROR.ERROR_INSTALL_VOLUME_NOT_EMPTY;
pub const ERROR_INSTALL_VOLUME_OFFLINE = WIN32_ERROR.ERROR_INSTALL_VOLUME_OFFLINE;
pub const ERROR_INSTALL_VOLUME_CORRUPT = WIN32_ERROR.ERROR_INSTALL_VOLUME_CORRUPT;
pub const ERROR_NEEDS_REGISTRATION = WIN32_ERROR.ERROR_NEEDS_REGISTRATION;
pub const ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE = WIN32_ERROR.ERROR_INSTALL_WRONG_PROCESSOR_ARCHITECTURE;
pub const ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_DEV_SIDELOAD_LIMIT_EXCEEDED;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE = WIN32_ERROR.ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE;
pub const ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM = WIN32_ERROR.ERROR_PACKAGE_NOT_SUPPORTED_ON_FILESYSTEM;
pub const ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING = WIN32_ERROR.ERROR_PACKAGE_MOVE_BLOCKED_BY_STREAMING;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE = WIN32_ERROR.ERROR_INSTALL_OPTIONAL_PACKAGE_APPLICATIONID_NOT_UNIQUE;
pub const ERROR_PACKAGE_STAGING_ONHOLD = WIN32_ERROR.ERROR_PACKAGE_STAGING_ONHOLD;
pub const ERROR_INSTALL_INVALID_RELATED_SET_UPDATE = WIN32_ERROR.ERROR_INSTALL_INVALID_RELATED_SET_UPDATE;
pub const ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY = WIN32_ERROR.ERROR_INSTALL_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF = WIN32_ERROR.ERROR_DEPLOYMENT_BLOCKED_BY_USER_LOG_OFF;
pub const ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED = WIN32_ERROR.ERROR_PROVISION_OPTIONAL_PACKAGE_REQUIRES_MAIN_PACKAGE_PROVISIONED;
pub const ERROR_PACKAGES_REPUTATION_CHECK_FAILED = WIN32_ERROR.ERROR_PACKAGES_REPUTATION_CHECK_FAILED;
pub const ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT = WIN32_ERROR.ERROR_PACKAGES_REPUTATION_CHECK_TIMEDOUT;
pub const ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED = WIN32_ERROR.ERROR_DEPLOYMENT_OPTION_NOT_SUPPORTED;
pub const ERROR_APPINSTALLER_ACTIVATION_BLOCKED = WIN32_ERROR.ERROR_APPINSTALLER_ACTIVATION_BLOCKED;
pub const ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED = WIN32_ERROR.ERROR_REGISTRATION_FROM_REMOTE_DRIVE_NOT_SUPPORTED;
pub const ERROR_APPX_RAW_DATA_WRITE_FAILED = WIN32_ERROR.ERROR_APPX_RAW_DATA_WRITE_FAILED;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE = WIN32_ERROR.ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_PACKAGE;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE = WIN32_ERROR.ERROR_DEPLOYMENT_BLOCKED_BY_VOLUME_POLICY_MACHINE;
pub const ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY = WIN32_ERROR.ERROR_DEPLOYMENT_BLOCKED_BY_PROFILE_POLICY;
pub const ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY = WIN32_ERROR.ERROR_DEPLOYMENT_FAILED_CONFLICTING_MUTABLE_PACKAGE_DIRECTORY;
pub const ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER = WIN32_ERROR.ERROR_SINGLETON_RESOURCE_INSTALLED_IN_ACTIVE_USER;
pub const ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED = WIN32_ERROR.ERROR_DIFFERENT_VERSION_OF_PACKAGED_SERVICE_INSTALLED;
pub const ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE = WIN32_ERROR.ERROR_SERVICE_EXISTS_AS_NON_PACKAGED_SERVICE;
pub const ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES = WIN32_ERROR.ERROR_PACKAGED_SERVICE_REQUIRES_ADMIN_PRIVILEGES;
pub const ERROR_REDIRECTION_TO_DEFAULT_ACCOUNT_NOT_ALLOWED = WIN32_ERROR.ERROR_REDIRECTION_TO_DEFAULT_ACCOUNT_NOT_ALLOWED;
pub const ERROR_PACKAGE_LACKS_CAPABILITY_TO_DEPLOY_ON_HOST = WIN32_ERROR.ERROR_PACKAGE_LACKS_CAPABILITY_TO_DEPLOY_ON_HOST;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_CONTENT = WIN32_ERROR.ERROR_UNSIGNED_PACKAGE_INVALID_CONTENT;
pub const ERROR_UNSIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE = WIN32_ERROR.ERROR_UNSIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE;
pub const ERROR_SIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE = WIN32_ERROR.ERROR_SIGNED_PACKAGE_INVALID_PUBLISHER_NAMESPACE;
pub const ERROR_PACKAGE_EXTERNAL_LOCATION_NOT_ALLOWED = WIN32_ERROR.ERROR_PACKAGE_EXTERNAL_LOCATION_NOT_ALLOWED;
pub const ERROR_INSTALL_FULLTRUST_HOSTRUNTIME_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY = WIN32_ERROR.ERROR_INSTALL_FULLTRUST_HOSTRUNTIME_REQUIRES_MAIN_PACKAGE_FULLTRUST_CAPABILITY;
pub const ERROR_STATE_LOAD_STORE_FAILED = WIN32_ERROR.ERROR_STATE_LOAD_STORE_FAILED;
pub const ERROR_STATE_GET_VERSION_FAILED = WIN32_ERROR.ERROR_STATE_GET_VERSION_FAILED;
pub const ERROR_STATE_SET_VERSION_FAILED = WIN32_ERROR.ERROR_STATE_SET_VERSION_FAILED;
pub const ERROR_STATE_STRUCTURED_RESET_FAILED = WIN32_ERROR.ERROR_STATE_STRUCTURED_RESET_FAILED;
pub const ERROR_STATE_OPEN_CONTAINER_FAILED = WIN32_ERROR.ERROR_STATE_OPEN_CONTAINER_FAILED;
pub const ERROR_STATE_CREATE_CONTAINER_FAILED = WIN32_ERROR.ERROR_STATE_CREATE_CONTAINER_FAILED;
pub const ERROR_STATE_DELETE_CONTAINER_FAILED = WIN32_ERROR.ERROR_STATE_DELETE_CONTAINER_FAILED;
pub const ERROR_STATE_READ_SETTING_FAILED = WIN32_ERROR.ERROR_STATE_READ_SETTING_FAILED;
pub const ERROR_STATE_WRITE_SETTING_FAILED = WIN32_ERROR.ERROR_STATE_WRITE_SETTING_FAILED;
pub const ERROR_STATE_DELETE_SETTING_FAILED = WIN32_ERROR.ERROR_STATE_DELETE_SETTING_FAILED;
pub const ERROR_STATE_QUERY_SETTING_FAILED = WIN32_ERROR.ERROR_STATE_QUERY_SETTING_FAILED;
pub const ERROR_STATE_READ_COMPOSITE_SETTING_FAILED = WIN32_ERROR.ERROR_STATE_READ_COMPOSITE_SETTING_FAILED;
pub const ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED = WIN32_ERROR.ERROR_STATE_WRITE_COMPOSITE_SETTING_FAILED;
pub const ERROR_STATE_ENUMERATE_CONTAINER_FAILED = WIN32_ERROR.ERROR_STATE_ENUMERATE_CONTAINER_FAILED;
pub const ERROR_STATE_ENUMERATE_SETTINGS_FAILED = WIN32_ERROR.ERROR_STATE_ENUMERATE_SETTINGS_FAILED;
pub const ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_STATE_COMPOSITE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED;
pub const ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_STATE_SETTING_VALUE_SIZE_LIMIT_EXCEEDED;
pub const ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_STATE_SETTING_NAME_SIZE_LIMIT_EXCEEDED;
pub const ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_STATE_CONTAINER_NAME_SIZE_LIMIT_EXCEEDED;
pub const ERROR_API_UNAVAILABLE = WIN32_ERROR.ERROR_API_UNAVAILABLE;
pub const ERROR_NDIS_INTERFACE_CLOSING = WIN32_ERROR.ERROR_NDIS_INTERFACE_CLOSING;
pub const ERROR_NDIS_BAD_VERSION = WIN32_ERROR.ERROR_NDIS_BAD_VERSION;
pub const ERROR_NDIS_BAD_CHARACTERISTICS = WIN32_ERROR.ERROR_NDIS_BAD_CHARACTERISTICS;
pub const ERROR_NDIS_ADAPTER_NOT_FOUND = WIN32_ERROR.ERROR_NDIS_ADAPTER_NOT_FOUND;
pub const ERROR_NDIS_OPEN_FAILED = WIN32_ERROR.ERROR_NDIS_OPEN_FAILED;
pub const ERROR_NDIS_DEVICE_FAILED = WIN32_ERROR.ERROR_NDIS_DEVICE_FAILED;
pub const ERROR_NDIS_MULTICAST_FULL = WIN32_ERROR.ERROR_NDIS_MULTICAST_FULL;
pub const ERROR_NDIS_MULTICAST_EXISTS = WIN32_ERROR.ERROR_NDIS_MULTICAST_EXISTS;
pub const ERROR_NDIS_MULTICAST_NOT_FOUND = WIN32_ERROR.ERROR_NDIS_MULTICAST_NOT_FOUND;
pub const ERROR_NDIS_REQUEST_ABORTED = WIN32_ERROR.ERROR_NDIS_REQUEST_ABORTED;
pub const ERROR_NDIS_RESET_IN_PROGRESS = WIN32_ERROR.ERROR_NDIS_RESET_IN_PROGRESS;
pub const ERROR_NDIS_NOT_SUPPORTED = WIN32_ERROR.ERROR_NDIS_NOT_SUPPORTED;
pub const ERROR_NDIS_INVALID_PACKET = WIN32_ERROR.ERROR_NDIS_INVALID_PACKET;
pub const ERROR_NDIS_ADAPTER_NOT_READY = WIN32_ERROR.ERROR_NDIS_ADAPTER_NOT_READY;
pub const ERROR_NDIS_INVALID_LENGTH = WIN32_ERROR.ERROR_NDIS_INVALID_LENGTH;
pub const ERROR_NDIS_INVALID_DATA = WIN32_ERROR.ERROR_NDIS_INVALID_DATA;
pub const ERROR_NDIS_BUFFER_TOO_SHORT = WIN32_ERROR.ERROR_NDIS_BUFFER_TOO_SHORT;
pub const ERROR_NDIS_INVALID_OID = WIN32_ERROR.ERROR_NDIS_INVALID_OID;
pub const ERROR_NDIS_ADAPTER_REMOVED = WIN32_ERROR.ERROR_NDIS_ADAPTER_REMOVED;
pub const ERROR_NDIS_UNSUPPORTED_MEDIA = WIN32_ERROR.ERROR_NDIS_UNSUPPORTED_MEDIA;
pub const ERROR_NDIS_GROUP_ADDRESS_IN_USE = WIN32_ERROR.ERROR_NDIS_GROUP_ADDRESS_IN_USE;
pub const ERROR_NDIS_FILE_NOT_FOUND = WIN32_ERROR.ERROR_NDIS_FILE_NOT_FOUND;
pub const ERROR_NDIS_ERROR_READING_FILE = WIN32_ERROR.ERROR_NDIS_ERROR_READING_FILE;
pub const ERROR_NDIS_ALREADY_MAPPED = WIN32_ERROR.ERROR_NDIS_ALREADY_MAPPED;
pub const ERROR_NDIS_RESOURCE_CONFLICT = WIN32_ERROR.ERROR_NDIS_RESOURCE_CONFLICT;
pub const ERROR_NDIS_MEDIA_DISCONNECTED = WIN32_ERROR.ERROR_NDIS_MEDIA_DISCONNECTED;
pub const ERROR_NDIS_INVALID_ADDRESS = WIN32_ERROR.ERROR_NDIS_INVALID_ADDRESS;
pub const ERROR_NDIS_INVALID_DEVICE_REQUEST = WIN32_ERROR.ERROR_NDIS_INVALID_DEVICE_REQUEST;
pub const ERROR_NDIS_PAUSED = WIN32_ERROR.ERROR_NDIS_PAUSED;
pub const ERROR_NDIS_INTERFACE_NOT_FOUND = WIN32_ERROR.ERROR_NDIS_INTERFACE_NOT_FOUND;
pub const ERROR_NDIS_UNSUPPORTED_REVISION = WIN32_ERROR.ERROR_NDIS_UNSUPPORTED_REVISION;
pub const ERROR_NDIS_INVALID_PORT = WIN32_ERROR.ERROR_NDIS_INVALID_PORT;
pub const ERROR_NDIS_INVALID_PORT_STATE = WIN32_ERROR.ERROR_NDIS_INVALID_PORT_STATE;
pub const ERROR_NDIS_LOW_POWER_STATE = WIN32_ERROR.ERROR_NDIS_LOW_POWER_STATE;
pub const ERROR_NDIS_REINIT_REQUIRED = WIN32_ERROR.ERROR_NDIS_REINIT_REQUIRED;
pub const ERROR_NDIS_NO_QUEUES = WIN32_ERROR.ERROR_NDIS_NO_QUEUES;
pub const ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED = WIN32_ERROR.ERROR_NDIS_DOT11_AUTO_CONFIG_ENABLED;
pub const ERROR_NDIS_DOT11_MEDIA_IN_USE = WIN32_ERROR.ERROR_NDIS_DOT11_MEDIA_IN_USE;
pub const ERROR_NDIS_DOT11_POWER_STATE_INVALID = WIN32_ERROR.ERROR_NDIS_DOT11_POWER_STATE_INVALID;
pub const ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL = WIN32_ERROR.ERROR_NDIS_PM_WOL_PATTERN_LIST_FULL;
pub const ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL = WIN32_ERROR.ERROR_NDIS_PM_PROTOCOL_OFFLOAD_LIST_FULL;
pub const ERROR_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE = WIN32_ERROR.ERROR_NDIS_DOT11_AP_CHANNEL_CURRENTLY_NOT_AVAILABLE;
pub const ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE = WIN32_ERROR.ERROR_NDIS_DOT11_AP_BAND_CURRENTLY_NOT_AVAILABLE;
pub const ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED = WIN32_ERROR.ERROR_NDIS_DOT11_AP_CHANNEL_NOT_ALLOWED;
pub const ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED = WIN32_ERROR.ERROR_NDIS_DOT11_AP_BAND_NOT_ALLOWED;
pub const ERROR_NDIS_INDICATION_REQUIRED = WIN32_ERROR.ERROR_NDIS_INDICATION_REQUIRED;
pub const ERROR_NDIS_OFFLOAD_POLICY = WIN32_ERROR.ERROR_NDIS_OFFLOAD_POLICY;
pub const ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED = WIN32_ERROR.ERROR_NDIS_OFFLOAD_CONNECTION_REJECTED;
pub const ERROR_NDIS_OFFLOAD_PATH_REJECTED = WIN32_ERROR.ERROR_NDIS_OFFLOAD_PATH_REJECTED;
pub const ERROR_HV_INVALID_HYPERCALL_CODE = WIN32_ERROR.ERROR_HV_INVALID_HYPERCALL_CODE;
pub const ERROR_HV_INVALID_HYPERCALL_INPUT = WIN32_ERROR.ERROR_HV_INVALID_HYPERCALL_INPUT;
pub const ERROR_HV_INVALID_ALIGNMENT = WIN32_ERROR.ERROR_HV_INVALID_ALIGNMENT;
pub const ERROR_HV_INVALID_PARAMETER = WIN32_ERROR.ERROR_HV_INVALID_PARAMETER;
pub const ERROR_HV_ACCESS_DENIED = WIN32_ERROR.ERROR_HV_ACCESS_DENIED;
pub const ERROR_HV_INVALID_PARTITION_STATE = WIN32_ERROR.ERROR_HV_INVALID_PARTITION_STATE;
pub const ERROR_HV_OPERATION_DENIED = WIN32_ERROR.ERROR_HV_OPERATION_DENIED;
pub const ERROR_HV_UNKNOWN_PROPERTY = WIN32_ERROR.ERROR_HV_UNKNOWN_PROPERTY;
pub const ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE = WIN32_ERROR.ERROR_HV_PROPERTY_VALUE_OUT_OF_RANGE;
pub const ERROR_HV_INSUFFICIENT_MEMORY = WIN32_ERROR.ERROR_HV_INSUFFICIENT_MEMORY;
pub const ERROR_HV_PARTITION_TOO_DEEP = WIN32_ERROR.ERROR_HV_PARTITION_TOO_DEEP;
pub const ERROR_HV_INVALID_PARTITION_ID = WIN32_ERROR.ERROR_HV_INVALID_PARTITION_ID;
pub const ERROR_HV_INVALID_VP_INDEX = WIN32_ERROR.ERROR_HV_INVALID_VP_INDEX;
pub const ERROR_HV_INVALID_PORT_ID = WIN32_ERROR.ERROR_HV_INVALID_PORT_ID;
pub const ERROR_HV_INVALID_CONNECTION_ID = WIN32_ERROR.ERROR_HV_INVALID_CONNECTION_ID;
pub const ERROR_HV_INSUFFICIENT_BUFFERS = WIN32_ERROR.ERROR_HV_INSUFFICIENT_BUFFERS;
pub const ERROR_HV_NOT_ACKNOWLEDGED = WIN32_ERROR.ERROR_HV_NOT_ACKNOWLEDGED;
pub const ERROR_HV_INVALID_VP_STATE = WIN32_ERROR.ERROR_HV_INVALID_VP_STATE;
pub const ERROR_HV_ACKNOWLEDGED = WIN32_ERROR.ERROR_HV_ACKNOWLEDGED;
pub const ERROR_HV_INVALID_SAVE_RESTORE_STATE = WIN32_ERROR.ERROR_HV_INVALID_SAVE_RESTORE_STATE;
pub const ERROR_HV_INVALID_SYNIC_STATE = WIN32_ERROR.ERROR_HV_INVALID_SYNIC_STATE;
pub const ERROR_HV_OBJECT_IN_USE = WIN32_ERROR.ERROR_HV_OBJECT_IN_USE;
pub const ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO = WIN32_ERROR.ERROR_HV_INVALID_PROXIMITY_DOMAIN_INFO;
pub const ERROR_HV_NO_DATA = WIN32_ERROR.ERROR_HV_NO_DATA;
pub const ERROR_HV_INACTIVE = WIN32_ERROR.ERROR_HV_INACTIVE;
pub const ERROR_HV_NO_RESOURCES = WIN32_ERROR.ERROR_HV_NO_RESOURCES;
pub const ERROR_HV_FEATURE_UNAVAILABLE = WIN32_ERROR.ERROR_HV_FEATURE_UNAVAILABLE;
pub const ERROR_HV_INSUFFICIENT_BUFFER = WIN32_ERROR.ERROR_HV_INSUFFICIENT_BUFFER;
pub const ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS = WIN32_ERROR.ERROR_HV_INSUFFICIENT_DEVICE_DOMAINS;
pub const ERROR_HV_CPUID_FEATURE_VALIDATION = WIN32_ERROR.ERROR_HV_CPUID_FEATURE_VALIDATION;
pub const ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION = WIN32_ERROR.ERROR_HV_CPUID_XSAVE_FEATURE_VALIDATION;
pub const ERROR_HV_PROCESSOR_STARTUP_TIMEOUT = WIN32_ERROR.ERROR_HV_PROCESSOR_STARTUP_TIMEOUT;
pub const ERROR_HV_SMX_ENABLED = WIN32_ERROR.ERROR_HV_SMX_ENABLED;
pub const ERROR_HV_INVALID_LP_INDEX = WIN32_ERROR.ERROR_HV_INVALID_LP_INDEX;
pub const ERROR_HV_INVALID_REGISTER_VALUE = WIN32_ERROR.ERROR_HV_INVALID_REGISTER_VALUE;
pub const ERROR_HV_INVALID_VTL_STATE = WIN32_ERROR.ERROR_HV_INVALID_VTL_STATE;
pub const ERROR_HV_NX_NOT_DETECTED = WIN32_ERROR.ERROR_HV_NX_NOT_DETECTED;
pub const ERROR_HV_INVALID_DEVICE_ID = WIN32_ERROR.ERROR_HV_INVALID_DEVICE_ID;
pub const ERROR_HV_INVALID_DEVICE_STATE = WIN32_ERROR.ERROR_HV_INVALID_DEVICE_STATE;
pub const ERROR_HV_PENDING_PAGE_REQUESTS = WIN32_ERROR.ERROR_HV_PENDING_PAGE_REQUESTS;
pub const ERROR_HV_PAGE_REQUEST_INVALID = WIN32_ERROR.ERROR_HV_PAGE_REQUEST_INVALID;
pub const ERROR_HV_INVALID_CPU_GROUP_ID = WIN32_ERROR.ERROR_HV_INVALID_CPU_GROUP_ID;
pub const ERROR_HV_INVALID_CPU_GROUP_STATE = WIN32_ERROR.ERROR_HV_INVALID_CPU_GROUP_STATE;
pub const ERROR_HV_OPERATION_FAILED = WIN32_ERROR.ERROR_HV_OPERATION_FAILED;
pub const ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE = WIN32_ERROR.ERROR_HV_NOT_ALLOWED_WITH_NESTED_VIRT_ACTIVE;
pub const ERROR_HV_INSUFFICIENT_ROOT_MEMORY = WIN32_ERROR.ERROR_HV_INSUFFICIENT_ROOT_MEMORY;
pub const ERROR_HV_EVENT_BUFFER_ALREADY_FREED = WIN32_ERROR.ERROR_HV_EVENT_BUFFER_ALREADY_FREED;
pub const ERROR_HV_INSUFFICIENT_CONTIGUOUS_MEMORY = WIN32_ERROR.ERROR_HV_INSUFFICIENT_CONTIGUOUS_MEMORY;
pub const ERROR_HV_NOT_PRESENT = WIN32_ERROR.ERROR_HV_NOT_PRESENT;
pub const ERROR_VID_DUPLICATE_HANDLER = WIN32_ERROR.ERROR_VID_DUPLICATE_HANDLER;
pub const ERROR_VID_TOO_MANY_HANDLERS = WIN32_ERROR.ERROR_VID_TOO_MANY_HANDLERS;
pub const ERROR_VID_QUEUE_FULL = WIN32_ERROR.ERROR_VID_QUEUE_FULL;
pub const ERROR_VID_HANDLER_NOT_PRESENT = WIN32_ERROR.ERROR_VID_HANDLER_NOT_PRESENT;
pub const ERROR_VID_INVALID_OBJECT_NAME = WIN32_ERROR.ERROR_VID_INVALID_OBJECT_NAME;
pub const ERROR_VID_PARTITION_NAME_TOO_LONG = WIN32_ERROR.ERROR_VID_PARTITION_NAME_TOO_LONG;
pub const ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG = WIN32_ERROR.ERROR_VID_MESSAGE_QUEUE_NAME_TOO_LONG;
pub const ERROR_VID_PARTITION_ALREADY_EXISTS = WIN32_ERROR.ERROR_VID_PARTITION_ALREADY_EXISTS;
pub const ERROR_VID_PARTITION_DOES_NOT_EXIST = WIN32_ERROR.ERROR_VID_PARTITION_DOES_NOT_EXIST;
pub const ERROR_VID_PARTITION_NAME_NOT_FOUND = WIN32_ERROR.ERROR_VID_PARTITION_NAME_NOT_FOUND;
pub const ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS = WIN32_ERROR.ERROR_VID_MESSAGE_QUEUE_ALREADY_EXISTS;
pub const ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT = WIN32_ERROR.ERROR_VID_EXCEEDED_MBP_ENTRY_MAP_LIMIT;
pub const ERROR_VID_MB_STILL_REFERENCED = WIN32_ERROR.ERROR_VID_MB_STILL_REFERENCED;
pub const ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED = WIN32_ERROR.ERROR_VID_CHILD_GPA_PAGE_SET_CORRUPTED;
pub const ERROR_VID_INVALID_NUMA_SETTINGS = WIN32_ERROR.ERROR_VID_INVALID_NUMA_SETTINGS;
pub const ERROR_VID_INVALID_NUMA_NODE_INDEX = WIN32_ERROR.ERROR_VID_INVALID_NUMA_NODE_INDEX;
pub const ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED = WIN32_ERROR.ERROR_VID_NOTIFICATION_QUEUE_ALREADY_ASSOCIATED;
pub const ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE = WIN32_ERROR.ERROR_VID_INVALID_MEMORY_BLOCK_HANDLE;
pub const ERROR_VID_PAGE_RANGE_OVERFLOW = WIN32_ERROR.ERROR_VID_PAGE_RANGE_OVERFLOW;
pub const ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE = WIN32_ERROR.ERROR_VID_INVALID_MESSAGE_QUEUE_HANDLE;
pub const ERROR_VID_INVALID_GPA_RANGE_HANDLE = WIN32_ERROR.ERROR_VID_INVALID_GPA_RANGE_HANDLE;
pub const ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE = WIN32_ERROR.ERROR_VID_NO_MEMORY_BLOCK_NOTIFICATION_QUEUE;
pub const ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED = WIN32_ERROR.ERROR_VID_MEMORY_BLOCK_LOCK_COUNT_EXCEEDED;
pub const ERROR_VID_INVALID_PPM_HANDLE = WIN32_ERROR.ERROR_VID_INVALID_PPM_HANDLE;
pub const ERROR_VID_MBPS_ARE_LOCKED = WIN32_ERROR.ERROR_VID_MBPS_ARE_LOCKED;
pub const ERROR_VID_MESSAGE_QUEUE_CLOSED = WIN32_ERROR.ERROR_VID_MESSAGE_QUEUE_CLOSED;
pub const ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED = WIN32_ERROR.ERROR_VID_VIRTUAL_PROCESSOR_LIMIT_EXCEEDED;
pub const ERROR_VID_STOP_PENDING = WIN32_ERROR.ERROR_VID_STOP_PENDING;
pub const ERROR_VID_INVALID_PROCESSOR_STATE = WIN32_ERROR.ERROR_VID_INVALID_PROCESSOR_STATE;
pub const ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT = WIN32_ERROR.ERROR_VID_EXCEEDED_KM_CONTEXT_COUNT_LIMIT;
pub const ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED = WIN32_ERROR.ERROR_VID_KM_INTERFACE_ALREADY_INITIALIZED;
pub const ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET = WIN32_ERROR.ERROR_VID_MB_PROPERTY_ALREADY_SET_RESET;
pub const ERROR_VID_MMIO_RANGE_DESTROYED = WIN32_ERROR.ERROR_VID_MMIO_RANGE_DESTROYED;
pub const ERROR_VID_INVALID_CHILD_GPA_PAGE_SET = WIN32_ERROR.ERROR_VID_INVALID_CHILD_GPA_PAGE_SET;
pub const ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED = WIN32_ERROR.ERROR_VID_RESERVE_PAGE_SET_IS_BEING_USED;
pub const ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL = WIN32_ERROR.ERROR_VID_RESERVE_PAGE_SET_TOO_SMALL;
pub const ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE = WIN32_ERROR.ERROR_VID_MBP_ALREADY_LOCKED_USING_RESERVED_PAGE;
pub const ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT = WIN32_ERROR.ERROR_VID_MBP_COUNT_EXCEEDED_LIMIT;
pub const ERROR_VID_SAVED_STATE_CORRUPT = WIN32_ERROR.ERROR_VID_SAVED_STATE_CORRUPT;
pub const ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM = WIN32_ERROR.ERROR_VID_SAVED_STATE_UNRECOGNIZED_ITEM;
pub const ERROR_VID_SAVED_STATE_INCOMPATIBLE = WIN32_ERROR.ERROR_VID_SAVED_STATE_INCOMPATIBLE;
pub const ERROR_VID_VTL_ACCESS_DENIED = WIN32_ERROR.ERROR_VID_VTL_ACCESS_DENIED;
pub const ERROR_VMCOMPUTE_TERMINATED_DURING_START = WIN32_ERROR.ERROR_VMCOMPUTE_TERMINATED_DURING_START;
pub const ERROR_VMCOMPUTE_IMAGE_MISMATCH = WIN32_ERROR.ERROR_VMCOMPUTE_IMAGE_MISMATCH;
pub const ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED = WIN32_ERROR.ERROR_VMCOMPUTE_HYPERV_NOT_INSTALLED;
pub const ERROR_VMCOMPUTE_OPERATION_PENDING = WIN32_ERROR.ERROR_VMCOMPUTE_OPERATION_PENDING;
pub const ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS = WIN32_ERROR.ERROR_VMCOMPUTE_TOO_MANY_NOTIFICATIONS;
pub const ERROR_VMCOMPUTE_INVALID_STATE = WIN32_ERROR.ERROR_VMCOMPUTE_INVALID_STATE;
pub const ERROR_VMCOMPUTE_UNEXPECTED_EXIT = WIN32_ERROR.ERROR_VMCOMPUTE_UNEXPECTED_EXIT;
pub const ERROR_VMCOMPUTE_TERMINATED = WIN32_ERROR.ERROR_VMCOMPUTE_TERMINATED;
pub const ERROR_VMCOMPUTE_CONNECT_FAILED = WIN32_ERROR.ERROR_VMCOMPUTE_CONNECT_FAILED;
pub const ERROR_VMCOMPUTE_TIMEOUT = WIN32_ERROR.ERROR_VMCOMPUTE_TIMEOUT;
pub const ERROR_VMCOMPUTE_CONNECTION_CLOSED = WIN32_ERROR.ERROR_VMCOMPUTE_CONNECTION_CLOSED;
pub const ERROR_VMCOMPUTE_UNKNOWN_MESSAGE = WIN32_ERROR.ERROR_VMCOMPUTE_UNKNOWN_MESSAGE;
pub const ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION = WIN32_ERROR.ERROR_VMCOMPUTE_UNSUPPORTED_PROTOCOL_VERSION;
pub const ERROR_VMCOMPUTE_INVALID_JSON = WIN32_ERROR.ERROR_VMCOMPUTE_INVALID_JSON;
pub const ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND = WIN32_ERROR.ERROR_VMCOMPUTE_SYSTEM_NOT_FOUND;
pub const ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS = WIN32_ERROR.ERROR_VMCOMPUTE_SYSTEM_ALREADY_EXISTS;
pub const ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED = WIN32_ERROR.ERROR_VMCOMPUTE_SYSTEM_ALREADY_STOPPED;
pub const ERROR_VMCOMPUTE_PROTOCOL_ERROR = WIN32_ERROR.ERROR_VMCOMPUTE_PROTOCOL_ERROR;
pub const ERROR_VMCOMPUTE_INVALID_LAYER = WIN32_ERROR.ERROR_VMCOMPUTE_INVALID_LAYER;
pub const ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED = WIN32_ERROR.ERROR_VMCOMPUTE_WINDOWS_INSIDER_REQUIRED;
pub const ERROR_VNET_VIRTUAL_SWITCH_NAME_NOT_FOUND = WIN32_ERROR.ERROR_VNET_VIRTUAL_SWITCH_NAME_NOT_FOUND;
pub const ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED = WIN32_ERROR.ERROR_VID_REMOTE_NODE_PARENT_GPA_PAGES_USED;
pub const ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND = WIN32_ERROR.ERROR_VSMB_SAVED_STATE_FILE_NOT_FOUND;
pub const ERROR_VSMB_SAVED_STATE_CORRUPT = WIN32_ERROR.ERROR_VSMB_SAVED_STATE_CORRUPT;
pub const ERROR_VOLMGR_INCOMPLETE_REGENERATION = WIN32_ERROR.ERROR_VOLMGR_INCOMPLETE_REGENERATION;
pub const ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION = WIN32_ERROR.ERROR_VOLMGR_INCOMPLETE_DISK_MIGRATION;
pub const ERROR_VOLMGR_DATABASE_FULL = WIN32_ERROR.ERROR_VOLMGR_DATABASE_FULL;
pub const ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED = WIN32_ERROR.ERROR_VOLMGR_DISK_CONFIGURATION_CORRUPTED;
pub const ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC = WIN32_ERROR.ERROR_VOLMGR_DISK_CONFIGURATION_NOT_IN_SYNC;
pub const ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED = WIN32_ERROR.ERROR_VOLMGR_PACK_CONFIG_UPDATE_FAILED;
pub const ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME = WIN32_ERROR.ERROR_VOLMGR_DISK_CONTAINS_NON_SIMPLE_VOLUME;
pub const ERROR_VOLMGR_DISK_DUPLICATE = WIN32_ERROR.ERROR_VOLMGR_DISK_DUPLICATE;
pub const ERROR_VOLMGR_DISK_DYNAMIC = WIN32_ERROR.ERROR_VOLMGR_DISK_DYNAMIC;
pub const ERROR_VOLMGR_DISK_ID_INVALID = WIN32_ERROR.ERROR_VOLMGR_DISK_ID_INVALID;
pub const ERROR_VOLMGR_DISK_INVALID = WIN32_ERROR.ERROR_VOLMGR_DISK_INVALID;
pub const ERROR_VOLMGR_DISK_LAST_VOTER = WIN32_ERROR.ERROR_VOLMGR_DISK_LAST_VOTER;
pub const ERROR_VOLMGR_DISK_LAYOUT_INVALID = WIN32_ERROR.ERROR_VOLMGR_DISK_LAYOUT_INVALID;
pub const ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS = WIN32_ERROR.ERROR_VOLMGR_DISK_LAYOUT_NON_BASIC_BETWEEN_BASIC_PARTITIONS;
pub const ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED = WIN32_ERROR.ERROR_VOLMGR_DISK_LAYOUT_NOT_CYLINDER_ALIGNED;
pub const ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL = WIN32_ERROR.ERROR_VOLMGR_DISK_LAYOUT_PARTITIONS_TOO_SMALL;
pub const ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS = WIN32_ERROR.ERROR_VOLMGR_DISK_LAYOUT_PRIMARY_BETWEEN_LOGICAL_PARTITIONS;
pub const ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS = WIN32_ERROR.ERROR_VOLMGR_DISK_LAYOUT_TOO_MANY_PARTITIONS;
pub const ERROR_VOLMGR_DISK_MISSING = WIN32_ERROR.ERROR_VOLMGR_DISK_MISSING;
pub const ERROR_VOLMGR_DISK_NOT_EMPTY = WIN32_ERROR.ERROR_VOLMGR_DISK_NOT_EMPTY;
pub const ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE = WIN32_ERROR.ERROR_VOLMGR_DISK_NOT_ENOUGH_SPACE;
pub const ERROR_VOLMGR_DISK_REVECTORING_FAILED = WIN32_ERROR.ERROR_VOLMGR_DISK_REVECTORING_FAILED;
pub const ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID = WIN32_ERROR.ERROR_VOLMGR_DISK_SECTOR_SIZE_INVALID;
pub const ERROR_VOLMGR_DISK_SET_NOT_CONTAINED = WIN32_ERROR.ERROR_VOLMGR_DISK_SET_NOT_CONTAINED;
pub const ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS = WIN32_ERROR.ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_MEMBERS;
pub const ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES = WIN32_ERROR.ERROR_VOLMGR_DISK_USED_BY_MULTIPLE_PLEXES;
pub const ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED = WIN32_ERROR.ERROR_VOLMGR_DYNAMIC_DISK_NOT_SUPPORTED;
pub const ERROR_VOLMGR_EXTENT_ALREADY_USED = WIN32_ERROR.ERROR_VOLMGR_EXTENT_ALREADY_USED;
pub const ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS = WIN32_ERROR.ERROR_VOLMGR_EXTENT_NOT_CONTIGUOUS;
pub const ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION = WIN32_ERROR.ERROR_VOLMGR_EXTENT_NOT_IN_PUBLIC_REGION;
pub const ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED = WIN32_ERROR.ERROR_VOLMGR_EXTENT_NOT_SECTOR_ALIGNED;
pub const ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION = WIN32_ERROR.ERROR_VOLMGR_EXTENT_OVERLAPS_EBR_PARTITION;
pub const ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH = WIN32_ERROR.ERROR_VOLMGR_EXTENT_VOLUME_LENGTHS_DO_NOT_MATCH;
pub const ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED = WIN32_ERROR.ERROR_VOLMGR_FAULT_TOLERANT_NOT_SUPPORTED;
pub const ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID = WIN32_ERROR.ERROR_VOLMGR_INTERLEAVE_LENGTH_INVALID;
pub const ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS = WIN32_ERROR.ERROR_VOLMGR_MAXIMUM_REGISTERED_USERS;
pub const ERROR_VOLMGR_MEMBER_IN_SYNC = WIN32_ERROR.ERROR_VOLMGR_MEMBER_IN_SYNC;
pub const ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE = WIN32_ERROR.ERROR_VOLMGR_MEMBER_INDEX_DUPLICATE;
pub const ERROR_VOLMGR_MEMBER_INDEX_INVALID = WIN32_ERROR.ERROR_VOLMGR_MEMBER_INDEX_INVALID;
pub const ERROR_VOLMGR_MEMBER_MISSING = WIN32_ERROR.ERROR_VOLMGR_MEMBER_MISSING;
pub const ERROR_VOLMGR_MEMBER_NOT_DETACHED = WIN32_ERROR.ERROR_VOLMGR_MEMBER_NOT_DETACHED;
pub const ERROR_VOLMGR_MEMBER_REGENERATING = WIN32_ERROR.ERROR_VOLMGR_MEMBER_REGENERATING;
pub const ERROR_VOLMGR_ALL_DISKS_FAILED = WIN32_ERROR.ERROR_VOLMGR_ALL_DISKS_FAILED;
pub const ERROR_VOLMGR_NO_REGISTERED_USERS = WIN32_ERROR.ERROR_VOLMGR_NO_REGISTERED_USERS;
pub const ERROR_VOLMGR_NO_SUCH_USER = WIN32_ERROR.ERROR_VOLMGR_NO_SUCH_USER;
pub const ERROR_VOLMGR_NOTIFICATION_RESET = WIN32_ERROR.ERROR_VOLMGR_NOTIFICATION_RESET;
pub const ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID = WIN32_ERROR.ERROR_VOLMGR_NUMBER_OF_MEMBERS_INVALID;
pub const ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID = WIN32_ERROR.ERROR_VOLMGR_NUMBER_OF_PLEXES_INVALID;
pub const ERROR_VOLMGR_PACK_DUPLICATE = WIN32_ERROR.ERROR_VOLMGR_PACK_DUPLICATE;
pub const ERROR_VOLMGR_PACK_ID_INVALID = WIN32_ERROR.ERROR_VOLMGR_PACK_ID_INVALID;
pub const ERROR_VOLMGR_PACK_INVALID = WIN32_ERROR.ERROR_VOLMGR_PACK_INVALID;
pub const ERROR_VOLMGR_PACK_NAME_INVALID = WIN32_ERROR.ERROR_VOLMGR_PACK_NAME_INVALID;
pub const ERROR_VOLMGR_PACK_OFFLINE = WIN32_ERROR.ERROR_VOLMGR_PACK_OFFLINE;
pub const ERROR_VOLMGR_PACK_HAS_QUORUM = WIN32_ERROR.ERROR_VOLMGR_PACK_HAS_QUORUM;
pub const ERROR_VOLMGR_PACK_WITHOUT_QUORUM = WIN32_ERROR.ERROR_VOLMGR_PACK_WITHOUT_QUORUM;
pub const ERROR_VOLMGR_PARTITION_STYLE_INVALID = WIN32_ERROR.ERROR_VOLMGR_PARTITION_STYLE_INVALID;
pub const ERROR_VOLMGR_PARTITION_UPDATE_FAILED = WIN32_ERROR.ERROR_VOLMGR_PARTITION_UPDATE_FAILED;
pub const ERROR_VOLMGR_PLEX_IN_SYNC = WIN32_ERROR.ERROR_VOLMGR_PLEX_IN_SYNC;
pub const ERROR_VOLMGR_PLEX_INDEX_DUPLICATE = WIN32_ERROR.ERROR_VOLMGR_PLEX_INDEX_DUPLICATE;
pub const ERROR_VOLMGR_PLEX_INDEX_INVALID = WIN32_ERROR.ERROR_VOLMGR_PLEX_INDEX_INVALID;
pub const ERROR_VOLMGR_PLEX_LAST_ACTIVE = WIN32_ERROR.ERROR_VOLMGR_PLEX_LAST_ACTIVE;
pub const ERROR_VOLMGR_PLEX_MISSING = WIN32_ERROR.ERROR_VOLMGR_PLEX_MISSING;
pub const ERROR_VOLMGR_PLEX_REGENERATING = WIN32_ERROR.ERROR_VOLMGR_PLEX_REGENERATING;
pub const ERROR_VOLMGR_PLEX_TYPE_INVALID = WIN32_ERROR.ERROR_VOLMGR_PLEX_TYPE_INVALID;
pub const ERROR_VOLMGR_PLEX_NOT_RAID5 = WIN32_ERROR.ERROR_VOLMGR_PLEX_NOT_RAID5;
pub const ERROR_VOLMGR_PLEX_NOT_SIMPLE = WIN32_ERROR.ERROR_VOLMGR_PLEX_NOT_SIMPLE;
pub const ERROR_VOLMGR_STRUCTURE_SIZE_INVALID = WIN32_ERROR.ERROR_VOLMGR_STRUCTURE_SIZE_INVALID;
pub const ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS = WIN32_ERROR.ERROR_VOLMGR_TOO_MANY_NOTIFICATION_REQUESTS;
pub const ERROR_VOLMGR_TRANSACTION_IN_PROGRESS = WIN32_ERROR.ERROR_VOLMGR_TRANSACTION_IN_PROGRESS;
pub const ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE = WIN32_ERROR.ERROR_VOLMGR_UNEXPECTED_DISK_LAYOUT_CHANGE;
pub const ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK = WIN32_ERROR.ERROR_VOLMGR_VOLUME_CONTAINS_MISSING_DISK;
pub const ERROR_VOLMGR_VOLUME_ID_INVALID = WIN32_ERROR.ERROR_VOLMGR_VOLUME_ID_INVALID;
pub const ERROR_VOLMGR_VOLUME_LENGTH_INVALID = WIN32_ERROR.ERROR_VOLMGR_VOLUME_LENGTH_INVALID;
pub const ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE = WIN32_ERROR.ERROR_VOLMGR_VOLUME_LENGTH_NOT_SECTOR_SIZE_MULTIPLE;
pub const ERROR_VOLMGR_VOLUME_NOT_MIRRORED = WIN32_ERROR.ERROR_VOLMGR_VOLUME_NOT_MIRRORED;
pub const ERROR_VOLMGR_VOLUME_NOT_RETAINED = WIN32_ERROR.ERROR_VOLMGR_VOLUME_NOT_RETAINED;
pub const ERROR_VOLMGR_VOLUME_OFFLINE = WIN32_ERROR.ERROR_VOLMGR_VOLUME_OFFLINE;
pub const ERROR_VOLMGR_VOLUME_RETAINED = WIN32_ERROR.ERROR_VOLMGR_VOLUME_RETAINED;
pub const ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID = WIN32_ERROR.ERROR_VOLMGR_NUMBER_OF_EXTENTS_INVALID;
pub const ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE = WIN32_ERROR.ERROR_VOLMGR_DIFFERENT_SECTOR_SIZE;
pub const ERROR_VOLMGR_BAD_BOOT_DISK = WIN32_ERROR.ERROR_VOLMGR_BAD_BOOT_DISK;
pub const ERROR_VOLMGR_PACK_CONFIG_OFFLINE = WIN32_ERROR.ERROR_VOLMGR_PACK_CONFIG_OFFLINE;
pub const ERROR_VOLMGR_PACK_CONFIG_ONLINE = WIN32_ERROR.ERROR_VOLMGR_PACK_CONFIG_ONLINE;
pub const ERROR_VOLMGR_NOT_PRIMARY_PACK = WIN32_ERROR.ERROR_VOLMGR_NOT_PRIMARY_PACK;
pub const ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED = WIN32_ERROR.ERROR_VOLMGR_PACK_LOG_UPDATE_FAILED;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID = WIN32_ERROR.ERROR_VOLMGR_NUMBER_OF_DISKS_IN_PLEX_INVALID;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID = WIN32_ERROR.ERROR_VOLMGR_NUMBER_OF_DISKS_IN_MEMBER_INVALID;
pub const ERROR_VOLMGR_VOLUME_MIRRORED = WIN32_ERROR.ERROR_VOLMGR_VOLUME_MIRRORED;
pub const ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED = WIN32_ERROR.ERROR_VOLMGR_PLEX_NOT_SIMPLE_SPANNED;
pub const ERROR_VOLMGR_NO_VALID_LOG_COPIES = WIN32_ERROR.ERROR_VOLMGR_NO_VALID_LOG_COPIES;
pub const ERROR_VOLMGR_PRIMARY_PACK_PRESENT = WIN32_ERROR.ERROR_VOLMGR_PRIMARY_PACK_PRESENT;
pub const ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID = WIN32_ERROR.ERROR_VOLMGR_NUMBER_OF_DISKS_INVALID;
pub const ERROR_VOLMGR_MIRROR_NOT_SUPPORTED = WIN32_ERROR.ERROR_VOLMGR_MIRROR_NOT_SUPPORTED;
pub const ERROR_VOLMGR_RAID5_NOT_SUPPORTED = WIN32_ERROR.ERROR_VOLMGR_RAID5_NOT_SUPPORTED;
pub const ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED = WIN32_ERROR.ERROR_BCD_NOT_ALL_ENTRIES_IMPORTED;
pub const ERROR_BCD_TOO_MANY_ELEMENTS = WIN32_ERROR.ERROR_BCD_TOO_MANY_ELEMENTS;
pub const ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED = WIN32_ERROR.ERROR_BCD_NOT_ALL_ENTRIES_SYNCHRONIZED;
pub const ERROR_VHD_DRIVE_FOOTER_MISSING = WIN32_ERROR.ERROR_VHD_DRIVE_FOOTER_MISSING;
pub const ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH = WIN32_ERROR.ERROR_VHD_DRIVE_FOOTER_CHECKSUM_MISMATCH;
pub const ERROR_VHD_DRIVE_FOOTER_CORRUPT = WIN32_ERROR.ERROR_VHD_DRIVE_FOOTER_CORRUPT;
pub const ERROR_VHD_FORMAT_UNKNOWN = WIN32_ERROR.ERROR_VHD_FORMAT_UNKNOWN;
pub const ERROR_VHD_FORMAT_UNSUPPORTED_VERSION = WIN32_ERROR.ERROR_VHD_FORMAT_UNSUPPORTED_VERSION;
pub const ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH = WIN32_ERROR.ERROR_VHD_SPARSE_HEADER_CHECKSUM_MISMATCH;
pub const ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION = WIN32_ERROR.ERROR_VHD_SPARSE_HEADER_UNSUPPORTED_VERSION;
pub const ERROR_VHD_SPARSE_HEADER_CORRUPT = WIN32_ERROR.ERROR_VHD_SPARSE_HEADER_CORRUPT;
pub const ERROR_VHD_BLOCK_ALLOCATION_FAILURE = WIN32_ERROR.ERROR_VHD_BLOCK_ALLOCATION_FAILURE;
pub const ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT = WIN32_ERROR.ERROR_VHD_BLOCK_ALLOCATION_TABLE_CORRUPT;
pub const ERROR_VHD_INVALID_BLOCK_SIZE = WIN32_ERROR.ERROR_VHD_INVALID_BLOCK_SIZE;
pub const ERROR_VHD_BITMAP_MISMATCH = WIN32_ERROR.ERROR_VHD_BITMAP_MISMATCH;
pub const ERROR_VHD_PARENT_VHD_NOT_FOUND = WIN32_ERROR.ERROR_VHD_PARENT_VHD_NOT_FOUND;
pub const ERROR_VHD_CHILD_PARENT_ID_MISMATCH = WIN32_ERROR.ERROR_VHD_CHILD_PARENT_ID_MISMATCH;
pub const ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH = WIN32_ERROR.ERROR_VHD_CHILD_PARENT_TIMESTAMP_MISMATCH;
pub const ERROR_VHD_METADATA_READ_FAILURE = WIN32_ERROR.ERROR_VHD_METADATA_READ_FAILURE;
pub const ERROR_VHD_METADATA_WRITE_FAILURE = WIN32_ERROR.ERROR_VHD_METADATA_WRITE_FAILURE;
pub const ERROR_VHD_INVALID_SIZE = WIN32_ERROR.ERROR_VHD_INVALID_SIZE;
pub const ERROR_VHD_INVALID_FILE_SIZE = WIN32_ERROR.ERROR_VHD_INVALID_FILE_SIZE;
pub const ERROR_VIRTDISK_PROVIDER_NOT_FOUND = WIN32_ERROR.ERROR_VIRTDISK_PROVIDER_NOT_FOUND;
pub const ERROR_VIRTDISK_NOT_VIRTUAL_DISK = WIN32_ERROR.ERROR_VIRTDISK_NOT_VIRTUAL_DISK;
pub const ERROR_VHD_PARENT_VHD_ACCESS_DENIED = WIN32_ERROR.ERROR_VHD_PARENT_VHD_ACCESS_DENIED;
pub const ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH = WIN32_ERROR.ERROR_VHD_CHILD_PARENT_SIZE_MISMATCH;
pub const ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED = WIN32_ERROR.ERROR_VHD_DIFFERENCING_CHAIN_CYCLE_DETECTED;
pub const ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT = WIN32_ERROR.ERROR_VHD_DIFFERENCING_CHAIN_ERROR_IN_PARENT;
pub const ERROR_VIRTUAL_DISK_LIMITATION = WIN32_ERROR.ERROR_VIRTUAL_DISK_LIMITATION;
pub const ERROR_VHD_INVALID_TYPE = WIN32_ERROR.ERROR_VHD_INVALID_TYPE;
pub const ERROR_VHD_INVALID_STATE = WIN32_ERROR.ERROR_VHD_INVALID_STATE;
pub const ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE = WIN32_ERROR.ERROR_VIRTDISK_UNSUPPORTED_DISK_SECTOR_SIZE;
pub const ERROR_VIRTDISK_DISK_ALREADY_OWNED = WIN32_ERROR.ERROR_VIRTDISK_DISK_ALREADY_OWNED;
pub const ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE = WIN32_ERROR.ERROR_VIRTDISK_DISK_ONLINE_AND_WRITABLE;
pub const ERROR_CTLOG_TRACKING_NOT_INITIALIZED = WIN32_ERROR.ERROR_CTLOG_TRACKING_NOT_INITIALIZED;
pub const ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE = WIN32_ERROR.ERROR_CTLOG_LOGFILE_SIZE_EXCEEDED_MAXSIZE;
pub const ERROR_CTLOG_VHD_CHANGED_OFFLINE = WIN32_ERROR.ERROR_CTLOG_VHD_CHANGED_OFFLINE;
pub const ERROR_CTLOG_INVALID_TRACKING_STATE = WIN32_ERROR.ERROR_CTLOG_INVALID_TRACKING_STATE;
pub const ERROR_CTLOG_INCONSISTENT_TRACKING_FILE = WIN32_ERROR.ERROR_CTLOG_INCONSISTENT_TRACKING_FILE;
pub const ERROR_VHD_RESIZE_WOULD_TRUNCATE_DATA = WIN32_ERROR.ERROR_VHD_RESIZE_WOULD_TRUNCATE_DATA;
pub const ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE = WIN32_ERROR.ERROR_VHD_COULD_NOT_COMPUTE_MINIMUM_VIRTUAL_SIZE;
pub const ERROR_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE = WIN32_ERROR.ERROR_VHD_ALREADY_AT_OR_BELOW_MINIMUM_VIRTUAL_SIZE;
pub const ERROR_VHD_METADATA_FULL = WIN32_ERROR.ERROR_VHD_METADATA_FULL;
pub const ERROR_VHD_INVALID_CHANGE_TRACKING_ID = WIN32_ERROR.ERROR_VHD_INVALID_CHANGE_TRACKING_ID;
pub const ERROR_VHD_CHANGE_TRACKING_DISABLED = WIN32_ERROR.ERROR_VHD_CHANGE_TRACKING_DISABLED;
pub const ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION = WIN32_ERROR.ERROR_VHD_MISSING_CHANGE_TRACKING_INFORMATION;
pub const ERROR_QUERY_STORAGE_ERROR = WIN32_ERROR.ERROR_QUERY_STORAGE_ERROR;

pub const FACILITY_CODE = enum(u32) {
    NULL = 0,
    RPC = 1,
    DISPATCH = 2,
    STORAGE = 3,
    ITF = 4,
    WIN32 = 7,
    WINDOWS = 8,
    SSPI = 9,
    // SECURITY = 9, this enum value conflicts with SSPI
    CONTROL = 10,
    CERT = 11,
    INTERNET = 12,
    MEDIASERVER = 13,
    MSMQ = 14,
    SETUPAPI = 15,
    SCARD = 16,
    COMPLUS = 17,
    AAF = 18,
    URT = 19,
    ACS = 20,
    DPLAY = 21,
    UMI = 22,
    SXS = 23,
    WINDOWS_CE = 24,
    HTTP = 25,
    USERMODE_COMMONLOG = 26,
    WER = 27,
    USERMODE_FILTER_MANAGER = 31,
    BACKGROUNDCOPY = 32,
    CONFIGURATION = 33,
    // WIA = 33, this enum value conflicts with CONFIGURATION
    STATE_MANAGEMENT = 34,
    METADIRECTORY = 35,
    WINDOWSUPDATE = 36,
    DIRECTORYSERVICE = 37,
    GRAPHICS = 38,
    SHELL = 39,
    // NAP = 39, this enum value conflicts with SHELL
    TPM_SERVICES = 40,
    TPM_SOFTWARE = 41,
    UI = 42,
    XAML = 43,
    ACTION_QUEUE = 44,
    PLA = 48,
    // WINDOWS_SETUP = 48, this enum value conflicts with PLA
    FVE = 49,
    FWP = 50,
    WINRM = 51,
    NDIS = 52,
    USERMODE_HYPERVISOR = 53,
    CMI = 54,
    USERMODE_VIRTUALIZATION = 55,
    USERMODE_VOLMGR = 56,
    BCD = 57,
    USERMODE_VHD = 58,
    USERMODE_HNS = 59,
    SDIAG = 60,
    WEBSERVICES = 61,
    // WINPE = 61, this enum value conflicts with WEBSERVICES
    WPN = 62,
    WINDOWS_STORE = 63,
    INPUT = 64,
    QUIC = 65,
    EAP = 66,
    WINDOWS_DEFENDER = 80,
    OPC = 81,
    XPS = 82,
    MBN = 84,
    // POWERSHELL = 84, this enum value conflicts with MBN
    RAS = 83,
    P2P_INT = 98,
    P2P = 99,
    DAF = 100,
    BLUETOOTH_ATT = 101,
    AUDIO = 102,
    STATEREPOSITORY = 103,
    VISUALCPP = 109,
    SCRIPT = 112,
    PARSE = 113,
    BLB = 120,
    BLB_CLI = 121,
    WSBAPP = 122,
    BLBUI = 128,
    USN = 129,
    USERMODE_VOLSNAP = 130,
    TIERING = 131,
    WSB_ONLINE = 133,
    ONLINE_ID = 134,
    DEVICE_UPDATE_AGENT = 135,
    DRVSERVICING = 136,
    DLS = 153,
    DELIVERY_OPTIMIZATION = 208,
    USERMODE_SPACES = 231,
    USER_MODE_SECURITY_CORE = 232,
    USERMODE_LICENSING = 234,
    SOS = 160,
    DEBUGGERS = 176,
    SPP = 256,
    // RESTORE = 256, this enum value conflicts with SPP
    // DMSERVER = 256, this enum value conflicts with SPP
    DEPLOYMENT_SERVICES_SERVER = 257,
    DEPLOYMENT_SERVICES_IMAGING = 258,
    DEPLOYMENT_SERVICES_MANAGEMENT = 259,
    DEPLOYMENT_SERVICES_UTIL = 260,
    DEPLOYMENT_SERVICES_BINLSVC = 261,
    DEPLOYMENT_SERVICES_PXE = 263,
    DEPLOYMENT_SERVICES_TFTP = 264,
    DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = 272,
    DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = 278,
    DEPLOYMENT_SERVICES_MULTICAST_SERVER = 289,
    DEPLOYMENT_SERVICES_MULTICAST_CLIENT = 290,
    DEPLOYMENT_SERVICES_CONTENT_PROVIDER = 293,
    LINGUISTIC_SERVICES = 305,
    AUDIOSTREAMING = 1094,
    TTD = 1490,
    ACCELERATOR = 1536,
    WMAAECMA = 1996,
    DIRECTMUSIC = 2168,
    DIRECT3D10 = 2169,
    DXGI = 2170,
    DXGI_DDI = 2171,
    DIRECT3D11 = 2172,
    DIRECT3D11_DEBUG = 2173,
    DIRECT3D12 = 2174,
    DIRECT3D12_DEBUG = 2175,
    DXCORE = 2176,
    LEAP = 2184,
    AUDCLNT = 2185,
    WINCODEC_DWRITE_DWM = 2200,
    WINML = 2192,
    DIRECT2D = 2201,
    DEFRAG = 2304,
    USERMODE_SDBUS = 2305,
    JSCRIPT = 2306,
    PIDGENX = 2561,
    EAS = 85,
    WEB = 885,
    WEB_SOCKET = 886,
    MOBILE = 1793,
    SQLITE = 1967,
    UTC = 1989,
    WEP = 2049,
    SYNCENGINE = 2050,
    XBOX = 2339,
    GAME = 2340,
    PIX = 2748,
    NT_BIT = 268435456,
};
pub const FACILITY_NULL = FACILITY_CODE.NULL;
pub const FACILITY_RPC = FACILITY_CODE.RPC;
pub const FACILITY_DISPATCH = FACILITY_CODE.DISPATCH;
pub const FACILITY_STORAGE = FACILITY_CODE.STORAGE;
pub const FACILITY_ITF = FACILITY_CODE.ITF;
pub const FACILITY_WIN32 = FACILITY_CODE.WIN32;
pub const FACILITY_WINDOWS = FACILITY_CODE.WINDOWS;
pub const FACILITY_SSPI = FACILITY_CODE.SSPI;
pub const FACILITY_SECURITY = FACILITY_CODE.SSPI;
pub const FACILITY_CONTROL = FACILITY_CODE.CONTROL;
pub const FACILITY_CERT = FACILITY_CODE.CERT;
pub const FACILITY_INTERNET = FACILITY_CODE.INTERNET;
pub const FACILITY_MEDIASERVER = FACILITY_CODE.MEDIASERVER;
pub const FACILITY_MSMQ = FACILITY_CODE.MSMQ;
pub const FACILITY_SETUPAPI = FACILITY_CODE.SETUPAPI;
pub const FACILITY_SCARD = FACILITY_CODE.SCARD;
pub const FACILITY_COMPLUS = FACILITY_CODE.COMPLUS;
pub const FACILITY_AAF = FACILITY_CODE.AAF;
pub const FACILITY_URT = FACILITY_CODE.URT;
pub const FACILITY_ACS = FACILITY_CODE.ACS;
pub const FACILITY_DPLAY = FACILITY_CODE.DPLAY;
pub const FACILITY_UMI = FACILITY_CODE.UMI;
pub const FACILITY_SXS = FACILITY_CODE.SXS;
pub const FACILITY_WINDOWS_CE = FACILITY_CODE.WINDOWS_CE;
pub const FACILITY_HTTP = FACILITY_CODE.HTTP;
pub const FACILITY_USERMODE_COMMONLOG = FACILITY_CODE.USERMODE_COMMONLOG;
pub const FACILITY_WER = FACILITY_CODE.WER;
pub const FACILITY_USERMODE_FILTER_MANAGER = FACILITY_CODE.USERMODE_FILTER_MANAGER;
pub const FACILITY_BACKGROUNDCOPY = FACILITY_CODE.BACKGROUNDCOPY;
pub const FACILITY_CONFIGURATION = FACILITY_CODE.CONFIGURATION;
pub const FACILITY_WIA = FACILITY_CODE.CONFIGURATION;
pub const FACILITY_STATE_MANAGEMENT = FACILITY_CODE.STATE_MANAGEMENT;
pub const FACILITY_METADIRECTORY = FACILITY_CODE.METADIRECTORY;
pub const FACILITY_WINDOWSUPDATE = FACILITY_CODE.WINDOWSUPDATE;
pub const FACILITY_DIRECTORYSERVICE = FACILITY_CODE.DIRECTORYSERVICE;
pub const FACILITY_GRAPHICS = FACILITY_CODE.GRAPHICS;
pub const FACILITY_SHELL = FACILITY_CODE.SHELL;
pub const FACILITY_NAP = FACILITY_CODE.SHELL;
pub const FACILITY_TPM_SERVICES = FACILITY_CODE.TPM_SERVICES;
pub const FACILITY_TPM_SOFTWARE = FACILITY_CODE.TPM_SOFTWARE;
pub const FACILITY_UI = FACILITY_CODE.UI;
pub const FACILITY_XAML = FACILITY_CODE.XAML;
pub const FACILITY_ACTION_QUEUE = FACILITY_CODE.ACTION_QUEUE;
pub const FACILITY_PLA = FACILITY_CODE.PLA;
pub const FACILITY_WINDOWS_SETUP = FACILITY_CODE.PLA;
pub const FACILITY_FVE = FACILITY_CODE.FVE;
pub const FACILITY_FWP = FACILITY_CODE.FWP;
pub const FACILITY_WINRM = FACILITY_CODE.WINRM;
pub const FACILITY_NDIS = FACILITY_CODE.NDIS;
pub const FACILITY_USERMODE_HYPERVISOR = FACILITY_CODE.USERMODE_HYPERVISOR;
pub const FACILITY_CMI = FACILITY_CODE.CMI;
pub const FACILITY_USERMODE_VIRTUALIZATION = FACILITY_CODE.USERMODE_VIRTUALIZATION;
pub const FACILITY_USERMODE_VOLMGR = FACILITY_CODE.USERMODE_VOLMGR;
pub const FACILITY_BCD = FACILITY_CODE.BCD;
pub const FACILITY_USERMODE_VHD = FACILITY_CODE.USERMODE_VHD;
pub const FACILITY_USERMODE_HNS = FACILITY_CODE.USERMODE_HNS;
pub const FACILITY_SDIAG = FACILITY_CODE.SDIAG;
pub const FACILITY_WEBSERVICES = FACILITY_CODE.WEBSERVICES;
pub const FACILITY_WINPE = FACILITY_CODE.WEBSERVICES;
pub const FACILITY_WPN = FACILITY_CODE.WPN;
pub const FACILITY_WINDOWS_STORE = FACILITY_CODE.WINDOWS_STORE;
pub const FACILITY_INPUT = FACILITY_CODE.INPUT;
pub const FACILITY_QUIC = FACILITY_CODE.QUIC;
pub const FACILITY_EAP = FACILITY_CODE.EAP;
pub const FACILITY_WINDOWS_DEFENDER = FACILITY_CODE.WINDOWS_DEFENDER;
pub const FACILITY_OPC = FACILITY_CODE.OPC;
pub const FACILITY_XPS = FACILITY_CODE.XPS;
pub const FACILITY_MBN = FACILITY_CODE.MBN;
pub const FACILITY_POWERSHELL = FACILITY_CODE.MBN;
pub const FACILITY_RAS = FACILITY_CODE.RAS;
pub const FACILITY_P2P_INT = FACILITY_CODE.P2P_INT;
pub const FACILITY_P2P = FACILITY_CODE.P2P;
pub const FACILITY_DAF = FACILITY_CODE.DAF;
pub const FACILITY_BLUETOOTH_ATT = FACILITY_CODE.BLUETOOTH_ATT;
pub const FACILITY_AUDIO = FACILITY_CODE.AUDIO;
pub const FACILITY_STATEREPOSITORY = FACILITY_CODE.STATEREPOSITORY;
pub const FACILITY_VISUALCPP = FACILITY_CODE.VISUALCPP;
pub const FACILITY_SCRIPT = FACILITY_CODE.SCRIPT;
pub const FACILITY_PARSE = FACILITY_CODE.PARSE;
pub const FACILITY_BLB = FACILITY_CODE.BLB;
pub const FACILITY_BLB_CLI = FACILITY_CODE.BLB_CLI;
pub const FACILITY_WSBAPP = FACILITY_CODE.WSBAPP;
pub const FACILITY_BLBUI = FACILITY_CODE.BLBUI;
pub const FACILITY_USN = FACILITY_CODE.USN;
pub const FACILITY_USERMODE_VOLSNAP = FACILITY_CODE.USERMODE_VOLSNAP;
pub const FACILITY_TIERING = FACILITY_CODE.TIERING;
pub const FACILITY_WSB_ONLINE = FACILITY_CODE.WSB_ONLINE;
pub const FACILITY_ONLINE_ID = FACILITY_CODE.ONLINE_ID;
pub const FACILITY_DEVICE_UPDATE_AGENT = FACILITY_CODE.DEVICE_UPDATE_AGENT;
pub const FACILITY_DRVSERVICING = FACILITY_CODE.DRVSERVICING;
pub const FACILITY_DLS = FACILITY_CODE.DLS;
pub const FACILITY_DELIVERY_OPTIMIZATION = FACILITY_CODE.DELIVERY_OPTIMIZATION;
pub const FACILITY_USERMODE_SPACES = FACILITY_CODE.USERMODE_SPACES;
pub const FACILITY_USER_MODE_SECURITY_CORE = FACILITY_CODE.USER_MODE_SECURITY_CORE;
pub const FACILITY_USERMODE_LICENSING = FACILITY_CODE.USERMODE_LICENSING;
pub const FACILITY_SOS = FACILITY_CODE.SOS;
pub const FACILITY_DEBUGGERS = FACILITY_CODE.DEBUGGERS;
pub const FACILITY_SPP = FACILITY_CODE.SPP;
pub const FACILITY_RESTORE = FACILITY_CODE.SPP;
pub const FACILITY_DMSERVER = FACILITY_CODE.SPP;
pub const FACILITY_DEPLOYMENT_SERVICES_SERVER = FACILITY_CODE.DEPLOYMENT_SERVICES_SERVER;
pub const FACILITY_DEPLOYMENT_SERVICES_IMAGING = FACILITY_CODE.DEPLOYMENT_SERVICES_IMAGING;
pub const FACILITY_DEPLOYMENT_SERVICES_MANAGEMENT = FACILITY_CODE.DEPLOYMENT_SERVICES_MANAGEMENT;
pub const FACILITY_DEPLOYMENT_SERVICES_UTIL = FACILITY_CODE.DEPLOYMENT_SERVICES_UTIL;
pub const FACILITY_DEPLOYMENT_SERVICES_BINLSVC = FACILITY_CODE.DEPLOYMENT_SERVICES_BINLSVC;
pub const FACILITY_DEPLOYMENT_SERVICES_PXE = FACILITY_CODE.DEPLOYMENT_SERVICES_PXE;
pub const FACILITY_DEPLOYMENT_SERVICES_TFTP = FACILITY_CODE.DEPLOYMENT_SERVICES_TFTP;
pub const FACILITY_DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT = FACILITY_CODE.DEPLOYMENT_SERVICES_TRANSPORT_MANAGEMENT;
pub const FACILITY_DEPLOYMENT_SERVICES_DRIVER_PROVISIONING = FACILITY_CODE.DEPLOYMENT_SERVICES_DRIVER_PROVISIONING;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_SERVER = FACILITY_CODE.DEPLOYMENT_SERVICES_MULTICAST_SERVER;
pub const FACILITY_DEPLOYMENT_SERVICES_MULTICAST_CLIENT = FACILITY_CODE.DEPLOYMENT_SERVICES_MULTICAST_CLIENT;
pub const FACILITY_DEPLOYMENT_SERVICES_CONTENT_PROVIDER = FACILITY_CODE.DEPLOYMENT_SERVICES_CONTENT_PROVIDER;
pub const FACILITY_LINGUISTIC_SERVICES = FACILITY_CODE.LINGUISTIC_SERVICES;
pub const FACILITY_AUDIOSTREAMING = FACILITY_CODE.AUDIOSTREAMING;
pub const FACILITY_TTD = FACILITY_CODE.TTD;
pub const FACILITY_ACCELERATOR = FACILITY_CODE.ACCELERATOR;
pub const FACILITY_WMAAECMA = FACILITY_CODE.WMAAECMA;
pub const FACILITY_DIRECTMUSIC = FACILITY_CODE.DIRECTMUSIC;
pub const FACILITY_DIRECT3D10 = FACILITY_CODE.DIRECT3D10;
pub const FACILITY_DXGI = FACILITY_CODE.DXGI;
pub const FACILITY_DXGI_DDI = FACILITY_CODE.DXGI_DDI;
pub const FACILITY_DIRECT3D11 = FACILITY_CODE.DIRECT3D11;
pub const FACILITY_DIRECT3D11_DEBUG = FACILITY_CODE.DIRECT3D11_DEBUG;
pub const FACILITY_DIRECT3D12 = FACILITY_CODE.DIRECT3D12;
pub const FACILITY_DIRECT3D12_DEBUG = FACILITY_CODE.DIRECT3D12_DEBUG;
pub const FACILITY_DXCORE = FACILITY_CODE.DXCORE;
pub const FACILITY_LEAP = FACILITY_CODE.LEAP;
pub const FACILITY_AUDCLNT = FACILITY_CODE.AUDCLNT;
pub const FACILITY_WINCODEC_DWRITE_DWM = FACILITY_CODE.WINCODEC_DWRITE_DWM;
pub const FACILITY_WINML = FACILITY_CODE.WINML;
pub const FACILITY_DIRECT2D = FACILITY_CODE.DIRECT2D;
pub const FACILITY_DEFRAG = FACILITY_CODE.DEFRAG;
pub const FACILITY_USERMODE_SDBUS = FACILITY_CODE.USERMODE_SDBUS;
pub const FACILITY_JSCRIPT = FACILITY_CODE.JSCRIPT;
pub const FACILITY_PIDGENX = FACILITY_CODE.PIDGENX;
pub const FACILITY_EAS = FACILITY_CODE.EAS;
pub const FACILITY_WEB = FACILITY_CODE.WEB;
pub const FACILITY_WEB_SOCKET = FACILITY_CODE.WEB_SOCKET;
pub const FACILITY_MOBILE = FACILITY_CODE.MOBILE;
pub const FACILITY_SQLITE = FACILITY_CODE.SQLITE;
pub const FACILITY_UTC = FACILITY_CODE.UTC;
pub const FACILITY_WEP = FACILITY_CODE.WEP;
pub const FACILITY_SYNCENGINE = FACILITY_CODE.SYNCENGINE;
pub const FACILITY_XBOX = FACILITY_CODE.XBOX;
pub const FACILITY_GAME = FACILITY_CODE.GAME;
pub const FACILITY_PIX = FACILITY_CODE.PIX;
pub const FACILITY_NT_BIT = FACILITY_CODE.NT_BIT;

pub const THREAD_ERROR_MODE = enum(u32) {
    ALL_ERRORS = 0,
    FAILCRITICALERRORS = 1,
    NOGPFAULTERRORBOX = 2,
    NOOPENFILEERRORBOX = 32768,
    NOALIGNMENTFAULTEXCEPT = 4,
    _,
    pub fn initFlags(o: struct {
        ALL_ERRORS: u1 = 0,
        FAILCRITICALERRORS: u1 = 0,
        NOGPFAULTERRORBOX: u1 = 0,
        NOOPENFILEERRORBOX: u1 = 0,
        NOALIGNMENTFAULTEXCEPT: u1 = 0,
    }) THREAD_ERROR_MODE {
        return @intToEnum(THREAD_ERROR_MODE,
              (if (o.ALL_ERRORS == 1) @enumToInt(THREAD_ERROR_MODE.ALL_ERRORS) else 0)
            | (if (o.FAILCRITICALERRORS == 1) @enumToInt(THREAD_ERROR_MODE.FAILCRITICALERRORS) else 0)
            | (if (o.NOGPFAULTERRORBOX == 1) @enumToInt(THREAD_ERROR_MODE.NOGPFAULTERRORBOX) else 0)
            | (if (o.NOOPENFILEERRORBOX == 1) @enumToInt(THREAD_ERROR_MODE.NOOPENFILEERRORBOX) else 0)
            | (if (o.NOALIGNMENTFAULTEXCEPT == 1) @enumToInt(THREAD_ERROR_MODE.NOALIGNMENTFAULTEXCEPT) else 0)
        );
    }
};
pub const SEM_ALL_ERRORS = THREAD_ERROR_MODE.ALL_ERRORS;
pub const SEM_FAILCRITICALERRORS = THREAD_ERROR_MODE.FAILCRITICALERRORS;
pub const SEM_NOGPFAULTERRORBOX = THREAD_ERROR_MODE.NOGPFAULTERRORBOX;
pub const SEM_NOOPENFILEERRORBOX = THREAD_ERROR_MODE.NOOPENFILEERRORBOX;
pub const SEM_NOALIGNMENTFAULTEXCEPT = THREAD_ERROR_MODE.NOALIGNMENTFAULTEXCEPT;

pub const FORMAT_MESSAGE_OPTIONS = enum(u32) {
    ALLOCATE_BUFFER = 256,
    ARGUMENT_ARRAY = 8192,
    FROM_HMODULE = 2048,
    FROM_STRING = 1024,
    FROM_SYSTEM = 4096,
    IGNORE_INSERTS = 512,
    _,
    pub fn initFlags(o: struct {
        ALLOCATE_BUFFER: u1 = 0,
        ARGUMENT_ARRAY: u1 = 0,
        FROM_HMODULE: u1 = 0,
        FROM_STRING: u1 = 0,
        FROM_SYSTEM: u1 = 0,
        IGNORE_INSERTS: u1 = 0,
    }) FORMAT_MESSAGE_OPTIONS {
        return @intToEnum(FORMAT_MESSAGE_OPTIONS,
              (if (o.ALLOCATE_BUFFER == 1) @enumToInt(FORMAT_MESSAGE_OPTIONS.ALLOCATE_BUFFER) else 0)
            | (if (o.ARGUMENT_ARRAY == 1) @enumToInt(FORMAT_MESSAGE_OPTIONS.ARGUMENT_ARRAY) else 0)
            | (if (o.FROM_HMODULE == 1) @enumToInt(FORMAT_MESSAGE_OPTIONS.FROM_HMODULE) else 0)
            | (if (o.FROM_STRING == 1) @enumToInt(FORMAT_MESSAGE_OPTIONS.FROM_STRING) else 0)
            | (if (o.FROM_SYSTEM == 1) @enumToInt(FORMAT_MESSAGE_OPTIONS.FROM_SYSTEM) else 0)
            | (if (o.IGNORE_INSERTS == 1) @enumToInt(FORMAT_MESSAGE_OPTIONS.IGNORE_INSERTS) else 0)
        );
    }
};
pub const FORMAT_MESSAGE_ALLOCATE_BUFFER = FORMAT_MESSAGE_OPTIONS.ALLOCATE_BUFFER;
pub const FORMAT_MESSAGE_ARGUMENT_ARRAY = FORMAT_MESSAGE_OPTIONS.ARGUMENT_ARRAY;
pub const FORMAT_MESSAGE_FROM_HMODULE = FORMAT_MESSAGE_OPTIONS.FROM_HMODULE;
pub const FORMAT_MESSAGE_FROM_STRING = FORMAT_MESSAGE_OPTIONS.FROM_STRING;
pub const FORMAT_MESSAGE_FROM_SYSTEM = FORMAT_MESSAGE_OPTIONS.FROM_SYSTEM;
pub const FORMAT_MESSAGE_IGNORE_INSERTS = FORMAT_MESSAGE_OPTIONS.IGNORE_INSERTS;

pub const RTL_VIRTUAL_UNWIND_HANDLER_TYPE = enum(u32) {
    NHANDLER = 0,
    EHANDLER = 1,
    UHANDLER = 2,
    CHAININFO = 4,
};
pub const UNW_FLAG_NHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.NHANDLER;
pub const UNW_FLAG_EHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.EHANDLER;
pub const UNW_FLAG_UHANDLER = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.UHANDLER;
pub const UNW_FLAG_CHAININFO = RTL_VIRTUAL_UNWIND_HANDLER_TYPE.CHAININFO;

pub const OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS = enum(u32) {
    G = 1,
};
pub const WCT_ASYNC_OPEN_FLAG = OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS.G;

pub const SYM_SRV_STORE_FILE_FLAGS = enum(u32) {
    COMPRESS = 1,
    OVERWRITE = 2,
    PASS_IF_EXISTS = 64,
    POINTER = 8,
    RETURNINDEX = 4,
};
pub const SYMSTOREOPT_COMPRESS = SYM_SRV_STORE_FILE_FLAGS.COMPRESS;
pub const SYMSTOREOPT_OVERWRITE = SYM_SRV_STORE_FILE_FLAGS.OVERWRITE;
pub const SYMSTOREOPT_PASS_IF_EXISTS = SYM_SRV_STORE_FILE_FLAGS.PASS_IF_EXISTS;
pub const SYMSTOREOPT_POINTER = SYM_SRV_STORE_FILE_FLAGS.POINTER;
pub const SYMSTOREOPT_RETURNINDEX = SYM_SRV_STORE_FILE_FLAGS.RETURNINDEX;

pub const PROCESSOR_ARCHITECTURE = enum(u16) {
    AMD64 = 9,
    IA64 = 6,
    INTEL = 0,
    ARM = 5,
    UNKNOWN = 65535,
};
pub const PROCESSOR_ARCHITECTURE_AMD64 = PROCESSOR_ARCHITECTURE.AMD64;
pub const PROCESSOR_ARCHITECTURE_IA64 = PROCESSOR_ARCHITECTURE.IA64;
pub const PROCESSOR_ARCHITECTURE_INTEL = PROCESSOR_ARCHITECTURE.INTEL;
pub const PROCESSOR_ARCHITECTURE_ARM = PROCESSOR_ARCHITECTURE.ARM;
pub const PROCESSOR_ARCHITECTURE_UNKNOWN = PROCESSOR_ARCHITECTURE.UNKNOWN;

pub const IMAGE_DIRECTORY_ENTRY = enum(u32) {
    ARCHITECTURE = 7,
    BASERELOC = 5,
    BOUND_IMPORT = 11,
    COM_DESCRIPTOR = 14,
    DEBUG = 6,
    DELAY_IMPORT = 13,
    EXCEPTION = 3,
    EXPORT = 0,
    GLOBALPTR = 8,
    IAT = 12,
    IMPORT = 1,
    LOAD_CONFIG = 10,
    RESOURCE = 2,
    SECURITY = 4,
    TLS = 9,
};
pub const IMAGE_DIRECTORY_ENTRY_ARCHITECTURE = IMAGE_DIRECTORY_ENTRY.ARCHITECTURE;
pub const IMAGE_DIRECTORY_ENTRY_BASERELOC = IMAGE_DIRECTORY_ENTRY.BASERELOC;
pub const IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT = IMAGE_DIRECTORY_ENTRY.BOUND_IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR = IMAGE_DIRECTORY_ENTRY.COM_DESCRIPTOR;
pub const IMAGE_DIRECTORY_ENTRY_DEBUG = IMAGE_DIRECTORY_ENTRY.DEBUG;
pub const IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT = IMAGE_DIRECTORY_ENTRY.DELAY_IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_EXCEPTION = IMAGE_DIRECTORY_ENTRY.EXCEPTION;
pub const IMAGE_DIRECTORY_ENTRY_EXPORT = IMAGE_DIRECTORY_ENTRY.EXPORT;
pub const IMAGE_DIRECTORY_ENTRY_GLOBALPTR = IMAGE_DIRECTORY_ENTRY.GLOBALPTR;
pub const IMAGE_DIRECTORY_ENTRY_IAT = IMAGE_DIRECTORY_ENTRY.IAT;
pub const IMAGE_DIRECTORY_ENTRY_IMPORT = IMAGE_DIRECTORY_ENTRY.IMPORT;
pub const IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG = IMAGE_DIRECTORY_ENTRY.LOAD_CONFIG;
pub const IMAGE_DIRECTORY_ENTRY_RESOURCE = IMAGE_DIRECTORY_ENTRY.RESOURCE;
pub const IMAGE_DIRECTORY_ENTRY_SECURITY = IMAGE_DIRECTORY_ENTRY.SECURITY;
pub const IMAGE_DIRECTORY_ENTRY_TLS = IMAGE_DIRECTORY_ENTRY.TLS;

pub const WAIT_CHAIN_THREAD_OPTIONS = enum(u32) {
    COM_FLAG = 2,
    CS_FLAG = 4,
    FLAG = 1,
};
pub const WCT_OUT_OF_PROC_COM_FLAG = WAIT_CHAIN_THREAD_OPTIONS.COM_FLAG;
pub const WCT_OUT_OF_PROC_CS_FLAG = WAIT_CHAIN_THREAD_OPTIONS.CS_FLAG;
pub const WCT_OUT_OF_PROC_FLAG = WAIT_CHAIN_THREAD_OPTIONS.FLAG;

pub const SYM_FIND_ID_OPTION = enum(u32) {
    DWORD = 2,
    DWORDPTR = 4,
    GUIDPTR = 8,
};
pub const SSRVOPT_DWORD = SYM_FIND_ID_OPTION.DWORD;
pub const SSRVOPT_DWORDPTR = SYM_FIND_ID_OPTION.DWORDPTR;
pub const SSRVOPT_GUIDPTR = SYM_FIND_ID_OPTION.GUIDPTR;

pub const IMAGE_FILE_CHARACTERISTICS = enum(u16) {
    RELOCS_STRIPPED = 1,
    EXECUTABLE_IMAGE = 2,
    LINE_NUMS_STRIPPED = 4,
    LOCAL_SYMS_STRIPPED = 8,
    AGGRESIVE_WS_TRIM = 16,
    LARGE_ADDRESS_AWARE = 32,
    BYTES_REVERSED_LO = 128,
    @"32BIT_MACHINE" = 256,
    DEBUG_STRIPPED = 512,
    REMOVABLE_RUN_FROM_SWAP = 1024,
    NET_RUN_FROM_SWAP = 2048,
    SYSTEM = 4096,
    DLL = 8192,
    UP_SYSTEM_ONLY = 16384,
    BYTES_REVERSED_HI = 32768,
    _,
    pub fn initFlags(o: struct {
        RELOCS_STRIPPED: u1 = 0,
        EXECUTABLE_IMAGE: u1 = 0,
        LINE_NUMS_STRIPPED: u1 = 0,
        LOCAL_SYMS_STRIPPED: u1 = 0,
        AGGRESIVE_WS_TRIM: u1 = 0,
        LARGE_ADDRESS_AWARE: u1 = 0,
        BYTES_REVERSED_LO: u1 = 0,
        @"32BIT_MACHINE": u1 = 0,
        DEBUG_STRIPPED: u1 = 0,
        REMOVABLE_RUN_FROM_SWAP: u1 = 0,
        NET_RUN_FROM_SWAP: u1 = 0,
        SYSTEM: u1 = 0,
        DLL: u1 = 0,
        UP_SYSTEM_ONLY: u1 = 0,
        BYTES_REVERSED_HI: u1 = 0,
    }) IMAGE_FILE_CHARACTERISTICS {
        return @intToEnum(IMAGE_FILE_CHARACTERISTICS,
              (if (o.RELOCS_STRIPPED == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.RELOCS_STRIPPED) else 0)
            | (if (o.EXECUTABLE_IMAGE == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.EXECUTABLE_IMAGE) else 0)
            | (if (o.LINE_NUMS_STRIPPED == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.LINE_NUMS_STRIPPED) else 0)
            | (if (o.LOCAL_SYMS_STRIPPED == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.LOCAL_SYMS_STRIPPED) else 0)
            | (if (o.AGGRESIVE_WS_TRIM == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.AGGRESIVE_WS_TRIM) else 0)
            | (if (o.LARGE_ADDRESS_AWARE == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.LARGE_ADDRESS_AWARE) else 0)
            | (if (o.BYTES_REVERSED_LO == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_LO) else 0)
            | (if (o.@"32BIT_MACHINE" == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.@"32BIT_MACHINE") else 0)
            | (if (o.DEBUG_STRIPPED == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.DEBUG_STRIPPED) else 0)
            | (if (o.REMOVABLE_RUN_FROM_SWAP == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.REMOVABLE_RUN_FROM_SWAP) else 0)
            | (if (o.NET_RUN_FROM_SWAP == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.NET_RUN_FROM_SWAP) else 0)
            | (if (o.SYSTEM == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.SYSTEM) else 0)
            | (if (o.DLL == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.DLL) else 0)
            | (if (o.UP_SYSTEM_ONLY == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.UP_SYSTEM_ONLY) else 0)
            | (if (o.BYTES_REVERSED_HI == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_HI) else 0)
        );
    }
};
pub const IMAGE_FILE_RELOCS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.RELOCS_STRIPPED;
pub const IMAGE_FILE_EXECUTABLE_IMAGE = IMAGE_FILE_CHARACTERISTICS.EXECUTABLE_IMAGE;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.LINE_NUMS_STRIPPED;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED = IMAGE_FILE_CHARACTERISTICS.LOCAL_SYMS_STRIPPED;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM = IMAGE_FILE_CHARACTERISTICS.AGGRESIVE_WS_TRIM;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE = IMAGE_FILE_CHARACTERISTICS.LARGE_ADDRESS_AWARE;
pub const IMAGE_FILE_BYTES_REVERSED_LO = IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_LO;
pub const IMAGE_FILE_32BIT_MACHINE = IMAGE_FILE_CHARACTERISTICS.@"32BIT_MACHINE";
pub const IMAGE_FILE_DEBUG_STRIPPED = IMAGE_FILE_CHARACTERISTICS.DEBUG_STRIPPED;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP = IMAGE_FILE_CHARACTERISTICS.REMOVABLE_RUN_FROM_SWAP;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP = IMAGE_FILE_CHARACTERISTICS.NET_RUN_FROM_SWAP;
pub const IMAGE_FILE_SYSTEM = IMAGE_FILE_CHARACTERISTICS.SYSTEM;
pub const IMAGE_FILE_DLL = IMAGE_FILE_CHARACTERISTICS.DLL;
pub const IMAGE_FILE_UP_SYSTEM_ONLY = IMAGE_FILE_CHARACTERISTICS.UP_SYSTEM_ONLY;
pub const IMAGE_FILE_BYTES_REVERSED_HI = IMAGE_FILE_CHARACTERISTICS.BYTES_REVERSED_HI;

pub const IMAGE_FILE_CHARACTERISTICS2 = enum(u32) {
    RELOCS_STRIPPED2 = 1,
    EXECUTABLE_IMAGE2 = 2,
    LINE_NUMS_STRIPPED2 = 4,
    LOCAL_SYMS_STRIPPED2 = 8,
    AGGRESIVE_WS_TRIM2 = 16,
    LARGE_ADDRESS_AWARE2 = 32,
    BYTES_REVERSED_LO2 = 128,
    @"32BIT_MACHINE2" = 256,
    DEBUG_STRIPPED2 = 512,
    REMOVABLE_RUN_FROM_SWAP2 = 1024,
    NET_RUN_FROM_SWAP2 = 2048,
    SYSTEM_2 = 4096,
    DLL_2 = 8192,
    UP_SYSTEM_ONLY_2 = 16384,
    BYTES_REVERSED_HI_2 = 32768,
    _,
    pub fn initFlags(o: struct {
        RELOCS_STRIPPED2: u1 = 0,
        EXECUTABLE_IMAGE2: u1 = 0,
        LINE_NUMS_STRIPPED2: u1 = 0,
        LOCAL_SYMS_STRIPPED2: u1 = 0,
        AGGRESIVE_WS_TRIM2: u1 = 0,
        LARGE_ADDRESS_AWARE2: u1 = 0,
        BYTES_REVERSED_LO2: u1 = 0,
        @"32BIT_MACHINE2": u1 = 0,
        DEBUG_STRIPPED2: u1 = 0,
        REMOVABLE_RUN_FROM_SWAP2: u1 = 0,
        NET_RUN_FROM_SWAP2: u1 = 0,
        SYSTEM_2: u1 = 0,
        DLL_2: u1 = 0,
        UP_SYSTEM_ONLY_2: u1 = 0,
        BYTES_REVERSED_HI_2: u1 = 0,
    }) IMAGE_FILE_CHARACTERISTICS2 {
        return @intToEnum(IMAGE_FILE_CHARACTERISTICS2,
              (if (o.RELOCS_STRIPPED2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.RELOCS_STRIPPED2) else 0)
            | (if (o.EXECUTABLE_IMAGE2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.EXECUTABLE_IMAGE2) else 0)
            | (if (o.LINE_NUMS_STRIPPED2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.LINE_NUMS_STRIPPED2) else 0)
            | (if (o.LOCAL_SYMS_STRIPPED2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.LOCAL_SYMS_STRIPPED2) else 0)
            | (if (o.AGGRESIVE_WS_TRIM2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.AGGRESIVE_WS_TRIM2) else 0)
            | (if (o.LARGE_ADDRESS_AWARE2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.LARGE_ADDRESS_AWARE2) else 0)
            | (if (o.BYTES_REVERSED_LO2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_LO2) else 0)
            | (if (o.@"32BIT_MACHINE2" == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.@"32BIT_MACHINE2") else 0)
            | (if (o.DEBUG_STRIPPED2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.DEBUG_STRIPPED2) else 0)
            | (if (o.REMOVABLE_RUN_FROM_SWAP2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.REMOVABLE_RUN_FROM_SWAP2) else 0)
            | (if (o.NET_RUN_FROM_SWAP2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.NET_RUN_FROM_SWAP2) else 0)
            | (if (o.SYSTEM_2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.SYSTEM_2) else 0)
            | (if (o.DLL_2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.DLL_2) else 0)
            | (if (o.UP_SYSTEM_ONLY_2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.UP_SYSTEM_ONLY_2) else 0)
            | (if (o.BYTES_REVERSED_HI_2 == 1) @enumToInt(IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_HI_2) else 0)
        );
    }
};
pub const IMAGE_FILE_RELOCS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.RELOCS_STRIPPED2;
pub const IMAGE_FILE_EXECUTABLE_IMAGE2 = IMAGE_FILE_CHARACTERISTICS2.EXECUTABLE_IMAGE2;
pub const IMAGE_FILE_LINE_NUMS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.LINE_NUMS_STRIPPED2;
pub const IMAGE_FILE_LOCAL_SYMS_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.LOCAL_SYMS_STRIPPED2;
pub const IMAGE_FILE_AGGRESIVE_WS_TRIM2 = IMAGE_FILE_CHARACTERISTICS2.AGGRESIVE_WS_TRIM2;
pub const IMAGE_FILE_LARGE_ADDRESS_AWARE2 = IMAGE_FILE_CHARACTERISTICS2.LARGE_ADDRESS_AWARE2;
pub const IMAGE_FILE_BYTES_REVERSED_LO2 = IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_LO2;
pub const IMAGE_FILE_32BIT_MACHINE2 = IMAGE_FILE_CHARACTERISTICS2.@"32BIT_MACHINE2";
pub const IMAGE_FILE_DEBUG_STRIPPED2 = IMAGE_FILE_CHARACTERISTICS2.DEBUG_STRIPPED2;
pub const IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP2 = IMAGE_FILE_CHARACTERISTICS2.REMOVABLE_RUN_FROM_SWAP2;
pub const IMAGE_FILE_NET_RUN_FROM_SWAP2 = IMAGE_FILE_CHARACTERISTICS2.NET_RUN_FROM_SWAP2;
pub const IMAGE_FILE_SYSTEM_2 = IMAGE_FILE_CHARACTERISTICS2.SYSTEM_2;
pub const IMAGE_FILE_DLL_2 = IMAGE_FILE_CHARACTERISTICS2.DLL_2;
pub const IMAGE_FILE_UP_SYSTEM_ONLY_2 = IMAGE_FILE_CHARACTERISTICS2.UP_SYSTEM_ONLY_2;
pub const IMAGE_FILE_BYTES_REVERSED_HI_2 = IMAGE_FILE_CHARACTERISTICS2.BYTES_REVERSED_HI_2;

pub const SYMBOL_INFO_FLAGS = enum(u32) {
    CLR_TOKEN = 262144,
    CONSTANT = 256,
    EXPORT = 512,
    FORWARDER = 1024,
    FRAMEREL = 32,
    FUNCTION = 2048,
    ILREL = 65536,
    LOCAL = 128,
    METADATA = 131072,
    PARAMETER = 64,
    REGISTER = 8,
    REGREL = 16,
    SLOT = 32768,
    THUNK = 8192,
    TLSREL = 16384,
    VALUEPRESENT = 1,
    VIRTUAL = 4096,
    _,
    pub fn initFlags(o: struct {
        CLR_TOKEN: u1 = 0,
        CONSTANT: u1 = 0,
        EXPORT: u1 = 0,
        FORWARDER: u1 = 0,
        FRAMEREL: u1 = 0,
        FUNCTION: u1 = 0,
        ILREL: u1 = 0,
        LOCAL: u1 = 0,
        METADATA: u1 = 0,
        PARAMETER: u1 = 0,
        REGISTER: u1 = 0,
        REGREL: u1 = 0,
        SLOT: u1 = 0,
        THUNK: u1 = 0,
        TLSREL: u1 = 0,
        VALUEPRESENT: u1 = 0,
        VIRTUAL: u1 = 0,
    }) SYMBOL_INFO_FLAGS {
        return @intToEnum(SYMBOL_INFO_FLAGS,
              (if (o.CLR_TOKEN == 1) @enumToInt(SYMBOL_INFO_FLAGS.CLR_TOKEN) else 0)
            | (if (o.CONSTANT == 1) @enumToInt(SYMBOL_INFO_FLAGS.CONSTANT) else 0)
            | (if (o.EXPORT == 1) @enumToInt(SYMBOL_INFO_FLAGS.EXPORT) else 0)
            | (if (o.FORWARDER == 1) @enumToInt(SYMBOL_INFO_FLAGS.FORWARDER) else 0)
            | (if (o.FRAMEREL == 1) @enumToInt(SYMBOL_INFO_FLAGS.FRAMEREL) else 0)
            | (if (o.FUNCTION == 1) @enumToInt(SYMBOL_INFO_FLAGS.FUNCTION) else 0)
            | (if (o.ILREL == 1) @enumToInt(SYMBOL_INFO_FLAGS.ILREL) else 0)
            | (if (o.LOCAL == 1) @enumToInt(SYMBOL_INFO_FLAGS.LOCAL) else 0)
            | (if (o.METADATA == 1) @enumToInt(SYMBOL_INFO_FLAGS.METADATA) else 0)
            | (if (o.PARAMETER == 1) @enumToInt(SYMBOL_INFO_FLAGS.PARAMETER) else 0)
            | (if (o.REGISTER == 1) @enumToInt(SYMBOL_INFO_FLAGS.REGISTER) else 0)
            | (if (o.REGREL == 1) @enumToInt(SYMBOL_INFO_FLAGS.REGREL) else 0)
            | (if (o.SLOT == 1) @enumToInt(SYMBOL_INFO_FLAGS.SLOT) else 0)
            | (if (o.THUNK == 1) @enumToInt(SYMBOL_INFO_FLAGS.THUNK) else 0)
            | (if (o.TLSREL == 1) @enumToInt(SYMBOL_INFO_FLAGS.TLSREL) else 0)
            | (if (o.VALUEPRESENT == 1) @enumToInt(SYMBOL_INFO_FLAGS.VALUEPRESENT) else 0)
            | (if (o.VIRTUAL == 1) @enumToInt(SYMBOL_INFO_FLAGS.VIRTUAL) else 0)
        );
    }
};
pub const SYMFLAG_CLR_TOKEN = SYMBOL_INFO_FLAGS.CLR_TOKEN;
pub const SYMFLAG_CONSTANT = SYMBOL_INFO_FLAGS.CONSTANT;
pub const SYMFLAG_EXPORT = SYMBOL_INFO_FLAGS.EXPORT;
pub const SYMFLAG_FORWARDER = SYMBOL_INFO_FLAGS.FORWARDER;
pub const SYMFLAG_FRAMEREL = SYMBOL_INFO_FLAGS.FRAMEREL;
pub const SYMFLAG_FUNCTION = SYMBOL_INFO_FLAGS.FUNCTION;
pub const SYMFLAG_ILREL = SYMBOL_INFO_FLAGS.ILREL;
pub const SYMFLAG_LOCAL = SYMBOL_INFO_FLAGS.LOCAL;
pub const SYMFLAG_METADATA = SYMBOL_INFO_FLAGS.METADATA;
pub const SYMFLAG_PARAMETER = SYMBOL_INFO_FLAGS.PARAMETER;
pub const SYMFLAG_REGISTER = SYMBOL_INFO_FLAGS.REGISTER;
pub const SYMFLAG_REGREL = SYMBOL_INFO_FLAGS.REGREL;
pub const SYMFLAG_SLOT = SYMBOL_INFO_FLAGS.SLOT;
pub const SYMFLAG_THUNK = SYMBOL_INFO_FLAGS.THUNK;
pub const SYMFLAG_TLSREL = SYMBOL_INFO_FLAGS.TLSREL;
pub const SYMFLAG_VALUEPRESENT = SYMBOL_INFO_FLAGS.VALUEPRESENT;
pub const SYMFLAG_VIRTUAL = SYMBOL_INFO_FLAGS.VIRTUAL;

pub const IMAGEHLP_CBA_EVENT_SEVERITY = enum(u32) {
    Info = 0,
    Problem = 1,
    Attn = 2,
    Fatal = 3,
};
// TODO: enum 'IMAGEHLP_CBA_EVENT_SEVERITY' has known issues with its value aliases

pub const IMAGEHLP_GET_TYPE_INFO_FLAGS = enum(u32) {
    CHILDREN = 2,
    UNCACHED = 1,
};
pub const IMAGEHLP_GET_TYPE_INFO_CHILDREN = IMAGEHLP_GET_TYPE_INFO_FLAGS.CHILDREN;
pub const IMAGEHLP_GET_TYPE_INFO_UNCACHED = IMAGEHLP_GET_TYPE_INFO_FLAGS.UNCACHED;

pub const RIP_INFO_TYPE = enum(u32) {
    ERROR = 1,
    MINORERROR = 2,
    WARNING = 3,
};
pub const SLE_ERROR = RIP_INFO_TYPE.ERROR;
pub const SLE_MINORERROR = RIP_INFO_TYPE.MINORERROR;
pub const SLE_WARNING = RIP_INFO_TYPE.WARNING;

pub const VER_PLATFORM = enum(u32) {
    s = 0,
    _WINDOWS = 1,
    _NT = 2,
};
pub const VER_PLATFORM_WIN32s = VER_PLATFORM.s;
pub const VER_PLATFORM_WIN32_WINDOWS = VER_PLATFORM._WINDOWS;
pub const VER_PLATFORM_WIN32_NT = VER_PLATFORM._NT;

pub const IMAGE_DEBUG_TYPE = enum(u32) {
    UNKNOWN = 0,
    COFF = 1,
    CODEVIEW = 2,
    FPO = 3,
    MISC = 4,
    EXCEPTION = 5,
    FIXUP = 6,
    BORLAND = 9,
};
pub const IMAGE_DEBUG_TYPE_UNKNOWN = IMAGE_DEBUG_TYPE.UNKNOWN;
pub const IMAGE_DEBUG_TYPE_COFF = IMAGE_DEBUG_TYPE.COFF;
pub const IMAGE_DEBUG_TYPE_CODEVIEW = IMAGE_DEBUG_TYPE.CODEVIEW;
pub const IMAGE_DEBUG_TYPE_FPO = IMAGE_DEBUG_TYPE.FPO;
pub const IMAGE_DEBUG_TYPE_MISC = IMAGE_DEBUG_TYPE.MISC;
pub const IMAGE_DEBUG_TYPE_EXCEPTION = IMAGE_DEBUG_TYPE.EXCEPTION;
pub const IMAGE_DEBUG_TYPE_FIXUP = IMAGE_DEBUG_TYPE.FIXUP;
pub const IMAGE_DEBUG_TYPE_BORLAND = IMAGE_DEBUG_TYPE.BORLAND;

pub const MINIDUMP_THREAD_INFO_DUMP_FLAGS = enum(u32) {
    ERROR_THREAD = 1,
    EXITED_THREAD = 4,
    INVALID_CONTEXT = 16,
    INVALID_INFO = 8,
    INVALID_TEB = 32,
    WRITING_THREAD = 2,
};
pub const MINIDUMP_THREAD_INFO_ERROR_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.ERROR_THREAD;
pub const MINIDUMP_THREAD_INFO_EXITED_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.EXITED_THREAD;
pub const MINIDUMP_THREAD_INFO_INVALID_CONTEXT = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_CONTEXT;
pub const MINIDUMP_THREAD_INFO_INVALID_INFO = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_INFO;
pub const MINIDUMP_THREAD_INFO_INVALID_TEB = MINIDUMP_THREAD_INFO_DUMP_FLAGS.INVALID_TEB;
pub const MINIDUMP_THREAD_INFO_WRITING_THREAD = MINIDUMP_THREAD_INFO_DUMP_FLAGS.WRITING_THREAD;

pub const DEBUG_EVENT_CODE = enum(u32) {
    CREATE_PROCESS_DEBUG_EVENT = 3,
    CREATE_THREAD_DEBUG_EVENT = 2,
    EXCEPTION_DEBUG_EVENT = 1,
    EXIT_PROCESS_DEBUG_EVENT = 5,
    EXIT_THREAD_DEBUG_EVENT = 4,
    LOAD_DLL_DEBUG_EVENT = 6,
    OUTPUT_DEBUG_STRING_EVENT = 8,
    RIP_EVENT = 9,
    UNLOAD_DLL_DEBUG_EVENT = 7,
};
pub const CREATE_PROCESS_DEBUG_EVENT = DEBUG_EVENT_CODE.CREATE_PROCESS_DEBUG_EVENT;
pub const CREATE_THREAD_DEBUG_EVENT = DEBUG_EVENT_CODE.CREATE_THREAD_DEBUG_EVENT;
pub const EXCEPTION_DEBUG_EVENT = DEBUG_EVENT_CODE.EXCEPTION_DEBUG_EVENT;
pub const EXIT_PROCESS_DEBUG_EVENT = DEBUG_EVENT_CODE.EXIT_PROCESS_DEBUG_EVENT;
pub const EXIT_THREAD_DEBUG_EVENT = DEBUG_EVENT_CODE.EXIT_THREAD_DEBUG_EVENT;
pub const LOAD_DLL_DEBUG_EVENT = DEBUG_EVENT_CODE.LOAD_DLL_DEBUG_EVENT;
pub const OUTPUT_DEBUG_STRING_EVENT = DEBUG_EVENT_CODE.OUTPUT_DEBUG_STRING_EVENT;
pub const RIP_EVENT = DEBUG_EVENT_CODE.RIP_EVENT;
pub const UNLOAD_DLL_DEBUG_EVENT = DEBUG_EVENT_CODE.UNLOAD_DLL_DEBUG_EVENT;

pub const MINIDUMP_MISC_INFO_FLAGS = enum(u32) {
    ID = 1,
    TIMES = 2,
    _,
    pub fn initFlags(o: struct {
        ID: u1 = 0,
        TIMES: u1 = 0,
    }) MINIDUMP_MISC_INFO_FLAGS {
        return @intToEnum(MINIDUMP_MISC_INFO_FLAGS,
              (if (o.ID == 1) @enumToInt(MINIDUMP_MISC_INFO_FLAGS.ID) else 0)
            | (if (o.TIMES == 1) @enumToInt(MINIDUMP_MISC_INFO_FLAGS.TIMES) else 0)
        );
    }
};
pub const MINIDUMP_MISC1_PROCESS_ID = MINIDUMP_MISC_INFO_FLAGS.ID;
pub const MINIDUMP_MISC1_PROCESS_TIMES = MINIDUMP_MISC_INFO_FLAGS.TIMES;

pub const MODLOAD_DATA_TYPE = enum(u32) {
    DEBUGDIRS = 1,
    CVMISC = 2,
};
pub const DBHHEADER_DEBUGDIRS = MODLOAD_DATA_TYPE.DEBUGDIRS;
pub const DBHHEADER_CVMISC = MODLOAD_DATA_TYPE.CVMISC;










pub const LDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: extern union {
        Bytes: extern struct {
            BaseMid: u8,
            Flags1: u8,
            Flags2: u8,
            BaseHi: u8,
        },
        Bits: extern struct {
            _bitfield: u32,
        },
    },
};

pub const WOW64_FLOATING_SAVE_AREA = extern struct {
    ControlWord: u32,
    StatusWord: u32,
    TagWord: u32,
    ErrorOffset: u32,
    ErrorSelector: u32,
    DataOffset: u32,
    DataSelector: u32,
    RegisterArea: [80]u8,
    Cr0NpxState: u32,
};

pub const WOW64_CONTEXT = extern struct {
    ContextFlags: u32,
    Dr0: u32,
    Dr1: u32,
    Dr2: u32,
    Dr3: u32,
    Dr6: u32,
    Dr7: u32,
    FloatSave: WOW64_FLOATING_SAVE_AREA,
    SegGs: u32,
    SegFs: u32,
    SegEs: u32,
    SegDs: u32,
    Edi: u32,
    Esi: u32,
    Ebx: u32,
    Edx: u32,
    Ecx: u32,
    Eax: u32,
    Ebp: u32,
    Eip: u32,
    SegCs: u32,
    EFlags: u32,
    Esp: u32,
    SegSs: u32,
    ExtendedRegisters: [512]u8,
};

pub const WOW64_LDT_ENTRY = extern struct {
    LimitLow: u16,
    BaseLow: u16,
    HighWord: extern union {
        Bytes: extern struct {
            BaseMid: u8,
            Flags1: u8,
            Flags2: u8,
            BaseHi: u8,
        },
        Bits: extern struct {
            _bitfield: u32,
        },
    },
};

pub const WOW64_DESCRIPTOR_TABLE_ENTRY = extern struct {
    Selector: u32,
    Descriptor: WOW64_LDT_ENTRY,
};

pub const EXCEPTION_RECORD = extern struct {
    ExceptionCode: NTSTATUS,
    ExceptionFlags: u32,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ExceptionAddress: ?*c_void,
    NumberParameters: u32,
    ExceptionInformation: [15]usize,
};

pub const EXCEPTION_RECORD64 = extern struct {
    ExceptionCode: NTSTATUS,
    ExceptionFlags: u32,
    ExceptionRecord: u64,
    ExceptionAddress: u64,
    NumberParameters: u32,
    __unusedAlignment: u32,
    ExceptionInformation: [15]u64,
};

pub const EXCEPTION_POINTERS = extern struct {
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ContextRecord: ?*CONTEXT,
};

pub const IMAGE_FILE_HEADER = extern struct {
    Machine: IMAGE_FILE_MACHINE,
    NumberOfSections: u16,
    TimeDateStamp: u32,
    PointerToSymbolTable: u32,
    NumberOfSymbols: u32,
    SizeOfOptionalHeader: u16,
    Characteristics: IMAGE_FILE_CHARACTERISTICS,
};

pub const IMAGE_DATA_DIRECTORY = extern struct {
    VirtualAddress: u32,
    Size: u32,
};

pub const IMAGE_OPTIONAL_HEADER32 = extern struct {
    Magic: IMAGE_OPTIONAL_HEADER_MAGIC,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    BaseOfData: u32,
    ImageBase: u32,
    SectionAlignment: u32,
    FileAlignment: u32,
    MajorOperatingSystemVersion: u16,
    MinorOperatingSystemVersion: u16,
    MajorImageVersion: u16,
    MinorImageVersion: u16,
    MajorSubsystemVersion: u16,
    MinorSubsystemVersion: u16,
    Win32VersionValue: u32,
    SizeOfImage: u32,
    SizeOfHeaders: u32,
    CheckSum: u32,
    Subsystem: IMAGE_SUBSYSTEM,
    DllCharacteristics: IMAGE_DLL_CHARACTERISTICS,
    SizeOfStackReserve: u32,
    SizeOfStackCommit: u32,
    SizeOfHeapReserve: u32,
    SizeOfHeapCommit: u32,
    /// Deprecated
    LoaderFlags: u32,
    NumberOfRvaAndSizes: u32,
    DataDirectory: [16]IMAGE_DATA_DIRECTORY,
};

pub const IMAGE_OPTIONAL_HEADER64 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Magic: IMAGE_OPTIONAL_HEADER_MAGIC,
    MajorLinkerVersion: u8,
    MinorLinkerVersion: u8,
    SizeOfCode: u32,
    SizeOfInitializedData: u32,
    SizeOfUninitializedData: u32,
    AddressOfEntryPoint: u32,
    BaseOfCode: u32,
    ImageBase: u64,
    SectionAlignment: u32,
    FileAlignment: u32,
    MajorOperatingSystemVersion: u16,
    MinorOperatingSystemVersion: u16,
    MajorImageVersion: u16,
    MinorImageVersion: u16,
    MajorSubsystemVersion: u16,
    MinorSubsystemVersion: u16,
    Win32VersionValue: u32,
    SizeOfImage: u32,
    SizeOfHeaders: u32,
    CheckSum: u32,
    Subsystem: IMAGE_SUBSYSTEM,
    DllCharacteristics: IMAGE_DLL_CHARACTERISTICS,
    SizeOfStackReserve: u64,
    SizeOfStackCommit: u64,
    SizeOfHeapReserve: u64,
    SizeOfHeapCommit: u64,
    /// Deprecated
    LoaderFlags: u32,
    NumberOfRvaAndSizes: u32,
    DataDirectory: [16]IMAGE_DATA_DIRECTORY,
};

pub const IMAGE_NT_HEADERS64 = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER64,
};

pub const IMAGE_NT_HEADERS32 = extern struct {
    Signature: u32,
    FileHeader: IMAGE_FILE_HEADER,
    OptionalHeader: IMAGE_OPTIONAL_HEADER32,
};

pub const IMAGE_SECTION_HEADER = extern struct {
    Name: [8]u8,
    Misc: extern union {
        PhysicalAddress: u32,
        VirtualSize: u32,
    },
    VirtualAddress: u32,
    SizeOfRawData: u32,
    PointerToRawData: u32,
    PointerToRelocations: u32,
    PointerToLinenumbers: u32,
    NumberOfRelocations: u16,
    NumberOfLinenumbers: u16,
    Characteristics: IMAGE_SECTION_CHARACTERISTICS,
};

pub const IMAGE_LOAD_CONFIG_DIRECTORY32 = extern struct {
    Size: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    GlobalFlagsClear: u32,
    GlobalFlagsSet: u32,
    CriticalSectionDefaultTimeout: u32,
    DeCommitFreeBlockThreshold: u32,
    DeCommitTotalFreeThreshold: u32,
    LockPrefixTable: u32,
    MaximumAllocationSize: u32,
    VirtualMemoryThreshold: u32,
    ProcessHeapFlags: u32,
    ProcessAffinityMask: u32,
    CSDVersion: u16,
    DependentLoadFlags: u16,
    EditList: u32,
    SecurityCookie: u32,
    SEHandlerTable: u32,
    SEHandlerCount: u32,
    GuardCFCheckFunctionPointer: u32,
    GuardCFDispatchFunctionPointer: u32,
    GuardCFFunctionTable: u32,
    GuardCFFunctionCount: u32,
    GuardFlags: u32,
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    GuardAddressTakenIatEntryTable: u32,
    GuardAddressTakenIatEntryCount: u32,
    GuardLongJumpTargetTable: u32,
    GuardLongJumpTargetCount: u32,
    DynamicValueRelocTable: u32,
    CHPEMetadataPointer: u32,
    GuardRFFailureRoutine: u32,
    GuardRFFailureRoutineFunctionPointer: u32,
    DynamicValueRelocTableOffset: u32,
    DynamicValueRelocTableSection: u16,
    Reserved2: u16,
    GuardRFVerifyStackPointerFunctionPointer: u32,
    HotPatchTableOffset: u32,
    Reserved3: u32,
    EnclaveConfigurationPointer: u32,
    VolatileMetadataPointer: u32,
    GuardEHContinuationTable: u32,
    GuardEHContinuationCount: u32,
};

pub const IMAGE_LOAD_CONFIG_DIRECTORY64 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Size: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    GlobalFlagsClear: u32,
    GlobalFlagsSet: u32,
    CriticalSectionDefaultTimeout: u32,
    DeCommitFreeBlockThreshold: u64,
    DeCommitTotalFreeThreshold: u64,
    LockPrefixTable: u64,
    MaximumAllocationSize: u64,
    VirtualMemoryThreshold: u64,
    ProcessAffinityMask: u64,
    ProcessHeapFlags: u32,
    CSDVersion: u16,
    DependentLoadFlags: u16,
    EditList: u64,
    SecurityCookie: u64,
    SEHandlerTable: u64,
    SEHandlerCount: u64,
    GuardCFCheckFunctionPointer: u64,
    GuardCFDispatchFunctionPointer: u64,
    GuardCFFunctionTable: u64,
    GuardCFFunctionCount: u64,
    GuardFlags: u32,
    CodeIntegrity: IMAGE_LOAD_CONFIG_CODE_INTEGRITY,
    GuardAddressTakenIatEntryTable: u64,
    GuardAddressTakenIatEntryCount: u64,
    GuardLongJumpTargetTable: u64,
    GuardLongJumpTargetCount: u64,
    DynamicValueRelocTable: u64,
    CHPEMetadataPointer: u64,
    GuardRFFailureRoutine: u64,
    GuardRFFailureRoutineFunctionPointer: u64,
    DynamicValueRelocTableOffset: u32,
    DynamicValueRelocTableSection: u16,
    Reserved2: u16,
    GuardRFVerifyStackPointerFunctionPointer: u64,
    HotPatchTableOffset: u32,
    Reserved3: u32,
    EnclaveConfigurationPointer: u64,
    VolatileMetadataPointer: u64,
    GuardEHContinuationTable: u64,
    GuardEHContinuationCount: u64,
};

pub const IMAGE_DEBUG_DIRECTORY = extern struct {
    Characteristics: u32,
    TimeDateStamp: u32,
    MajorVersion: u16,
    MinorVersion: u16,
    Type: IMAGE_DEBUG_TYPE,
    SizeOfData: u32,
    AddressOfRawData: u32,
    PointerToRawData: u32,
};

pub const IMAGE_COFF_SYMBOLS_HEADER = extern struct {
    NumberOfSymbols: u32,
    LvaToFirstSymbol: u32,
    NumberOfLinenumbers: u32,
    LvaToFirstLinenumber: u32,
    RvaToFirstByteOfCode: u32,
    RvaToLastByteOfCode: u32,
    RvaToFirstByteOfData: u32,
    RvaToLastByteOfData: u32,
};

pub const FPO_DATA = extern struct {
    ulOffStart: u32,
    cbProcSize: u32,
    cdwLocals: u32,
    cdwParams: u16,
    _bitfield: u16,
};

pub const IMAGE_FUNCTION_ENTRY = extern struct {
    StartingAddress: u32,
    EndingAddress: u32,
    EndOfPrologue: u32,
};

pub const IMAGE_FUNCTION_ENTRY64 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    StartingAddress: u64,
    EndingAddress: u64,
    Anonymous: extern union {
        // WARNING: unable to add field alignment because it's not implemented for unions
        EndOfPrologue: u64,
        UnwindInfoAddress: u64,
    },
};

pub const PVECTORED_EXCEPTION_HANDLER = fn(
    ExceptionInfo: ?*EXCEPTION_POINTERS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const EXCEPTION_DEBUG_INFO = extern struct {
    ExceptionRecord: EXCEPTION_RECORD,
    dwFirstChance: u32,
};

pub const CREATE_THREAD_DEBUG_INFO = extern struct {
    hThread: ?HANDLE,
    lpThreadLocalBase: ?*c_void,
    lpStartAddress: ?LPTHREAD_START_ROUTINE,
};

pub const CREATE_PROCESS_DEBUG_INFO = extern struct {
    hFile: ?HANDLE,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    lpBaseOfImage: ?*c_void,
    dwDebugInfoFileOffset: u32,
    nDebugInfoSize: u32,
    lpThreadLocalBase: ?*c_void,
    lpStartAddress: ?LPTHREAD_START_ROUTINE,
    lpImageName: ?*c_void,
    fUnicode: u16,
};

pub const EXIT_THREAD_DEBUG_INFO = extern struct {
    dwExitCode: u32,
};

pub const EXIT_PROCESS_DEBUG_INFO = extern struct {
    dwExitCode: u32,
};

pub const LOAD_DLL_DEBUG_INFO = extern struct {
    hFile: ?HANDLE,
    lpBaseOfDll: ?*c_void,
    dwDebugInfoFileOffset: u32,
    nDebugInfoSize: u32,
    lpImageName: ?*c_void,
    fUnicode: u16,
};

pub const UNLOAD_DLL_DEBUG_INFO = extern struct {
    lpBaseOfDll: ?*c_void,
};

pub const OUTPUT_DEBUG_STRING_INFO = extern struct {
    lpDebugStringData: ?PSTR,
    fUnicode: u16,
    nDebugStringLength: u16,
};

pub const RIP_INFO = extern struct {
    dwError: u32,
    dwType: RIP_INFO_TYPE,
};

pub const DEBUG_EVENT = extern struct {
    dwDebugEventCode: DEBUG_EVENT_CODE,
    dwProcessId: u32,
    dwThreadId: u32,
    u: extern union {
        Exception: EXCEPTION_DEBUG_INFO,
        CreateThread: CREATE_THREAD_DEBUG_INFO,
        CreateProcessInfo: CREATE_PROCESS_DEBUG_INFO,
        ExitThread: EXIT_THREAD_DEBUG_INFO,
        ExitProcess: EXIT_PROCESS_DEBUG_INFO,
        LoadDll: LOAD_DLL_DEBUG_INFO,
        UnloadDll: UNLOAD_DLL_DEBUG_INFO,
        DebugString: OUTPUT_DEBUG_STRING_INFO,
        RipInfo: RIP_INFO,
    },
};

pub const LPTOP_LEVEL_EXCEPTION_FILTER = fn(
    ExceptionInfo: ?*EXCEPTION_POINTERS,
) callconv(@import("std").os.windows.WINAPI) i32;

pub const WCT_OBJECT_TYPE = enum(i32) {
    CriticalSectionType = 1,
    SendMessageType = 2,
    MutexType = 3,
    AlpcType = 4,
    ComType = 5,
    ThreadWaitType = 6,
    ProcessWaitType = 7,
    ThreadType = 8,
    ComActivationType = 9,
    UnknownType = 10,
    SocketIoType = 11,
    SmbIoType = 12,
    MaxType = 13,
};
pub const WctCriticalSectionType = WCT_OBJECT_TYPE.CriticalSectionType;
pub const WctSendMessageType = WCT_OBJECT_TYPE.SendMessageType;
pub const WctMutexType = WCT_OBJECT_TYPE.MutexType;
pub const WctAlpcType = WCT_OBJECT_TYPE.AlpcType;
pub const WctComType = WCT_OBJECT_TYPE.ComType;
pub const WctThreadWaitType = WCT_OBJECT_TYPE.ThreadWaitType;
pub const WctProcessWaitType = WCT_OBJECT_TYPE.ProcessWaitType;
pub const WctThreadType = WCT_OBJECT_TYPE.ThreadType;
pub const WctComActivationType = WCT_OBJECT_TYPE.ComActivationType;
pub const WctUnknownType = WCT_OBJECT_TYPE.UnknownType;
pub const WctSocketIoType = WCT_OBJECT_TYPE.SocketIoType;
pub const WctSmbIoType = WCT_OBJECT_TYPE.SmbIoType;
pub const WctMaxType = WCT_OBJECT_TYPE.MaxType;

pub const WCT_OBJECT_STATUS = enum(i32) {
    NoAccess = 1,
    Running = 2,
    Blocked = 3,
    PidOnly = 4,
    PidOnlyRpcss = 5,
    Owned = 6,
    NotOwned = 7,
    Abandoned = 8,
    Unknown = 9,
    Error = 10,
    Max = 11,
};
pub const WctStatusNoAccess = WCT_OBJECT_STATUS.NoAccess;
pub const WctStatusRunning = WCT_OBJECT_STATUS.Running;
pub const WctStatusBlocked = WCT_OBJECT_STATUS.Blocked;
pub const WctStatusPidOnly = WCT_OBJECT_STATUS.PidOnly;
pub const WctStatusPidOnlyRpcss = WCT_OBJECT_STATUS.PidOnlyRpcss;
pub const WctStatusOwned = WCT_OBJECT_STATUS.Owned;
pub const WctStatusNotOwned = WCT_OBJECT_STATUS.NotOwned;
pub const WctStatusAbandoned = WCT_OBJECT_STATUS.Abandoned;
pub const WctStatusUnknown = WCT_OBJECT_STATUS.Unknown;
pub const WctStatusError = WCT_OBJECT_STATUS.Error;
pub const WctStatusMax = WCT_OBJECT_STATUS.Max;

pub const WAITCHAIN_NODE_INFO = extern struct {
    ObjectType: WCT_OBJECT_TYPE,
    ObjectStatus: WCT_OBJECT_STATUS,
    Anonymous: extern union {
        LockObject: extern struct {
            ObjectName: [128]u16,
            Timeout: LARGE_INTEGER,
            Alertable: BOOL,
        },
        ThreadObject: extern struct {
            ProcessId: u32,
            ThreadId: u32,
            WaitTime: u32,
            ContextSwitches: u32,
        },
    },
};

pub const PWAITCHAINCALLBACK = fn(
    WctHandle: ?*c_void,
    Context: usize,
    CallbackStatus: u32,
    NodeCount: ?*u32,
    NodeInfoArray: ?*WAITCHAIN_NODE_INFO,
    IsCycle: ?*i32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PCOGETCALLSTATE = fn(
    param0: i32,
    param1: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PCOGETACTIVATIONSTATE = fn(
    param0: Guid,
    param1: u32,
    param2: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const MINIDUMP_LOCATION_DESCRIPTOR = extern struct {
    DataSize: u32,
    Rva: u32,
};

pub const MINIDUMP_LOCATION_DESCRIPTOR64 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    DataSize: u64,
    Rva: u64,
};

pub const MINIDUMP_MEMORY_DESCRIPTOR = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    StartOfMemoryRange: u64,
    Memory: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_MEMORY_DESCRIPTOR64 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    StartOfMemoryRange: u64,
    DataSize: u64,
};

pub const MINIDUMP_HEADER = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Signature: u32,
    Version: u32,
    NumberOfStreams: u32,
    StreamDirectoryRva: u32,
    CheckSum: u32,
    Anonymous: extern union {
        Reserved: u32,
        TimeDateStamp: u32,
    },
    Flags: u64,
};

pub const MINIDUMP_DIRECTORY = extern struct {
    StreamType: u32,
    Location: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_STRING = extern struct {
    Length: u32,
    Buffer: [1]u16,
};

pub const MINIDUMP_STREAM_TYPE = enum(i32) {
    UnusedStream = 0,
    ReservedStream0 = 1,
    ReservedStream1 = 2,
    ThreadListStream = 3,
    ModuleListStream = 4,
    MemoryListStream = 5,
    ExceptionStream = 6,
    SystemInfoStream = 7,
    ThreadExListStream = 8,
    Memory64ListStream = 9,
    CommentStreamA = 10,
    CommentStreamW = 11,
    HandleDataStream = 12,
    FunctionTableStream = 13,
    UnloadedModuleListStream = 14,
    MiscInfoStream = 15,
    MemoryInfoListStream = 16,
    ThreadInfoListStream = 17,
    HandleOperationListStream = 18,
    TokenStream = 19,
    JavaScriptDataStream = 20,
    SystemMemoryInfoStream = 21,
    ProcessVmCountersStream = 22,
    IptTraceStream = 23,
    ThreadNamesStream = 24,
    ceStreamNull = 32768,
    ceStreamSystemInfo = 32769,
    ceStreamException = 32770,
    ceStreamModuleList = 32771,
    ceStreamProcessList = 32772,
    ceStreamThreadList = 32773,
    ceStreamThreadContextList = 32774,
    ceStreamThreadCallStackList = 32775,
    ceStreamMemoryVirtualList = 32776,
    ceStreamMemoryPhysicalList = 32777,
    ceStreamBucketParameters = 32778,
    ceStreamProcessModuleMap = 32779,
    ceStreamDiagnosisList = 32780,
    LastReservedStream = 65535,
};
pub const UnusedStream = MINIDUMP_STREAM_TYPE.UnusedStream;
pub const ReservedStream0 = MINIDUMP_STREAM_TYPE.ReservedStream0;
pub const ReservedStream1 = MINIDUMP_STREAM_TYPE.ReservedStream1;
pub const ThreadListStream = MINIDUMP_STREAM_TYPE.ThreadListStream;
pub const ModuleListStream = MINIDUMP_STREAM_TYPE.ModuleListStream;
pub const MemoryListStream = MINIDUMP_STREAM_TYPE.MemoryListStream;
pub const ExceptionStream = MINIDUMP_STREAM_TYPE.ExceptionStream;
pub const SystemInfoStream = MINIDUMP_STREAM_TYPE.SystemInfoStream;
pub const ThreadExListStream = MINIDUMP_STREAM_TYPE.ThreadExListStream;
pub const Memory64ListStream = MINIDUMP_STREAM_TYPE.Memory64ListStream;
pub const CommentStreamA = MINIDUMP_STREAM_TYPE.CommentStreamA;
pub const CommentStreamW = MINIDUMP_STREAM_TYPE.CommentStreamW;
pub const HandleDataStream = MINIDUMP_STREAM_TYPE.HandleDataStream;
pub const FunctionTableStream = MINIDUMP_STREAM_TYPE.FunctionTableStream;
pub const UnloadedModuleListStream = MINIDUMP_STREAM_TYPE.UnloadedModuleListStream;
pub const MiscInfoStream = MINIDUMP_STREAM_TYPE.MiscInfoStream;
pub const MemoryInfoListStream = MINIDUMP_STREAM_TYPE.MemoryInfoListStream;
pub const ThreadInfoListStream = MINIDUMP_STREAM_TYPE.ThreadInfoListStream;
pub const HandleOperationListStream = MINIDUMP_STREAM_TYPE.HandleOperationListStream;
pub const TokenStream = MINIDUMP_STREAM_TYPE.TokenStream;
pub const JavaScriptDataStream = MINIDUMP_STREAM_TYPE.JavaScriptDataStream;
pub const SystemMemoryInfoStream = MINIDUMP_STREAM_TYPE.SystemMemoryInfoStream;
pub const ProcessVmCountersStream = MINIDUMP_STREAM_TYPE.ProcessVmCountersStream;
pub const IptTraceStream = MINIDUMP_STREAM_TYPE.IptTraceStream;
pub const ThreadNamesStream = MINIDUMP_STREAM_TYPE.ThreadNamesStream;
pub const ceStreamNull = MINIDUMP_STREAM_TYPE.ceStreamNull;
pub const ceStreamSystemInfo = MINIDUMP_STREAM_TYPE.ceStreamSystemInfo;
pub const ceStreamException = MINIDUMP_STREAM_TYPE.ceStreamException;
pub const ceStreamModuleList = MINIDUMP_STREAM_TYPE.ceStreamModuleList;
pub const ceStreamProcessList = MINIDUMP_STREAM_TYPE.ceStreamProcessList;
pub const ceStreamThreadList = MINIDUMP_STREAM_TYPE.ceStreamThreadList;
pub const ceStreamThreadContextList = MINIDUMP_STREAM_TYPE.ceStreamThreadContextList;
pub const ceStreamThreadCallStackList = MINIDUMP_STREAM_TYPE.ceStreamThreadCallStackList;
pub const ceStreamMemoryVirtualList = MINIDUMP_STREAM_TYPE.ceStreamMemoryVirtualList;
pub const ceStreamMemoryPhysicalList = MINIDUMP_STREAM_TYPE.ceStreamMemoryPhysicalList;
pub const ceStreamBucketParameters = MINIDUMP_STREAM_TYPE.ceStreamBucketParameters;
pub const ceStreamProcessModuleMap = MINIDUMP_STREAM_TYPE.ceStreamProcessModuleMap;
pub const ceStreamDiagnosisList = MINIDUMP_STREAM_TYPE.ceStreamDiagnosisList;
pub const LastReservedStream = MINIDUMP_STREAM_TYPE.LastReservedStream;

pub const CPU_INFORMATION = extern union {
    X86CpuInfo: extern struct {
        VendorId: [3]u32,
        VersionInformation: u32,
        FeatureInformation: u32,
        AMDExtendedCpuFeatures: u32,
    },
    OtherCpuInfo: extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        ProcessorFeatures: [2]u64,
    },
};

pub const MINIDUMP_SYSTEM_INFO = extern struct {
    ProcessorArchitecture: PROCESSOR_ARCHITECTURE,
    ProcessorLevel: u16,
    ProcessorRevision: u16,
    Anonymous1: extern union {
        Reserved0: u16,
        Anonymous: extern struct {
            NumberOfProcessors: u8,
            ProductType: u8,
        },
    },
    MajorVersion: u32,
    MinorVersion: u32,
    BuildNumber: u32,
    PlatformId: VER_PLATFORM,
    CSDVersionRva: u32,
    Anonymous2: extern union {
        Reserved1: u32,
        Anonymous: extern struct {
            SuiteMask: u16,
            Reserved2: u16,
        },
    },
    Cpu: CPU_INFORMATION,
};

pub const MINIDUMP_THREAD = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    ThreadId: u32,
    SuspendCount: u32,
    PriorityClass: u32,
    Priority: u32,
    Teb: u64,
    Stack: MINIDUMP_MEMORY_DESCRIPTOR,
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_THREAD_LIST = extern struct {
    NumberOfThreads: u32,
    Threads: [1]MINIDUMP_THREAD,
};

pub const MINIDUMP_THREAD_EX = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    ThreadId: u32,
    SuspendCount: u32,
    PriorityClass: u32,
    Priority: u32,
    Teb: u64,
    Stack: MINIDUMP_MEMORY_DESCRIPTOR,
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR,
    BackingStore: MINIDUMP_MEMORY_DESCRIPTOR,
};

pub const MINIDUMP_THREAD_EX_LIST = extern struct {
    NumberOfThreads: u32,
    Threads: [1]MINIDUMP_THREAD_EX,
};

pub const MINIDUMP_EXCEPTION = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    ExceptionCode: u32,
    ExceptionFlags: u32,
    ExceptionRecord: u64,
    ExceptionAddress: u64,
    NumberParameters: u32,
    __unusedAlignment: u32,
    ExceptionInformation: [15]u64,
};

pub const MINIDUMP_EXCEPTION_STREAM = extern struct {
    ThreadId: u32,
    __alignment: u32,
    ExceptionRecord: MINIDUMP_EXCEPTION,
    ThreadContext: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_MODULE = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    BaseOfImage: u64,
    SizeOfImage: u32,
    CheckSum: u32,
    TimeDateStamp: u32,
    ModuleNameRva: u32,
    VersionInfo: VS_FIXEDFILEINFO,
    CvRecord: MINIDUMP_LOCATION_DESCRIPTOR,
    MiscRecord: MINIDUMP_LOCATION_DESCRIPTOR,
    Reserved0: u64,
    Reserved1: u64,
};

pub const MINIDUMP_MODULE_LIST = extern struct {
    NumberOfModules: u32,
    Modules: [1]MINIDUMP_MODULE,
};

pub const MINIDUMP_MEMORY_LIST = extern struct {
    NumberOfMemoryRanges: u32,
    MemoryRanges: [1]MINIDUMP_MEMORY_DESCRIPTOR,
};

pub const MINIDUMP_MEMORY64_LIST = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    NumberOfMemoryRanges: u64,
    BaseRva: u64,
    MemoryRanges: [1]MINIDUMP_MEMORY_DESCRIPTOR64,
};

pub const MINIDUMP_EXCEPTION_INFORMATION64 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    ThreadId: u32,
    ExceptionRecord: u64,
    ContextRecord: u64,
    ClientPointers: BOOL,
};

pub const MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE = enum(i32) {
    HandleObjectInformationNone = 0,
    ThreadInformation1 = 1,
    MutantInformation1 = 2,
    MutantInformation2 = 3,
    ProcessInformation1 = 4,
    ProcessInformation2 = 5,
    EventInformation1 = 6,
    SectionInformation1 = 7,
    SemaphoreInformation1 = 8,
    HandleObjectInformationTypeMax = 9,
};
pub const MiniHandleObjectInformationNone = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.HandleObjectInformationNone;
pub const MiniThreadInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ThreadInformation1;
pub const MiniMutantInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MutantInformation1;
pub const MiniMutantInformation2 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.MutantInformation2;
pub const MiniProcessInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ProcessInformation1;
pub const MiniProcessInformation2 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.ProcessInformation2;
pub const MiniEventInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.EventInformation1;
pub const MiniSectionInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.SectionInformation1;
pub const MiniSemaphoreInformation1 = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.SemaphoreInformation1;
pub const MiniHandleObjectInformationTypeMax = MINIDUMP_HANDLE_OBJECT_INFORMATION_TYPE.HandleObjectInformationTypeMax;

pub const MINIDUMP_HANDLE_OBJECT_INFORMATION = extern struct {
    NextInfoRva: u32,
    InfoType: u32,
    SizeOfInfo: u32,
};

pub const MINIDUMP_HANDLE_DESCRIPTOR = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Handle: u64,
    TypeNameRva: u32,
    ObjectNameRva: u32,
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
};

pub const MINIDUMP_HANDLE_DESCRIPTOR_2 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Handle: u64,
    TypeNameRva: u32,
    ObjectNameRva: u32,
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
    ObjectInfoRva: u32,
    Reserved0: u32,
};

pub const MINIDUMP_HANDLE_DATA_STREAM = extern struct {
    SizeOfHeader: u32,
    SizeOfDescriptor: u32,
    NumberOfDescriptors: u32,
    Reserved: u32,
};

pub const MINIDUMP_HANDLE_OPERATION_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
    Reserved: u32,
};

pub const MINIDUMP_FUNCTION_TABLE_DESCRIPTOR = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    MinimumAddress: u64,
    MaximumAddress: u64,
    BaseAddress: u64,
    EntryCount: u32,
    SizeOfAlignPad: u32,
};

pub const MINIDUMP_FUNCTION_TABLE_STREAM = extern struct {
    SizeOfHeader: u32,
    SizeOfDescriptor: u32,
    SizeOfNativeDescriptor: u32,
    SizeOfFunctionEntry: u32,
    NumberOfDescriptors: u32,
    SizeOfAlignPad: u32,
};

pub const MINIDUMP_UNLOADED_MODULE = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    BaseOfImage: u64,
    SizeOfImage: u32,
    CheckSum: u32,
    TimeDateStamp: u32,
    ModuleNameRva: u32,
};

pub const MINIDUMP_UNLOADED_MODULE_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
};

pub const XSTATE_CONFIG_FEATURE_MSC_INFO = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    SizeOfInfo: u32,
    ContextSize: u32,
    EnabledFeatures: u64,
    Features: [64]XSTATE_FEATURE,
};

pub const MINIDUMP_MISC_INFO = extern struct {
    SizeOfInfo: u32,
    Flags1: MINIDUMP_MISC_INFO_FLAGS,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
};

pub const MINIDUMP_MISC_INFO_2 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
};

pub const MINIDUMP_MISC_INFO_3 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
};

pub const MINIDUMP_MISC_INFO_4 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
    BuildString: [260]u16,
    DbgBldStr: [40]u16,
};

pub const MINIDUMP_MISC_INFO_5 = extern struct {
    SizeOfInfo: u32,
    Flags1: u32,
    ProcessId: u32,
    ProcessCreateTime: u32,
    ProcessUserTime: u32,
    ProcessKernelTime: u32,
    ProcessorMaxMhz: u32,
    ProcessorCurrentMhz: u32,
    ProcessorMhzLimit: u32,
    ProcessorMaxIdleState: u32,
    ProcessorCurrentIdleState: u32,
    ProcessIntegrityLevel: u32,
    ProcessExecuteFlags: u32,
    ProtectedProcess: u32,
    TimeZoneId: u32,
    TimeZone: TIME_ZONE_INFORMATION,
    BuildString: [260]u16,
    DbgBldStr: [40]u16,
    XStateData: XSTATE_CONFIG_FEATURE_MSC_INFO,
    ProcessCookie: u32,
};

pub const MINIDUMP_MEMORY_INFO = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    BaseAddress: u64,
    AllocationBase: u64,
    AllocationProtect: u32,
    __alignment1: u32,
    RegionSize: u64,
    State: VIRTUAL_ALLOCATION_TYPE,
    Protect: u32,
    Type: u32,
    __alignment2: u32,
};

pub const MINIDUMP_MEMORY_INFO_LIST = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u64,
};

pub const MINIDUMP_THREAD_NAME = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    ThreadId: u32,
    RvaOfThreadName: u64,
};

pub const MINIDUMP_THREAD_NAME_LIST = extern struct {
    NumberOfThreadNames: u32,
    ThreadNames: [1]MINIDUMP_THREAD_NAME,
};

pub const MINIDUMP_THREAD_INFO = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    ThreadId: u32,
    DumpFlags: MINIDUMP_THREAD_INFO_DUMP_FLAGS,
    DumpError: u32,
    ExitStatus: u32,
    CreateTime: u64,
    ExitTime: u64,
    KernelTime: u64,
    UserTime: u64,
    StartAddress: u64,
    Affinity: u64,
};

pub const MINIDUMP_THREAD_INFO_LIST = extern struct {
    SizeOfHeader: u32,
    SizeOfEntry: u32,
    NumberOfEntries: u32,
};

pub const MINIDUMP_TOKEN_INFO_HEADER = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    TokenSize: u32,
    TokenId: u32,
    TokenHandle: u64,
};

pub const MINIDUMP_TOKEN_INFO_LIST = extern struct {
    TokenListSize: u32,
    TokenListEntries: u32,
    ListHeaderSize: u32,
    ElementHeaderSize: u32,
};

pub const MINIDUMP_SYSTEM_BASIC_INFORMATION = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    TimerResolution: u32,
    PageSize: u32,
    NumberOfPhysicalPages: u32,
    LowestPhysicalPageNumber: u32,
    HighestPhysicalPageNumber: u32,
    AllocationGranularity: u32,
    MinimumUserModeAddress: u64,
    MaximumUserModeAddress: u64,
    ActiveProcessorsAffinityMask: u64,
    NumberOfProcessors: u32,
};

pub const MINIDUMP_SYSTEM_FILECACHE_INFORMATION = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    CurrentSize: u64,
    PeakSize: u64,
    PageFaultCount: u32,
    MinimumWorkingSet: u64,
    MaximumWorkingSet: u64,
    CurrentSizeIncludingTransitionInPages: u64,
    PeakSizeIncludingTransitionInPages: u64,
    TransitionRePurposeCount: u32,
    Flags: u32,
};

pub const MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    AvailablePages: u64,
    CommittedPages: u64,
    CommitLimit: u64,
    PeakCommitment: u64,
};

pub const MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    IdleProcessTime: u64,
    IoReadTransferCount: u64,
    IoWriteTransferCount: u64,
    IoOtherTransferCount: u64,
    IoReadOperationCount: u32,
    IoWriteOperationCount: u32,
    IoOtherOperationCount: u32,
    AvailablePages: u32,
    CommittedPages: u32,
    CommitLimit: u32,
    PeakCommitment: u32,
    PageFaultCount: u32,
    CopyOnWriteCount: u32,
    TransitionCount: u32,
    CacheTransitionCount: u32,
    DemandZeroCount: u32,
    PageReadCount: u32,
    PageReadIoCount: u32,
    CacheReadCount: u32,
    CacheIoCount: u32,
    DirtyPagesWriteCount: u32,
    DirtyWriteIoCount: u32,
    MappedPagesWriteCount: u32,
    MappedWriteIoCount: u32,
    PagedPoolPages: u32,
    NonPagedPoolPages: u32,
    PagedPoolAllocs: u32,
    PagedPoolFrees: u32,
    NonPagedPoolAllocs: u32,
    NonPagedPoolFrees: u32,
    FreeSystemPtes: u32,
    ResidentSystemCodePage: u32,
    TotalSystemDriverPages: u32,
    TotalSystemCodePages: u32,
    NonPagedPoolLookasideHits: u32,
    PagedPoolLookasideHits: u32,
    AvailablePagedPoolPages: u32,
    ResidentSystemCachePage: u32,
    ResidentPagedPoolPage: u32,
    ResidentSystemDriverPage: u32,
    CcFastReadNoWait: u32,
    CcFastReadWait: u32,
    CcFastReadResourceMiss: u32,
    CcFastReadNotPossible: u32,
    CcFastMdlReadNoWait: u32,
    CcFastMdlReadWait: u32,
    CcFastMdlReadResourceMiss: u32,
    CcFastMdlReadNotPossible: u32,
    CcMapDataNoWait: u32,
    CcMapDataWait: u32,
    CcMapDataNoWaitMiss: u32,
    CcMapDataWaitMiss: u32,
    CcPinMappedDataCount: u32,
    CcPinReadNoWait: u32,
    CcPinReadWait: u32,
    CcPinReadNoWaitMiss: u32,
    CcPinReadWaitMiss: u32,
    CcCopyReadNoWait: u32,
    CcCopyReadWait: u32,
    CcCopyReadNoWaitMiss: u32,
    CcCopyReadWaitMiss: u32,
    CcMdlReadNoWait: u32,
    CcMdlReadWait: u32,
    CcMdlReadNoWaitMiss: u32,
    CcMdlReadWaitMiss: u32,
    CcReadAheadIos: u32,
    CcLazyWriteIos: u32,
    CcLazyWritePages: u32,
    CcDataFlushes: u32,
    CcDataPages: u32,
    ContextSwitches: u32,
    FirstLevelTbFills: u32,
    SecondLevelTbFills: u32,
    SystemCalls: u32,
    CcTotalDirtyPages: u64,
    CcDirtyPageThreshold: u64,
    ResidentAvailablePages: i64,
    SharedCommittedPages: u64,
};

pub const MINIDUMP_SYSTEM_MEMORY_INFO_1 = extern struct {
    Revision: u16,
    Flags: u16,
    BasicInfo: MINIDUMP_SYSTEM_BASIC_INFORMATION,
    FileCacheInfo: MINIDUMP_SYSTEM_FILECACHE_INFORMATION,
    BasicPerfInfo: MINIDUMP_SYSTEM_BASIC_PERFORMANCE_INFORMATION,
    PerfInfo: MINIDUMP_SYSTEM_PERFORMANCE_INFORMATION,
};

pub const MINIDUMP_PROCESS_VM_COUNTERS_1 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Revision: u16,
    PageFaultCount: u32,
    PeakWorkingSetSize: u64,
    WorkingSetSize: u64,
    QuotaPeakPagedPoolUsage: u64,
    QuotaPagedPoolUsage: u64,
    QuotaPeakNonPagedPoolUsage: u64,
    QuotaNonPagedPoolUsage: u64,
    PagefileUsage: u64,
    PeakPagefileUsage: u64,
    PrivateUsage: u64,
};

pub const MINIDUMP_PROCESS_VM_COUNTERS_2 = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Revision: u16,
    Flags: u16,
    PageFaultCount: u32,
    PeakWorkingSetSize: u64,
    WorkingSetSize: u64,
    QuotaPeakPagedPoolUsage: u64,
    QuotaPagedPoolUsage: u64,
    QuotaPeakNonPagedPoolUsage: u64,
    QuotaNonPagedPoolUsage: u64,
    PagefileUsage: u64,
    PeakPagefileUsage: u64,
    PeakVirtualSize: u64,
    VirtualSize: u64,
    PrivateUsage: u64,
    PrivateWorkingSetSize: u64,
    SharedCommitUsage: u64,
    JobSharedCommitUsage: u64,
    JobPrivateCommitUsage: u64,
    JobPeakPrivateCommitUsage: u64,
    JobPrivateCommitLimit: u64,
    JobTotalCommitLimit: u64,
};

pub const MINIDUMP_USER_RECORD = extern struct {
    Type: u32,
    Memory: MINIDUMP_LOCATION_DESCRIPTOR,
};

pub const MINIDUMP_CALLBACK_TYPE = enum(i32) {
    ModuleCallback = 0,
    ThreadCallback = 1,
    ThreadExCallback = 2,
    IncludeThreadCallback = 3,
    IncludeModuleCallback = 4,
    MemoryCallback = 5,
    CancelCallback = 6,
    WriteKernelMinidumpCallback = 7,
    KernelMinidumpStatusCallback = 8,
    RemoveMemoryCallback = 9,
    IncludeVmRegionCallback = 10,
    IoStartCallback = 11,
    IoWriteAllCallback = 12,
    IoFinishCallback = 13,
    ReadMemoryFailureCallback = 14,
    SecondaryFlagsCallback = 15,
    IsProcessSnapshotCallback = 16,
    VmStartCallback = 17,
    VmQueryCallback = 18,
    VmPreReadCallback = 19,
    VmPostReadCallback = 20,
};
pub const ModuleCallback = MINIDUMP_CALLBACK_TYPE.ModuleCallback;
pub const ThreadCallback = MINIDUMP_CALLBACK_TYPE.ThreadCallback;
pub const ThreadExCallback = MINIDUMP_CALLBACK_TYPE.ThreadExCallback;
pub const IncludeThreadCallback = MINIDUMP_CALLBACK_TYPE.IncludeThreadCallback;
pub const IncludeModuleCallback = MINIDUMP_CALLBACK_TYPE.IncludeModuleCallback;
pub const MemoryCallback = MINIDUMP_CALLBACK_TYPE.MemoryCallback;
pub const CancelCallback = MINIDUMP_CALLBACK_TYPE.CancelCallback;
pub const WriteKernelMinidumpCallback = MINIDUMP_CALLBACK_TYPE.WriteKernelMinidumpCallback;
pub const KernelMinidumpStatusCallback = MINIDUMP_CALLBACK_TYPE.KernelMinidumpStatusCallback;
pub const RemoveMemoryCallback = MINIDUMP_CALLBACK_TYPE.RemoveMemoryCallback;
pub const IncludeVmRegionCallback = MINIDUMP_CALLBACK_TYPE.IncludeVmRegionCallback;
pub const IoStartCallback = MINIDUMP_CALLBACK_TYPE.IoStartCallback;
pub const IoWriteAllCallback = MINIDUMP_CALLBACK_TYPE.IoWriteAllCallback;
pub const IoFinishCallback = MINIDUMP_CALLBACK_TYPE.IoFinishCallback;
pub const ReadMemoryFailureCallback = MINIDUMP_CALLBACK_TYPE.ReadMemoryFailureCallback;
pub const SecondaryFlagsCallback = MINIDUMP_CALLBACK_TYPE.SecondaryFlagsCallback;
pub const IsProcessSnapshotCallback = MINIDUMP_CALLBACK_TYPE.IsProcessSnapshotCallback;
pub const VmStartCallback = MINIDUMP_CALLBACK_TYPE.VmStartCallback;
pub const VmQueryCallback = MINIDUMP_CALLBACK_TYPE.VmQueryCallback;
pub const VmPreReadCallback = MINIDUMP_CALLBACK_TYPE.VmPreReadCallback;
pub const VmPostReadCallback = MINIDUMP_CALLBACK_TYPE.VmPostReadCallback;



pub const MINIDUMP_INCLUDE_THREAD_CALLBACK = extern struct {
    ThreadId: u32,
};

pub const THREAD_WRITE_FLAGS = enum(i32) {
    Thread = 1,
    Stack = 2,
    Context = 4,
    BackingStore = 8,
    InstructionWindow = 16,
    ThreadData = 32,
    ThreadInfo = 64,
};
pub const ThreadWriteThread = THREAD_WRITE_FLAGS.Thread;
pub const ThreadWriteStack = THREAD_WRITE_FLAGS.Stack;
pub const ThreadWriteContext = THREAD_WRITE_FLAGS.Context;
pub const ThreadWriteBackingStore = THREAD_WRITE_FLAGS.BackingStore;
pub const ThreadWriteInstructionWindow = THREAD_WRITE_FLAGS.InstructionWindow;
pub const ThreadWriteThreadData = THREAD_WRITE_FLAGS.ThreadData;
pub const ThreadWriteThreadInfo = THREAD_WRITE_FLAGS.ThreadInfo;

pub const MINIDUMP_MODULE_CALLBACK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    FullPath: ?[*]u16,
    BaseOfImage: u64,
    SizeOfImage: u32,
    CheckSum: u32,
    TimeDateStamp: u32,
    VersionInfo: VS_FIXEDFILEINFO,
    CvRecord: ?*c_void,
    SizeOfCvRecord: u32,
    MiscRecord: ?*c_void,
    SizeOfMiscRecord: u32,
};

pub const MINIDUMP_INCLUDE_MODULE_CALLBACK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    BaseOfImage: u64,
};

pub const MODULE_WRITE_FLAGS = enum(i32) {
    WriteModule = 1,
    WriteDataSeg = 2,
    WriteMiscRecord = 4,
    WriteCvRecord = 8,
    ReferencedByMemory = 16,
    WriteTlsData = 32,
    WriteCodeSegs = 64,
};
pub const ModuleWriteModule = MODULE_WRITE_FLAGS.WriteModule;
pub const ModuleWriteDataSeg = MODULE_WRITE_FLAGS.WriteDataSeg;
pub const ModuleWriteMiscRecord = MODULE_WRITE_FLAGS.WriteMiscRecord;
pub const ModuleWriteCvRecord = MODULE_WRITE_FLAGS.WriteCvRecord;
pub const ModuleReferencedByMemory = MODULE_WRITE_FLAGS.ReferencedByMemory;
pub const ModuleWriteTlsData = MODULE_WRITE_FLAGS.WriteTlsData;
pub const ModuleWriteCodeSegs = MODULE_WRITE_FLAGS.WriteCodeSegs;

pub const MINIDUMP_IO_CALLBACK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Handle: ?HANDLE,
    Offset: u64,
    Buffer: ?*c_void,
    BufferBytes: u32,
};

pub const MINIDUMP_READ_MEMORY_FAILURE_CALLBACK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Offset: u64,
    Bytes: u32,
    FailureStatus: HRESULT,
};

pub const MINIDUMP_VM_QUERY_CALLBACK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Offset: u64,
};

pub const MINIDUMP_VM_PRE_READ_CALLBACK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Offset: u64,
    Buffer: ?*c_void,
    Size: u32,
};

pub const MINIDUMP_VM_POST_READ_CALLBACK = extern struct {
    // WARNING: unable to add field alignment because it's causing a compiler bug
    Offset: u64,
    Buffer: ?*c_void,
    Size: u32,
    Completed: u32,
    Status: HRESULT,
};

pub const MINIDUMP_CALLBACK_INPUT = extern struct {
    ProcessId: u32,
    ProcessHandle: ?HANDLE,
    CallbackType: u32,
    Anonymous: extern union {
        Status: HRESULT,
        Thread: MINIDUMP_THREAD_CALLBACK,
        ThreadEx: MINIDUMP_THREAD_EX_CALLBACK,
        Module: MINIDUMP_MODULE_CALLBACK,
        IncludeThread: MINIDUMP_INCLUDE_THREAD_CALLBACK,
        IncludeModule: MINIDUMP_INCLUDE_MODULE_CALLBACK,
        Io: MINIDUMP_IO_CALLBACK,
        ReadMemoryFailure: MINIDUMP_READ_MEMORY_FAILURE_CALLBACK,
        SecondaryFlags: u32,
        VmQuery: MINIDUMP_VM_QUERY_CALLBACK,
        VmPreRead: MINIDUMP_VM_PRE_READ_CALLBACK,
        VmPostRead: MINIDUMP_VM_POST_READ_CALLBACK,
    },
};

pub const MINIDUMP_CALLBACK_OUTPUT = extern struct {
    Anonymous: extern union {
        // WARNING: unable to add field alignment because it's not implemented for unions
        ModuleWriteFlags: u32,
        ThreadWriteFlags: u32,
        SecondaryFlags: u32,
        Anonymous1: extern struct {
            // WARNING: unable to add field alignment because it's causing a compiler bug
            MemoryBase: u64,
            MemorySize: u32,
        },
        Anonymous2: extern struct {
            CheckCancel: BOOL,
            Cancel: BOOL,
        },
        Handle: ?HANDLE,
        Anonymous3: extern struct {
            VmRegion: MINIDUMP_MEMORY_INFO,
            Continue: BOOL,
        },
        Anonymous4: extern struct {
            VmQueryStatus: HRESULT,
            VmQueryResult: MINIDUMP_MEMORY_INFO,
        },
        Anonymous5: extern struct {
            VmReadStatus: HRESULT,
            VmReadBytesCompleted: u32,
        },
        Status: HRESULT,
    },
};

pub const MINIDUMP_TYPE = enum(u32) {
    Normal = 0,
    WithDataSegs = 1,
    WithFullMemory = 2,
    WithHandleData = 4,
    FilterMemory = 8,
    ScanMemory = 16,
    WithUnloadedModules = 32,
    WithIndirectlyReferencedMemory = 64,
    FilterModulePaths = 128,
    WithProcessThreadData = 256,
    WithPrivateReadWriteMemory = 512,
    WithoutOptionalData = 1024,
    WithFullMemoryInfo = 2048,
    WithThreadInfo = 4096,
    WithCodeSegs = 8192,
    WithoutAuxiliaryState = 16384,
    WithFullAuxiliaryState = 32768,
    WithPrivateWriteCopyMemory = 65536,
    IgnoreInaccessibleMemory = 131072,
    WithTokenInformation = 262144,
    WithModuleHeaders = 524288,
    FilterTriage = 1048576,
    WithAvxXStateContext = 2097152,
    WithIptTrace = 4194304,
    ScanInaccessiblePartialPages = 8388608,
    ValidTypeFlags = 16777215,
    _,
    pub fn initFlags(o: struct {
        Normal: u1 = 0,
        WithDataSegs: u1 = 0,
        WithFullMemory: u1 = 0,
        WithHandleData: u1 = 0,
        FilterMemory: u1 = 0,
        ScanMemory: u1 = 0,
        WithUnloadedModules: u1 = 0,
        WithIndirectlyReferencedMemory: u1 = 0,
        FilterModulePaths: u1 = 0,
        WithProcessThreadData: u1 = 0,
        WithPrivateReadWriteMemory: u1 = 0,
        WithoutOptionalData: u1 = 0,
        WithFullMemoryInfo: u1 = 0,
        WithThreadInfo: u1 = 0,
        WithCodeSegs: u1 = 0,
        WithoutAuxiliaryState: u1 = 0,
        WithFullAuxiliaryState: u1 = 0,
        WithPrivateWriteCopyMemory: u1 = 0,
        IgnoreInaccessibleMemory: u1 = 0,
        WithTokenInformation: u1 = 0,
        WithModuleHeaders: u1 = 0,
        FilterTriage: u1 = 0,
        WithAvxXStateContext: u1 = 0,
        WithIptTrace: u1 = 0,
        ScanInaccessiblePartialPages: u1 = 0,
        ValidTypeFlags: u1 = 0,
    }) MINIDUMP_TYPE {
        return @intToEnum(MINIDUMP_TYPE,
              (if (o.Normal == 1) @enumToInt(MINIDUMP_TYPE.Normal) else 0)
            | (if (o.WithDataSegs == 1) @enumToInt(MINIDUMP_TYPE.WithDataSegs) else 0)
            | (if (o.WithFullMemory == 1) @enumToInt(MINIDUMP_TYPE.WithFullMemory) else 0)
            | (if (o.WithHandleData == 1) @enumToInt(MINIDUMP_TYPE.WithHandleData) else 0)
            | (if (o.FilterMemory == 1) @enumToInt(MINIDUMP_TYPE.FilterMemory) else 0)
            | (if (o.ScanMemory == 1) @enumToInt(MINIDUMP_TYPE.ScanMemory) else 0)
            | (if (o.WithUnloadedModules == 1) @enumToInt(MINIDUMP_TYPE.WithUnloadedModules) else 0)
            | (if (o.WithIndirectlyReferencedMemory == 1) @enumToInt(MINIDUMP_TYPE.WithIndirectlyReferencedMemory) else 0)
            | (if (o.FilterModulePaths == 1) @enumToInt(MINIDUMP_TYPE.FilterModulePaths) else 0)
            | (if (o.WithProcessThreadData == 1) @enumToInt(MINIDUMP_TYPE.WithProcessThreadData) else 0)
            | (if (o.WithPrivateReadWriteMemory == 1) @enumToInt(MINIDUMP_TYPE.WithPrivateReadWriteMemory) else 0)
            | (if (o.WithoutOptionalData == 1) @enumToInt(MINIDUMP_TYPE.WithoutOptionalData) else 0)
            | (if (o.WithFullMemoryInfo == 1) @enumToInt(MINIDUMP_TYPE.WithFullMemoryInfo) else 0)
            | (if (o.WithThreadInfo == 1) @enumToInt(MINIDUMP_TYPE.WithThreadInfo) else 0)
            | (if (o.WithCodeSegs == 1) @enumToInt(MINIDUMP_TYPE.WithCodeSegs) else 0)
            | (if (o.WithoutAuxiliaryState == 1) @enumToInt(MINIDUMP_TYPE.WithoutAuxiliaryState) else 0)
            | (if (o.WithFullAuxiliaryState == 1) @enumToInt(MINIDUMP_TYPE.WithFullAuxiliaryState) else 0)
            | (if (o.WithPrivateWriteCopyMemory == 1) @enumToInt(MINIDUMP_TYPE.WithPrivateWriteCopyMemory) else 0)
            | (if (o.IgnoreInaccessibleMemory == 1) @enumToInt(MINIDUMP_TYPE.IgnoreInaccessibleMemory) else 0)
            | (if (o.WithTokenInformation == 1) @enumToInt(MINIDUMP_TYPE.WithTokenInformation) else 0)
            | (if (o.WithModuleHeaders == 1) @enumToInt(MINIDUMP_TYPE.WithModuleHeaders) else 0)
            | (if (o.FilterTriage == 1) @enumToInt(MINIDUMP_TYPE.FilterTriage) else 0)
            | (if (o.WithAvxXStateContext == 1) @enumToInt(MINIDUMP_TYPE.WithAvxXStateContext) else 0)
            | (if (o.WithIptTrace == 1) @enumToInt(MINIDUMP_TYPE.WithIptTrace) else 0)
            | (if (o.ScanInaccessiblePartialPages == 1) @enumToInt(MINIDUMP_TYPE.ScanInaccessiblePartialPages) else 0)
            | (if (o.ValidTypeFlags == 1) @enumToInt(MINIDUMP_TYPE.ValidTypeFlags) else 0)
        );
    }
};
pub const MiniDumpNormal = MINIDUMP_TYPE.Normal;
pub const MiniDumpWithDataSegs = MINIDUMP_TYPE.WithDataSegs;
pub const MiniDumpWithFullMemory = MINIDUMP_TYPE.WithFullMemory;
pub const MiniDumpWithHandleData = MINIDUMP_TYPE.WithHandleData;
pub const MiniDumpFilterMemory = MINIDUMP_TYPE.FilterMemory;
pub const MiniDumpScanMemory = MINIDUMP_TYPE.ScanMemory;
pub const MiniDumpWithUnloadedModules = MINIDUMP_TYPE.WithUnloadedModules;
pub const MiniDumpWithIndirectlyReferencedMemory = MINIDUMP_TYPE.WithIndirectlyReferencedMemory;
pub const MiniDumpFilterModulePaths = MINIDUMP_TYPE.FilterModulePaths;
pub const MiniDumpWithProcessThreadData = MINIDUMP_TYPE.WithProcessThreadData;
pub const MiniDumpWithPrivateReadWriteMemory = MINIDUMP_TYPE.WithPrivateReadWriteMemory;
pub const MiniDumpWithoutOptionalData = MINIDUMP_TYPE.WithoutOptionalData;
pub const MiniDumpWithFullMemoryInfo = MINIDUMP_TYPE.WithFullMemoryInfo;
pub const MiniDumpWithThreadInfo = MINIDUMP_TYPE.WithThreadInfo;
pub const MiniDumpWithCodeSegs = MINIDUMP_TYPE.WithCodeSegs;
pub const MiniDumpWithoutAuxiliaryState = MINIDUMP_TYPE.WithoutAuxiliaryState;
pub const MiniDumpWithFullAuxiliaryState = MINIDUMP_TYPE.WithFullAuxiliaryState;
pub const MiniDumpWithPrivateWriteCopyMemory = MINIDUMP_TYPE.WithPrivateWriteCopyMemory;
pub const MiniDumpIgnoreInaccessibleMemory = MINIDUMP_TYPE.IgnoreInaccessibleMemory;
pub const MiniDumpWithTokenInformation = MINIDUMP_TYPE.WithTokenInformation;
pub const MiniDumpWithModuleHeaders = MINIDUMP_TYPE.WithModuleHeaders;
pub const MiniDumpFilterTriage = MINIDUMP_TYPE.FilterTriage;
pub const MiniDumpWithAvxXStateContext = MINIDUMP_TYPE.WithAvxXStateContext;
pub const MiniDumpWithIptTrace = MINIDUMP_TYPE.WithIptTrace;
pub const MiniDumpScanInaccessiblePartialPages = MINIDUMP_TYPE.ScanInaccessiblePartialPages;
pub const MiniDumpValidTypeFlags = MINIDUMP_TYPE.ValidTypeFlags;

pub const MINIDUMP_SECONDARY_FLAGS = enum(i32) {
    WithoutPowerInfo = 1,
    // ValidFlags = 1, this enum value conflicts with WithoutPowerInfo
};
pub const MiniSecondaryWithoutPowerInfo = MINIDUMP_SECONDARY_FLAGS.WithoutPowerInfo;
pub const MiniSecondaryValidFlags = MINIDUMP_SECONDARY_FLAGS.WithoutPowerInfo;

pub const MINIDUMP_CALLBACK_ROUTINE = fn(
    CallbackParam: ?*c_void,
    CallbackInput: ?*MINIDUMP_CALLBACK_INPUT,
    CallbackOutput: ?*MINIDUMP_CALLBACK_OUTPUT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

const CLSID_ProcessDebugManager_Value = @import("../../zig.zig").Guid.initString("78a51822-51f4-11d0-8f20-00805f2cd064");
pub const CLSID_ProcessDebugManager = &CLSID_ProcessDebugManager_Value;

const CLSID_DebugHelper_Value = @import("../../zig.zig").Guid.initString("0bfcc060-8c1d-11d0-accd-00aa0060275c");
pub const CLSID_DebugHelper = &CLSID_DebugHelper_Value;

const CLSID_CDebugDocumentHelper_Value = @import("../../zig.zig").Guid.initString("83b8bca6-687c-11d0-a405-00aa0060275c");
pub const CLSID_CDebugDocumentHelper = &CLSID_CDebugDocumentHelper_Value;

const CLSID_MachineDebugManager_RETAIL_Value = @import("../../zig.zig").Guid.initString("0c0a3666-30c9-11d0-8f20-00805f2cd064");
pub const CLSID_MachineDebugManager_RETAIL = &CLSID_MachineDebugManager_RETAIL_Value;

const CLSID_MachineDebugManager_DEBUG_Value = @import("../../zig.zig").Guid.initString("49769cec-3a55-4bb0-b697-88fede77e8ea");
pub const CLSID_MachineDebugManager_DEBUG = &CLSID_MachineDebugManager_DEBUG_Value;

const CLSID_DefaultDebugSessionProvider_Value = @import("../../zig.zig").Guid.initString("834128a2-51f4-11d0-8f20-00805f2cd064");
pub const CLSID_DefaultDebugSessionProvider = &CLSID_DefaultDebugSessionProvider_Value;

pub const SCRIPTLANGUAGEVERSION = enum(i32) {
    DEFAULT = 0,
    @"5_7" = 1,
    @"5_8" = 2,
    MAX = 255,
};
pub const SCRIPTLANGUAGEVERSION_DEFAULT = SCRIPTLANGUAGEVERSION.DEFAULT;
pub const SCRIPTLANGUAGEVERSION_5_7 = SCRIPTLANGUAGEVERSION.@"5_7";
pub const SCRIPTLANGUAGEVERSION_5_8 = SCRIPTLANGUAGEVERSION.@"5_8";
pub const SCRIPTLANGUAGEVERSION_MAX = SCRIPTLANGUAGEVERSION.MAX;

pub const SCRIPTSTATE = enum(i32) {
    UNINITIALIZED = 0,
    INITIALIZED = 5,
    STARTED = 1,
    CONNECTED = 2,
    DISCONNECTED = 3,
    CLOSED = 4,
};
pub const SCRIPTSTATE_UNINITIALIZED = SCRIPTSTATE.UNINITIALIZED;
pub const SCRIPTSTATE_INITIALIZED = SCRIPTSTATE.INITIALIZED;
pub const SCRIPTSTATE_STARTED = SCRIPTSTATE.STARTED;
pub const SCRIPTSTATE_CONNECTED = SCRIPTSTATE.CONNECTED;
pub const SCRIPTSTATE_DISCONNECTED = SCRIPTSTATE.DISCONNECTED;
pub const SCRIPTSTATE_CLOSED = SCRIPTSTATE.CLOSED;

pub const SCRIPTTRACEINFO = enum(i32) {
    SCRIPTSTART = 0,
    SCRIPTEND = 1,
    COMCALLSTART = 2,
    COMCALLEND = 3,
    CREATEOBJSTART = 4,
    CREATEOBJEND = 5,
    GETOBJSTART = 6,
    GETOBJEND = 7,
};
pub const SCRIPTTRACEINFO_SCRIPTSTART = SCRIPTTRACEINFO.SCRIPTSTART;
pub const SCRIPTTRACEINFO_SCRIPTEND = SCRIPTTRACEINFO.SCRIPTEND;
pub const SCRIPTTRACEINFO_COMCALLSTART = SCRIPTTRACEINFO.COMCALLSTART;
pub const SCRIPTTRACEINFO_COMCALLEND = SCRIPTTRACEINFO.COMCALLEND;
pub const SCRIPTTRACEINFO_CREATEOBJSTART = SCRIPTTRACEINFO.CREATEOBJSTART;
pub const SCRIPTTRACEINFO_CREATEOBJEND = SCRIPTTRACEINFO.CREATEOBJEND;
pub const SCRIPTTRACEINFO_GETOBJSTART = SCRIPTTRACEINFO.GETOBJSTART;
pub const SCRIPTTRACEINFO_GETOBJEND = SCRIPTTRACEINFO.GETOBJEND;

pub const SCRIPTTHREADSTATE = enum(i32) {
    NOTINSCRIPT = 0,
    RUNNING = 1,
};
pub const SCRIPTTHREADSTATE_NOTINSCRIPT = SCRIPTTHREADSTATE.NOTINSCRIPT;
pub const SCRIPTTHREADSTATE_RUNNING = SCRIPTTHREADSTATE.RUNNING;

pub const SCRIPTGCTYPE = enum(i32) {
    NORMAL = 0,
    EXHAUSTIVE = 1,
};
pub const SCRIPTGCTYPE_NORMAL = SCRIPTGCTYPE.NORMAL;
pub const SCRIPTGCTYPE_EXHAUSTIVE = SCRIPTGCTYPE.EXHAUSTIVE;

pub const SCRIPTUICITEM = enum(i32) {
    INPUTBOX = 1,
    MSGBOX = 2,
};
pub const SCRIPTUICITEM_INPUTBOX = SCRIPTUICITEM.INPUTBOX;
pub const SCRIPTUICITEM_MSGBOX = SCRIPTUICITEM.MSGBOX;

pub const SCRIPTUICHANDLING = enum(i32) {
    ALLOW = 0,
    NOUIERROR = 1,
    NOUIDEFAULT = 2,
};
pub const SCRIPTUICHANDLING_ALLOW = SCRIPTUICHANDLING.ALLOW;
pub const SCRIPTUICHANDLING_NOUIERROR = SCRIPTUICHANDLING.NOUIERROR;
pub const SCRIPTUICHANDLING_NOUIDEFAULT = SCRIPTUICHANDLING.NOUIDEFAULT;

const IID_IActiveScriptSite_Value = @import("../../zig.zig").Guid.initString("db01a1e3-a42b-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptSite = &IID_IActiveScriptSite_Value;
pub const IActiveScriptSite = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetLCID: fn(
            self: *const IActiveScriptSite,
            plcid: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetItemInfo: fn(
            self: *const IActiveScriptSite,
            pstrName: ?[*:0]const u16,
            dwReturnMask: u32,
            ppiunkItem: ?*?*IUnknown,
            ppti: ?*?*ITypeInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocVersionString: fn(
            self: *const IActiveScriptSite,
            pbstrVersion: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnScriptTerminate: fn(
            self: *const IActiveScriptSite,
            pvarResult: ?*const VARIANT,
            pexcepinfo: ?*const EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnStateChange: fn(
            self: *const IActiveScriptSite,
            ssScriptState: SCRIPTSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnScriptError: fn(
            self: *const IActiveScriptSite,
            pscripterror: ?*IActiveScriptError,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEnterScript: fn(
            self: *const IActiveScriptSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLeaveScript: fn(
            self: *const IActiveScriptSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetLCID(self: *const T, plcid: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).GetLCID(@ptrCast(*const IActiveScriptSite, self), plcid);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetItemInfo(self: *const T, pstrName: ?[*:0]const u16, dwReturnMask: u32, ppiunkItem: ?*?*IUnknown, ppti: ?*?*ITypeInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).GetItemInfo(@ptrCast(*const IActiveScriptSite, self), pstrName, dwReturnMask, ppiunkItem, ppti);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_GetDocVersionString(self: *const T, pbstrVersion: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).GetDocVersionString(@ptrCast(*const IActiveScriptSite, self), pbstrVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnScriptTerminate(self: *const T, pvarResult: ?*const VARIANT, pexcepinfo: ?*const EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnScriptTerminate(@ptrCast(*const IActiveScriptSite, self), pvarResult, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnStateChange(self: *const T, ssScriptState: SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnStateChange(@ptrCast(*const IActiveScriptSite, self), ssScriptState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnScriptError(self: *const T, pscripterror: ?*IActiveScriptError) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnScriptError(@ptrCast(*const IActiveScriptSite, self), pscripterror);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnEnterScript(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnEnterScript(@ptrCast(*const IActiveScriptSite, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSite_OnLeaveScript(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSite.VTable, self.vtable).OnLeaveScript(@ptrCast(*const IActiveScriptSite, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptError_Value = @import("../../zig.zig").Guid.initString("eae1ba61-a4ed-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptError = &IID_IActiveScriptError_Value;
pub const IActiveScriptError = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetExceptionInfo: fn(
            self: *const IActiveScriptError,
            pexcepinfo: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePosition: fn(
            self: *const IActiveScriptError,
            pdwSourceContext: ?*u32,
            pulLineNumber: ?*u32,
            plCharacterPosition: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceLineText: fn(
            self: *const IActiveScriptError,
            pbstrSourceLine: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetExceptionInfo(self: *const T, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptError.VTable, self.vtable).GetExceptionInfo(@ptrCast(*const IActiveScriptError, self), pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetSourcePosition(self: *const T, pdwSourceContext: ?*u32, pulLineNumber: ?*u32, plCharacterPosition: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptError.VTable, self.vtable).GetSourcePosition(@ptrCast(*const IActiveScriptError, self), pdwSourceContext, pulLineNumber, plCharacterPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError_GetSourceLineText(self: *const T, pbstrSourceLine: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptError.VTable, self.vtable).GetSourceLineText(@ptrCast(*const IActiveScriptError, self), pbstrSourceLine);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptError64_Value = @import("../../zig.zig").Guid.initString("b21fb2a1-5b8f-4963-8c21-21450f84ed7f");
pub const IID_IActiveScriptError64 = &IID_IActiveScriptError64_Value;
pub const IActiveScriptError64 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetSourcePosition64: fn(
            self: *const IActiveScriptError64,
            pdwSourceContext: ?*u64,
            pulLineNumber: ?*u32,
            plCharacterPosition: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptError64_GetSourcePosition64(self: *const T, pdwSourceContext: ?*u64, pulLineNumber: ?*u32, plCharacterPosition: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptError64.VTable, self.vtable).GetSourcePosition64(@ptrCast(*const IActiveScriptError64, self), pdwSourceContext, pulLineNumber, plCharacterPosition);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteWindow_Value = @import("../../zig.zig").Guid.initString("d10f6761-83e9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptSiteWindow = &IID_IActiveScriptSiteWindow_Value;
pub const IActiveScriptSiteWindow = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetWindow: fn(
            self: *const IActiveScriptSiteWindow,
            phwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnableModeless: fn(
            self: *const IActiveScriptSiteWindow,
            fEnable: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteWindow_GetWindow(self: *const T, phwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteWindow.VTable, self.vtable).GetWindow(@ptrCast(*const IActiveScriptSiteWindow, self), phwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteWindow_EnableModeless(self: *const T, fEnable: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteWindow.VTable, self.vtable).EnableModeless(@ptrCast(*const IActiveScriptSiteWindow, self), fEnable);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteUIControl_Value = @import("../../zig.zig").Guid.initString("aedae97e-d7ee-4796-b960-7f092ae844ab");
pub const IID_IActiveScriptSiteUIControl = &IID_IActiveScriptSiteUIControl_Value;
pub const IActiveScriptSiteUIControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetUIBehavior: fn(
            self: *const IActiveScriptSiteUIControl,
            UicItem: SCRIPTUICITEM,
            pUicHandling: ?*SCRIPTUICHANDLING,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteUIControl_GetUIBehavior(self: *const T, UicItem: SCRIPTUICITEM, pUicHandling: ?*SCRIPTUICHANDLING) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteUIControl.VTable, self.vtable).GetUIBehavior(@ptrCast(*const IActiveScriptSiteUIControl, self), UicItem, pUicHandling);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteInterruptPoll_Value = @import("../../zig.zig").Guid.initString("539698a0-cdca-11cf-a5eb-00aa0047a063");
pub const IID_IActiveScriptSiteInterruptPoll = &IID_IActiveScriptSiteInterruptPoll_Value;
pub const IActiveScriptSiteInterruptPoll = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryContinue: fn(
            self: *const IActiveScriptSiteInterruptPoll,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteInterruptPoll_QueryContinue(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteInterruptPoll.VTable, self.vtable).QueryContinue(@ptrCast(*const IActiveScriptSiteInterruptPoll, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScript_Value = @import("../../zig.zig").Guid.initString("bb1a2ae1-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScript = &IID_IActiveScript_Value;
pub const IActiveScript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetScriptSite: fn(
            self: *const IActiveScript,
            pass: ?*IActiveScriptSite,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptSite: fn(
            self: *const IActiveScript,
            riid: ?*const Guid,
            ppvObject: ?*?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScriptState: fn(
            self: *const IActiveScript,
            ss: SCRIPTSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptState: fn(
            self: *const IActiveScript,
            pssState: ?*SCRIPTSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IActiveScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddNamedItem: fn(
            self: *const IActiveScript,
            pstrName: ?[*:0]const u16,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTypeLib: fn(
            self: *const IActiveScript,
            rguidTypeLib: ?*const Guid,
            dwMajor: u32,
            dwMinor: u32,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptDispatch: fn(
            self: *const IActiveScript,
            pstrItemName: ?[*:0]const u16,
            ppdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentScriptThreadID: fn(
            self: *const IActiveScript,
            pstidThread: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptThreadID: fn(
            self: *const IActiveScript,
            dwWin32ThreadId: u32,
            pstidThread: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptThreadState: fn(
            self: *const IActiveScript,
            stidThread: u32,
            pstsState: ?*SCRIPTTHREADSTATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InterruptScriptThread: fn(
            self: *const IActiveScript,
            stidThread: u32,
            pexcepinfo: ?*const EXCEPINFO,
            dwFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IActiveScript,
            ppscript: ?*?*IActiveScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_SetScriptSite(self: *const T, pass: ?*IActiveScriptSite) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).SetScriptSite(@ptrCast(*const IActiveScript, self), pass);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptSite(self: *const T, riid: ?*const Guid, ppvObject: ?*?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptSite(@ptrCast(*const IActiveScript, self), riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_SetScriptState(self: *const T, ss: SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).SetScriptState(@ptrCast(*const IActiveScript, self), ss);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptState(self: *const T, pssState: ?*SCRIPTSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptState(@ptrCast(*const IActiveScript, self), pssState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).Close(@ptrCast(*const IActiveScript, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_AddNamedItem(self: *const T, pstrName: ?[*:0]const u16, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).AddNamedItem(@ptrCast(*const IActiveScript, self), pstrName, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_AddTypeLib(self: *const T, rguidTypeLib: ?*const Guid, dwMajor: u32, dwMinor: u32, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).AddTypeLib(@ptrCast(*const IActiveScript, self), rguidTypeLib, dwMajor, dwMinor, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptDispatch(self: *const T, pstrItemName: ?[*:0]const u16, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptDispatch(@ptrCast(*const IActiveScript, self), pstrItemName, ppdisp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetCurrentScriptThreadID(self: *const T, pstidThread: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetCurrentScriptThreadID(@ptrCast(*const IActiveScript, self), pstidThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptThreadID(self: *const T, dwWin32ThreadId: u32, pstidThread: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptThreadID(@ptrCast(*const IActiveScript, self), dwWin32ThreadId, pstidThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_GetScriptThreadState(self: *const T, stidThread: u32, pstsState: ?*SCRIPTTHREADSTATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).GetScriptThreadState(@ptrCast(*const IActiveScript, self), stidThread, pstsState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_InterruptScriptThread(self: *const T, stidThread: u32, pexcepinfo: ?*const EXCEPINFO, dwFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).InterruptScriptThread(@ptrCast(*const IActiveScript, self), stidThread, pexcepinfo, dwFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScript_Clone(self: *const T, ppscript: ?*?*IActiveScript) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScript.VTable, self.vtable).Clone(@ptrCast(*const IActiveScript, self), ppscript);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParse32_Value = @import("../../zig.zig").Guid.initString("bb1a2ae2-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptParse32 = &IID_IActiveScriptParse32_Value;
pub const IActiveScriptParse32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitNew: fn(
            self: *const IActiveScriptParse32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddScriptlet: fn(
            self: *const IActiveScriptParse32,
            pstrDefaultName: ?[*:0]const u16,
            pstrCode: ?[*:0]const u16,
            pstrItemName: ?[*:0]const u16,
            pstrSubItemName: ?[*:0]const u16,
            pstrEventName: ?[*:0]const u16,
            pstrDelimiter: ?[*:0]const u16,
            dwSourceContextCookie: u32,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            pbstrName: ?*?BSTR,
            pexcepinfo: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseScriptText: fn(
            self: *const IActiveScriptParse32,
            pstrCode: ?[*:0]const u16,
            pstrItemName: ?[*:0]const u16,
            punkContext: ?*IUnknown,
            pstrDelimiter: ?[*:0]const u16,
            dwSourceContextCookie: u32,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            pvarResult: ?*VARIANT,
            pexcepinfo: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse32.VTable, self.vtable).InitNew(@ptrCast(*const IActiveScriptParse32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_AddScriptlet(self: *const T, pstrDefaultName: ?[*:0]const u16, pstrCode: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, pstrSubItemName: ?[*:0]const u16, pstrEventName: ?[*:0]const u16, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, pbstrName: ?*?BSTR, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse32.VTable, self.vtable).AddScriptlet(@ptrCast(*const IActiveScriptParse32, self), pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pbstrName, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse32_ParseScriptText(self: *const T, pstrCode: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, pvarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse32.VTable, self.vtable).ParseScriptText(@ptrCast(*const IActiveScriptParse32, self), pstrCode, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pvarResult, pexcepinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParse64_Value = @import("../../zig.zig").Guid.initString("c7ef7658-e1ee-480e-97ea-d52cb4d76d17");
pub const IID_IActiveScriptParse64 = &IID_IActiveScriptParse64_Value;
pub const IActiveScriptParse64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitNew: fn(
            self: *const IActiveScriptParse64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddScriptlet: fn(
            self: *const IActiveScriptParse64,
            pstrDefaultName: ?[*:0]const u16,
            pstrCode: ?[*:0]const u16,
            pstrItemName: ?[*:0]const u16,
            pstrSubItemName: ?[*:0]const u16,
            pstrEventName: ?[*:0]const u16,
            pstrDelimiter: ?[*:0]const u16,
            dwSourceContextCookie: u64,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            pbstrName: ?*?BSTR,
            pexcepinfo: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ParseScriptText: fn(
            self: *const IActiveScriptParse64,
            pstrCode: ?[*:0]const u16,
            pstrItemName: ?[*:0]const u16,
            punkContext: ?*IUnknown,
            pstrDelimiter: ?[*:0]const u16,
            dwSourceContextCookie: u64,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            pvarResult: ?*VARIANT,
            pexcepinfo: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_InitNew(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse64.VTable, self.vtable).InitNew(@ptrCast(*const IActiveScriptParse64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_AddScriptlet(self: *const T, pstrDefaultName: ?[*:0]const u16, pstrCode: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, pstrSubItemName: ?[*:0]const u16, pstrEventName: ?[*:0]const u16, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, pbstrName: ?*?BSTR, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse64.VTable, self.vtable).AddScriptlet(@ptrCast(*const IActiveScriptParse64, self), pstrDefaultName, pstrCode, pstrItemName, pstrSubItemName, pstrEventName, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pbstrName, pexcepinfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParse64_ParseScriptText(self: *const T, pstrCode: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, pvarResult: ?*VARIANT, pexcepinfo: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParse64.VTable, self.vtable).ParseScriptText(@ptrCast(*const IActiveScriptParse64, self), pstrCode, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, pvarResult, pexcepinfo);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedureOld32_Value = @import("../../zig.zig").Guid.initString("1cff0050-6fdd-11d0-9328-00a0c90dcaa9");
pub const IID_IActiveScriptParseProcedureOld32 = &IID_IActiveScriptParseProcedureOld32_Value;
pub const IActiveScriptParseProcedureOld32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: fn(
            self: *const IActiveScriptParseProcedureOld32,
            pstrCode: ?[*:0]const u16,
            pstrFormalParams: ?[*:0]const u16,
            pstrItemName: ?[*:0]const u16,
            punkContext: ?*IUnknown,
            pstrDelimiter: ?[*:0]const u16,
            dwSourceContextCookie: u32,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            ppdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedureOld32_ParseProcedureText(self: *const T, pstrCode: ?[*:0]const u16, pstrFormalParams: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParseProcedureOld32.VTable, self.vtable).ParseProcedureText(@ptrCast(*const IActiveScriptParseProcedureOld32, self), pstrCode, pstrFormalParams, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedureOld64_Value = @import("../../zig.zig").Guid.initString("21f57128-08c9-4638-ba12-22d15d88dc5c");
pub const IID_IActiveScriptParseProcedureOld64 = &IID_IActiveScriptParseProcedureOld64_Value;
pub const IActiveScriptParseProcedureOld64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: fn(
            self: *const IActiveScriptParseProcedureOld64,
            pstrCode: ?[*:0]const u16,
            pstrFormalParams: ?[*:0]const u16,
            pstrItemName: ?[*:0]const u16,
            punkContext: ?*IUnknown,
            pstrDelimiter: ?[*:0]const u16,
            dwSourceContextCookie: u64,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            ppdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedureOld64_ParseProcedureText(self: *const T, pstrCode: ?[*:0]const u16, pstrFormalParams: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParseProcedureOld64.VTable, self.vtable).ParseProcedureText(@ptrCast(*const IActiveScriptParseProcedureOld64, self), pstrCode, pstrFormalParams, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure32_Value = @import("../../zig.zig").Guid.initString("aa5b6a80-b834-11d0-932f-00a0c90dcaa9");
pub const IID_IActiveScriptParseProcedure32 = &IID_IActiveScriptParseProcedure32_Value;
pub const IActiveScriptParseProcedure32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: fn(
            self: *const IActiveScriptParseProcedure32,
            pstrCode: ?[*:0]const u16,
            pstrFormalParams: ?[*:0]const u16,
            pstrProcedureName: ?[*:0]const u16,
            pstrItemName: ?[*:0]const u16,
            punkContext: ?*IUnknown,
            pstrDelimiter: ?[*:0]const u16,
            dwSourceContextCookie: u32,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            ppdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedure32_ParseProcedureText(self: *const T, pstrCode: ?[*:0]const u16, pstrFormalParams: ?[*:0]const u16, pstrProcedureName: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u32, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParseProcedure32.VTable, self.vtable).ParseProcedureText(@ptrCast(*const IActiveScriptParseProcedure32, self), pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure64_Value = @import("../../zig.zig").Guid.initString("c64713b6-e029-4cc5-9200-438b72890b6a");
pub const IID_IActiveScriptParseProcedure64 = &IID_IActiveScriptParseProcedure64_Value;
pub const IActiveScriptParseProcedure64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseProcedureText: fn(
            self: *const IActiveScriptParseProcedure64,
            pstrCode: ?[*:0]const u16,
            pstrFormalParams: ?[*:0]const u16,
            pstrProcedureName: ?[*:0]const u16,
            pstrItemName: ?[*:0]const u16,
            punkContext: ?*IUnknown,
            pstrDelimiter: ?[*:0]const u16,
            dwSourceContextCookie: u64,
            ulStartingLineNumber: u32,
            dwFlags: u32,
            ppdisp: ?*?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptParseProcedure64_ParseProcedureText(self: *const T, pstrCode: ?[*:0]const u16, pstrFormalParams: ?[*:0]const u16, pstrProcedureName: ?[*:0]const u16, pstrItemName: ?[*:0]const u16, punkContext: ?*IUnknown, pstrDelimiter: ?[*:0]const u16, dwSourceContextCookie: u64, ulStartingLineNumber: u32, dwFlags: u32, ppdisp: ?*?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptParseProcedure64.VTable, self.vtable).ParseProcedureText(@ptrCast(*const IActiveScriptParseProcedure64, self), pstrCode, pstrFormalParams, pstrProcedureName, pstrItemName, punkContext, pstrDelimiter, dwSourceContextCookie, ulStartingLineNumber, dwFlags, ppdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure2_32_Value = @import("../../zig.zig").Guid.initString("71ee5b20-fb04-11d1-b3a8-00a0c911e8b2");
pub const IID_IActiveScriptParseProcedure2_32 = &IID_IActiveScriptParseProcedure2_32_Value;
pub const IActiveScriptParseProcedure2_32 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptParseProcedure32.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptParseProcedure32.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptParseProcedure2_64_Value = @import("../../zig.zig").Guid.initString("fe7c4271-210c-448d-9f54-76dab7047b28");
pub const IID_IActiveScriptParseProcedure2_64 = &IID_IActiveScriptParseProcedure2_64_Value;
pub const IActiveScriptParseProcedure2_64 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptParseProcedure64.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptParseProcedure64.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptEncode_Value = @import("../../zig.zig").Guid.initString("bb1a2ae3-a4f9-11cf-8f20-00805f2cd064");
pub const IID_IActiveScriptEncode = &IID_IActiveScriptEncode_Value;
pub const IActiveScriptEncode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncodeSection: fn(
            self: *const IActiveScriptEncode,
            pchIn: ?[*:0]const u16,
            cchIn: u32,
            pchOut: ?PWSTR,
            cchOut: u32,
            pcchRet: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DecodeScript: fn(
            self: *const IActiveScriptEncode,
            pchIn: ?[*:0]const u16,
            cchIn: u32,
            pchOut: ?PWSTR,
            cchOut: u32,
            pcchRet: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEncodeProgId: fn(
            self: *const IActiveScriptEncode,
            pbstrOut: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_EncodeSection(self: *const T, pchIn: ?[*:0]const u16, cchIn: u32, pchOut: ?PWSTR, cchOut: u32, pcchRet: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptEncode.VTable, self.vtable).EncodeSection(@ptrCast(*const IActiveScriptEncode, self), pchIn, cchIn, pchOut, cchOut, pcchRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_DecodeScript(self: *const T, pchIn: ?[*:0]const u16, cchIn: u32, pchOut: ?PWSTR, cchOut: u32, pcchRet: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptEncode.VTable, self.vtable).DecodeScript(@ptrCast(*const IActiveScriptEncode, self), pchIn, cchIn, pchOut, cchOut, pcchRet);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptEncode_GetEncodeProgId(self: *const T, pbstrOut: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptEncode.VTable, self.vtable).GetEncodeProgId(@ptrCast(*const IActiveScriptEncode, self), pbstrOut);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptHostEncode_Value = @import("../../zig.zig").Guid.initString("bee9b76e-cfe3-11d1-b747-00c04fc2b085");
pub const IID_IActiveScriptHostEncode = &IID_IActiveScriptHostEncode_Value;
pub const IActiveScriptHostEncode = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EncodeScriptHostFile: fn(
            self: *const IActiveScriptHostEncode,
            bstrInFile: ?BSTR,
            pbstrOutFile: ?*?BSTR,
            cFlags: u32,
            bstrDefaultLang: ?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptHostEncode_EncodeScriptHostFile(self: *const T, bstrInFile: ?BSTR, pbstrOutFile: ?*?BSTR, cFlags: u32, bstrDefaultLang: ?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptHostEncode.VTable, self.vtable).EncodeScriptHostFile(@ptrCast(*const IActiveScriptHostEncode, self), bstrInFile, pbstrOutFile, cFlags, bstrDefaultLang);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IBindEventHandler_Value = @import("../../zig.zig").Guid.initString("63cdbcb0-c1b1-11d0-9336-00a0c90dcaa9");
pub const IID_IBindEventHandler = &IID_IBindEventHandler_Value;
pub const IBindEventHandler = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindHandler: fn(
            self: *const IBindEventHandler,
            pstrEvent: ?[*:0]const u16,
            pdisp: ?*IDispatch,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IBindEventHandler_BindHandler(self: *const T, pstrEvent: ?[*:0]const u16, pdisp: ?*IDispatch) callconv(.Inline) HRESULT {
            return @ptrCast(*const IBindEventHandler.VTable, self.vtable).BindHandler(@ptrCast(*const IBindEventHandler, self), pstrEvent, pdisp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptStats_Value = @import("../../zig.zig").Guid.initString("b8da6310-e19b-11d0-933c-00a0c90dcaa9");
pub const IID_IActiveScriptStats = &IID_IActiveScriptStats_Value;
pub const IActiveScriptStats = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStat: fn(
            self: *const IActiveScriptStats,
            stid: u32,
            pluHi: ?*u32,
            pluLo: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStatEx: fn(
            self: *const IActiveScriptStats,
            guid: ?*const Guid,
            pluHi: ?*u32,
            pluLo: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetStats: fn(
            self: *const IActiveScriptStats,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_GetStat(self: *const T, stid: u32, pluHi: ?*u32, pluLo: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptStats.VTable, self.vtable).GetStat(@ptrCast(*const IActiveScriptStats, self), stid, pluHi, pluLo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_GetStatEx(self: *const T, guid: ?*const Guid, pluHi: ?*u32, pluLo: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptStats.VTable, self.vtable).GetStatEx(@ptrCast(*const IActiveScriptStats, self), guid, pluHi, pluLo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStats_ResetStats(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptStats.VTable, self.vtable).ResetStats(@ptrCast(*const IActiveScriptStats, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProperty_Value = @import("../../zig.zig").Guid.initString("4954e0d0-fbc7-11d1-8410-006008c3fbfc");
pub const IID_IActiveScriptProperty = &IID_IActiveScriptProperty_Value;
pub const IActiveScriptProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetProperty: fn(
            self: *const IActiveScriptProperty,
            dwProperty: u32,
            pvarIndex: ?*VARIANT,
            pvarValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProperty: fn(
            self: *const IActiveScriptProperty,
            dwProperty: u32,
            pvarIndex: ?*VARIANT,
            pvarValue: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProperty_GetProperty(self: *const T, dwProperty: u32, pvarIndex: ?*VARIANT, pvarValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProperty.VTable, self.vtable).GetProperty(@ptrCast(*const IActiveScriptProperty, self), dwProperty, pvarIndex, pvarValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProperty_SetProperty(self: *const T, dwProperty: u32, pvarIndex: ?*VARIANT, pvarValue: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProperty.VTable, self.vtable).SetProperty(@ptrCast(*const IActiveScriptProperty, self), dwProperty, pvarIndex, pvarValue);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ITridentEventSink_Value = @import("../../zig.zig").Guid.initString("1dc9ca50-06ef-11d2-8415-006008c3fbfc");
pub const IID_ITridentEventSink = &IID_ITridentEventSink_Value;
pub const ITridentEventSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        FireEvent: fn(
            self: *const ITridentEventSink,
            pstrEvent: ?[*:0]const u16,
            pdp: ?*DISPPARAMS,
            pvarRes: ?*VARIANT,
            pei: ?*EXCEPINFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ITridentEventSink_FireEvent(self: *const T, pstrEvent: ?[*:0]const u16, pdp: ?*DISPPARAMS, pvarRes: ?*VARIANT, pei: ?*EXCEPINFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const ITridentEventSink.VTable, self.vtable).FireEvent(@ptrCast(*const ITridentEventSink, self), pstrEvent, pdp, pvarRes, pei);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptGarbageCollector_Value = @import("../../zig.zig").Guid.initString("6aa2c4a0-2b53-11d4-a2a0-00104bd35090");
pub const IID_IActiveScriptGarbageCollector = &IID_IActiveScriptGarbageCollector_Value;
pub const IActiveScriptGarbageCollector = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CollectGarbage: fn(
            self: *const IActiveScriptGarbageCollector,
            scriptgctype: SCRIPTGCTYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptGarbageCollector_CollectGarbage(self: *const T, scriptgctype: SCRIPTGCTYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptGarbageCollector.VTable, self.vtable).CollectGarbage(@ptrCast(*const IActiveScriptGarbageCollector, self), scriptgctype);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSIPInfo_Value = @import("../../zig.zig").Guid.initString("764651d0-38de-11d4-a2a3-00104bd35090");
pub const IID_IActiveScriptSIPInfo = &IID_IActiveScriptSIPInfo_Value;
pub const IActiveScriptSIPInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSIPOID: fn(
            self: *const IActiveScriptSIPInfo,
            poid_sip: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSIPInfo_GetSIPOID(self: *const T, poid_sip: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSIPInfo.VTable, self.vtable).GetSIPOID(@ptrCast(*const IActiveScriptSIPInfo, self), poid_sip);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteTraceInfo_Value = @import("../../zig.zig").Guid.initString("4b7272ae-1955-4bfe-98b0-780621888569");
pub const IID_IActiveScriptSiteTraceInfo = &IID_IActiveScriptSiteTraceInfo_Value;
pub const IActiveScriptSiteTraceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SendScriptTraceInfo: fn(
            self: *const IActiveScriptSiteTraceInfo,
            stiEventType: SCRIPTTRACEINFO,
            guidContextID: Guid,
            dwScriptContextCookie: u32,
            lScriptStatementStart: i32,
            lScriptStatementEnd: i32,
            dwReserved: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteTraceInfo_SendScriptTraceInfo(self: *const T, stiEventType: SCRIPTTRACEINFO, guidContextID: Guid, dwScriptContextCookie: u32, lScriptStatementStart: i32, lScriptStatementEnd: i32, dwReserved: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteTraceInfo.VTable, self.vtable).SendScriptTraceInfo(@ptrCast(*const IActiveScriptSiteTraceInfo, self), stiEventType, guidContextID, dwScriptContextCookie, lScriptStatementStart, lScriptStatementEnd, dwReserved);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptTraceInfo_Value = @import("../../zig.zig").Guid.initString("c35456e7-bebf-4a1b-86a9-24d56be8b369");
pub const IID_IActiveScriptTraceInfo = &IID_IActiveScriptTraceInfo_Value;
pub const IActiveScriptTraceInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartScriptTracing: fn(
            self: *const IActiveScriptTraceInfo,
            pSiteTraceInfo: ?*IActiveScriptSiteTraceInfo,
            guidContextID: Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopScriptTracing: fn(
            self: *const IActiveScriptTraceInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptTraceInfo_StartScriptTracing(self: *const T, pSiteTraceInfo: ?*IActiveScriptSiteTraceInfo, guidContextID: Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptTraceInfo.VTable, self.vtable).StartScriptTracing(@ptrCast(*const IActiveScriptTraceInfo, self), pSiteTraceInfo, guidContextID);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptTraceInfo_StopScriptTracing(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptTraceInfo.VTable, self.vtable).StopScriptTracing(@ptrCast(*const IActiveScriptTraceInfo, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptStringCompare_Value = @import("../../zig.zig").Guid.initString("58562769-ed52-42f7-8403-4963514e1f11");
pub const IID_IActiveScriptStringCompare = &IID_IActiveScriptStringCompare_Value;
pub const IActiveScriptStringCompare = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StrComp: fn(
            self: *const IActiveScriptStringCompare,
            bszStr1: ?BSTR,
            bszStr2: ?BSTR,
            iRet: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptStringCompare_StrComp(self: *const T, bszStr1: ?BSTR, bszStr2: ?BSTR, iRet: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptStringCompare.VTable, self.vtable).StrComp(@ptrCast(*const IActiveScriptStringCompare, self), bszStr1, bszStr2, iRet);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DBGPROP_ATTRIB_FLAGS = enum(u32) {
    NO_ATTRIB = 0,
    VALUE_IS_INVALID = 8,
    VALUE_IS_EXPANDABLE = 16,
    VALUE_IS_FAKE = 32,
    VALUE_IS_METHOD = 256,
    VALUE_IS_EVENT = 512,
    VALUE_IS_RAW_STRING = 1024,
    VALUE_READONLY = 2048,
    ACCESS_PUBLIC = 4096,
    ACCESS_PRIVATE = 8192,
    ACCESS_PROTECTED = 16384,
    ACCESS_FINAL = 32768,
    STORAGE_GLOBAL = 65536,
    STORAGE_STATIC = 131072,
    STORAGE_FIELD = 262144,
    STORAGE_VIRTUAL = 524288,
    TYPE_IS_CONSTANT = 1048576,
    TYPE_IS_SYNCHRONIZED = 2097152,
    TYPE_IS_VOLATILE = 4194304,
    HAS_EXTENDED_ATTRIBS = 8388608,
    FRAME_INTRYBLOCK = 16777216,
    FRAME_INCATCHBLOCK = 33554432,
    FRAME_INFINALLYBLOCK = 67108864,
    VALUE_IS_RETURN_VALUE = 134217728,
    VALUE_PENDING_MUTATION = 268435456,
    _,
    pub fn initFlags(o: struct {
        NO_ATTRIB: u1 = 0,
        VALUE_IS_INVALID: u1 = 0,
        VALUE_IS_EXPANDABLE: u1 = 0,
        VALUE_IS_FAKE: u1 = 0,
        VALUE_IS_METHOD: u1 = 0,
        VALUE_IS_EVENT: u1 = 0,
        VALUE_IS_RAW_STRING: u1 = 0,
        VALUE_READONLY: u1 = 0,
        ACCESS_PUBLIC: u1 = 0,
        ACCESS_PRIVATE: u1 = 0,
        ACCESS_PROTECTED: u1 = 0,
        ACCESS_FINAL: u1 = 0,
        STORAGE_GLOBAL: u1 = 0,
        STORAGE_STATIC: u1 = 0,
        STORAGE_FIELD: u1 = 0,
        STORAGE_VIRTUAL: u1 = 0,
        TYPE_IS_CONSTANT: u1 = 0,
        TYPE_IS_SYNCHRONIZED: u1 = 0,
        TYPE_IS_VOLATILE: u1 = 0,
        HAS_EXTENDED_ATTRIBS: u1 = 0,
        FRAME_INTRYBLOCK: u1 = 0,
        FRAME_INCATCHBLOCK: u1 = 0,
        FRAME_INFINALLYBLOCK: u1 = 0,
        VALUE_IS_RETURN_VALUE: u1 = 0,
        VALUE_PENDING_MUTATION: u1 = 0,
    }) DBGPROP_ATTRIB_FLAGS {
        return @intToEnum(DBGPROP_ATTRIB_FLAGS,
              (if (o.NO_ATTRIB == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.NO_ATTRIB) else 0)
            | (if (o.VALUE_IS_INVALID == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_IS_INVALID) else 0)
            | (if (o.VALUE_IS_EXPANDABLE == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_IS_EXPANDABLE) else 0)
            | (if (o.VALUE_IS_FAKE == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_IS_FAKE) else 0)
            | (if (o.VALUE_IS_METHOD == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_IS_METHOD) else 0)
            | (if (o.VALUE_IS_EVENT == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_IS_EVENT) else 0)
            | (if (o.VALUE_IS_RAW_STRING == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_IS_RAW_STRING) else 0)
            | (if (o.VALUE_READONLY == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_READONLY) else 0)
            | (if (o.ACCESS_PUBLIC == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.ACCESS_PUBLIC) else 0)
            | (if (o.ACCESS_PRIVATE == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.ACCESS_PRIVATE) else 0)
            | (if (o.ACCESS_PROTECTED == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.ACCESS_PROTECTED) else 0)
            | (if (o.ACCESS_FINAL == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.ACCESS_FINAL) else 0)
            | (if (o.STORAGE_GLOBAL == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.STORAGE_GLOBAL) else 0)
            | (if (o.STORAGE_STATIC == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.STORAGE_STATIC) else 0)
            | (if (o.STORAGE_FIELD == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.STORAGE_FIELD) else 0)
            | (if (o.STORAGE_VIRTUAL == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.STORAGE_VIRTUAL) else 0)
            | (if (o.TYPE_IS_CONSTANT == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.TYPE_IS_CONSTANT) else 0)
            | (if (o.TYPE_IS_SYNCHRONIZED == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.TYPE_IS_SYNCHRONIZED) else 0)
            | (if (o.TYPE_IS_VOLATILE == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.TYPE_IS_VOLATILE) else 0)
            | (if (o.HAS_EXTENDED_ATTRIBS == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.HAS_EXTENDED_ATTRIBS) else 0)
            | (if (o.FRAME_INTRYBLOCK == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.FRAME_INTRYBLOCK) else 0)
            | (if (o.FRAME_INCATCHBLOCK == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.FRAME_INCATCHBLOCK) else 0)
            | (if (o.FRAME_INFINALLYBLOCK == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.FRAME_INFINALLYBLOCK) else 0)
            | (if (o.VALUE_IS_RETURN_VALUE == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_IS_RETURN_VALUE) else 0)
            | (if (o.VALUE_PENDING_MUTATION == 1) @enumToInt(DBGPROP_ATTRIB_FLAGS.VALUE_PENDING_MUTATION) else 0)
        );
    }
};
pub const DBGPROP_ATTRIB_NO_ATTRIB = DBGPROP_ATTRIB_FLAGS.NO_ATTRIB;
pub const DBGPROP_ATTRIB_VALUE_IS_INVALID = DBGPROP_ATTRIB_FLAGS.VALUE_IS_INVALID;
pub const DBGPROP_ATTRIB_VALUE_IS_EXPANDABLE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_EXPANDABLE;
pub const DBGPROP_ATTRIB_VALUE_IS_FAKE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_FAKE;
pub const DBGPROP_ATTRIB_VALUE_IS_METHOD = DBGPROP_ATTRIB_FLAGS.VALUE_IS_METHOD;
pub const DBGPROP_ATTRIB_VALUE_IS_EVENT = DBGPROP_ATTRIB_FLAGS.VALUE_IS_EVENT;
pub const DBGPROP_ATTRIB_VALUE_IS_RAW_STRING = DBGPROP_ATTRIB_FLAGS.VALUE_IS_RAW_STRING;
pub const DBGPROP_ATTRIB_VALUE_READONLY = DBGPROP_ATTRIB_FLAGS.VALUE_READONLY;
pub const DBGPROP_ATTRIB_ACCESS_PUBLIC = DBGPROP_ATTRIB_FLAGS.ACCESS_PUBLIC;
pub const DBGPROP_ATTRIB_ACCESS_PRIVATE = DBGPROP_ATTRIB_FLAGS.ACCESS_PRIVATE;
pub const DBGPROP_ATTRIB_ACCESS_PROTECTED = DBGPROP_ATTRIB_FLAGS.ACCESS_PROTECTED;
pub const DBGPROP_ATTRIB_ACCESS_FINAL = DBGPROP_ATTRIB_FLAGS.ACCESS_FINAL;
pub const DBGPROP_ATTRIB_STORAGE_GLOBAL = DBGPROP_ATTRIB_FLAGS.STORAGE_GLOBAL;
pub const DBGPROP_ATTRIB_STORAGE_STATIC = DBGPROP_ATTRIB_FLAGS.STORAGE_STATIC;
pub const DBGPROP_ATTRIB_STORAGE_FIELD = DBGPROP_ATTRIB_FLAGS.STORAGE_FIELD;
pub const DBGPROP_ATTRIB_STORAGE_VIRTUAL = DBGPROP_ATTRIB_FLAGS.STORAGE_VIRTUAL;
pub const DBGPROP_ATTRIB_TYPE_IS_CONSTANT = DBGPROP_ATTRIB_FLAGS.TYPE_IS_CONSTANT;
pub const DBGPROP_ATTRIB_TYPE_IS_SYNCHRONIZED = DBGPROP_ATTRIB_FLAGS.TYPE_IS_SYNCHRONIZED;
pub const DBGPROP_ATTRIB_TYPE_IS_VOLATILE = DBGPROP_ATTRIB_FLAGS.TYPE_IS_VOLATILE;
pub const DBGPROP_ATTRIB_HAS_EXTENDED_ATTRIBS = DBGPROP_ATTRIB_FLAGS.HAS_EXTENDED_ATTRIBS;
pub const DBGPROP_ATTRIB_FRAME_INTRYBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INTRYBLOCK;
pub const DBGPROP_ATTRIB_FRAME_INCATCHBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INCATCHBLOCK;
pub const DBGPROP_ATTRIB_FRAME_INFINALLYBLOCK = DBGPROP_ATTRIB_FLAGS.FRAME_INFINALLYBLOCK;
pub const DBGPROP_ATTRIB_VALUE_IS_RETURN_VALUE = DBGPROP_ATTRIB_FLAGS.VALUE_IS_RETURN_VALUE;
pub const DBGPROP_ATTRIB_VALUE_PENDING_MUTATION = DBGPROP_ATTRIB_FLAGS.VALUE_PENDING_MUTATION;

pub const DBGPROP_INFO = enum(u32) {
    NAME = 1,
    TYPE = 2,
    VALUE = 4,
    FULLNAME = 32,
    ATTRIBUTES = 8,
    DEBUGPROP = 16,
    BEAUTIFY = 33554432,
    CALLTOSTRING = 67108864,
    AUTOEXPAND = 134217728,
    _,
    pub fn initFlags(o: struct {
        NAME: u1 = 0,
        TYPE: u1 = 0,
        VALUE: u1 = 0,
        FULLNAME: u1 = 0,
        ATTRIBUTES: u1 = 0,
        DEBUGPROP: u1 = 0,
        BEAUTIFY: u1 = 0,
        CALLTOSTRING: u1 = 0,
        AUTOEXPAND: u1 = 0,
    }) DBGPROP_INFO {
        return @intToEnum(DBGPROP_INFO,
              (if (o.NAME == 1) @enumToInt(DBGPROP_INFO.NAME) else 0)
            | (if (o.TYPE == 1) @enumToInt(DBGPROP_INFO.TYPE) else 0)
            | (if (o.VALUE == 1) @enumToInt(DBGPROP_INFO.VALUE) else 0)
            | (if (o.FULLNAME == 1) @enumToInt(DBGPROP_INFO.FULLNAME) else 0)
            | (if (o.ATTRIBUTES == 1) @enumToInt(DBGPROP_INFO.ATTRIBUTES) else 0)
            | (if (o.DEBUGPROP == 1) @enumToInt(DBGPROP_INFO.DEBUGPROP) else 0)
            | (if (o.BEAUTIFY == 1) @enumToInt(DBGPROP_INFO.BEAUTIFY) else 0)
            | (if (o.CALLTOSTRING == 1) @enumToInt(DBGPROP_INFO.CALLTOSTRING) else 0)
            | (if (o.AUTOEXPAND == 1) @enumToInt(DBGPROP_INFO.AUTOEXPAND) else 0)
        );
    }
};
pub const DBGPROP_INFO_NAME = DBGPROP_INFO.NAME;
pub const DBGPROP_INFO_TYPE = DBGPROP_INFO.TYPE;
pub const DBGPROP_INFO_VALUE = DBGPROP_INFO.VALUE;
pub const DBGPROP_INFO_FULLNAME = DBGPROP_INFO.FULLNAME;
pub const DBGPROP_INFO_ATTRIBUTES = DBGPROP_INFO.ATTRIBUTES;
pub const DBGPROP_INFO_DEBUGPROP = DBGPROP_INFO.DEBUGPROP;
pub const DBGPROP_INFO_BEAUTIFY = DBGPROP_INFO.BEAUTIFY;
pub const DBGPROP_INFO_CALLTOSTRING = DBGPROP_INFO.CALLTOSTRING;
pub const DBGPROP_INFO_AUTOEXPAND = DBGPROP_INFO.AUTOEXPAND;

pub const OBJECT_ATTRIB_FLAG = enum(u32) {
    NO_ATTRIB = 0,
    NO_NAME = 1,
    NO_TYPE = 2,
    NO_VALUE = 4,
    VALUE_IS_INVALID = 8,
    VALUE_IS_OBJECT = 16,
    VALUE_IS_ENUM = 32,
    VALUE_IS_CUSTOM = 64,
    OBJECT_IS_EXPANDABLE = 112,
    VALUE_HAS_CODE = 128,
    TYPE_IS_OBJECT = 256,
    TYPE_HAS_CODE = 512,
    // TYPE_IS_EXPANDABLE = 256, this enum value conflicts with TYPE_IS_OBJECT
    SLOT_IS_CATEGORY = 1024,
    VALUE_READONLY = 2048,
    ACCESS_PUBLIC = 4096,
    ACCESS_PRIVATE = 8192,
    ACCESS_PROTECTED = 16384,
    ACCESS_FINAL = 32768,
    STORAGE_GLOBAL = 65536,
    STORAGE_STATIC = 131072,
    STORAGE_FIELD = 262144,
    STORAGE_VIRTUAL = 524288,
    TYPE_IS_CONSTANT = 1048576,
    TYPE_IS_SYNCHRONIZED = 2097152,
    TYPE_IS_VOLATILE = 4194304,
    HAS_EXTENDED_ATTRIBS = 8388608,
    IS_CLASS = 16777216,
    IS_FUNCTION = 33554432,
    IS_VARIABLE = 67108864,
    IS_PROPERTY = 134217728,
    IS_MACRO = 268435456,
    IS_TYPE = 536870912,
    IS_INHERITED = 1073741824,
    IS_INTERFACE = 2147483648,
    _,
    pub fn initFlags(o: struct {
        NO_ATTRIB: u1 = 0,
        NO_NAME: u1 = 0,
        NO_TYPE: u1 = 0,
        NO_VALUE: u1 = 0,
        VALUE_IS_INVALID: u1 = 0,
        VALUE_IS_OBJECT: u1 = 0,
        VALUE_IS_ENUM: u1 = 0,
        VALUE_IS_CUSTOM: u1 = 0,
        OBJECT_IS_EXPANDABLE: u1 = 0,
        VALUE_HAS_CODE: u1 = 0,
        TYPE_IS_OBJECT: u1 = 0,
        TYPE_HAS_CODE: u1 = 0,
        SLOT_IS_CATEGORY: u1 = 0,
        VALUE_READONLY: u1 = 0,
        ACCESS_PUBLIC: u1 = 0,
        ACCESS_PRIVATE: u1 = 0,
        ACCESS_PROTECTED: u1 = 0,
        ACCESS_FINAL: u1 = 0,
        STORAGE_GLOBAL: u1 = 0,
        STORAGE_STATIC: u1 = 0,
        STORAGE_FIELD: u1 = 0,
        STORAGE_VIRTUAL: u1 = 0,
        TYPE_IS_CONSTANT: u1 = 0,
        TYPE_IS_SYNCHRONIZED: u1 = 0,
        TYPE_IS_VOLATILE: u1 = 0,
        HAS_EXTENDED_ATTRIBS: u1 = 0,
        IS_CLASS: u1 = 0,
        IS_FUNCTION: u1 = 0,
        IS_VARIABLE: u1 = 0,
        IS_PROPERTY: u1 = 0,
        IS_MACRO: u1 = 0,
        IS_TYPE: u1 = 0,
        IS_INHERITED: u1 = 0,
        IS_INTERFACE: u1 = 0,
    }) OBJECT_ATTRIB_FLAG {
        return @intToEnum(OBJECT_ATTRIB_FLAG,
              (if (o.NO_ATTRIB == 1) @enumToInt(OBJECT_ATTRIB_FLAG.NO_ATTRIB) else 0)
            | (if (o.NO_NAME == 1) @enumToInt(OBJECT_ATTRIB_FLAG.NO_NAME) else 0)
            | (if (o.NO_TYPE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.NO_TYPE) else 0)
            | (if (o.NO_VALUE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.NO_VALUE) else 0)
            | (if (o.VALUE_IS_INVALID == 1) @enumToInt(OBJECT_ATTRIB_FLAG.VALUE_IS_INVALID) else 0)
            | (if (o.VALUE_IS_OBJECT == 1) @enumToInt(OBJECT_ATTRIB_FLAG.VALUE_IS_OBJECT) else 0)
            | (if (o.VALUE_IS_ENUM == 1) @enumToInt(OBJECT_ATTRIB_FLAG.VALUE_IS_ENUM) else 0)
            | (if (o.VALUE_IS_CUSTOM == 1) @enumToInt(OBJECT_ATTRIB_FLAG.VALUE_IS_CUSTOM) else 0)
            | (if (o.OBJECT_IS_EXPANDABLE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.OBJECT_IS_EXPANDABLE) else 0)
            | (if (o.VALUE_HAS_CODE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.VALUE_HAS_CODE) else 0)
            | (if (o.TYPE_IS_OBJECT == 1) @enumToInt(OBJECT_ATTRIB_FLAG.TYPE_IS_OBJECT) else 0)
            | (if (o.TYPE_HAS_CODE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.TYPE_HAS_CODE) else 0)
            | (if (o.SLOT_IS_CATEGORY == 1) @enumToInt(OBJECT_ATTRIB_FLAG.SLOT_IS_CATEGORY) else 0)
            | (if (o.VALUE_READONLY == 1) @enumToInt(OBJECT_ATTRIB_FLAG.VALUE_READONLY) else 0)
            | (if (o.ACCESS_PUBLIC == 1) @enumToInt(OBJECT_ATTRIB_FLAG.ACCESS_PUBLIC) else 0)
            | (if (o.ACCESS_PRIVATE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.ACCESS_PRIVATE) else 0)
            | (if (o.ACCESS_PROTECTED == 1) @enumToInt(OBJECT_ATTRIB_FLAG.ACCESS_PROTECTED) else 0)
            | (if (o.ACCESS_FINAL == 1) @enumToInt(OBJECT_ATTRIB_FLAG.ACCESS_FINAL) else 0)
            | (if (o.STORAGE_GLOBAL == 1) @enumToInt(OBJECT_ATTRIB_FLAG.STORAGE_GLOBAL) else 0)
            | (if (o.STORAGE_STATIC == 1) @enumToInt(OBJECT_ATTRIB_FLAG.STORAGE_STATIC) else 0)
            | (if (o.STORAGE_FIELD == 1) @enumToInt(OBJECT_ATTRIB_FLAG.STORAGE_FIELD) else 0)
            | (if (o.STORAGE_VIRTUAL == 1) @enumToInt(OBJECT_ATTRIB_FLAG.STORAGE_VIRTUAL) else 0)
            | (if (o.TYPE_IS_CONSTANT == 1) @enumToInt(OBJECT_ATTRIB_FLAG.TYPE_IS_CONSTANT) else 0)
            | (if (o.TYPE_IS_SYNCHRONIZED == 1) @enumToInt(OBJECT_ATTRIB_FLAG.TYPE_IS_SYNCHRONIZED) else 0)
            | (if (o.TYPE_IS_VOLATILE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.TYPE_IS_VOLATILE) else 0)
            | (if (o.HAS_EXTENDED_ATTRIBS == 1) @enumToInt(OBJECT_ATTRIB_FLAG.HAS_EXTENDED_ATTRIBS) else 0)
            | (if (o.IS_CLASS == 1) @enumToInt(OBJECT_ATTRIB_FLAG.IS_CLASS) else 0)
            | (if (o.IS_FUNCTION == 1) @enumToInt(OBJECT_ATTRIB_FLAG.IS_FUNCTION) else 0)
            | (if (o.IS_VARIABLE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.IS_VARIABLE) else 0)
            | (if (o.IS_PROPERTY == 1) @enumToInt(OBJECT_ATTRIB_FLAG.IS_PROPERTY) else 0)
            | (if (o.IS_MACRO == 1) @enumToInt(OBJECT_ATTRIB_FLAG.IS_MACRO) else 0)
            | (if (o.IS_TYPE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.IS_TYPE) else 0)
            | (if (o.IS_INHERITED == 1) @enumToInt(OBJECT_ATTRIB_FLAG.IS_INHERITED) else 0)
            | (if (o.IS_INTERFACE == 1) @enumToInt(OBJECT_ATTRIB_FLAG.IS_INTERFACE) else 0)
        );
    }
};
pub const OBJECT_ATTRIB_NO_ATTRIB = OBJECT_ATTRIB_FLAG.NO_ATTRIB;
pub const OBJECT_ATTRIB_NO_NAME = OBJECT_ATTRIB_FLAG.NO_NAME;
pub const OBJECT_ATTRIB_NO_TYPE = OBJECT_ATTRIB_FLAG.NO_TYPE;
pub const OBJECT_ATTRIB_NO_VALUE = OBJECT_ATTRIB_FLAG.NO_VALUE;
pub const OBJECT_ATTRIB_VALUE_IS_INVALID = OBJECT_ATTRIB_FLAG.VALUE_IS_INVALID;
pub const OBJECT_ATTRIB_VALUE_IS_OBJECT = OBJECT_ATTRIB_FLAG.VALUE_IS_OBJECT;
pub const OBJECT_ATTRIB_VALUE_IS_ENUM = OBJECT_ATTRIB_FLAG.VALUE_IS_ENUM;
pub const OBJECT_ATTRIB_VALUE_IS_CUSTOM = OBJECT_ATTRIB_FLAG.VALUE_IS_CUSTOM;
pub const OBJECT_ATTRIB_OBJECT_IS_EXPANDABLE = OBJECT_ATTRIB_FLAG.OBJECT_IS_EXPANDABLE;
pub const OBJECT_ATTRIB_VALUE_HAS_CODE = OBJECT_ATTRIB_FLAG.VALUE_HAS_CODE;
pub const OBJECT_ATTRIB_TYPE_IS_OBJECT = OBJECT_ATTRIB_FLAG.TYPE_IS_OBJECT;
pub const OBJECT_ATTRIB_TYPE_HAS_CODE = OBJECT_ATTRIB_FLAG.TYPE_HAS_CODE;
pub const OBJECT_ATTRIB_TYPE_IS_EXPANDABLE = OBJECT_ATTRIB_FLAG.TYPE_IS_OBJECT;
pub const OBJECT_ATTRIB_SLOT_IS_CATEGORY = OBJECT_ATTRIB_FLAG.SLOT_IS_CATEGORY;
pub const OBJECT_ATTRIB_VALUE_READONLY = OBJECT_ATTRIB_FLAG.VALUE_READONLY;
pub const OBJECT_ATTRIB_ACCESS_PUBLIC = OBJECT_ATTRIB_FLAG.ACCESS_PUBLIC;
pub const OBJECT_ATTRIB_ACCESS_PRIVATE = OBJECT_ATTRIB_FLAG.ACCESS_PRIVATE;
pub const OBJECT_ATTRIB_ACCESS_PROTECTED = OBJECT_ATTRIB_FLAG.ACCESS_PROTECTED;
pub const OBJECT_ATTRIB_ACCESS_FINAL = OBJECT_ATTRIB_FLAG.ACCESS_FINAL;
pub const OBJECT_ATTRIB_STORAGE_GLOBAL = OBJECT_ATTRIB_FLAG.STORAGE_GLOBAL;
pub const OBJECT_ATTRIB_STORAGE_STATIC = OBJECT_ATTRIB_FLAG.STORAGE_STATIC;
pub const OBJECT_ATTRIB_STORAGE_FIELD = OBJECT_ATTRIB_FLAG.STORAGE_FIELD;
pub const OBJECT_ATTRIB_STORAGE_VIRTUAL = OBJECT_ATTRIB_FLAG.STORAGE_VIRTUAL;
pub const OBJECT_ATTRIB_TYPE_IS_CONSTANT = OBJECT_ATTRIB_FLAG.TYPE_IS_CONSTANT;
pub const OBJECT_ATTRIB_TYPE_IS_SYNCHRONIZED = OBJECT_ATTRIB_FLAG.TYPE_IS_SYNCHRONIZED;
pub const OBJECT_ATTRIB_TYPE_IS_VOLATILE = OBJECT_ATTRIB_FLAG.TYPE_IS_VOLATILE;
pub const OBJECT_ATTRIB_HAS_EXTENDED_ATTRIBS = OBJECT_ATTRIB_FLAG.HAS_EXTENDED_ATTRIBS;
pub const OBJECT_ATTRIB_IS_CLASS = OBJECT_ATTRIB_FLAG.IS_CLASS;
pub const OBJECT_ATTRIB_IS_FUNCTION = OBJECT_ATTRIB_FLAG.IS_FUNCTION;
pub const OBJECT_ATTRIB_IS_VARIABLE = OBJECT_ATTRIB_FLAG.IS_VARIABLE;
pub const OBJECT_ATTRIB_IS_PROPERTY = OBJECT_ATTRIB_FLAG.IS_PROPERTY;
pub const OBJECT_ATTRIB_IS_MACRO = OBJECT_ATTRIB_FLAG.IS_MACRO;
pub const OBJECT_ATTRIB_IS_TYPE = OBJECT_ATTRIB_FLAG.IS_TYPE;
pub const OBJECT_ATTRIB_IS_INHERITED = OBJECT_ATTRIB_FLAG.IS_INHERITED;
pub const OBJECT_ATTRIB_IS_INTERFACE = OBJECT_ATTRIB_FLAG.IS_INTERFACE;

pub const PROP_INFO_FLAGS = enum(i32) {
    NAME = 1,
    TYPE = 2,
    VALUE = 4,
    FULLNAME = 32,
    ATTRIBUTES = 8,
    DEBUGPROP = 16,
    AUTOEXPAND = 134217728,
};
pub const PROP_INFO_NAME = PROP_INFO_FLAGS.NAME;
pub const PROP_INFO_TYPE = PROP_INFO_FLAGS.TYPE;
pub const PROP_INFO_VALUE = PROP_INFO_FLAGS.VALUE;
pub const PROP_INFO_FULLNAME = PROP_INFO_FLAGS.FULLNAME;
pub const PROP_INFO_ATTRIBUTES = PROP_INFO_FLAGS.ATTRIBUTES;
pub const PROP_INFO_DEBUGPROP = PROP_INFO_FLAGS.DEBUGPROP;
pub const PROP_INFO_AUTOEXPAND = PROP_INFO_FLAGS.AUTOEXPAND;

pub const DebugPropertyInfo = extern struct {
    m_dwValidFields: u32,
    m_bstrName: ?BSTR,
    m_bstrType: ?BSTR,
    m_bstrValue: ?BSTR,
    m_bstrFullName: ?BSTR,
    m_dwAttrib: u32,
    m_pDebugProp: ?*IDebugProperty,
};

pub const EX_PROP_INFO_FLAGS = enum(i32) {
    ID = 256,
    NTYPE = 512,
    NVALUE = 1024,
    LOCKBYTES = 2048,
    DEBUGEXTPROP = 4096,
};
pub const EX_PROP_INFO_ID = EX_PROP_INFO_FLAGS.ID;
pub const EX_PROP_INFO_NTYPE = EX_PROP_INFO_FLAGS.NTYPE;
pub const EX_PROP_INFO_NVALUE = EX_PROP_INFO_FLAGS.NVALUE;
pub const EX_PROP_INFO_LOCKBYTES = EX_PROP_INFO_FLAGS.LOCKBYTES;
pub const EX_PROP_INFO_DEBUGEXTPROP = EX_PROP_INFO_FLAGS.DEBUGEXTPROP;

pub const ExtendedDebugPropertyInfo = extern struct {
    dwValidFields: u32,
    pszName: ?PWSTR,
    pszType: ?PWSTR,
    pszValue: ?PWSTR,
    pszFullName: ?PWSTR,
    dwAttrib: u32,
    pDebugProp: ?*IDebugProperty,
    nDISPID: u32,
    nType: u32,
    varValue: VARIANT,
    plbValue: ?*ILockBytes,
    pDebugExtProp: ?*IDebugExtendedProperty,
};

const IID_IDebugProperty_Value = @import("../../zig.zig").Guid.initString("51973c50-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugProperty = &IID_IDebugProperty_Value;
pub const IDebugProperty = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPropertyInfo: fn(
            self: *const IDebugProperty,
            dwFieldSpec: u32,
            nRadix: u32,
            pPropertyInfo: ?*DebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtendedInfo: fn(
            self: *const IDebugProperty,
            cInfos: u32,
            rgguidExtendedInfo: [*]Guid,
            rgvar: [*]VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValueAsString: fn(
            self: *const IDebugProperty,
            pszValue: ?[*:0]const u16,
            nRadix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumMembers: fn(
            self: *const IDebugProperty,
            dwFieldSpec: u32,
            nRadix: u32,
            refiid: ?*const Guid,
            ppepi: ?*?*IEnumDebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParent: fn(
            self: *const IDebugProperty,
            ppDebugProp: ?*?*IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetPropertyInfo(self: *const T, dwFieldSpec: u32, nRadix: u32, pPropertyInfo: ?*DebugPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).GetPropertyInfo(@ptrCast(*const IDebugProperty, self), dwFieldSpec, nRadix, pPropertyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetExtendedInfo(self: *const T, cInfos: u32, rgguidExtendedInfo: [*]Guid, rgvar: [*]VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).GetExtendedInfo(@ptrCast(*const IDebugProperty, self), cInfos, rgguidExtendedInfo, rgvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_SetValueAsString(self: *const T, pszValue: ?[*:0]const u16, nRadix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).SetValueAsString(@ptrCast(*const IDebugProperty, self), pszValue, nRadix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_EnumMembers(self: *const T, dwFieldSpec: u32, nRadix: u32, refiid: ?*const Guid, ppepi: ?*?*IEnumDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).EnumMembers(@ptrCast(*const IDebugProperty, self), dwFieldSpec, nRadix, refiid, ppepi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugProperty_GetParent(self: *const T, ppDebugProp: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugProperty.VTable, self.vtable).GetParent(@ptrCast(*const IDebugProperty, self), ppDebugProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugPropertyInfo_Value = @import("../../zig.zig").Guid.initString("51973c51-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugPropertyInfo = &IID_IEnumDebugPropertyInfo_Value;
pub const IEnumDebugPropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugPropertyInfo,
            celt: u32,
            pi: [*]DebugPropertyInfo,
            pcEltsfetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugPropertyInfo,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugPropertyInfo,
            ppepi: ?*?*IEnumDebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const IEnumDebugPropertyInfo,
            pcelt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Next(self: *const T, celt: u32, pi: [*]DebugPropertyInfo, pcEltsfetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugPropertyInfo, self), celt, pi, pcEltsfetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugPropertyInfo, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugPropertyInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_Clone(self: *const T, ppepi: ?*?*IEnumDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugPropertyInfo, self), ppepi);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugPropertyInfo_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugPropertyInfo.VTable, self.vtable).GetCount(@ptrCast(*const IEnumDebugPropertyInfo, self), pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExtendedProperty_Value = @import("../../zig.zig").Guid.initString("51973c52-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExtendedProperty = &IID_IDebugExtendedProperty_Value;
pub const IDebugExtendedProperty = extern struct {
    pub const VTable = extern struct {
        base: IDebugProperty.VTable,
        GetExtendedPropertyInfo: fn(
            self: *const IDebugExtendedProperty,
            dwFieldSpec: u32,
            nRadix: u32,
            pExtendedPropertyInfo: ?*ExtendedDebugPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumExtendedMembers: fn(
            self: *const IDebugExtendedProperty,
            dwFieldSpec: u32,
            nRadix: u32,
            ppeepi: ?*?*IEnumDebugExtendedPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugProperty.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExtendedProperty_GetExtendedPropertyInfo(self: *const T, dwFieldSpec: u32, nRadix: u32, pExtendedPropertyInfo: ?*ExtendedDebugPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExtendedProperty.VTable, self.vtable).GetExtendedPropertyInfo(@ptrCast(*const IDebugExtendedProperty, self), dwFieldSpec, nRadix, pExtendedPropertyInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExtendedProperty_EnumExtendedMembers(self: *const T, dwFieldSpec: u32, nRadix: u32, ppeepi: ?*?*IEnumDebugExtendedPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExtendedProperty.VTable, self.vtable).EnumExtendedMembers(@ptrCast(*const IDebugExtendedProperty, self), dwFieldSpec, nRadix, ppeepi);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugExtendedPropertyInfo_Value = @import("../../zig.zig").Guid.initString("51973c53-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugExtendedPropertyInfo = &IID_IEnumDebugExtendedPropertyInfo_Value;
pub const IEnumDebugExtendedPropertyInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
            celt: u32,
            rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
            pedpe: ?*?*IEnumDebugExtendedPropertyInfo,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCount: fn(
            self: *const IEnumDebugExtendedPropertyInfo,
            pcelt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Next(self: *const T, celt: u32, rgExtendedPropertyInfo: [*]ExtendedDebugPropertyInfo, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self), celt, rgExtendedPropertyInfo, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_Clone(self: *const T, pedpe: ?*?*IEnumDebugExtendedPropertyInfo) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self), pedpe);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExtendedPropertyInfo_GetCount(self: *const T, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExtendedPropertyInfo.VTable, self.vtable).GetCount(@ptrCast(*const IEnumDebugExtendedPropertyInfo, self), pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPerPropertyBrowsing2_Value = @import("../../zig.zig").Guid.initString("51973c54-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IPerPropertyBrowsing2 = &IID_IPerPropertyBrowsing2_Value;
pub const IPerPropertyBrowsing2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDisplayString: fn(
            self: *const IPerPropertyBrowsing2,
            dispid: i32,
            pBstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        MapPropertyToPage: fn(
            self: *const IPerPropertyBrowsing2,
            dispid: i32,
            pClsidPropPage: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPredefinedStrings: fn(
            self: *const IPerPropertyBrowsing2,
            dispid: i32,
            pCaStrings: ?*CALPOLESTR,
            pCaCookies: ?*CADWORD,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPredefinedValue: fn(
            self: *const IPerPropertyBrowsing2,
            dispid: i32,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_GetDisplayString(self: *const T, dispid: i32, pBstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing2.VTable, self.vtable).GetDisplayString(@ptrCast(*const IPerPropertyBrowsing2, self), dispid, pBstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_MapPropertyToPage(self: *const T, dispid: i32, pClsidPropPage: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing2.VTable, self.vtable).MapPropertyToPage(@ptrCast(*const IPerPropertyBrowsing2, self), dispid, pClsidPropPage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_GetPredefinedStrings(self: *const T, dispid: i32, pCaStrings: ?*CALPOLESTR, pCaCookies: ?*CADWORD) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing2.VTable, self.vtable).GetPredefinedStrings(@ptrCast(*const IPerPropertyBrowsing2, self), dispid, pCaStrings, pCaCookies);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPerPropertyBrowsing2_SetPredefinedValue(self: *const T, dispid: i32, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPerPropertyBrowsing2.VTable, self.vtable).SetPredefinedValue(@ptrCast(*const IPerPropertyBrowsing2, self), dispid, dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_All_Value = @import("../../zig.zig").Guid.initString("51973c55-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_All = &IID_IDebugPropertyEnumType_All_Value;
pub const IDebugPropertyEnumType_All = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IDebugPropertyEnumType_All,
            __MIDL__IDebugPropertyEnumType_All0000: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPropertyEnumType_All_GetName(self: *const T, __MIDL__IDebugPropertyEnumType_All0000: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPropertyEnumType_All.VTable, self.vtable).GetName(@ptrCast(*const IDebugPropertyEnumType_All, self), __MIDL__IDebugPropertyEnumType_All0000);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Locals_Value = @import("../../zig.zig").Guid.initString("51973c56-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Locals = &IID_IDebugPropertyEnumType_Locals_Value;
pub const IDebugPropertyEnumType_Locals = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Arguments_Value = @import("../../zig.zig").Guid.initString("51973c57-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Arguments = &IID_IDebugPropertyEnumType_Arguments_Value;
pub const IDebugPropertyEnumType_Arguments = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_LocalsPlusArgs_Value = @import("../../zig.zig").Guid.initString("51973c58-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_LocalsPlusArgs = &IID_IDebugPropertyEnumType_LocalsPlusArgs_Value;
pub const IDebugPropertyEnumType_LocalsPlusArgs = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPropertyEnumType_Registers_Value = @import("../../zig.zig").Guid.initString("51973c59-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugPropertyEnumType_Registers = &IID_IDebugPropertyEnumType_Registers_Value;
pub const IDebugPropertyEnumType_Registers = extern struct {
    pub const VTable = extern struct {
        base: IDebugPropertyEnumType_All.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugPropertyEnumType_All.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const BREAKPOINT_STATE = enum(i32) {
    DELETED = 0,
    DISABLED = 1,
    ENABLED = 2,
};
pub const BREAKPOINT_DELETED = BREAKPOINT_STATE.DELETED;
pub const BREAKPOINT_DISABLED = BREAKPOINT_STATE.DISABLED;
pub const BREAKPOINT_ENABLED = BREAKPOINT_STATE.ENABLED;

pub const BREAKREASON = enum(i32) {
    STEP = 0,
    BREAKPOINT = 1,
    DEBUGGER_BLOCK = 2,
    HOST_INITIATED = 3,
    LANGUAGE_INITIATED = 4,
    DEBUGGER_HALT = 5,
    ERROR = 6,
    JIT = 7,
    MUTATION_BREAKPOINT = 8,
};
pub const BREAKREASON_STEP = BREAKREASON.STEP;
pub const BREAKREASON_BREAKPOINT = BREAKREASON.BREAKPOINT;
pub const BREAKREASON_DEBUGGER_BLOCK = BREAKREASON.DEBUGGER_BLOCK;
pub const BREAKREASON_HOST_INITIATED = BREAKREASON.HOST_INITIATED;
pub const BREAKREASON_LANGUAGE_INITIATED = BREAKREASON.LANGUAGE_INITIATED;
pub const BREAKREASON_DEBUGGER_HALT = BREAKREASON.DEBUGGER_HALT;
pub const BREAKREASON_ERROR = BREAKREASON.ERROR;
pub const BREAKREASON_JIT = BREAKREASON.JIT;
pub const BREAKREASON_MUTATION_BREAKPOINT = BREAKREASON.MUTATION_BREAKPOINT;

pub const BREAKRESUME_ACTION = enum(i32) {
    ABORT = 0,
    CONTINUE = 1,
    STEP_INTO = 2,
    STEP_OVER = 3,
    STEP_OUT = 4,
    IGNORE = 5,
    STEP_DOCUMENT = 6,
};
pub const BREAKRESUMEACTION_ABORT = BREAKRESUME_ACTION.ABORT;
pub const BREAKRESUMEACTION_CONTINUE = BREAKRESUME_ACTION.CONTINUE;
pub const BREAKRESUMEACTION_STEP_INTO = BREAKRESUME_ACTION.STEP_INTO;
pub const BREAKRESUMEACTION_STEP_OVER = BREAKRESUME_ACTION.STEP_OVER;
pub const BREAKRESUMEACTION_STEP_OUT = BREAKRESUME_ACTION.STEP_OUT;
pub const BREAKRESUMEACTION_IGNORE = BREAKRESUME_ACTION.IGNORE;
pub const BREAKRESUMEACTION_STEP_DOCUMENT = BREAKRESUME_ACTION.STEP_DOCUMENT;

pub const ERRORRESUMEACTION = enum(i32) {
    ReexecuteErrorStatement = 0,
    AbortCallAndReturnErrorToCaller = 1,
    SkipErrorStatement = 2,
};
pub const ERRORRESUMEACTION_ReexecuteErrorStatement = ERRORRESUMEACTION.ReexecuteErrorStatement;
pub const ERRORRESUMEACTION_AbortCallAndReturnErrorToCaller = ERRORRESUMEACTION.AbortCallAndReturnErrorToCaller;
pub const ERRORRESUMEACTION_SkipErrorStatement = ERRORRESUMEACTION.SkipErrorStatement;

pub const DOCUMENTNAMETYPE = enum(i32) {
    APPNODE = 0,
    TITLE = 1,
    FILE_TAIL = 2,
    URL = 3,
    UNIQUE_TITLE = 4,
    SOURCE_MAP_URL = 5,
};
pub const DOCUMENTNAMETYPE_APPNODE = DOCUMENTNAMETYPE.APPNODE;
pub const DOCUMENTNAMETYPE_TITLE = DOCUMENTNAMETYPE.TITLE;
pub const DOCUMENTNAMETYPE_FILE_TAIL = DOCUMENTNAMETYPE.FILE_TAIL;
pub const DOCUMENTNAMETYPE_URL = DOCUMENTNAMETYPE.URL;
pub const DOCUMENTNAMETYPE_UNIQUE_TITLE = DOCUMENTNAMETYPE.UNIQUE_TITLE;
pub const DOCUMENTNAMETYPE_SOURCE_MAP_URL = DOCUMENTNAMETYPE.SOURCE_MAP_URL;

const IID_IActiveScriptDebug32_Value = @import("../../zig.zig").Guid.initString("51973c10-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptDebug32 = &IID_IActiveScriptDebug32_Value;
pub const IActiveScriptDebug32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetScriptTextAttributes: fn(
            self: *const IActiveScriptDebug32,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: ?[*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptletTextAttributes: fn(
            self: *const IActiveScriptDebug32,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: ?[*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCodeContextsOfPosition: fn(
            self: *const IActiveScriptDebug32,
            dwSourceContext: u32,
            uCharacterOffset: u32,
            uNumChars: u32,
            ppescc: ?*?*IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug32.VTable, self.vtable).GetScriptTextAttributes(@ptrCast(*const IActiveScriptDebug32, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_GetScriptletTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug32.VTable, self.vtable).GetScriptletTextAttributes(@ptrCast(*const IActiveScriptDebug32, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug32_EnumCodeContextsOfPosition(self: *const T, dwSourceContext: u32, uCharacterOffset: u32, uNumChars: u32, ppescc: ?*?*IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug32.VTable, self.vtable).EnumCodeContextsOfPosition(@ptrCast(*const IActiveScriptDebug32, self), dwSourceContext, uCharacterOffset, uNumChars, ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptDebug64_Value = @import("../../zig.zig").Guid.initString("bc437e23-f5b8-47f4-bb79-7d1ce5483b86");
pub const IID_IActiveScriptDebug64 = &IID_IActiveScriptDebug64_Value;
pub const IActiveScriptDebug64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetScriptTextAttributes: fn(
            self: *const IActiveScriptDebug64,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: ?[*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptletTextAttributes: fn(
            self: *const IActiveScriptDebug64,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: ?[*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCodeContextsOfPosition: fn(
            self: *const IActiveScriptDebug64,
            dwSourceContext: u64,
            uCharacterOffset: u32,
            uNumChars: u32,
            ppescc: ?*?*IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug64.VTable, self.vtable).GetScriptTextAttributes(@ptrCast(*const IActiveScriptDebug64, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_GetScriptletTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug64.VTable, self.vtable).GetScriptletTextAttributes(@ptrCast(*const IActiveScriptDebug64, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptDebug64_EnumCodeContextsOfPosition(self: *const T, dwSourceContext: u64, uCharacterOffset: u32, uNumChars: u32, ppescc: ?*?*IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptDebug64.VTable, self.vtable).EnumCodeContextsOfPosition(@ptrCast(*const IActiveScriptDebug64, self), dwSourceContext, uCharacterOffset, uNumChars, ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebug32_Value = @import("../../zig.zig").Guid.initString("51973c11-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptSiteDebug32 = &IID_IActiveScriptSiteDebug32_Value;
pub const IActiveScriptSiteDebug32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContextFromPosition: fn(
            self: *const IActiveScriptSiteDebug32,
            dwSourceContext: u32,
            uCharacterOffset: u32,
            uNumChars: u32,
            ppsc: ?*?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplication: fn(
            self: *const IActiveScriptSiteDebug32,
            ppda: ?*?*IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootApplicationNode: fn(
            self: *const IActiveScriptSiteDebug32,
            ppdanRoot: ?*?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnScriptErrorDebug: fn(
            self: *const IActiveScriptSiteDebug32,
            pErrorDebug: ?*IActiveScriptErrorDebug,
            pfEnterDebugger: ?*BOOL,
            pfCallOnScriptErrorWhenContinuing: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetDocumentContextFromPosition(self: *const T, dwSourceContext: u32, uCharacterOffset: u32, uNumChars: u32, ppsc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug32.VTable, self.vtable).GetDocumentContextFromPosition(@ptrCast(*const IActiveScriptSiteDebug32, self), dwSourceContext, uCharacterOffset, uNumChars, ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetApplication(self: *const T, ppda: ?*?*IDebugApplication32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug32.VTable, self.vtable).GetApplication(@ptrCast(*const IActiveScriptSiteDebug32, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_GetRootApplicationNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug32.VTable, self.vtable).GetRootApplicationNode(@ptrCast(*const IActiveScriptSiteDebug32, self), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug32_OnScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfEnterDebugger: ?*BOOL, pfCallOnScriptErrorWhenContinuing: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug32.VTable, self.vtable).OnScriptErrorDebug(@ptrCast(*const IActiveScriptSiteDebug32, self), pErrorDebug, pfEnterDebugger, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebug64_Value = @import("../../zig.zig").Guid.initString("d6b96b0a-7463-402c-92ac-89984226942f");
pub const IID_IActiveScriptSiteDebug64 = &IID_IActiveScriptSiteDebug64_Value;
pub const IActiveScriptSiteDebug64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContextFromPosition: fn(
            self: *const IActiveScriptSiteDebug64,
            dwSourceContext: u64,
            uCharacterOffset: u32,
            uNumChars: u32,
            ppsc: ?*?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplication: fn(
            self: *const IActiveScriptSiteDebug64,
            ppda: ?*?*IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootApplicationNode: fn(
            self: *const IActiveScriptSiteDebug64,
            ppdanRoot: ?*?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnScriptErrorDebug: fn(
            self: *const IActiveScriptSiteDebug64,
            pErrorDebug: ?*IActiveScriptErrorDebug,
            pfEnterDebugger: ?*BOOL,
            pfCallOnScriptErrorWhenContinuing: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetDocumentContextFromPosition(self: *const T, dwSourceContext: u64, uCharacterOffset: u32, uNumChars: u32, ppsc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug64.VTable, self.vtable).GetDocumentContextFromPosition(@ptrCast(*const IActiveScriptSiteDebug64, self), dwSourceContext, uCharacterOffset, uNumChars, ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetApplication(self: *const T, ppda: ?*?*IDebugApplication64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug64.VTable, self.vtable).GetApplication(@ptrCast(*const IActiveScriptSiteDebug64, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_GetRootApplicationNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug64.VTable, self.vtable).GetRootApplicationNode(@ptrCast(*const IActiveScriptSiteDebug64, self), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebug64_OnScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfEnterDebugger: ?*BOOL, pfCallOnScriptErrorWhenContinuing: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebug64.VTable, self.vtable).OnScriptErrorDebug(@ptrCast(*const IActiveScriptSiteDebug64, self), pErrorDebug, pfEnterDebugger, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptSiteDebugEx_Value = @import("../../zig.zig").Guid.initString("bb722ccb-6ad2-41c6-b780-af9c03ee69f5");
pub const IID_IActiveScriptSiteDebugEx = &IID_IActiveScriptSiteDebugEx_Value;
pub const IActiveScriptSiteDebugEx = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnCanNotJITScriptErrorDebug: fn(
            self: *const IActiveScriptSiteDebugEx,
            pErrorDebug: ?*IActiveScriptErrorDebug,
            pfCallOnScriptErrorWhenContinuing: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptSiteDebugEx_OnCanNotJITScriptErrorDebug(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pfCallOnScriptErrorWhenContinuing: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptSiteDebugEx.VTable, self.vtable).OnCanNotJITScriptErrorDebug(@ptrCast(*const IActiveScriptSiteDebugEx, self), pErrorDebug, pfCallOnScriptErrorWhenContinuing);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptErrorDebug_Value = @import("../../zig.zig").Guid.initString("51973c12-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IActiveScriptErrorDebug = &IID_IActiveScriptErrorDebug_Value;
pub const IActiveScriptErrorDebug = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptError.VTable,
        GetDocumentContext: fn(
            self: *const IActiveScriptErrorDebug,
            ppssc: ?*?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackFrame: fn(
            self: *const IActiveScriptErrorDebug,
            ppdsf: ?*?*IDebugStackFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptError.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptErrorDebug_GetDocumentContext(self: *const T, ppssc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptErrorDebug.VTable, self.vtable).GetDocumentContext(@ptrCast(*const IActiveScriptErrorDebug, self), ppssc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptErrorDebug_GetStackFrame(self: *const T, ppdsf: ?*?*IDebugStackFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptErrorDebug.VTable, self.vtable).GetStackFrame(@ptrCast(*const IActiveScriptErrorDebug, self), ppdsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCodeContext_Value = @import("../../zig.zig").Guid.initString("51973c13-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugCodeContext = &IID_IDebugCodeContext_Value;
pub const IDebugCodeContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocumentContext: fn(
            self: *const IDebugCodeContext,
            ppsc: ?*?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakPoint: fn(
            self: *const IDebugCodeContext,
            bps: BREAKPOINT_STATE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCodeContext_GetDocumentContext(self: *const T, ppsc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCodeContext.VTable, self.vtable).GetDocumentContext(@ptrCast(*const IDebugCodeContext, self), ppsc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCodeContext_SetBreakPoint(self: *const T, bps: BREAKPOINT_STATE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCodeContext.VTable, self.vtable).SetBreakPoint(@ptrCast(*const IDebugCodeContext, self), bps);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpression_Value = @import("../../zig.zig").Guid.initString("51973c14-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpression = &IID_IDebugExpression_Value;
pub const IDebugExpression = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Start: fn(
            self: *const IDebugExpression,
            pdecb: ?*IDebugExpressionCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IDebugExpression,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryIsComplete: fn(
            self: *const IDebugExpression,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResultAsString: fn(
            self: *const IDebugExpression,
            phrResult: ?*HRESULT,
            pbstrResult: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResultAsDebugProperty: fn(
            self: *const IDebugExpression,
            phrResult: ?*HRESULT,
            ppdp: ?*?*IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_Start(self: *const T, pdecb: ?*IDebugExpressionCallBack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).Start(@ptrCast(*const IDebugExpression, self), pdecb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).Abort(@ptrCast(*const IDebugExpression, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_QueryIsComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).QueryIsComplete(@ptrCast(*const IDebugExpression, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_GetResultAsString(self: *const T, phrResult: ?*HRESULT, pbstrResult: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).GetResultAsString(@ptrCast(*const IDebugExpression, self), phrResult, pbstrResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpression_GetResultAsDebugProperty(self: *const T, phrResult: ?*HRESULT, ppdp: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpression.VTable, self.vtable).GetResultAsDebugProperty(@ptrCast(*const IDebugExpression, self), phrResult, ppdp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpressionContext_Value = @import("../../zig.zig").Guid.initString("51973c15-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpressionContext = &IID_IDebugExpressionContext_Value;
pub const IDebugExpressionContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ParseLanguageText: fn(
            self: *const IDebugExpressionContext,
            pstrCode: ?[*:0]const u16,
            nRadix: u32,
            pstrDelimiter: ?[*:0]const u16,
            dwFlags: u32,
            ppe: ?*?*IDebugExpression,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageInfo: fn(
            self: *const IDebugExpressionContext,
            pbstrLanguageName: ?*?BSTR,
            pLanguageID: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionContext_ParseLanguageText(self: *const T, pstrCode: ?[*:0]const u16, nRadix: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, ppe: ?*?*IDebugExpression) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpressionContext.VTable, self.vtable).ParseLanguageText(@ptrCast(*const IDebugExpressionContext, self), pstrCode, nRadix, pstrDelimiter, dwFlags, ppe);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionContext_GetLanguageInfo(self: *const T, pbstrLanguageName: ?*?BSTR, pLanguageID: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpressionContext.VTable, self.vtable).GetLanguageInfo(@ptrCast(*const IDebugExpressionContext, self), pbstrLanguageName, pLanguageID);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugExpressionCallBack_Value = @import("../../zig.zig").Guid.initString("51973c16-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugExpressionCallBack = &IID_IDebugExpressionCallBack_Value;
pub const IDebugExpressionCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: fn(
            self: *const IDebugExpressionCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugExpressionCallBack_onComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugExpressionCallBack.VTable, self.vtable).onComplete(@ptrCast(*const IDebugExpressionCallBack, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrame_Value = @import("../../zig.zig").Guid.initString("51973c17-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrame = &IID_IDebugStackFrame_Value;
pub const IDebugStackFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetCodeContext: fn(
            self: *const IDebugStackFrame,
            ppcc: ?*?*IDebugCodeContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionString: fn(
            self: *const IDebugStackFrame,
            fLong: BOOL,
            pbstrDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLanguageString: fn(
            self: *const IDebugStackFrame,
            fLong: BOOL,
            pbstrLanguage: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThread: fn(
            self: *const IDebugStackFrame,
            ppat: ?*?*IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebugProperty: fn(
            self: *const IDebugStackFrame,
            ppDebugProp: ?*?*IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetCodeContext(self: *const T, ppcc: ?*?*IDebugCodeContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetCodeContext(@ptrCast(*const IDebugStackFrame, self), ppcc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetDescriptionString(self: *const T, fLong: BOOL, pbstrDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetDescriptionString(@ptrCast(*const IDebugStackFrame, self), fLong, pbstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetLanguageString(self: *const T, fLong: BOOL, pbstrLanguage: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetLanguageString(@ptrCast(*const IDebugStackFrame, self), fLong, pbstrLanguage);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetThread(self: *const T, ppat: ?*?*IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetThread(@ptrCast(*const IDebugStackFrame, self), ppat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrame_GetDebugProperty(self: *const T, ppDebugProp: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrame.VTable, self.vtable).GetDebugProperty(@ptrCast(*const IDebugStackFrame, self), ppDebugProp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSniffer_Value = @import("../../zig.zig").Guid.initString("51973c18-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrameSniffer = &IID_IDebugStackFrameSniffer_Value;
pub const IDebugStackFrameSniffer = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumStackFrames: fn(
            self: *const IDebugStackFrameSniffer,
            ppedsf: ?*?*IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSniffer_EnumStackFrames(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrameSniffer.VTable, self.vtable).EnumStackFrames(@ptrCast(*const IDebugStackFrameSniffer, self), ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSnifferEx32_Value = @import("../../zig.zig").Guid.initString("51973c19-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugStackFrameSnifferEx32 = &IID_IDebugStackFrameSnifferEx32_Value;
pub const IDebugStackFrameSnifferEx32 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrameSniffer.VTable,
        EnumStackFramesEx32: fn(
            self: *const IDebugStackFrameSnifferEx32,
            dwSpMin: u32,
            ppedsf: ?*?*IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugStackFrameSniffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSnifferEx32_EnumStackFramesEx32(self: *const T, dwSpMin: u32, ppedsf: ?*?*IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrameSnifferEx32.VTable, self.vtable).EnumStackFramesEx32(@ptrCast(*const IDebugStackFrameSnifferEx32, self), dwSpMin, ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugStackFrameSnifferEx64_Value = @import("../../zig.zig").Guid.initString("8cd12af4-49c1-4d52-8d8a-c146f47581aa");
pub const IID_IDebugStackFrameSnifferEx64 = &IID_IDebugStackFrameSnifferEx64_Value;
pub const IDebugStackFrameSnifferEx64 = extern struct {
    pub const VTable = extern struct {
        base: IDebugStackFrameSniffer.VTable,
        EnumStackFramesEx64: fn(
            self: *const IDebugStackFrameSnifferEx64,
            dwSpMin: u64,
            ppedsf: ?*?*IEnumDebugStackFrames64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugStackFrameSniffer.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugStackFrameSnifferEx64_EnumStackFramesEx64(self: *const T, dwSpMin: u64, ppedsf: ?*?*IEnumDebugStackFrames64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugStackFrameSnifferEx64.VTable, self.vtable).EnumStackFramesEx64(@ptrCast(*const IDebugStackFrameSnifferEx64, self), dwSpMin, ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSyncOperation_Value = @import("../../zig.zig").Guid.initString("51973c1a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugSyncOperation = &IID_IDebugSyncOperation_Value;
pub const IDebugSyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetTargetThread: fn(
            self: *const IDebugSyncOperation,
            ppatTarget: ?*?*IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugSyncOperation,
            ppunkResult: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InProgressAbort: fn(
            self: *const IDebugSyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_GetTargetThread(self: *const T, ppatTarget: ?*?*IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSyncOperation.VTable, self.vtable).GetTargetThread(@ptrCast(*const IDebugSyncOperation, self), ppatTarget);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_Execute(self: *const T, ppunkResult: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSyncOperation.VTable, self.vtable).Execute(@ptrCast(*const IDebugSyncOperation, self), ppunkResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSyncOperation_InProgressAbort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSyncOperation.VTable, self.vtable).InProgressAbort(@ptrCast(*const IDebugSyncOperation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAsyncOperation_Value = @import("../../zig.zig").Guid.initString("51973c1b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugAsyncOperation = &IID_IDebugAsyncOperation_Value;
pub const IDebugAsyncOperation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSyncDebugOperation: fn(
            self: *const IDebugAsyncOperation,
            ppsdo: ?*?*IDebugSyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Start: fn(
            self: *const IDebugAsyncOperation,
            padocb: ?*IDebugAsyncOperationCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Abort: fn(
            self: *const IDebugAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryIsComplete: fn(
            self: *const IDebugAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetResult: fn(
            self: *const IDebugAsyncOperation,
            phrResult: ?*HRESULT,
            ppunkResult: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_GetSyncDebugOperation(self: *const T, ppsdo: ?*?*IDebugSyncOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).GetSyncDebugOperation(@ptrCast(*const IDebugAsyncOperation, self), ppsdo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_Start(self: *const T, padocb: ?*IDebugAsyncOperationCallBack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).Start(@ptrCast(*const IDebugAsyncOperation, self), padocb);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_Abort(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).Abort(@ptrCast(*const IDebugAsyncOperation, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_QueryIsComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).QueryIsComplete(@ptrCast(*const IDebugAsyncOperation, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperation_GetResult(self: *const T, phrResult: ?*HRESULT, ppunkResult: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperation.VTable, self.vtable).GetResult(@ptrCast(*const IDebugAsyncOperation, self), phrResult, ppunkResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAsyncOperationCallBack_Value = @import("../../zig.zig").Guid.initString("51973c1c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugAsyncOperationCallBack = &IID_IDebugAsyncOperationCallBack_Value;
pub const IDebugAsyncOperationCallBack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onComplete: fn(
            self: *const IDebugAsyncOperationCallBack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAsyncOperationCallBack_onComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAsyncOperationCallBack.VTable, self.vtable).onComplete(@ptrCast(*const IDebugAsyncOperationCallBack, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugCodeContexts_Value = @import("../../zig.zig").Guid.initString("51973c1d-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugCodeContexts = &IID_IEnumDebugCodeContexts_Value;
pub const IEnumDebugCodeContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugCodeContexts,
            celt: u32,
            pscc: ?*?*IDebugCodeContext,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugCodeContexts,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugCodeContexts,
            ppescc: ?*?*IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Next(self: *const T, celt: u32, pscc: ?*?*IDebugCodeContext, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugCodeContexts.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugCodeContexts, self), celt, pscc, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugCodeContexts.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugCodeContexts, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugCodeContexts.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugCodeContexts, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugCodeContexts_Clone(self: *const T, ppescc: ?*?*IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugCodeContexts.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugCodeContexts, self), ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DebugStackFrameDescriptor = extern struct {
    pdsf: ?*IDebugStackFrame,
    dwMin: u32,
    dwLim: u32,
    fFinal: BOOL,
    punkFinal: ?*IUnknown,
};

pub const DebugStackFrameDescriptor64 = extern struct {
    pdsf: ?*IDebugStackFrame,
    dwMin: u64,
    dwLim: u64,
    fFinal: BOOL,
    punkFinal: ?*IUnknown,
};

const IID_IEnumDebugStackFrames_Value = @import("../../zig.zig").Guid.initString("51973c1e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugStackFrames = &IID_IEnumDebugStackFrames_Value;
pub const IEnumDebugStackFrames = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugStackFrames,
            celt: u32,
            prgdsfd: ?*DebugStackFrameDescriptor,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugStackFrames,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugStackFrames,
            ppedsf: ?*?*IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Next(self: *const T, celt: u32, prgdsfd: ?*DebugStackFrameDescriptor, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugStackFrames, self), celt, prgdsfd, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugStackFrames, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugStackFrames, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames_Clone(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugStackFrames, self), ppedsf);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugStackFrames64_Value = @import("../../zig.zig").Guid.initString("0dc38853-c1b0-4176-a984-b298361027af");
pub const IID_IEnumDebugStackFrames64 = &IID_IEnumDebugStackFrames64_Value;
pub const IEnumDebugStackFrames64 = extern struct {
    pub const VTable = extern struct {
        base: IEnumDebugStackFrames.VTable,
        Next64: fn(
            self: *const IEnumDebugStackFrames64,
            celt: u32,
            prgdsfd: ?*DebugStackFrameDescriptor64,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IEnumDebugStackFrames.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugStackFrames64_Next64(self: *const T, celt: u32, prgdsfd: ?*DebugStackFrameDescriptor64, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugStackFrames64.VTable, self.vtable).Next64(@ptrCast(*const IEnumDebugStackFrames64, self), celt, prgdsfd, pceltFetched);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentInfo_Value = @import("../../zig.zig").Guid.initString("51973c1f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentInfo = &IID_IDebugDocumentInfo_Value;
pub const IDebugDocumentInfo = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IDebugDocumentInfo,
            dnt: DOCUMENTNAMETYPE,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDocumentClassId: fn(
            self: *const IDebugDocumentInfo,
            pclsidDocument: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentInfo_GetName(self: *const T, dnt: DOCUMENTNAMETYPE, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentInfo.VTable, self.vtable).GetName(@ptrCast(*const IDebugDocumentInfo, self), dnt, pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentInfo_GetDocumentClassId(self: *const T, pclsidDocument: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentInfo.VTable, self.vtable).GetDocumentClassId(@ptrCast(*const IDebugDocumentInfo, self), pclsidDocument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentProvider_Value = @import("../../zig.zig").Guid.initString("51973c20-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentProvider = &IID_IDebugDocumentProvider_Value;
pub const IDebugDocumentProvider = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentInfo.VTable,
        GetDocument: fn(
            self: *const IDebugDocumentProvider,
            ppssd: ?*?*IDebugDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentInfo.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentProvider_GetDocument(self: *const T, ppssd: ?*?*IDebugDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentProvider.VTable, self.vtable).GetDocument(@ptrCast(*const IDebugDocumentProvider, self), ppssd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocument_Value = @import("../../zig.zig").Guid.initString("51973c21-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocument = &IID_IDebugDocument_Value;
pub const IDebugDocument = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentInfo.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentInfo.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentText_Value = @import("../../zig.zig").Guid.initString("51973c22-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentText = &IID_IDebugDocumentText_Value;
pub const IDebugDocumentText = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocument.VTable,
        GetDocumentAttributes: fn(
            self: *const IDebugDocumentText,
            ptextdocattr: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IDebugDocumentText,
            pcNumLines: ?*u32,
            pcNumChars: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionOfLine: fn(
            self: *const IDebugDocumentText,
            cLineNumber: u32,
            pcCharacterPosition: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineOfPosition: fn(
            self: *const IDebugDocumentText,
            cCharacterPosition: u32,
            pcLineNumber: ?*u32,
            pcCharacterOffsetInLine: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetText: fn(
            self: *const IDebugDocumentText,
            cCharacterPosition: u32,
            pcharText: [*:0]u16,
            pstaTextAttr: ?[*:0]u16,
            pcNumChars: ?*u32,
            cMaxChars: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPositionOfContext: fn(
            self: *const IDebugDocumentText,
            psc: ?*IDebugDocumentContext,
            pcCharacterPosition: ?*u32,
            cNumChars: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextOfPosition: fn(
            self: *const IDebugDocumentText,
            cCharacterPosition: u32,
            cNumChars: u32,
            ppsc: ?*?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocument.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetDocumentAttributes(self: *const T, ptextdocattr: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetDocumentAttributes(@ptrCast(*const IDebugDocumentText, self), ptextdocattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetSize(self: *const T, pcNumLines: ?*u32, pcNumChars: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetSize(@ptrCast(*const IDebugDocumentText, self), pcNumLines, pcNumChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetPositionOfLine(self: *const T, cLineNumber: u32, pcCharacterPosition: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetPositionOfLine(@ptrCast(*const IDebugDocumentText, self), cLineNumber, pcCharacterPosition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetLineOfPosition(self: *const T, cCharacterPosition: u32, pcLineNumber: ?*u32, pcCharacterOffsetInLine: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetLineOfPosition(@ptrCast(*const IDebugDocumentText, self), cCharacterPosition, pcLineNumber, pcCharacterOffsetInLine);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetText(self: *const T, cCharacterPosition: u32, pcharText: [*:0]u16, pstaTextAttr: ?[*:0]u16, pcNumChars: ?*u32, cMaxChars: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetText(@ptrCast(*const IDebugDocumentText, self), cCharacterPosition, pcharText, pstaTextAttr, pcNumChars, cMaxChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetPositionOfContext(self: *const T, psc: ?*IDebugDocumentContext, pcCharacterPosition: ?*u32, cNumChars: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetPositionOfContext(@ptrCast(*const IDebugDocumentText, self), psc, pcCharacterPosition, cNumChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentText_GetContextOfPosition(self: *const T, cCharacterPosition: u32, cNumChars: u32, ppsc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentText.VTable, self.vtable).GetContextOfPosition(@ptrCast(*const IDebugDocumentText, self), cCharacterPosition, cNumChars, ppsc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextEvents_Value = @import("../../zig.zig").Guid.initString("51973c23-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextEvents = &IID_IDebugDocumentTextEvents_Value;
pub const IDebugDocumentTextEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onDestroy: fn(
            self: *const IDebugDocumentTextEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onInsertText: fn(
            self: *const IDebugDocumentTextEvents,
            cCharacterPosition: u32,
            cNumToInsert: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onRemoveText: fn(
            self: *const IDebugDocumentTextEvents,
            cCharacterPosition: u32,
            cNumToRemove: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onReplaceText: fn(
            self: *const IDebugDocumentTextEvents,
            cCharacterPosition: u32,
            cNumToReplace: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onUpdateTextAttributes: fn(
            self: *const IDebugDocumentTextEvents,
            cCharacterPosition: u32,
            cNumToUpdate: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onUpdateDocumentAttributes: fn(
            self: *const IDebugDocumentTextEvents,
            textdocattr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onDestroy(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onDestroy(@ptrCast(*const IDebugDocumentTextEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onInsertText(self: *const T, cCharacterPosition: u32, cNumToInsert: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onInsertText(@ptrCast(*const IDebugDocumentTextEvents, self), cCharacterPosition, cNumToInsert);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onRemoveText(self: *const T, cCharacterPosition: u32, cNumToRemove: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onRemoveText(@ptrCast(*const IDebugDocumentTextEvents, self), cCharacterPosition, cNumToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onReplaceText(self: *const T, cCharacterPosition: u32, cNumToReplace: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onReplaceText(@ptrCast(*const IDebugDocumentTextEvents, self), cCharacterPosition, cNumToReplace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onUpdateTextAttributes(self: *const T, cCharacterPosition: u32, cNumToUpdate: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onUpdateTextAttributes(@ptrCast(*const IDebugDocumentTextEvents, self), cCharacterPosition, cNumToUpdate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextEvents_onUpdateDocumentAttributes(self: *const T, textdocattr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextEvents.VTable, self.vtable).onUpdateDocumentAttributes(@ptrCast(*const IDebugDocumentTextEvents, self), textdocattr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextAuthor_Value = @import("../../zig.zig").Guid.initString("51973c24-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextAuthor = &IID_IDebugDocumentTextAuthor_Value;
pub const IDebugDocumentTextAuthor = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentText.VTable,
        InsertText: fn(
            self: *const IDebugDocumentTextAuthor,
            cCharacterPosition: u32,
            cNumToInsert: u32,
            pcharText: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveText: fn(
            self: *const IDebugDocumentTextAuthor,
            cCharacterPosition: u32,
            cNumToRemove: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReplaceText: fn(
            self: *const IDebugDocumentTextAuthor,
            cCharacterPosition: u32,
            cNumToReplace: u32,
            pcharText: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentText.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_InsertText(self: *const T, cCharacterPosition: u32, cNumToInsert: u32, pcharText: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextAuthor.VTable, self.vtable).InsertText(@ptrCast(*const IDebugDocumentTextAuthor, self), cCharacterPosition, cNumToInsert, pcharText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_RemoveText(self: *const T, cCharacterPosition: u32, cNumToRemove: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextAuthor.VTable, self.vtable).RemoveText(@ptrCast(*const IDebugDocumentTextAuthor, self), cCharacterPosition, cNumToRemove);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextAuthor_ReplaceText(self: *const T, cCharacterPosition: u32, cNumToReplace: u32, pcharText: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextAuthor.VTable, self.vtable).ReplaceText(@ptrCast(*const IDebugDocumentTextAuthor, self), cCharacterPosition, cNumToReplace, pcharText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentTextExternalAuthor_Value = @import("../../zig.zig").Guid.initString("51973c25-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentTextExternalAuthor = &IID_IDebugDocumentTextExternalAuthor_Value;
pub const IDebugDocumentTextExternalAuthor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetPathName: fn(
            self: *const IDebugDocumentTextExternalAuthor,
            pbstrLongName: ?*?BSTR,
            pfIsOriginalFile: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IDebugDocumentTextExternalAuthor,
            pbstrShortName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyChanged: fn(
            self: *const IDebugDocumentTextExternalAuthor,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_GetPathName(self: *const T, pbstrLongName: ?*?BSTR, pfIsOriginalFile: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextExternalAuthor.VTable, self.vtable).GetPathName(@ptrCast(*const IDebugDocumentTextExternalAuthor, self), pbstrLongName, pfIsOriginalFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_GetFileName(self: *const T, pbstrShortName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextExternalAuthor.VTable, self.vtable).GetFileName(@ptrCast(*const IDebugDocumentTextExternalAuthor, self), pbstrShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentTextExternalAuthor_NotifyChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentTextExternalAuthor.VTable, self.vtable).NotifyChanged(@ptrCast(*const IDebugDocumentTextExternalAuthor, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHelper32_Value = @import("../../zig.zig").Guid.initString("51973c26-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentHelper32 = &IID_IDebugDocumentHelper32_Value;
pub const IDebugDocumentHelper32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IDebugDocumentHelper32,
            pda: ?*IDebugApplication32,
            pszShortName: ?[*:0]const u16,
            pszLongName: ?[*:0]const u16,
            docAttr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Attach: fn(
            self: *const IDebugDocumentHelper32,
            pddhParent: ?*IDebugDocumentHelper32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IDebugDocumentHelper32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUnicodeText: fn(
            self: *const IDebugDocumentHelper32,
            pszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDBCSText: fn(
            self: *const IDebugDocumentHelper32,
            pszText: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDebugDocumentHost: fn(
            self: *const IDebugDocumentHelper32,
            pddh: ?*IDebugDocumentHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDeferredText: fn(
            self: *const IDebugDocumentHelper32,
            cChars: u32,
            dwTextStartCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineScriptBlock: fn(
            self: *const IDebugDocumentHelper32,
            ulCharOffset: u32,
            cChars: u32,
            pas: ?*IActiveScript,
            fScriptlet: BOOL,
            pdwSourceContext: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTextAttr: fn(
            self: *const IDebugDocumentHelper32,
            staTextAttr: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextAttributes: fn(
            self: *const IDebugDocumentHelper32,
            ulCharOffset: u32,
            cChars: u32,
            pstaTextAttr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLongName: fn(
            self: *const IDebugDocumentHelper32,
            pszLongName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShortName: fn(
            self: *const IDebugDocumentHelper32,
            pszShortName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentAttr: fn(
            self: *const IDebugDocumentHelper32,
            pszAttributes: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebugApplicationNode: fn(
            self: *const IDebugDocumentHelper32,
            ppdan: ?*?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptBlockInfo: fn(
            self: *const IDebugDocumentHelper32,
            dwSourceContext: u32,
            ppasd: ?*?*IActiveScript,
            piCharPos: ?*u32,
            pcChars: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDebugDocumentContext: fn(
            self: *const IDebugDocumentHelper32,
            iCharPos: u32,
            cChars: u32,
            ppddc: ?*?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentToTop: fn(
            self: *const IDebugDocumentHelper32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentContextToTop: fn(
            self: *const IDebugDocumentHelper32,
            pddc: ?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Init(self: *const T, pda: ?*IDebugApplication32, pszShortName: ?[*:0]const u16, pszLongName: ?[*:0]const u16, docAttr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).Init(@ptrCast(*const IDebugDocumentHelper32, self), pda, pszShortName, pszLongName, docAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Attach(self: *const T, pddhParent: ?*IDebugDocumentHelper32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).Attach(@ptrCast(*const IDebugDocumentHelper32, self), pddhParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).Detach(@ptrCast(*const IDebugDocumentHelper32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddUnicodeText(self: *const T, pszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).AddUnicodeText(@ptrCast(*const IDebugDocumentHelper32, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddDBCSText(self: *const T, pszText: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).AddDBCSText(@ptrCast(*const IDebugDocumentHelper32, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDebugDocumentHost(self: *const T, pddh: ?*IDebugDocumentHost) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetDebugDocumentHost(@ptrCast(*const IDebugDocumentHelper32, self), pddh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_AddDeferredText(self: *const T, cChars: u32, dwTextStartCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).AddDeferredText(@ptrCast(*const IDebugDocumentHelper32, self), cChars, dwTextStartCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_DefineScriptBlock(self: *const T, ulCharOffset: u32, cChars: u32, pas: ?*IActiveScript, fScriptlet: BOOL, pdwSourceContext: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).DefineScriptBlock(@ptrCast(*const IDebugDocumentHelper32, self), ulCharOffset, cChars, pas, fScriptlet, pdwSourceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDefaultTextAttr(self: *const T, staTextAttr: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetDefaultTextAttr(@ptrCast(*const IDebugDocumentHelper32, self), staTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetTextAttributes(self: *const T, ulCharOffset: u32, cChars: u32, pstaTextAttr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetTextAttributes(@ptrCast(*const IDebugDocumentHelper32, self), ulCharOffset, cChars, pstaTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetLongName(self: *const T, pszLongName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetLongName(@ptrCast(*const IDebugDocumentHelper32, self), pszLongName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetShortName(self: *const T, pszShortName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetShortName(@ptrCast(*const IDebugDocumentHelper32, self), pszShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_SetDocumentAttr(self: *const T, pszAttributes: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).SetDocumentAttr(@ptrCast(*const IDebugDocumentHelper32, self), pszAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_GetDebugApplicationNode(self: *const T, ppdan: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).GetDebugApplicationNode(@ptrCast(*const IDebugDocumentHelper32, self), ppdan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_GetScriptBlockInfo(self: *const T, dwSourceContext: u32, ppasd: ?*?*IActiveScript, piCharPos: ?*u32, pcChars: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).GetScriptBlockInfo(@ptrCast(*const IDebugDocumentHelper32, self), dwSourceContext, ppasd, piCharPos, pcChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_CreateDebugDocumentContext(self: *const T, iCharPos: u32, cChars: u32, ppddc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).CreateDebugDocumentContext(@ptrCast(*const IDebugDocumentHelper32, self), iCharPos, cChars, ppddc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_BringDocumentToTop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).BringDocumentToTop(@ptrCast(*const IDebugDocumentHelper32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper32_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper32.VTable, self.vtable).BringDocumentContextToTop(@ptrCast(*const IDebugDocumentHelper32, self), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHelper64_Value = @import("../../zig.zig").Guid.initString("c4c7363c-20fd-47f9-bd82-4855e0150871");
pub const IID_IDebugDocumentHelper64 = &IID_IDebugDocumentHelper64_Value;
pub const IDebugDocumentHelper64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Init: fn(
            self: *const IDebugDocumentHelper64,
            pda: ?*IDebugApplication64,
            pszShortName: ?[*:0]const u16,
            pszLongName: ?[*:0]const u16,
            docAttr: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Attach: fn(
            self: *const IDebugDocumentHelper64,
            pddhParent: ?*IDebugDocumentHelper64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IDebugDocumentHelper64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddUnicodeText: fn(
            self: *const IDebugDocumentHelper64,
            pszText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDBCSText: fn(
            self: *const IDebugDocumentHelper64,
            pszText: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDebugDocumentHost: fn(
            self: *const IDebugDocumentHelper64,
            pddh: ?*IDebugDocumentHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDeferredText: fn(
            self: *const IDebugDocumentHelper64,
            cChars: u32,
            dwTextStartCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DefineScriptBlock: fn(
            self: *const IDebugDocumentHelper64,
            ulCharOffset: u32,
            cChars: u32,
            pas: ?*IActiveScript,
            fScriptlet: BOOL,
            pdwSourceContext: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDefaultTextAttr: fn(
            self: *const IDebugDocumentHelper64,
            staTextAttr: u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextAttributes: fn(
            self: *const IDebugDocumentHelper64,
            ulCharOffset: u32,
            cChars: u32,
            pstaTextAttr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLongName: fn(
            self: *const IDebugDocumentHelper64,
            pszLongName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetShortName: fn(
            self: *const IDebugDocumentHelper64,
            pszShortName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentAttr: fn(
            self: *const IDebugDocumentHelper64,
            pszAttributes: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebugApplicationNode: fn(
            self: *const IDebugDocumentHelper64,
            ppdan: ?*?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptBlockInfo: fn(
            self: *const IDebugDocumentHelper64,
            dwSourceContext: u64,
            ppasd: ?*?*IActiveScript,
            piCharPos: ?*u32,
            pcChars: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDebugDocumentContext: fn(
            self: *const IDebugDocumentHelper64,
            iCharPos: u32,
            cChars: u32,
            ppddc: ?*?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentToTop: fn(
            self: *const IDebugDocumentHelper64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentContextToTop: fn(
            self: *const IDebugDocumentHelper64,
            pddc: ?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Init(self: *const T, pda: ?*IDebugApplication64, pszShortName: ?[*:0]const u16, pszLongName: ?[*:0]const u16, docAttr: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).Init(@ptrCast(*const IDebugDocumentHelper64, self), pda, pszShortName, pszLongName, docAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Attach(self: *const T, pddhParent: ?*IDebugDocumentHelper64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).Attach(@ptrCast(*const IDebugDocumentHelper64, self), pddhParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).Detach(@ptrCast(*const IDebugDocumentHelper64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddUnicodeText(self: *const T, pszText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).AddUnicodeText(@ptrCast(*const IDebugDocumentHelper64, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddDBCSText(self: *const T, pszText: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).AddDBCSText(@ptrCast(*const IDebugDocumentHelper64, self), pszText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDebugDocumentHost(self: *const T, pddh: ?*IDebugDocumentHost) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetDebugDocumentHost(@ptrCast(*const IDebugDocumentHelper64, self), pddh);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_AddDeferredText(self: *const T, cChars: u32, dwTextStartCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).AddDeferredText(@ptrCast(*const IDebugDocumentHelper64, self), cChars, dwTextStartCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_DefineScriptBlock(self: *const T, ulCharOffset: u32, cChars: u32, pas: ?*IActiveScript, fScriptlet: BOOL, pdwSourceContext: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).DefineScriptBlock(@ptrCast(*const IDebugDocumentHelper64, self), ulCharOffset, cChars, pas, fScriptlet, pdwSourceContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDefaultTextAttr(self: *const T, staTextAttr: u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetDefaultTextAttr(@ptrCast(*const IDebugDocumentHelper64, self), staTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetTextAttributes(self: *const T, ulCharOffset: u32, cChars: u32, pstaTextAttr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetTextAttributes(@ptrCast(*const IDebugDocumentHelper64, self), ulCharOffset, cChars, pstaTextAttr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetLongName(self: *const T, pszLongName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetLongName(@ptrCast(*const IDebugDocumentHelper64, self), pszLongName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetShortName(self: *const T, pszShortName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetShortName(@ptrCast(*const IDebugDocumentHelper64, self), pszShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_SetDocumentAttr(self: *const T, pszAttributes: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).SetDocumentAttr(@ptrCast(*const IDebugDocumentHelper64, self), pszAttributes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_GetDebugApplicationNode(self: *const T, ppdan: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).GetDebugApplicationNode(@ptrCast(*const IDebugDocumentHelper64, self), ppdan);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_GetScriptBlockInfo(self: *const T, dwSourceContext: u64, ppasd: ?*?*IActiveScript, piCharPos: ?*u32, pcChars: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).GetScriptBlockInfo(@ptrCast(*const IDebugDocumentHelper64, self), dwSourceContext, ppasd, piCharPos, pcChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_CreateDebugDocumentContext(self: *const T, iCharPos: u32, cChars: u32, ppddc: ?*?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).CreateDebugDocumentContext(@ptrCast(*const IDebugDocumentHelper64, self), iCharPos, cChars, ppddc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_BringDocumentToTop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).BringDocumentToTop(@ptrCast(*const IDebugDocumentHelper64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHelper64_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHelper64.VTable, self.vtable).BringDocumentContextToTop(@ptrCast(*const IDebugDocumentHelper64, self), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentHost_Value = @import("../../zig.zig").Guid.initString("51973c27-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentHost = &IID_IDebugDocumentHost_Value;
pub const IDebugDocumentHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDeferredText: fn(
            self: *const IDebugDocumentHost,
            dwTextStartCookie: u32,
            pcharText: [*:0]u16,
            pstaTextAttr: [*:0]u16,
            pcNumChars: ?*u32,
            cMaxChars: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScriptTextAttributes: fn(
            self: *const IDebugDocumentHost,
            pstrCode: [*:0]const u16,
            uNumCodeChars: u32,
            pstrDelimiter: ?[*:0]const u16,
            dwFlags: u32,
            pattr: [*:0]u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCreateDocumentContext: fn(
            self: *const IDebugDocumentHost,
            ppunkOuter: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPathName: fn(
            self: *const IDebugDocumentHost,
            pbstrLongName: ?*?BSTR,
            pfIsOriginalFile: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFileName: fn(
            self: *const IDebugDocumentHost,
            pbstrShortName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyChanged: fn(
            self: *const IDebugDocumentHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetDeferredText(self: *const T, dwTextStartCookie: u32, pcharText: [*:0]u16, pstaTextAttr: [*:0]u16, pcNumChars: ?*u32, cMaxChars: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).GetDeferredText(@ptrCast(*const IDebugDocumentHost, self), dwTextStartCookie, pcharText, pstaTextAttr, pcNumChars, cMaxChars);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetScriptTextAttributes(self: *const T, pstrCode: [*:0]const u16, uNumCodeChars: u32, pstrDelimiter: ?[*:0]const u16, dwFlags: u32, pattr: [*:0]u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).GetScriptTextAttributes(@ptrCast(*const IDebugDocumentHost, self), pstrCode, uNumCodeChars, pstrDelimiter, dwFlags, pattr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_OnCreateDocumentContext(self: *const T, ppunkOuter: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).OnCreateDocumentContext(@ptrCast(*const IDebugDocumentHost, self), ppunkOuter);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetPathName(self: *const T, pbstrLongName: ?*?BSTR, pfIsOriginalFile: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).GetPathName(@ptrCast(*const IDebugDocumentHost, self), pbstrLongName, pfIsOriginalFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_GetFileName(self: *const T, pbstrShortName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).GetFileName(@ptrCast(*const IDebugDocumentHost, self), pbstrShortName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentHost_NotifyChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentHost.VTable, self.vtable).NotifyChanged(@ptrCast(*const IDebugDocumentHost, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDocumentContext_Value = @import("../../zig.zig").Guid.initString("51973c28-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugDocumentContext = &IID_IDebugDocumentContext_Value;
pub const IDebugDocumentContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDocument: fn(
            self: *const IDebugDocumentContext,
            ppsd: ?*?*IDebugDocument,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumCodeContexts: fn(
            self: *const IDebugDocumentContext,
            ppescc: ?*?*IEnumDebugCodeContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentContext_GetDocument(self: *const T, ppsd: ?*?*IDebugDocument) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentContext.VTable, self.vtable).GetDocument(@ptrCast(*const IDebugDocumentContext, self), ppsd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDocumentContext_EnumCodeContexts(self: *const T, ppescc: ?*?*IEnumDebugCodeContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDocumentContext.VTable, self.vtable).EnumCodeContexts(@ptrCast(*const IDebugDocumentContext, self), ppescc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSessionProvider_Value = @import("../../zig.zig").Guid.initString("51973c29-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugSessionProvider = &IID_IDebugSessionProvider_Value;
pub const IDebugSessionProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartDebugSession: fn(
            self: *const IDebugSessionProvider,
            pda: ?*IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSessionProvider_StartDebugSession(self: *const T, pda: ?*IRemoteDebugApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSessionProvider.VTable, self.vtable).StartDebugSession(@ptrCast(*const IDebugSessionProvider, self), pda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApplicationDebugger_Value = @import("../../zig.zig").Guid.initString("51973c2a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IApplicationDebugger = &IID_IApplicationDebugger_Value;
pub const IApplicationDebugger = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        QueryAlive: fn(
            self: *const IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstanceAtDebugger: fn(
            self: *const IApplicationDebugger,
            rclsid: ?*const Guid,
            pUnkOuter: ?*IUnknown,
            dwClsContext: u32,
            riid: ?*const Guid,
            ppvObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onDebugOutput: fn(
            self: *const IApplicationDebugger,
            pstr: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onHandleBreakPoint: fn(
            self: *const IApplicationDebugger,
            prpt: ?*IRemoteDebugApplicationThread,
            br: BREAKREASON,
            pError: ?*IActiveScriptErrorDebug,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onClose: fn(
            self: *const IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onDebuggerEvent: fn(
            self: *const IApplicationDebugger,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_QueryAlive(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).QueryAlive(@ptrCast(*const IApplicationDebugger, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_CreateInstanceAtDebugger(self: *const T, rclsid: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsContext: u32, riid: ?*const Guid, ppvObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).CreateInstanceAtDebugger(@ptrCast(*const IApplicationDebugger, self), rclsid, pUnkOuter, dwClsContext, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onDebugOutput(self: *const T, pstr: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).onDebugOutput(@ptrCast(*const IApplicationDebugger, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onHandleBreakPoint(self: *const T, prpt: ?*IRemoteDebugApplicationThread, br: BREAKREASON, pError: ?*IActiveScriptErrorDebug) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).onHandleBreakPoint(@ptrCast(*const IApplicationDebugger, self), prpt, br, pError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).onClose(@ptrCast(*const IApplicationDebugger, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebugger_onDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebugger.VTable, self.vtable).onDebuggerEvent(@ptrCast(*const IApplicationDebugger, self), riid, punk);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IApplicationDebuggerUI_Value = @import("../../zig.zig").Guid.initString("51973c2b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IApplicationDebuggerUI = &IID_IApplicationDebuggerUI_Value;
pub const IApplicationDebuggerUI = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BringDocumentToTop: fn(
            self: *const IApplicationDebuggerUI,
            pddt: ?*IDebugDocumentText,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BringDocumentContextToTop: fn(
            self: *const IApplicationDebuggerUI,
            pddc: ?*IDebugDocumentContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebuggerUI_BringDocumentToTop(self: *const T, pddt: ?*IDebugDocumentText) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebuggerUI.VTable, self.vtable).BringDocumentToTop(@ptrCast(*const IApplicationDebuggerUI, self), pddt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IApplicationDebuggerUI_BringDocumentContextToTop(self: *const T, pddc: ?*IDebugDocumentContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IApplicationDebuggerUI.VTable, self.vtable).BringDocumentContextToTop(@ptrCast(*const IApplicationDebuggerUI, self), pddc);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManager_Value = @import("../../zig.zig").Guid.initString("51973c2c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManager = &IID_IMachineDebugManager_Value;
pub const IMachineDebugManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddApplication: fn(
            self: *const IMachineDebugManager,
            pda: ?*IRemoteDebugApplication,
            pdwAppCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveApplication: fn(
            self: *const IMachineDebugManager,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumApplications: fn(
            self: *const IMachineDebugManager,
            ppeda: ?*?*IEnumRemoteDebugApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_AddApplication(self: *const T, pda: ?*IRemoteDebugApplication, pdwAppCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManager.VTable, self.vtable).AddApplication(@ptrCast(*const IMachineDebugManager, self), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManager.VTable, self.vtable).RemoveApplication(@ptrCast(*const IMachineDebugManager, self), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManager_EnumApplications(self: *const T, ppeda: ?*?*IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManager.VTable, self.vtable).EnumApplications(@ptrCast(*const IMachineDebugManager, self), ppeda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManagerCookie_Value = @import("../../zig.zig").Guid.initString("51973c2d-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManagerCookie = &IID_IMachineDebugManagerCookie_Value;
pub const IMachineDebugManagerCookie = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AddApplication: fn(
            self: *const IMachineDebugManagerCookie,
            pda: ?*IRemoteDebugApplication,
            dwDebugAppCookie: u32,
            pdwAppCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveApplication: fn(
            self: *const IMachineDebugManagerCookie,
            dwDebugAppCookie: u32,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumApplications: fn(
            self: *const IMachineDebugManagerCookie,
            ppeda: ?*?*IEnumRemoteDebugApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_AddApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwDebugAppCookie: u32, pdwAppCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerCookie.VTable, self.vtable).AddApplication(@ptrCast(*const IMachineDebugManagerCookie, self), pda, dwDebugAppCookie, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_RemoveApplication(self: *const T, dwDebugAppCookie: u32, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerCookie.VTable, self.vtable).RemoveApplication(@ptrCast(*const IMachineDebugManagerCookie, self), dwDebugAppCookie, dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerCookie_EnumApplications(self: *const T, ppeda: ?*?*IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerCookie.VTable, self.vtable).EnumApplications(@ptrCast(*const IMachineDebugManagerCookie, self), ppeda);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IMachineDebugManagerEvents_Value = @import("../../zig.zig").Guid.initString("51973c2e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IMachineDebugManagerEvents = &IID_IMachineDebugManagerEvents_Value;
pub const IMachineDebugManagerEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onAddApplication: fn(
            self: *const IMachineDebugManagerEvents,
            pda: ?*IRemoteDebugApplication,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onRemoveApplication: fn(
            self: *const IMachineDebugManagerEvents,
            pda: ?*IRemoteDebugApplication,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerEvents_onAddApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerEvents.VTable, self.vtable).onAddApplication(@ptrCast(*const IMachineDebugManagerEvents, self), pda, dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IMachineDebugManagerEvents_onRemoveApplication(self: *const T, pda: ?*IRemoteDebugApplication, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IMachineDebugManagerEvents.VTable, self.vtable).onRemoveApplication(@ptrCast(*const IMachineDebugManagerEvents, self), pda, dwAppCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProcessDebugManager32_Value = @import("../../zig.zig").Guid.initString("51973c2f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IProcessDebugManager32 = &IID_IProcessDebugManager32_Value;
pub const IProcessDebugManager32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateApplication: fn(
            self: *const IProcessDebugManager32,
            ppda: ?*?*IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultApplication: fn(
            self: *const IProcessDebugManager32,
            ppda: ?*?*IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddApplication: fn(
            self: *const IProcessDebugManager32,
            pda: ?*IDebugApplication32,
            pdwAppCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveApplication: fn(
            self: *const IProcessDebugManager32,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDebugDocumentHelper: fn(
            self: *const IProcessDebugManager32,
            punkOuter: ?*IUnknown,
            pddh: ?*?*IDebugDocumentHelper32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_CreateApplication(self: *const T, ppda: ?*?*IDebugApplication32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).CreateApplication(@ptrCast(*const IProcessDebugManager32, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_GetDefaultApplication(self: *const T, ppda: ?*?*IDebugApplication32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).GetDefaultApplication(@ptrCast(*const IProcessDebugManager32, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_AddApplication(self: *const T, pda: ?*IDebugApplication32, pdwAppCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).AddApplication(@ptrCast(*const IProcessDebugManager32, self), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).RemoveApplication(@ptrCast(*const IProcessDebugManager32, self), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager32_CreateDebugDocumentHelper(self: *const T, punkOuter: ?*IUnknown, pddh: ?*?*IDebugDocumentHelper32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager32.VTable, self.vtable).CreateDebugDocumentHelper(@ptrCast(*const IProcessDebugManager32, self), punkOuter, pddh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProcessDebugManager64_Value = @import("../../zig.zig").Guid.initString("56b9fc1c-63a9-4cc1-ac21-087d69a17fab");
pub const IID_IProcessDebugManager64 = &IID_IProcessDebugManager64_Value;
pub const IProcessDebugManager64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateApplication: fn(
            self: *const IProcessDebugManager64,
            ppda: ?*?*IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultApplication: fn(
            self: *const IProcessDebugManager64,
            ppda: ?*?*IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddApplication: fn(
            self: *const IProcessDebugManager64,
            pda: ?*IDebugApplication64,
            pdwAppCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveApplication: fn(
            self: *const IProcessDebugManager64,
            dwAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDebugDocumentHelper: fn(
            self: *const IProcessDebugManager64,
            punkOuter: ?*IUnknown,
            pddh: ?*?*IDebugDocumentHelper64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_CreateApplication(self: *const T, ppda: ?*?*IDebugApplication64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).CreateApplication(@ptrCast(*const IProcessDebugManager64, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_GetDefaultApplication(self: *const T, ppda: ?*?*IDebugApplication64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).GetDefaultApplication(@ptrCast(*const IProcessDebugManager64, self), ppda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_AddApplication(self: *const T, pda: ?*IDebugApplication64, pdwAppCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).AddApplication(@ptrCast(*const IProcessDebugManager64, self), pda, pdwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_RemoveApplication(self: *const T, dwAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).RemoveApplication(@ptrCast(*const IProcessDebugManager64, self), dwAppCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProcessDebugManager64_CreateDebugDocumentHelper(self: *const T, punkOuter: ?*IUnknown, pddh: ?*?*IDebugDocumentHelper64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProcessDebugManager64.VTable, self.vtable).CreateDebugDocumentHelper(@ptrCast(*const IProcessDebugManager64, self), punkOuter, pddh);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplication_Value = @import("../../zig.zig").Guid.initString("51973c30-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplication = &IID_IRemoteDebugApplication_Value;
pub const IRemoteDebugApplication = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ResumeFromBreakPoint: fn(
            self: *const IRemoteDebugApplication,
            prptFocus: ?*IRemoteDebugApplicationThread,
            bra: BREAKRESUME_ACTION,
            era: ERRORRESUMEACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CauseBreak: fn(
            self: *const IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectDebugger: fn(
            self: *const IRemoteDebugApplication,
            pad: ?*IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectDebugger: fn(
            self: *const IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebugger: fn(
            self: *const IRemoteDebugApplication,
            pad: ?*?*IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateInstanceAtApplication: fn(
            self: *const IRemoteDebugApplication,
            rclsid: ?*const Guid,
            pUnkOuter: ?*IUnknown,
            dwClsContext: u32,
            riid: ?*const Guid,
            ppvObject: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryAlive: fn(
            self: *const IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumThreads: fn(
            self: *const IRemoteDebugApplication,
            pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IRemoteDebugApplication,
            pbstrName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootNode: fn(
            self: *const IRemoteDebugApplication,
            ppdanRoot: ?*?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumGlobalExpressionContexts: fn(
            self: *const IRemoteDebugApplication,
            ppedec: ?*?*IEnumDebugExpressionContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_ResumeFromBreakPoint(self: *const T, prptFocus: ?*IRemoteDebugApplicationThread, bra: BREAKRESUME_ACTION, era: ERRORRESUMEACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).ResumeFromBreakPoint(@ptrCast(*const IRemoteDebugApplication, self), prptFocus, bra, era);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_CauseBreak(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).CauseBreak(@ptrCast(*const IRemoteDebugApplication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_ConnectDebugger(self: *const T, pad: ?*IApplicationDebugger) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).ConnectDebugger(@ptrCast(*const IRemoteDebugApplication, self), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_DisconnectDebugger(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).DisconnectDebugger(@ptrCast(*const IRemoteDebugApplication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetDebugger(self: *const T, pad: ?*?*IApplicationDebugger) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).GetDebugger(@ptrCast(*const IRemoteDebugApplication, self), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_CreateInstanceAtApplication(self: *const T, rclsid: ?*const Guid, pUnkOuter: ?*IUnknown, dwClsContext: u32, riid: ?*const Guid, ppvObject: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).CreateInstanceAtApplication(@ptrCast(*const IRemoteDebugApplication, self), rclsid, pUnkOuter, dwClsContext, riid, ppvObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_QueryAlive(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).QueryAlive(@ptrCast(*const IRemoteDebugApplication, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_EnumThreads(self: *const T, pperdat: ?*?*IEnumRemoteDebugApplicationThreads) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).EnumThreads(@ptrCast(*const IRemoteDebugApplication, self), pperdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetName(self: *const T, pbstrName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).GetName(@ptrCast(*const IRemoteDebugApplication, self), pbstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_GetRootNode(self: *const T, ppdanRoot: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).GetRootNode(@ptrCast(*const IRemoteDebugApplication, self), ppdanRoot);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplication_EnumGlobalExpressionContexts(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplication.VTable, self.vtable).EnumGlobalExpressionContexts(@ptrCast(*const IRemoteDebugApplication, self), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication32_Value = @import("../../zig.zig").Guid.initString("51973c32-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplication32 = &IID_IDebugApplication32_Value;
pub const IDebugApplication32 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication.VTable,
        SetName: fn(
            self: *const IDebugApplication32,
            pstrName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StepOutComplete: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugOutput: fn(
            self: *const IDebugApplication32,
            pstr: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartDebugSession: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleBreakPoint: fn(
            self: *const IDebugApplication32,
            br: BREAKREASON,
            pbra: ?*BREAKRESUME_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakFlags: fn(
            self: *const IDebugApplication32,
            pabf: ?*u32,
            pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThread: fn(
            self: *const IDebugApplication32,
            pat: ?*?*IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAsyncDebugOperation: fn(
            self: *const IDebugApplication32,
            psdo: ?*IDebugSyncOperation,
            ppado: ?*?*IDebugAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStackFrameSniffer: fn(
            self: *const IDebugApplication32,
            pdsfs: ?*IDebugStackFrameSniffer,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStackFrameSniffer: fn(
            self: *const IDebugApplication32,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryCurrentThreadIsDebuggerThread: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SynchronousCallInDebuggerThread: fn(
            self: *const IDebugApplication32,
            pptc: ?*IDebugThreadCall32,
            dwParam1: u32,
            dwParam2: u32,
            dwParam3: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplicationNode: fn(
            self: *const IDebugApplication32,
            ppdanNew: ?*?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FireDebuggerEvent: fn(
            self: *const IDebugApplication32,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleRuntimeError: fn(
            self: *const IDebugApplication32,
            pErrorDebug: ?*IActiveScriptErrorDebug,
            pScriptSite: ?*IActiveScriptSite,
            pbra: ?*BREAKRESUME_ACTION,
            perra: ?*ERRORRESUMEACTION,
            pfCallOnScriptError: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FCanJitDebug: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        FIsAutoJitDebugEnabled: fn(
            self: *const IDebugApplication32,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        AddGlobalExpressionContextProvider: fn(
            self: *const IDebugApplication32,
            pdsfs: ?*IProvideExpressionContexts,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveGlobalExpressionContextProvider: fn(
            self: *const IDebugApplication32,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplication.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_SetName(self: *const T, pstrName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).SetName(@ptrCast(*const IDebugApplication32, self), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_StepOutComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).StepOutComplete(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_DebugOutput(self: *const T, pstr: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).DebugOutput(@ptrCast(*const IDebugApplication32, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_StartDebugSession(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).StartDebugSession(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_HandleBreakPoint(self: *const T, br: BREAKREASON, pbra: ?*BREAKRESUME_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).HandleBreakPoint(@ptrCast(*const IDebugApplication32, self), br, pbra);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).Close(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_GetBreakFlags(self: *const T, pabf: ?*u32, pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).GetBreakFlags(@ptrCast(*const IDebugApplication32, self), pabf, pprdatSteppingThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_GetCurrentThread(self: *const T, pat: ?*?*IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).GetCurrentThread(@ptrCast(*const IDebugApplication32, self), pat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_CreateAsyncDebugOperation(self: *const T, psdo: ?*IDebugSyncOperation, ppado: ?*?*IDebugAsyncOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).CreateAsyncDebugOperation(@ptrCast(*const IDebugApplication32, self), psdo, ppado);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_AddStackFrameSniffer(self: *const T, pdsfs: ?*IDebugStackFrameSniffer, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).AddStackFrameSniffer(@ptrCast(*const IDebugApplication32, self), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_RemoveStackFrameSniffer(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).RemoveStackFrameSniffer(@ptrCast(*const IDebugApplication32, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_QueryCurrentThreadIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).QueryCurrentThreadIsDebuggerThread(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_SynchronousCallInDebuggerThread(self: *const T, pptc: ?*IDebugThreadCall32, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).SynchronousCallInDebuggerThread(@ptrCast(*const IDebugApplication32, self), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_CreateApplicationNode(self: *const T, ppdanNew: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).CreateApplicationNode(@ptrCast(*const IDebugApplication32, self), ppdanNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FireDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).FireDebuggerEvent(@ptrCast(*const IDebugApplication32, self), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_HandleRuntimeError(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pScriptSite: ?*IActiveScriptSite, pbra: ?*BREAKRESUME_ACTION, perra: ?*ERRORRESUMEACTION, pfCallOnScriptError: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).HandleRuntimeError(@ptrCast(*const IDebugApplication32, self), pErrorDebug, pScriptSite, pbra, perra, pfCallOnScriptError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FCanJitDebug(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).FCanJitDebug(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_FIsAutoJitDebugEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).FIsAutoJitDebugEnabled(@ptrCast(*const IDebugApplication32, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_AddGlobalExpressionContextProvider(self: *const T, pdsfs: ?*IProvideExpressionContexts, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).AddGlobalExpressionContextProvider(@ptrCast(*const IDebugApplication32, self), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication32_RemoveGlobalExpressionContextProvider(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication32.VTable, self.vtable).RemoveGlobalExpressionContextProvider(@ptrCast(*const IDebugApplication32, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplication64_Value = @import("../../zig.zig").Guid.initString("4dedc754-04c7-4f10-9e60-16a390fe6e62");
pub const IID_IDebugApplication64 = &IID_IDebugApplication64_Value;
pub const IDebugApplication64 = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplication.VTable,
        SetName: fn(
            self: *const IDebugApplication64,
            pstrName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StepOutComplete: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DebugOutput: fn(
            self: *const IDebugApplication64,
            pstr: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartDebugSession: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleBreakPoint: fn(
            self: *const IDebugApplication64,
            br: BREAKREASON,
            pbra: ?*BREAKRESUME_ACTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakFlags: fn(
            self: *const IDebugApplication64,
            pabf: ?*u32,
            pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThread: fn(
            self: *const IDebugApplication64,
            pat: ?*?*IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateAsyncDebugOperation: fn(
            self: *const IDebugApplication64,
            psdo: ?*IDebugSyncOperation,
            ppado: ?*?*IDebugAsyncOperation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddStackFrameSniffer: fn(
            self: *const IDebugApplication64,
            pdsfs: ?*IDebugStackFrameSniffer,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveStackFrameSniffer: fn(
            self: *const IDebugApplication64,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryCurrentThreadIsDebuggerThread: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SynchronousCallInDebuggerThread: fn(
            self: *const IDebugApplication64,
            pptc: ?*IDebugThreadCall64,
            dwParam1: u64,
            dwParam2: u64,
            dwParam3: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateApplicationNode: fn(
            self: *const IDebugApplication64,
            ppdanNew: ?*?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FireDebuggerEvent: fn(
            self: *const IDebugApplication64,
            riid: ?*const Guid,
            punk: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        HandleRuntimeError: fn(
            self: *const IDebugApplication64,
            pErrorDebug: ?*IActiveScriptErrorDebug,
            pScriptSite: ?*IActiveScriptSite,
            pbra: ?*BREAKRESUME_ACTION,
            perra: ?*ERRORRESUMEACTION,
            pfCallOnScriptError: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FCanJitDebug: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        FIsAutoJitDebugEnabled: fn(
            self: *const IDebugApplication64,
        ) callconv(@import("std").os.windows.WINAPI) BOOL,
        AddGlobalExpressionContextProvider: fn(
            self: *const IDebugApplication64,
            pdsfs: ?*IProvideExpressionContexts,
            pdwCookie: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveGlobalExpressionContextProvider: fn(
            self: *const IDebugApplication64,
            dwCookie: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplication.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_SetName(self: *const T, pstrName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).SetName(@ptrCast(*const IDebugApplication64, self), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_StepOutComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).StepOutComplete(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_DebugOutput(self: *const T, pstr: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).DebugOutput(@ptrCast(*const IDebugApplication64, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_StartDebugSession(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).StartDebugSession(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_HandleBreakPoint(self: *const T, br: BREAKREASON, pbra: ?*BREAKRESUME_ACTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).HandleBreakPoint(@ptrCast(*const IDebugApplication64, self), br, pbra);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).Close(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_GetBreakFlags(self: *const T, pabf: ?*u32, pprdatSteppingThread: ?*?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).GetBreakFlags(@ptrCast(*const IDebugApplication64, self), pabf, pprdatSteppingThread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_GetCurrentThread(self: *const T, pat: ?*?*IDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).GetCurrentThread(@ptrCast(*const IDebugApplication64, self), pat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_CreateAsyncDebugOperation(self: *const T, psdo: ?*IDebugSyncOperation, ppado: ?*?*IDebugAsyncOperation) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).CreateAsyncDebugOperation(@ptrCast(*const IDebugApplication64, self), psdo, ppado);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_AddStackFrameSniffer(self: *const T, pdsfs: ?*IDebugStackFrameSniffer, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).AddStackFrameSniffer(@ptrCast(*const IDebugApplication64, self), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_RemoveStackFrameSniffer(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).RemoveStackFrameSniffer(@ptrCast(*const IDebugApplication64, self), dwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_QueryCurrentThreadIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).QueryCurrentThreadIsDebuggerThread(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_SynchronousCallInDebuggerThread(self: *const T, pptc: ?*IDebugThreadCall64, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).SynchronousCallInDebuggerThread(@ptrCast(*const IDebugApplication64, self), pptc, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_CreateApplicationNode(self: *const T, ppdanNew: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).CreateApplicationNode(@ptrCast(*const IDebugApplication64, self), ppdanNew);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FireDebuggerEvent(self: *const T, riid: ?*const Guid, punk: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).FireDebuggerEvent(@ptrCast(*const IDebugApplication64, self), riid, punk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_HandleRuntimeError(self: *const T, pErrorDebug: ?*IActiveScriptErrorDebug, pScriptSite: ?*IActiveScriptSite, pbra: ?*BREAKRESUME_ACTION, perra: ?*ERRORRESUMEACTION, pfCallOnScriptError: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).HandleRuntimeError(@ptrCast(*const IDebugApplication64, self), pErrorDebug, pScriptSite, pbra, perra, pfCallOnScriptError);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FCanJitDebug(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).FCanJitDebug(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_FIsAutoJitDebugEnabled(self: *const T) callconv(.Inline) BOOL {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).FIsAutoJitDebugEnabled(@ptrCast(*const IDebugApplication64, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_AddGlobalExpressionContextProvider(self: *const T, pdsfs: ?*IProvideExpressionContexts, pdwCookie: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).AddGlobalExpressionContextProvider(@ptrCast(*const IDebugApplication64, self), pdsfs, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplication64_RemoveGlobalExpressionContextProvider(self: *const T, dwCookie: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplication64.VTable, self.vtable).RemoveGlobalExpressionContextProvider(@ptrCast(*const IDebugApplication64, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplicationEvents_Value = @import("../../zig.zig").Guid.initString("51973c33-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplicationEvents = &IID_IRemoteDebugApplicationEvents_Value;
pub const IRemoteDebugApplicationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnConnectDebugger: fn(
            self: *const IRemoteDebugApplicationEvents,
            pad: ?*IApplicationDebugger,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDisconnectDebugger: fn(
            self: *const IRemoteDebugApplicationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnSetName: fn(
            self: *const IRemoteDebugApplicationEvents,
            pstrName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDebugOutput: fn(
            self: *const IRemoteDebugApplicationEvents,
            pstr: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnClose: fn(
            self: *const IRemoteDebugApplicationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnEnterBreakPoint: fn(
            self: *const IRemoteDebugApplicationEvents,
            prdat: ?*IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnLeaveBreakPoint: fn(
            self: *const IRemoteDebugApplicationEvents,
            prdat: ?*IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCreateThread: fn(
            self: *const IRemoteDebugApplicationEvents,
            prdat: ?*IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnDestroyThread: fn(
            self: *const IRemoteDebugApplicationEvents,
            prdat: ?*IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnBreakFlagChange: fn(
            self: *const IRemoteDebugApplicationEvents,
            abf: u32,
            prdatSteppingThread: ?*IRemoteDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnConnectDebugger(self: *const T, pad: ?*IApplicationDebugger) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnConnectDebugger(@ptrCast(*const IRemoteDebugApplicationEvents, self), pad);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDisconnectDebugger(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnDisconnectDebugger(@ptrCast(*const IRemoteDebugApplicationEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnSetName(self: *const T, pstrName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnSetName(@ptrCast(*const IRemoteDebugApplicationEvents, self), pstrName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDebugOutput(self: *const T, pstr: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnDebugOutput(@ptrCast(*const IRemoteDebugApplicationEvents, self), pstr);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnClose(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnClose(@ptrCast(*const IRemoteDebugApplicationEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnEnterBreakPoint(self: *const T, prdat: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnEnterBreakPoint(@ptrCast(*const IRemoteDebugApplicationEvents, self), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnLeaveBreakPoint(self: *const T, prdat: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnLeaveBreakPoint(@ptrCast(*const IRemoteDebugApplicationEvents, self), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnCreateThread(self: *const T, prdat: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnCreateThread(@ptrCast(*const IRemoteDebugApplicationEvents, self), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnDestroyThread(self: *const T, prdat: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnDestroyThread(@ptrCast(*const IRemoteDebugApplicationEvents, self), prdat);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationEvents_OnBreakFlagChange(self: *const T, abf: u32, prdatSteppingThread: ?*IRemoteDebugApplicationThread) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationEvents.VTable, self.vtable).OnBreakFlagChange(@ptrCast(*const IRemoteDebugApplicationEvents, self), abf, prdatSteppingThread);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationNode_Value = @import("../../zig.zig").Guid.initString("51973c34-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationNode = &IID_IDebugApplicationNode_Value;
pub const IDebugApplicationNode = extern struct {
    pub const VTable = extern struct {
        base: IDebugDocumentProvider.VTable,
        EnumChildren: fn(
            self: *const IDebugApplicationNode,
            pperddp: ?*?*IEnumDebugApplicationNodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParent: fn(
            self: *const IDebugApplicationNode,
            pprddp: ?*?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDocumentProvider: fn(
            self: *const IDebugApplicationNode,
            pddp: ?*IDebugDocumentProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Close: fn(
            self: *const IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Attach: fn(
            self: *const IDebugApplicationNode,
            pdanParent: ?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Detach: fn(
            self: *const IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugDocumentProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_EnumChildren(self: *const T, pperddp: ?*?*IEnumDebugApplicationNodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).EnumChildren(@ptrCast(*const IDebugApplicationNode, self), pperddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_GetParent(self: *const T, pprddp: ?*?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).GetParent(@ptrCast(*const IDebugApplicationNode, self), pprddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_SetDocumentProvider(self: *const T, pddp: ?*IDebugDocumentProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).SetDocumentProvider(@ptrCast(*const IDebugApplicationNode, self), pddp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).Close(@ptrCast(*const IDebugApplicationNode, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Attach(self: *const T, pdanParent: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).Attach(@ptrCast(*const IDebugApplicationNode, self), pdanParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNode_Detach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNode.VTable, self.vtable).Detach(@ptrCast(*const IDebugApplicationNode, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationNodeEvents_Value = @import("../../zig.zig").Guid.initString("51973c35-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationNodeEvents = &IID_IDebugApplicationNodeEvents_Value;
pub const IDebugApplicationNodeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        onAddChild: fn(
            self: *const IDebugApplicationNodeEvents,
            prddpChild: ?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onRemoveChild: fn(
            self: *const IDebugApplicationNodeEvents,
            prddpChild: ?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onDetach: fn(
            self: *const IDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        onAttach: fn(
            self: *const IDebugApplicationNodeEvents,
            prddpParent: ?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onAddChild(self: *const T, prddpChild: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNodeEvents.VTable, self.vtable).onAddChild(@ptrCast(*const IDebugApplicationNodeEvents, self), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onRemoveChild(self: *const T, prddpChild: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNodeEvents.VTable, self.vtable).onRemoveChild(@ptrCast(*const IDebugApplicationNodeEvents, self), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNodeEvents.VTable, self.vtable).onDetach(@ptrCast(*const IDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationNodeEvents_onAttach(self: *const T, prddpParent: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationNodeEvents.VTable, self.vtable).onAttach(@ptrCast(*const IDebugApplicationNodeEvents, self), prddpParent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_AsyncIDebugApplicationNodeEvents_Value = @import("../../zig.zig").Guid.initString("a2e3aa3b-aa8d-4ebf-84cd-648b737b8c13");
pub const IID_AsyncIDebugApplicationNodeEvents = &IID_AsyncIDebugApplicationNodeEvents_Value;
pub const AsyncIDebugApplicationNodeEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Begin_onAddChild: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
            prddpChild: ?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_onAddChild: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_onRemoveChild: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
            prddpChild: ?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_onRemoveChild: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_onDetach: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_onDetach: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Begin_onAttach: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
            prddpParent: ?*IDebugApplicationNode,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Finish_onAttach: fn(
            self: *const AsyncIDebugApplicationNodeEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onAddChild(self: *const T, prddpChild: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Begin_onAddChild(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onAddChild(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Finish_onAddChild(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onRemoveChild(self: *const T, prddpChild: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Begin_onRemoveChild(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self), prddpChild);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onRemoveChild(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Finish_onRemoveChild(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Begin_onDetach(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onDetach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Finish_onDetach(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Begin_onAttach(self: *const T, prddpParent: ?*IDebugApplicationNode) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Begin_onAttach(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self), prddpParent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn AsyncIDebugApplicationNodeEvents_Finish_onAttach(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const AsyncIDebugApplicationNodeEvents.VTable, self.vtable).Finish_onAttach(@ptrCast(*const AsyncIDebugApplicationNodeEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugThreadCall32_Value = @import("../../zig.zig").Guid.initString("51973c36-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugThreadCall32 = &IID_IDebugThreadCall32_Value;
pub const IDebugThreadCall32 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadCallHandler: fn(
            self: *const IDebugThreadCall32,
            dwParam1: u32,
            dwParam2: u32,
            dwParam3: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugThreadCall32_ThreadCallHandler(self: *const T, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugThreadCall32.VTable, self.vtable).ThreadCallHandler(@ptrCast(*const IDebugThreadCall32, self), dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugThreadCall64_Value = @import("../../zig.zig").Guid.initString("cb3fa335-e979-42fd-9fcf-a7546a0f3905");
pub const IID_IDebugThreadCall64 = &IID_IDebugThreadCall64_Value;
pub const IDebugThreadCall64 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ThreadCallHandler: fn(
            self: *const IDebugThreadCall64,
            dwParam1: u64,
            dwParam2: u64,
            dwParam3: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugThreadCall64_ThreadCallHandler(self: *const T, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugThreadCall64.VTable, self.vtable).ThreadCallHandler(@ptrCast(*const IDebugThreadCall64, self), dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRemoteDebugApplicationThread_Value = @import("../../zig.zig").Guid.initString("51973c37-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IRemoteDebugApplicationThread = &IID_IRemoteDebugApplicationThread_Value;
pub const IRemoteDebugApplicationThread = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSystemThreadId: fn(
            self: *const IRemoteDebugApplicationThread,
            dwThreadId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetApplication: fn(
            self: *const IRemoteDebugApplicationThread,
            pprda: ?*?*IRemoteDebugApplication,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumStackFrames: fn(
            self: *const IRemoteDebugApplicationThread,
            ppedsf: ?*?*IEnumDebugStackFrames,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IRemoteDebugApplicationThread,
            pbstrDescription: ?*?BSTR,
            pbstrState: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNextStatement: fn(
            self: *const IRemoteDebugApplicationThread,
            pStackFrame: ?*IDebugStackFrame,
            pCodeContext: ?*IDebugCodeContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetState: fn(
            self: *const IRemoteDebugApplicationThread,
            pState: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Suspend: fn(
            self: *const IRemoteDebugApplicationThread,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Resume: fn(
            self: *const IRemoteDebugApplicationThread,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSuspendCount: fn(
            self: *const IRemoteDebugApplicationThread,
            pdwCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetSystemThreadId(self: *const T, dwThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetSystemThreadId(@ptrCast(*const IRemoteDebugApplicationThread, self), dwThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetApplication(self: *const T, pprda: ?*?*IRemoteDebugApplication) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetApplication(@ptrCast(*const IRemoteDebugApplicationThread, self), pprda);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_EnumStackFrames(self: *const T, ppedsf: ?*?*IEnumDebugStackFrames) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).EnumStackFrames(@ptrCast(*const IRemoteDebugApplicationThread, self), ppedsf);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetDescription(self: *const T, pbstrDescription: ?*?BSTR, pbstrState: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetDescription(@ptrCast(*const IRemoteDebugApplicationThread, self), pbstrDescription, pbstrState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_SetNextStatement(self: *const T, pStackFrame: ?*IDebugStackFrame, pCodeContext: ?*IDebugCodeContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).SetNextStatement(@ptrCast(*const IRemoteDebugApplicationThread, self), pStackFrame, pCodeContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetState(self: *const T, pState: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetState(@ptrCast(*const IRemoteDebugApplicationThread, self), pState);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_Suspend(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).Suspend(@ptrCast(*const IRemoteDebugApplicationThread, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_Resume(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).Resume(@ptrCast(*const IRemoteDebugApplicationThread, self), pdwCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRemoteDebugApplicationThread_GetSuspendCount(self: *const T, pdwCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRemoteDebugApplicationThread.VTable, self.vtable).GetSuspendCount(@ptrCast(*const IRemoteDebugApplicationThread, self), pdwCount);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread_Value = @import("../../zig.zig").Guid.initString("51973c38-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugApplicationThread = &IID_IDebugApplicationThread_Value;
pub const IDebugApplicationThread = extern struct {
    pub const VTable = extern struct {
        base: IRemoteDebugApplicationThread.VTable,
        SynchronousCallIntoThread32: fn(
            self: *const IDebugApplicationThread,
            pstcb: ?*IDebugThreadCall32,
            dwParam1: u32,
            dwParam2: u32,
            dwParam3: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryIsCurrentThread: fn(
            self: *const IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryIsDebuggerThread: fn(
            self: *const IDebugApplicationThread,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDescription: fn(
            self: *const IDebugApplicationThread,
            pstrDescription: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetStateString: fn(
            self: *const IDebugApplicationThread,
            pstrState: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IRemoteDebugApplicationThread.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SynchronousCallIntoThread32(self: *const T, pstcb: ?*IDebugThreadCall32, dwParam1: u32, dwParam2: u32, dwParam3: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).SynchronousCallIntoThread32(@ptrCast(*const IDebugApplicationThread, self), pstcb, dwParam1, dwParam2, dwParam3);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_QueryIsCurrentThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).QueryIsCurrentThread(@ptrCast(*const IDebugApplicationThread, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_QueryIsDebuggerThread(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).QueryIsDebuggerThread(@ptrCast(*const IDebugApplicationThread, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SetDescription(self: *const T, pstrDescription: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).SetDescription(@ptrCast(*const IDebugApplicationThread, self), pstrDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread_SetStateString(self: *const T, pstrState: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread.VTable, self.vtable).SetStateString(@ptrCast(*const IDebugApplicationThread, self), pstrState);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugApplicationThread64_Value = @import("../../zig.zig").Guid.initString("9dac5886-dbad-456d-9dee-5dec39ab3dda");
pub const IID_IDebugApplicationThread64 = &IID_IDebugApplicationThread64_Value;
pub const IDebugApplicationThread64 = extern struct {
    pub const VTable = extern struct {
        base: IDebugApplicationThread.VTable,
        SynchronousCallIntoThread64: fn(
            self: *const IDebugApplicationThread64,
            pstcb: ?*IDebugThreadCall64,
            dwParam1: u64,
            dwParam2: u64,
            dwParam3: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugApplicationThread.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugApplicationThread64_SynchronousCallIntoThread64(self: *const T, pstcb: ?*IDebugThreadCall64, dwParam1: u64, dwParam2: u64, dwParam3: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugApplicationThread64.VTable, self.vtable).SynchronousCallIntoThread64(@ptrCast(*const IDebugApplicationThread64, self), pstcb, dwParam1, dwParam2, dwParam3);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugCookie_Value = @import("../../zig.zig").Guid.initString("51973c39-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugCookie = &IID_IDebugCookie_Value;
pub const IDebugCookie = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SetDebugCookie: fn(
            self: *const IDebugCookie,
            dwDebugAppCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugCookie_SetDebugCookie(self: *const T, dwDebugAppCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugCookie.VTable, self.vtable).SetDebugCookie(@ptrCast(*const IDebugCookie, self), dwDebugAppCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugApplicationNodes_Value = @import("../../zig.zig").Guid.initString("51973c3a-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugApplicationNodes = &IID_IEnumDebugApplicationNodes_Value;
pub const IEnumDebugApplicationNodes = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugApplicationNodes,
            celt: u32,
            pprddp: ?*?*IDebugApplicationNode,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugApplicationNodes,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugApplicationNodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugApplicationNodes,
            pperddp: ?*?*IEnumDebugApplicationNodes,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Next(self: *const T, celt: u32, pprddp: ?*?*IDebugApplicationNode, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugApplicationNodes.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugApplicationNodes, self), celt, pprddp, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugApplicationNodes.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugApplicationNodes, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugApplicationNodes.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugApplicationNodes, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugApplicationNodes_Clone(self: *const T, pperddp: ?*?*IEnumDebugApplicationNodes) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugApplicationNodes.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugApplicationNodes, self), pperddp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRemoteDebugApplications_Value = @import("../../zig.zig").Guid.initString("51973c3b-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumRemoteDebugApplications = &IID_IEnumRemoteDebugApplications_Value;
pub const IEnumRemoteDebugApplications = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumRemoteDebugApplications,
            celt: u32,
            ppda: ?*?*IRemoteDebugApplication,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRemoteDebugApplications,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRemoteDebugApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumRemoteDebugApplications,
            ppessd: ?*?*IEnumRemoteDebugApplications,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Next(self: *const T, celt: u32, ppda: ?*?*IRemoteDebugApplication, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplications.VTable, self.vtable).Next(@ptrCast(*const IEnumRemoteDebugApplications, self), celt, ppda, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplications.VTable, self.vtable).Skip(@ptrCast(*const IEnumRemoteDebugApplications, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplications.VTable, self.vtable).Reset(@ptrCast(*const IEnumRemoteDebugApplications, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplications_Clone(self: *const T, ppessd: ?*?*IEnumRemoteDebugApplications) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplications.VTable, self.vtable).Clone(@ptrCast(*const IEnumRemoteDebugApplications, self), ppessd);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumRemoteDebugApplicationThreads_Value = @import("../../zig.zig").Guid.initString("51973c3c-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumRemoteDebugApplicationThreads = &IID_IEnumRemoteDebugApplicationThreads_Value;
pub const IEnumRemoteDebugApplicationThreads = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumRemoteDebugApplicationThreads,
            celt: u32,
            pprdat: ?*?*IRemoteDebugApplicationThread,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumRemoteDebugApplicationThreads,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumRemoteDebugApplicationThreads,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumRemoteDebugApplicationThreads,
            pperdat: ?*?*IEnumRemoteDebugApplicationThreads,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Next(self: *const T, celt: u32, pprdat: ?*?*IRemoteDebugApplicationThread, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplicationThreads.VTable, self.vtable).Next(@ptrCast(*const IEnumRemoteDebugApplicationThreads, self), celt, pprdat, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplicationThreads.VTable, self.vtable).Skip(@ptrCast(*const IEnumRemoteDebugApplicationThreads, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplicationThreads.VTable, self.vtable).Reset(@ptrCast(*const IEnumRemoteDebugApplicationThreads, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumRemoteDebugApplicationThreads_Clone(self: *const T, pperdat: ?*?*IEnumRemoteDebugApplicationThreads) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumRemoteDebugApplicationThreads.VTable, self.vtable).Clone(@ptrCast(*const IEnumRemoteDebugApplicationThreads, self), pperdat);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugFormatter_Value = @import("../../zig.zig").Guid.initString("51973c05-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugFormatter = &IID_IDebugFormatter_Value;
pub const IDebugFormatter = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetStringForVariant: fn(
            self: *const IDebugFormatter,
            pvar: ?*VARIANT,
            nRadix: u32,
            pbstrValue: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVariantForString: fn(
            self: *const IDebugFormatter,
            pwstrValue: ?[*:0]const u16,
            pvar: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStringForVarType: fn(
            self: *const IDebugFormatter,
            vt: u16,
            ptdescArrayType: ?*TYPEDESC,
            pbstr: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetStringForVariant(self: *const T, pvar: ?*VARIANT, nRadix: u32, pbstrValue: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugFormatter.VTable, self.vtable).GetStringForVariant(@ptrCast(*const IDebugFormatter, self), pvar, nRadix, pbstrValue);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetVariantForString(self: *const T, pwstrValue: ?[*:0]const u16, pvar: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugFormatter.VTable, self.vtable).GetVariantForString(@ptrCast(*const IDebugFormatter, self), pwstrValue, pvar);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugFormatter_GetStringForVarType(self: *const T, vt: u16, ptdescArrayType: ?*TYPEDESC, pbstr: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugFormatter.VTable, self.vtable).GetStringForVarType(@ptrCast(*const IDebugFormatter, self), vt, ptdescArrayType, pbstr);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_ISimpleConnectionPoint_Value = @import("../../zig.zig").Guid.initString("51973c3e-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_ISimpleConnectionPoint = &IID_ISimpleConnectionPoint_Value;
pub const ISimpleConnectionPoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventCount: fn(
            self: *const ISimpleConnectionPoint,
            pulCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DescribeEvents: fn(
            self: *const ISimpleConnectionPoint,
            iEvent: u32,
            cEvents: u32,
            prgid: [*]i32,
            prgbstr: [*]?BSTR,
            pcEventsFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const ISimpleConnectionPoint,
            pdisp: ?*IDispatch,
            pdwCookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const ISimpleConnectionPoint,
            dwCookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_GetEventCount(self: *const T, pulCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleConnectionPoint.VTable, self.vtable).GetEventCount(@ptrCast(*const ISimpleConnectionPoint, self), pulCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_DescribeEvents(self: *const T, iEvent: u32, cEvents: u32, prgid: [*]i32, prgbstr: [*]?BSTR, pcEventsFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleConnectionPoint.VTable, self.vtable).DescribeEvents(@ptrCast(*const ISimpleConnectionPoint, self), iEvent, cEvents, prgid, prgbstr, pcEventsFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_Advise(self: *const T, pdisp: ?*IDispatch, pdwCookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleConnectionPoint.VTable, self.vtable).Advise(@ptrCast(*const ISimpleConnectionPoint, self), pdisp, pdwCookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn ISimpleConnectionPoint_Unadvise(self: *const T, dwCookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const ISimpleConnectionPoint.VTable, self.vtable).Unadvise(@ptrCast(*const ISimpleConnectionPoint, self), dwCookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHelper_Value = @import("../../zig.zig").Guid.initString("51973c3f-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IDebugHelper = &IID_IDebugHelper_Value;
pub const IDebugHelper = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreatePropertyBrowser: fn(
            self: *const IDebugHelper,
            pvar: ?*VARIANT,
            bstrName: ?[*:0]const u16,
            pdat: ?*IDebugApplicationThread,
            ppdob: ?*?*IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePropertyBrowserEx: fn(
            self: *const IDebugHelper,
            pvar: ?*VARIANT,
            bstrName: ?[*:0]const u16,
            pdat: ?*IDebugApplicationThread,
            pdf: ?*IDebugFormatter,
            ppdob: ?*?*IDebugProperty,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSimpleConnectionPoint: fn(
            self: *const IDebugHelper,
            pdisp: ?*IDispatch,
            ppscp: ?*?*ISimpleConnectionPoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreatePropertyBrowser(self: *const T, pvar: ?*VARIANT, bstrName: ?[*:0]const u16, pdat: ?*IDebugApplicationThread, ppdob: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHelper.VTable, self.vtable).CreatePropertyBrowser(@ptrCast(*const IDebugHelper, self), pvar, bstrName, pdat, ppdob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreatePropertyBrowserEx(self: *const T, pvar: ?*VARIANT, bstrName: ?[*:0]const u16, pdat: ?*IDebugApplicationThread, pdf: ?*IDebugFormatter, ppdob: ?*?*IDebugProperty) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHelper.VTable, self.vtable).CreatePropertyBrowserEx(@ptrCast(*const IDebugHelper, self), pvar, bstrName, pdat, pdf, ppdob);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHelper_CreateSimpleConnectionPoint(self: *const T, pdisp: ?*IDispatch, ppscp: ?*?*ISimpleConnectionPoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHelper.VTable, self.vtable).CreateSimpleConnectionPoint(@ptrCast(*const IDebugHelper, self), pdisp, ppscp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEnumDebugExpressionContexts_Value = @import("../../zig.zig").Guid.initString("51973c40-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IEnumDebugExpressionContexts = &IID_IEnumDebugExpressionContexts_Value;
pub const IEnumDebugExpressionContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IEnumDebugExpressionContexts,
            celt: u32,
            ppdec: ?*?*IDebugExpressionContext,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Skip: fn(
            self: *const IEnumDebugExpressionContexts,
            celt: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reset: fn(
            self: *const IEnumDebugExpressionContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Clone: fn(
            self: *const IEnumDebugExpressionContexts,
            ppedec: ?*?*IEnumDebugExpressionContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Next(self: *const T, celt: u32, ppdec: ?*?*IDebugExpressionContext, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExpressionContexts.VTable, self.vtable).Next(@ptrCast(*const IEnumDebugExpressionContexts, self), celt, ppdec, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Skip(self: *const T, celt: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExpressionContexts.VTable, self.vtable).Skip(@ptrCast(*const IEnumDebugExpressionContexts, self), celt);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExpressionContexts.VTable, self.vtable).Reset(@ptrCast(*const IEnumDebugExpressionContexts, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEnumDebugExpressionContexts_Clone(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEnumDebugExpressionContexts.VTable, self.vtable).Clone(@ptrCast(*const IEnumDebugExpressionContexts, self), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IProvideExpressionContexts_Value = @import("../../zig.zig").Guid.initString("51973c41-cb0c-11d0-b5c9-00a0244a0e7a");
pub const IID_IProvideExpressionContexts = &IID_IProvideExpressionContexts_Value;
pub const IProvideExpressionContexts = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EnumExpressionContexts: fn(
            self: *const IProvideExpressionContexts,
            ppedec: ?*?*IEnumDebugExpressionContexts,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IProvideExpressionContexts_EnumExpressionContexts(self: *const T, ppedec: ?*?*IEnumDebugExpressionContexts) callconv(.Inline) HRESULT {
            return @ptrCast(*const IProvideExpressionContexts.VTable, self.vtable).EnumExpressionContexts(@ptrCast(*const IProvideExpressionContexts, self), ppedec);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROFILER_SCRIPT_TYPE = enum(i32) {
    USER = 0,
    DYNAMIC = 1,
    NATIVE = 2,
    DOM = 3,
};
pub const PROFILER_SCRIPT_TYPE_USER = PROFILER_SCRIPT_TYPE.USER;
pub const PROFILER_SCRIPT_TYPE_DYNAMIC = PROFILER_SCRIPT_TYPE.DYNAMIC;
pub const PROFILER_SCRIPT_TYPE_NATIVE = PROFILER_SCRIPT_TYPE.NATIVE;
pub const PROFILER_SCRIPT_TYPE_DOM = PROFILER_SCRIPT_TYPE.DOM;

pub const PROFILER_EVENT_MASK = enum(u32) {
    SCRIPT_FUNCTION_CALL = 1,
    NATIVE_FUNCTION_CALL = 2,
    DOM_FUNCTION_CALL = 4,
    ALL = 3,
    ALL_WITH_DOM = 7,
    _,
    pub fn initFlags(o: struct {
        SCRIPT_FUNCTION_CALL: u1 = 0,
        NATIVE_FUNCTION_CALL: u1 = 0,
        DOM_FUNCTION_CALL: u1 = 0,
        ALL: u1 = 0,
        ALL_WITH_DOM: u1 = 0,
    }) PROFILER_EVENT_MASK {
        return @intToEnum(PROFILER_EVENT_MASK,
              (if (o.SCRIPT_FUNCTION_CALL == 1) @enumToInt(PROFILER_EVENT_MASK.SCRIPT_FUNCTION_CALL) else 0)
            | (if (o.NATIVE_FUNCTION_CALL == 1) @enumToInt(PROFILER_EVENT_MASK.NATIVE_FUNCTION_CALL) else 0)
            | (if (o.DOM_FUNCTION_CALL == 1) @enumToInt(PROFILER_EVENT_MASK.DOM_FUNCTION_CALL) else 0)
            | (if (o.ALL == 1) @enumToInt(PROFILER_EVENT_MASK.ALL) else 0)
            | (if (o.ALL_WITH_DOM == 1) @enumToInt(PROFILER_EVENT_MASK.ALL_WITH_DOM) else 0)
        );
    }
};
pub const PROFILER_EVENT_MASK_TRACE_SCRIPT_FUNCTION_CALL = PROFILER_EVENT_MASK.SCRIPT_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_NATIVE_FUNCTION_CALL = PROFILER_EVENT_MASK.NATIVE_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_DOM_FUNCTION_CALL = PROFILER_EVENT_MASK.DOM_FUNCTION_CALL;
pub const PROFILER_EVENT_MASK_TRACE_ALL = PROFILER_EVENT_MASK.ALL;
pub const PROFILER_EVENT_MASK_TRACE_ALL_WITH_DOM = PROFILER_EVENT_MASK.ALL_WITH_DOM;

const IID_IActiveScriptProfilerControl_Value = @import("../../zig.zig").Guid.initString("784b5ff0-69b0-47d1-a7dc-2518f4230e90");
pub const IID_IActiveScriptProfilerControl = &IID_IActiveScriptProfilerControl_Value;
pub const IActiveScriptProfilerControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartProfiling: fn(
            self: *const IActiveScriptProfilerControl,
            clsidProfilerObject: ?*const Guid,
            dwEventMask: u32,
            dwContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProfilerEventMask: fn(
            self: *const IActiveScriptProfilerControl,
            dwEventMask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopProfiling: fn(
            self: *const IActiveScriptProfilerControl,
            hrShutdownReason: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_StartProfiling(self: *const T, clsidProfilerObject: ?*const Guid, dwEventMask: u32, dwContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl.VTable, self.vtable).StartProfiling(@ptrCast(*const IActiveScriptProfilerControl, self), clsidProfilerObject, dwEventMask, dwContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_SetProfilerEventMask(self: *const T, dwEventMask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl.VTable, self.vtable).SetProfilerEventMask(@ptrCast(*const IActiveScriptProfilerControl, self), dwEventMask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl_StopProfiling(self: *const T, hrShutdownReason: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl.VTable, self.vtable).StopProfiling(@ptrCast(*const IActiveScriptProfilerControl, self), hrShutdownReason);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl2_Value = @import("../../zig.zig").Guid.initString("47810165-498f-40be-94f1-653557e9e7da");
pub const IID_IActiveScriptProfilerControl2 = &IID_IActiveScriptProfilerControl2_Value;
pub const IActiveScriptProfilerControl2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl.VTable,
        CompleteProfilerStart: fn(
            self: *const IActiveScriptProfilerControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PrepareProfilerStop: fn(
            self: *const IActiveScriptProfilerControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl2_CompleteProfilerStart(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl2.VTable, self.vtable).CompleteProfilerStart(@ptrCast(*const IActiveScriptProfilerControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl2_PrepareProfilerStop(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl2.VTable, self.vtable).PrepareProfilerStop(@ptrCast(*const IActiveScriptProfilerControl2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROFILER_HEAP_OBJECT_FLAGS = enum(u32) {
    NEW_OBJECT = 1,
    IS_ROOT = 2,
    SITE_CLOSED = 4,
    EXTERNAL = 8,
    EXTERNAL_UNKNOWN = 16,
    EXTERNAL_DISPATCH = 32,
    SIZE_APPROXIMATE = 64,
    SIZE_UNAVAILABLE = 128,
    NEW_STATE_UNAVAILABLE = 256,
    WINRT_INSTANCE = 512,
    WINRT_RUNTIMECLASS = 1024,
    WINRT_DELEGATE = 2048,
    WINRT_NAMESPACE = 4096,
    _,
    pub fn initFlags(o: struct {
        NEW_OBJECT: u1 = 0,
        IS_ROOT: u1 = 0,
        SITE_CLOSED: u1 = 0,
        EXTERNAL: u1 = 0,
        EXTERNAL_UNKNOWN: u1 = 0,
        EXTERNAL_DISPATCH: u1 = 0,
        SIZE_APPROXIMATE: u1 = 0,
        SIZE_UNAVAILABLE: u1 = 0,
        NEW_STATE_UNAVAILABLE: u1 = 0,
        WINRT_INSTANCE: u1 = 0,
        WINRT_RUNTIMECLASS: u1 = 0,
        WINRT_DELEGATE: u1 = 0,
        WINRT_NAMESPACE: u1 = 0,
    }) PROFILER_HEAP_OBJECT_FLAGS {
        return @intToEnum(PROFILER_HEAP_OBJECT_FLAGS,
              (if (o.NEW_OBJECT == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.NEW_OBJECT) else 0)
            | (if (o.IS_ROOT == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.IS_ROOT) else 0)
            | (if (o.SITE_CLOSED == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.SITE_CLOSED) else 0)
            | (if (o.EXTERNAL == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL) else 0)
            | (if (o.EXTERNAL_UNKNOWN == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_UNKNOWN) else 0)
            | (if (o.EXTERNAL_DISPATCH == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_DISPATCH) else 0)
            | (if (o.SIZE_APPROXIMATE == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.SIZE_APPROXIMATE) else 0)
            | (if (o.SIZE_UNAVAILABLE == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.SIZE_UNAVAILABLE) else 0)
            | (if (o.NEW_STATE_UNAVAILABLE == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.NEW_STATE_UNAVAILABLE) else 0)
            | (if (o.WINRT_INSTANCE == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.WINRT_INSTANCE) else 0)
            | (if (o.WINRT_RUNTIMECLASS == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.WINRT_RUNTIMECLASS) else 0)
            | (if (o.WINRT_DELEGATE == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.WINRT_DELEGATE) else 0)
            | (if (o.WINRT_NAMESPACE == 1) @enumToInt(PROFILER_HEAP_OBJECT_FLAGS.WINRT_NAMESPACE) else 0)
        );
    }
};
pub const PROFILER_HEAP_OBJECT_FLAGS_NEW_OBJECT = PROFILER_HEAP_OBJECT_FLAGS.NEW_OBJECT;
pub const PROFILER_HEAP_OBJECT_FLAGS_IS_ROOT = PROFILER_HEAP_OBJECT_FLAGS.IS_ROOT;
pub const PROFILER_HEAP_OBJECT_FLAGS_SITE_CLOSED = PROFILER_HEAP_OBJECT_FLAGS.SITE_CLOSED;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_UNKNOWN = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_UNKNOWN;
pub const PROFILER_HEAP_OBJECT_FLAGS_EXTERNAL_DISPATCH = PROFILER_HEAP_OBJECT_FLAGS.EXTERNAL_DISPATCH;
pub const PROFILER_HEAP_OBJECT_FLAGS_SIZE_APPROXIMATE = PROFILER_HEAP_OBJECT_FLAGS.SIZE_APPROXIMATE;
pub const PROFILER_HEAP_OBJECT_FLAGS_SIZE_UNAVAILABLE = PROFILER_HEAP_OBJECT_FLAGS.SIZE_UNAVAILABLE;
pub const PROFILER_HEAP_OBJECT_FLAGS_NEW_STATE_UNAVAILABLE = PROFILER_HEAP_OBJECT_FLAGS.NEW_STATE_UNAVAILABLE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_INSTANCE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_INSTANCE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_RUNTIMECLASS = PROFILER_HEAP_OBJECT_FLAGS.WINRT_RUNTIMECLASS;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_DELEGATE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_DELEGATE;
pub const PROFILER_HEAP_OBJECT_FLAGS_WINRT_NAMESPACE = PROFILER_HEAP_OBJECT_FLAGS.WINRT_NAMESPACE;

pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE = enum(i32) {
    PROTOTYPE = 1,
    FUNCTION_NAME = 2,
    SCOPE_LIST = 3,
    INTERNAL_PROPERTY = 4,
    NAME_PROPERTIES = 5,
    INDEX_PROPERTIES = 6,
    ELEMENT_ATTRIBUTES_SIZE = 7,
    ELEMENT_TEXT_CHILDREN_SIZE = 8,
    RELATIONSHIPS = 9,
    WINRTEVENTS = 10,
    WEAKMAP_COLLECTION_LIST = 11,
    MAP_COLLECTION_LIST = 12,
    SET_COLLECTION_LIST = 13,
    // MAX_VALUE = 13, this enum value conflicts with SET_COLLECTION_LIST
};
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_PROTOTYPE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.PROTOTYPE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_FUNCTION_NAME = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.FUNCTION_NAME;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SCOPE_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SCOPE_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INTERNAL_PROPERTY = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.INTERNAL_PROPERTY;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_NAME_PROPERTIES = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.NAME_PROPERTIES;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_INDEX_PROPERTIES = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.INDEX_PROPERTIES;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_ATTRIBUTES_SIZE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.ELEMENT_ATTRIBUTES_SIZE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_ELEMENT_TEXT_CHILDREN_SIZE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.ELEMENT_TEXT_CHILDREN_SIZE;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_RELATIONSHIPS = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.RELATIONSHIPS;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WINRTEVENTS = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.WINRTEVENTS;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_WEAKMAP_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.WEAKMAP_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAP_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.MAP_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_SET_COLLECTION_LIST = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SET_COLLECTION_LIST;
pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO_MAX_VALUE = PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE.SET_COLLECTION_LIST;

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS = enum(u32) {
    NONE = 0,
    IS_GET_ACCESSOR = 65536,
    IS_SET_ACCESSOR = 131072,
    LET_VARIABLE = 262144,
    CONST_VARIABLE = 524288,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        IS_GET_ACCESSOR: u1 = 0,
        IS_SET_ACCESSOR: u1 = 0,
        LET_VARIABLE: u1 = 0,
        CONST_VARIABLE: u1 = 0,
    }) PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS {
        return @intToEnum(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS,
              (if (o.NONE == 1) @enumToInt(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.NONE) else 0)
            | (if (o.IS_GET_ACCESSOR == 1) @enumToInt(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_GET_ACCESSOR) else 0)
            | (if (o.IS_SET_ACCESSOR == 1) @enumToInt(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_SET_ACCESSOR) else 0)
            | (if (o.LET_VARIABLE == 1) @enumToInt(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.LET_VARIABLE) else 0)
            | (if (o.CONST_VARIABLE == 1) @enumToInt(PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.CONST_VARIABLE) else 0)
        );
    }
};
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_NONE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.NONE;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_GET_ACCESSOR = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_GET_ACCESSOR;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_IS_SET_ACCESSOR = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.IS_SET_ACCESSOR;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_LET_VARIABLE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.LET_VARIABLE;
pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS_CONST_VARIABLE = PROFILER_HEAP_OBJECT_RELATIONSHIP_FLAGS.CONST_VARIABLE;

pub const PROFILER_HEAP_ENUM_FLAGS = enum(u32) {
    NONE = 0,
    STORE_RELATIONSHIP_FLAGS = 1,
    SUBSTRINGS = 2,
    RELATIONSHIP_SUBSTRINGS = 3,
    _,
    pub fn initFlags(o: struct {
        NONE: u1 = 0,
        STORE_RELATIONSHIP_FLAGS: u1 = 0,
        SUBSTRINGS: u1 = 0,
        RELATIONSHIP_SUBSTRINGS: u1 = 0,
    }) PROFILER_HEAP_ENUM_FLAGS {
        return @intToEnum(PROFILER_HEAP_ENUM_FLAGS,
              (if (o.NONE == 1) @enumToInt(PROFILER_HEAP_ENUM_FLAGS.NONE) else 0)
            | (if (o.STORE_RELATIONSHIP_FLAGS == 1) @enumToInt(PROFILER_HEAP_ENUM_FLAGS.STORE_RELATIONSHIP_FLAGS) else 0)
            | (if (o.SUBSTRINGS == 1) @enumToInt(PROFILER_HEAP_ENUM_FLAGS.SUBSTRINGS) else 0)
            | (if (o.RELATIONSHIP_SUBSTRINGS == 1) @enumToInt(PROFILER_HEAP_ENUM_FLAGS.RELATIONSHIP_SUBSTRINGS) else 0)
        );
    }
};
pub const PROFILER_HEAP_ENUM_FLAGS_NONE = PROFILER_HEAP_ENUM_FLAGS.NONE;
pub const PROFILER_HEAP_ENUM_FLAGS_STORE_RELATIONSHIP_FLAGS = PROFILER_HEAP_ENUM_FLAGS.STORE_RELATIONSHIP_FLAGS;
pub const PROFILER_HEAP_ENUM_FLAGS_SUBSTRINGS = PROFILER_HEAP_ENUM_FLAGS.SUBSTRINGS;
pub const PROFILER_HEAP_ENUM_FLAGS_RELATIONSHIP_SUBSTRINGS = PROFILER_HEAP_ENUM_FLAGS.RELATIONSHIP_SUBSTRINGS;

pub const PROFILER_HEAP_OBJECT_SCOPE_LIST = extern struct {
    count: u32,
    scopes: [1]usize,
};

pub const PROFILER_RELATIONSHIP_INFO = enum(i32) {
    NUMBER = 1,
    STRING = 2,
    HEAP_OBJECT = 3,
    EXTERNAL_OBJECT = 4,
    BSTR = 5,
    SUBSTRING = 6,
};
pub const PROFILER_PROPERTY_TYPE_NUMBER = PROFILER_RELATIONSHIP_INFO.NUMBER;
pub const PROFILER_PROPERTY_TYPE_STRING = PROFILER_RELATIONSHIP_INFO.STRING;
pub const PROFILER_PROPERTY_TYPE_HEAP_OBJECT = PROFILER_RELATIONSHIP_INFO.HEAP_OBJECT;
pub const PROFILER_PROPERTY_TYPE_EXTERNAL_OBJECT = PROFILER_RELATIONSHIP_INFO.EXTERNAL_OBJECT;
pub const PROFILER_PROPERTY_TYPE_BSTR = PROFILER_RELATIONSHIP_INFO.BSTR;
pub const PROFILER_PROPERTY_TYPE_SUBSTRING = PROFILER_RELATIONSHIP_INFO.SUBSTRING;

pub const PROFILER_PROPERTY_TYPE_SUBSTRING_INFO = extern struct {
    length: u32,
    value: ?[*:0]const u16,
};

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP = extern struct {
    relationshipId: u32,
    relationshipInfo: PROFILER_RELATIONSHIP_INFO,
    Anonymous: extern union {
        numberValue: f64,
        stringValue: ?[*:0]const u16,
        bstrValue: ?BSTR,
        objectId: usize,
        externalObjectAddress: ?*c_void,
        subString: ?*PROFILER_PROPERTY_TYPE_SUBSTRING_INFO,
    },
};

pub const PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST = extern struct {
    count: u32,
    elements: [1]PROFILER_HEAP_OBJECT_RELATIONSHIP,
};

pub const PROFILER_HEAP_OBJECT_OPTIONAL_INFO = extern struct {
    infoType: PROFILER_HEAP_OBJECT_OPTIONAL_INFO_TYPE,
    Anonymous: extern union {
        prototype: usize,
        functionName: ?[*:0]const u16,
        elementAttributesSize: u32,
        elementTextChildrenSize: u32,
        scopeList: ?*PROFILER_HEAP_OBJECT_SCOPE_LIST,
        internalProperty: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP,
        namePropertyList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        indexPropertyList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        relationshipList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        eventList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        weakMapCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        mapCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
        setCollectionList: ?*PROFILER_HEAP_OBJECT_RELATIONSHIP_LIST,
    },
};

pub const PROFILER_HEAP_OBJECT = extern struct {
    size: u32,
    Anonymous: extern union {
        objectId: usize,
        externalObjectAddress: ?*c_void,
    },
    typeNameId: u32,
    flags: u32,
    unused: u16,
    optionalInfoCount: u16,
};

const IID_IActiveScriptProfilerHeapEnum_Value = @import("../../zig.zig").Guid.initString("32e4694e-0d37-419b-b93d-fa20ded6e8ea");
pub const IID_IActiveScriptProfilerHeapEnum = &IID_IActiveScriptProfilerHeapEnum_Value;
pub const IActiveScriptProfilerHeapEnum = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Next: fn(
            self: *const IActiveScriptProfilerHeapEnum,
            celt: u32,
            heapObjects: [*]?*PROFILER_HEAP_OBJECT,
            pceltFetched: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOptionalInfo: fn(
            self: *const IActiveScriptProfilerHeapEnum,
            heapObject: ?*PROFILER_HEAP_OBJECT,
            celt: u32,
            optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FreeObjectAndOptionalInfo: fn(
            self: *const IActiveScriptProfilerHeapEnum,
            celt: u32,
            heapObjects: [*]?*PROFILER_HEAP_OBJECT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameIdMap: fn(
            self: *const IActiveScriptProfilerHeapEnum,
            pNameList: [*]?*?*?PWSTR,
            pcelt: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_Next(self: *const T, celt: u32, heapObjects: [*]?*PROFILER_HEAP_OBJECT, pceltFetched: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerHeapEnum.VTable, self.vtable).Next(@ptrCast(*const IActiveScriptProfilerHeapEnum, self), celt, heapObjects, pceltFetched);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_GetOptionalInfo(self: *const T, heapObject: ?*PROFILER_HEAP_OBJECT, celt: u32, optionalInfo: [*]PROFILER_HEAP_OBJECT_OPTIONAL_INFO) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerHeapEnum.VTable, self.vtable).GetOptionalInfo(@ptrCast(*const IActiveScriptProfilerHeapEnum, self), heapObject, celt, optionalInfo);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_FreeObjectAndOptionalInfo(self: *const T, celt: u32, heapObjects: [*]?*PROFILER_HEAP_OBJECT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerHeapEnum.VTable, self.vtable).FreeObjectAndOptionalInfo(@ptrCast(*const IActiveScriptProfilerHeapEnum, self), celt, heapObjects);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerHeapEnum_GetNameIdMap(self: *const T, pNameList: [*]?*?*?PWSTR, pcelt: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerHeapEnum.VTable, self.vtable).GetNameIdMap(@ptrCast(*const IActiveScriptProfilerHeapEnum, self), pNameList, pcelt);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl3_Value = @import("../../zig.zig").Guid.initString("0b403015-f381-4023-a5d0-6fed076de716");
pub const IID_IActiveScriptProfilerControl3 = &IID_IActiveScriptProfilerControl3_Value;
pub const IActiveScriptProfilerControl3 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl2.VTable,
        EnumHeap: fn(
            self: *const IActiveScriptProfilerControl3,
            ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl3_EnumHeap(self: *const T, ppEnum: ?*?*IActiveScriptProfilerHeapEnum) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl3.VTable, self.vtable).EnumHeap(@ptrCast(*const IActiveScriptProfilerControl3, self), ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PROFILER_HEAP_SUMMARY_VERSION = enum(i32) {
    @"1" = 1,
};
pub const PROFILER_HEAP_SUMMARY_VERSION_1 = PROFILER_HEAP_SUMMARY_VERSION.@"1";

pub const PROFILER_HEAP_SUMMARY = extern struct {
    version: PROFILER_HEAP_SUMMARY_VERSION,
    totalHeapSize: u32,
};

const IID_IActiveScriptProfilerControl4_Value = @import("../../zig.zig").Guid.initString("160f94fd-9dbc-40d4-9eac-2b71db3132f4");
pub const IID_IActiveScriptProfilerControl4 = &IID_IActiveScriptProfilerControl4_Value;
pub const IActiveScriptProfilerControl4 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl3.VTable,
        SummarizeHeap: fn(
            self: *const IActiveScriptProfilerControl4,
            heapSummary: ?*PROFILER_HEAP_SUMMARY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl3.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl4_SummarizeHeap(self: *const T, heapSummary: ?*PROFILER_HEAP_SUMMARY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl4.VTable, self.vtable).SummarizeHeap(@ptrCast(*const IActiveScriptProfilerControl4, self), heapSummary);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerControl5_Value = @import("../../zig.zig").Guid.initString("1c01a2d1-8f0f-46a5-9720-0d7ed2c62f0a");
pub const IID_IActiveScriptProfilerControl5 = &IID_IActiveScriptProfilerControl5_Value;
pub const IActiveScriptProfilerControl5 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerControl4.VTable,
        EnumHeap2: fn(
            self: *const IActiveScriptProfilerControl5,
            enumFlags: PROFILER_HEAP_ENUM_FLAGS,
            ppEnum: ?*?*IActiveScriptProfilerHeapEnum,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerControl4.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerControl5_EnumHeap2(self: *const T, enumFlags: PROFILER_HEAP_ENUM_FLAGS, ppEnum: ?*?*IActiveScriptProfilerHeapEnum) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerControl5.VTable, self.vtable).EnumHeap2(@ptrCast(*const IActiveScriptProfilerControl5, self), enumFlags, ppEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback_Value = @import("../../zig.zig").Guid.initString("740eca23-7d9d-42e5-ba9d-f8b24b1c7a9b");
pub const IID_IActiveScriptProfilerCallback = &IID_IActiveScriptProfilerCallback_Value;
pub const IActiveScriptProfilerCallback = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Initialize: fn(
            self: *const IActiveScriptProfilerCallback,
            dwContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Shutdown: fn(
            self: *const IActiveScriptProfilerCallback,
            hrReason: HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScriptCompiled: fn(
            self: *const IActiveScriptProfilerCallback,
            scriptId: i32,
            type: PROFILER_SCRIPT_TYPE,
            pIDebugDocumentContext: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FunctionCompiled: fn(
            self: *const IActiveScriptProfilerCallback,
            functionId: i32,
            scriptId: i32,
            pwszFunctionName: ?[*:0]const u16,
            pwszFunctionNameHint: ?[*:0]const u16,
            pIDebugDocumentContext: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFunctionEnter: fn(
            self: *const IActiveScriptProfilerCallback,
            scriptId: i32,
            functionId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFunctionExit: fn(
            self: *const IActiveScriptProfilerCallback,
            scriptId: i32,
            functionId: i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_Initialize(self: *const T, dwContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).Initialize(@ptrCast(*const IActiveScriptProfilerCallback, self), dwContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_Shutdown(self: *const T, hrReason: HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).Shutdown(@ptrCast(*const IActiveScriptProfilerCallback, self), hrReason);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_ScriptCompiled(self: *const T, scriptId: i32, type_: PROFILER_SCRIPT_TYPE, pIDebugDocumentContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).ScriptCompiled(@ptrCast(*const IActiveScriptProfilerCallback, self), scriptId, type_, pIDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_FunctionCompiled(self: *const T, functionId: i32, scriptId: i32, pwszFunctionName: ?[*:0]const u16, pwszFunctionNameHint: ?[*:0]const u16, pIDebugDocumentContext: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).FunctionCompiled(@ptrCast(*const IActiveScriptProfilerCallback, self), functionId, scriptId, pwszFunctionName, pwszFunctionNameHint, pIDebugDocumentContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_OnFunctionEnter(self: *const T, scriptId: i32, functionId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).OnFunctionEnter(@ptrCast(*const IActiveScriptProfilerCallback, self), scriptId, functionId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback_OnFunctionExit(self: *const T, scriptId: i32, functionId: i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback.VTable, self.vtable).OnFunctionExit(@ptrCast(*const IActiveScriptProfilerCallback, self), scriptId, functionId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback2_Value = @import("../../zig.zig").Guid.initString("31b7f8ad-a637-409c-b22f-040995b6103d");
pub const IID_IActiveScriptProfilerCallback2 = &IID_IActiveScriptProfilerCallback2_Value;
pub const IActiveScriptProfilerCallback2 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerCallback.VTable,
        OnFunctionEnterByName: fn(
            self: *const IActiveScriptProfilerCallback2,
            pwszFunctionName: ?[*:0]const u16,
            type: PROFILER_SCRIPT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnFunctionExitByName: fn(
            self: *const IActiveScriptProfilerCallback2,
            pwszFunctionName: ?[*:0]const u16,
            type: PROFILER_SCRIPT_TYPE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerCallback.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback2_OnFunctionEnterByName(self: *const T, pwszFunctionName: ?[*:0]const u16, type_: PROFILER_SCRIPT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback2.VTable, self.vtable).OnFunctionEnterByName(@ptrCast(*const IActiveScriptProfilerCallback2, self), pwszFunctionName, type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback2_OnFunctionExitByName(self: *const T, pwszFunctionName: ?[*:0]const u16, type_: PROFILER_SCRIPT_TYPE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback2.VTable, self.vtable).OnFunctionExitByName(@ptrCast(*const IActiveScriptProfilerCallback2, self), pwszFunctionName, type_);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IActiveScriptProfilerCallback3_Value = @import("../../zig.zig").Guid.initString("6ac5ad25-2037-4687-91df-b59979d93d73");
pub const IID_IActiveScriptProfilerCallback3 = &IID_IActiveScriptProfilerCallback3_Value;
pub const IActiveScriptProfilerCallback3 = extern struct {
    pub const VTable = extern struct {
        base: IActiveScriptProfilerCallback2.VTable,
        SetWebWorkerId: fn(
            self: *const IActiveScriptProfilerCallback3,
            webWorkerId: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IActiveScriptProfilerCallback2.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IActiveScriptProfilerCallback3_SetWebWorkerId(self: *const T, webWorkerId: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IActiveScriptProfilerCallback3.VTable, self.vtable).SetWebWorkerId(@ptrCast(*const IActiveScriptProfilerCallback3, self), webWorkerId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationScriptEvents_Value = @import("../../zig.zig").Guid.initString("7c3f6998-1567-4bba-b52b-48d32141d613");
pub const IID_IWebApplicationScriptEvents = &IID_IWebApplicationScriptEvents_Value;
pub const IWebApplicationScriptEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeforeScriptExecute: fn(
            self: *const IWebApplicationScriptEvents,
            htmlWindow: ?*IHTMLWindow2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ScriptError: fn(
            self: *const IWebApplicationScriptEvents,
            htmlWindow: ?*IHTMLWindow2,
            scriptError: ?*IActiveScriptError,
            url: ?[*:0]const u16,
            errorHandled: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationScriptEvents_BeforeScriptExecute(self: *const T, htmlWindow: ?*IHTMLWindow2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationScriptEvents.VTable, self.vtable).BeforeScriptExecute(@ptrCast(*const IWebApplicationScriptEvents, self), htmlWindow);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationScriptEvents_ScriptError(self: *const T, htmlWindow: ?*IHTMLWindow2, scriptError: ?*IActiveScriptError, url: ?[*:0]const u16, errorHandled: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationScriptEvents.VTable, self.vtable).ScriptError(@ptrCast(*const IWebApplicationScriptEvents, self), htmlWindow, scriptError, url, errorHandled);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationNavigationEvents_Value = @import("../../zig.zig").Guid.initString("c22615d2-d318-4da2-8422-1fcaf77b10e4");
pub const IID_IWebApplicationNavigationEvents = &IID_IWebApplicationNavigationEvents_Value;
pub const IWebApplicationNavigationEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BeforeNavigate: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: ?*IHTMLWindow2,
            url: ?[*:0]const u16,
            navigationFlags: u32,
            targetFrameName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateComplete: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: ?*IHTMLWindow2,
            url: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NavigateError: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: ?*IHTMLWindow2,
            url: ?[*:0]const u16,
            targetFrameName: ?[*:0]const u16,
            statusCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DocumentComplete: fn(
            self: *const IWebApplicationNavigationEvents,
            htmlWindow: ?*IHTMLWindow2,
            url: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DownloadBegin: fn(
            self: *const IWebApplicationNavigationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DownloadComplete: fn(
            self: *const IWebApplicationNavigationEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_BeforeNavigate(self: *const T, htmlWindow: ?*IHTMLWindow2, url: ?[*:0]const u16, navigationFlags: u32, targetFrameName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).BeforeNavigate(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url, navigationFlags, targetFrameName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_NavigateComplete(self: *const T, htmlWindow: ?*IHTMLWindow2, url: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).NavigateComplete(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_NavigateError(self: *const T, htmlWindow: ?*IHTMLWindow2, url: ?[*:0]const u16, targetFrameName: ?[*:0]const u16, statusCode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).NavigateError(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url, targetFrameName, statusCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DocumentComplete(self: *const T, htmlWindow: ?*IHTMLWindow2, url: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DocumentComplete(@ptrCast(*const IWebApplicationNavigationEvents, self), htmlWindow, url);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DownloadBegin(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DownloadBegin(@ptrCast(*const IWebApplicationNavigationEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationNavigationEvents_DownloadComplete(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationNavigationEvents.VTable, self.vtable).DownloadComplete(@ptrCast(*const IWebApplicationNavigationEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationUIEvents_Value = @import("../../zig.zig").Guid.initString("5b2b3f99-328c-41d5-a6f7-7483ed8e71dd");
pub const IID_IWebApplicationUIEvents = &IID_IWebApplicationUIEvents_Value;
pub const IWebApplicationUIEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        SecurityProblem: fn(
            self: *const IWebApplicationUIEvents,
            securityProblem: u32,
            result: ?*HRESULT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUIEvents_SecurityProblem(self: *const T, securityProblem: u32, result: ?*HRESULT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUIEvents.VTable, self.vtable).SecurityProblem(@ptrCast(*const IWebApplicationUIEvents, self), securityProblem, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationUpdateEvents_Value = @import("../../zig.zig").Guid.initString("3e59e6b7-c652-4daf-ad5e-16feb350cde3");
pub const IID_IWebApplicationUpdateEvents = &IID_IWebApplicationUpdateEvents_Value;
pub const IWebApplicationUpdateEvents = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        OnPaint: fn(
            self: *const IWebApplicationUpdateEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OnCssChanged: fn(
            self: *const IWebApplicationUpdateEvents,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUpdateEvents_OnPaint(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUpdateEvents.VTable, self.vtable).OnPaint(@ptrCast(*const IWebApplicationUpdateEvents, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationUpdateEvents_OnCssChanged(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationUpdateEvents.VTable, self.vtable).OnCssChanged(@ptrCast(*const IWebApplicationUpdateEvents, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationHost_Value = @import("../../zig.zig").Guid.initString("cecbd2c3-a3a5-4749-9681-20e9161c6794");
pub const IID_IWebApplicationHost = &IID_IWebApplicationHost_Value;
pub const IWebApplicationHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_HWND: fn(
            self: *const IWebApplicationHost,
            hwnd: ?*?HWND,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_Document: fn(
            self: *const IWebApplicationHost,
            htmlDocument: ?*?*IHTMLDocument2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Refresh: fn(
            self: *const IWebApplicationHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Advise: fn(
            self: *const IWebApplicationHost,
            interfaceId: ?*const Guid,
            callback: ?*IUnknown,
            cookie: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unadvise: fn(
            self: *const IWebApplicationHost,
            cookie: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_get_HWND(self: *const T, hwnd: ?*?HWND) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).get_HWND(@ptrCast(*const IWebApplicationHost, self), hwnd);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_get_Document(self: *const T, htmlDocument: ?*?*IHTMLDocument2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).get_Document(@ptrCast(*const IWebApplicationHost, self), htmlDocument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Refresh(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Refresh(@ptrCast(*const IWebApplicationHost, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Advise(self: *const T, interfaceId: ?*const Guid, callback: ?*IUnknown, cookie: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Advise(@ptrCast(*const IWebApplicationHost, self), interfaceId, callback, cookie);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationHost_Unadvise(self: *const T, cookie: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationHost.VTable, self.vtable).Unadvise(@ptrCast(*const IWebApplicationHost, self), cookie);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationActivation_Value = @import("../../zig.zig").Guid.initString("bcdcd0de-330e-481b-b843-4898a6a8ebac");
pub const IID_IWebApplicationActivation = &IID_IWebApplicationActivation_Value;
pub const IWebApplicationActivation = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CancelPendingActivation: fn(
            self: *const IWebApplicationActivation,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationActivation_CancelPendingActivation(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationActivation.VTable, self.vtable).CancelPendingActivation(@ptrCast(*const IWebApplicationActivation, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

// TODO: this type is limited to platform 'windows8.0'
const IID_IWebApplicationAuthoringMode_Value = @import("../../zig.zig").Guid.initString("720aea93-1964-4db0-b005-29eb9e2b18a9");
pub const IID_IWebApplicationAuthoringMode = &IID_IWebApplicationAuthoringMode_Value;
pub const IWebApplicationAuthoringMode = extern struct {
    pub const VTable = extern struct {
        base: IServiceProvider.VTable,
        // TODO: this function has a "SpecialName", should Zig do anything with this?
        get_AuthoringClientBinary: fn(
            self: *const IWebApplicationAuthoringMode,
            designModeDllPath: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IServiceProvider.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IWebApplicationAuthoringMode_get_AuthoringClientBinary(self: *const T, designModeDllPath: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IWebApplicationAuthoringMode.VTable, self.vtable).get_AuthoringClientBinary(@ptrCast(*const IWebApplicationAuthoringMode, self), designModeDllPath);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RegisterAuthoringClientFunctionType = fn(
    authoringModeObject: ?*IWebApplicationAuthoringMode,
    host: ?*IWebApplicationHost,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const UnregisterAuthoringClientFunctionType = fn(
    host: ?*IWebApplicationHost,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PFIND_DEBUG_FILE_CALLBACK = fn(
    FileHandle: ?HANDLE,
    FileName: ?[*:0]const u8,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFIND_DEBUG_FILE_CALLBACKW = fn(
    FileHandle: ?HANDLE,
    FileName: ?[*:0]const u16,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFINDFILEINPATHCALLBACK = fn(
    filename: ?[*:0]const u8,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFINDFILEINPATHCALLBACKW = fn(
    filename: ?[*:0]const u16,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFIND_EXE_FILE_CALLBACK = fn(
    FileHandle: ?HANDLE,
    FileName: ?[*:0]const u8,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFIND_EXE_FILE_CALLBACKW = fn(
    FileHandle: ?HANDLE,
    FileName: ?[*:0]const u16,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PENUMDIRTREE_CALLBACK = fn(
    FilePath: ?[*:0]const u8,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PENUMDIRTREE_CALLBACKW = fn(
    FilePath: ?[*:0]const u16,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const MODLOAD_DATA = extern struct {
    ssize: u32,
    ssig: MODLOAD_DATA_TYPE,
    data: ?*c_void,
    size: u32,
    flags: u32,
};

pub const MODLOAD_CVMISC = extern struct {
    oCV: u32,
    cCV: usize,
    oMisc: u32,
    cMisc: usize,
    dtImage: u32,
    cImage: u32,
};

pub const MODLOAD_PDBGUID_PDBAGE = extern struct {
    PdbGuid: Guid,
    PdbAge: u32,
};

pub const ADDRESS_MODE = enum(i32) {
    @"1616" = 0,
    @"1632" = 1,
    Real = 2,
    Flat = 3,
};
pub const AddrMode1616 = ADDRESS_MODE.@"1616";
pub const AddrMode1632 = ADDRESS_MODE.@"1632";
pub const AddrModeReal = ADDRESS_MODE.Real;
pub const AddrModeFlat = ADDRESS_MODE.Flat;

pub const ADDRESS64 = extern struct {
    Offset: u64,
    Segment: u16,
    Mode: ADDRESS_MODE,
};

pub const KDHELP64 = extern struct {
    Thread: u64,
    ThCallbackStack: u32,
    ThCallbackBStore: u32,
    NextCallback: u32,
    FramePointer: u32,
    KiCallUserMode: u64,
    KeUserCallbackDispatcher: u64,
    SystemRangeStart: u64,
    KiUserExceptionDispatcher: u64,
    StackBase: u64,
    StackLimit: u64,
    BuildVersion: u32,
    RetpolineStubFunctionTableSize: u32,
    RetpolineStubFunctionTable: u64,
    RetpolineStubOffset: u32,
    RetpolineStubSize: u32,
    Reserved0: [2]u64,
};

pub const STACKFRAME64 = extern struct {
    AddrPC: ADDRESS64,
    AddrReturn: ADDRESS64,
    AddrFrame: ADDRESS64,
    AddrStack: ADDRESS64,
    AddrBStore: ADDRESS64,
    FuncTableEntry: ?*c_void,
    Params: [4]u64,
    Far: BOOL,
    Virtual: BOOL,
    Reserved: [3]u64,
    KdHelp: KDHELP64,
};

pub const STACKFRAME_EX = extern struct {
    AddrPC: ADDRESS64,
    AddrReturn: ADDRESS64,
    AddrFrame: ADDRESS64,
    AddrStack: ADDRESS64,
    AddrBStore: ADDRESS64,
    FuncTableEntry: ?*c_void,
    Params: [4]u64,
    Far: BOOL,
    Virtual: BOOL,
    Reserved: [3]u64,
    KdHelp: KDHELP64,
    StackFrameSize: u32,
    InlineFrameContext: u32,
};

pub const PREAD_PROCESS_MEMORY_ROUTINE64 = fn(
    hProcess: ?HANDLE,
    qwBaseAddress: u64,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*c_void,
    nSize: u32,
    lpNumberOfBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PFUNCTION_TABLE_ACCESS_ROUTINE64 = fn(
    ahProcess: ?HANDLE,
    AddrBase: u64,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PGET_MODULE_BASE_ROUTINE64 = fn(
    hProcess: ?HANDLE,
    Address: u64,
) callconv(@import("std").os.windows.WINAPI) u64;

pub const PTRANSLATE_ADDRESS_ROUTINE64 = fn(
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    lpaddr: ?*ADDRESS64,
) callconv(@import("std").os.windows.WINAPI) u64;

pub const API_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    Revision: u16,
    Reserved: u16,
};

pub const PSYM_ENUMMODULES_CALLBACK64 = fn(
    ModuleName: ?[*:0]const u8,
    BaseOfDll: u64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYM_ENUMMODULES_CALLBACKW64 = fn(
    ModuleName: ?[*:0]const u16,
    BaseOfDll: u64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PENUMLOADED_MODULES_CALLBACK64 = fn(
    ModuleName: ?[*:0]const u8,
    ModuleBase: u64,
    ModuleSize: u32,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PENUMLOADED_MODULES_CALLBACKW64 = fn(
    ModuleName: ?[*:0]const u16,
    ModuleBase: u64,
    ModuleSize: u32,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYM_ENUMSYMBOLS_CALLBACK64 = fn(
    SymbolName: ?[*:0]const u8,
    SymbolAddress: u64,
    SymbolSize: u32,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYM_ENUMSYMBOLS_CALLBACK64W = fn(
    SymbolName: ?[*:0]const u16,
    SymbolAddress: u64,
    SymbolSize: u32,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOL_REGISTERED_CALLBACK64 = fn(
    hProcess: ?HANDLE,
    ActionCode: u32,
    CallbackData: u64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOL_FUNCENTRY_CALLBACK = fn(
    hProcess: ?HANDLE,
    AddrBase: u32,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const PSYMBOL_FUNCENTRY_CALLBACK64 = fn(
    hProcess: ?HANDLE,
    AddrBase: u64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub const SYM_TYPE = enum(i32) {
    SymNone = 0,
    SymCoff = 1,
    SymCv = 2,
    SymPdb = 3,
    SymExport = 4,
    SymDeferred = 5,
    SymSym = 6,
    SymDia = 7,
    SymVirtual = 8,
    NumSymTypes = 9,
};
pub const SymNone = SYM_TYPE.SymNone;
pub const SymCoff = SYM_TYPE.SymCoff;
pub const SymCv = SYM_TYPE.SymCv;
pub const SymPdb = SYM_TYPE.SymPdb;
pub const SymExport = SYM_TYPE.SymExport;
pub const SymDeferred = SYM_TYPE.SymDeferred;
pub const SymSym = SYM_TYPE.SymSym;
pub const SymDia = SYM_TYPE.SymDia;
pub const SymVirtual = SYM_TYPE.SymVirtual;
pub const NumSymTypes = SYM_TYPE.NumSymTypes;

pub const IMAGEHLP_SYMBOL64 = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    Size: u32,
    Flags: u32,
    MaxNameLength: u32,
    Name: [1]CHAR,
};

pub const IMAGEHLP_SYMBOL64_PACKAGE = extern struct {
    sym: IMAGEHLP_SYMBOL64,
    name: [2001]CHAR,
};

pub const IMAGEHLP_SYMBOLW64 = extern struct {
    SizeOfStruct: u32,
    Address: u64,
    Size: u32,
    Flags: u32,
    MaxNameLength: u32,
    Name: [1]u16,
};

pub const IMAGEHLP_SYMBOLW64_PACKAGE = extern struct {
    sym: IMAGEHLP_SYMBOLW64,
    name: [2001]u16,
};

pub const IMAGEHLP_MODULE64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    ImageSize: u32,
    TimeDateStamp: u32,
    CheckSum: u32,
    NumSyms: u32,
    SymType: SYM_TYPE,
    ModuleName: [32]CHAR,
    ImageName: [256]CHAR,
    LoadedImageName: [256]CHAR,
    LoadedPdbName: [256]CHAR,
    CVSig: u32,
    CVData: [780]CHAR,
    PdbSig: u32,
    PdbSig70: Guid,
    PdbAge: u32,
    PdbUnmatched: BOOL,
    DbgUnmatched: BOOL,
    LineNumbers: BOOL,
    GlobalSymbols: BOOL,
    TypeInfo: BOOL,
    SourceIndexed: BOOL,
    Publics: BOOL,
    MachineType: u32,
    Reserved: u32,
};

pub const IMAGEHLP_MODULEW64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    ImageSize: u32,
    TimeDateStamp: u32,
    CheckSum: u32,
    NumSyms: u32,
    SymType: SYM_TYPE,
    ModuleName: [32]u16,
    ImageName: [256]u16,
    LoadedImageName: [256]u16,
    LoadedPdbName: [256]u16,
    CVSig: u32,
    CVData: [780]u16,
    PdbSig: u32,
    PdbSig70: Guid,
    PdbAge: u32,
    PdbUnmatched: BOOL,
    DbgUnmatched: BOOL,
    LineNumbers: BOOL,
    GlobalSymbols: BOOL,
    TypeInfo: BOOL,
    SourceIndexed: BOOL,
    Publics: BOOL,
    MachineType: u32,
    Reserved: u32,
};

pub const IMAGEHLP_LINE64 = extern struct {
    SizeOfStruct: u32,
    Key: ?*c_void,
    LineNumber: u32,
    FileName: ?[*]u8,
    Address: u64,
};

pub const IMAGEHLP_LINEW64 = extern struct {
    SizeOfStruct: u32,
    Key: ?*c_void,
    LineNumber: u32,
    FileName: ?PWSTR,
    Address: u64,
};

pub const SOURCEFILE = extern struct {
    ModBase: u64,
    FileName: ?[*]u8,
};

pub const SOURCEFILEW = extern struct {
    ModBase: u64,
    FileName: ?PWSTR,
};

pub const IMAGEHLP_CBA_READ_MEMORY = extern struct {
    addr: u64,
    buf: ?*c_void,
    bytes: u32,
    bytesread: ?*u32,
};

pub const IMAGEHLP_CBA_EVENT = extern struct {
    severity: IMAGEHLP_CBA_EVENT_SEVERITY,
    code: u32,
    desc: ?[*]u8,
    object: ?*c_void,
};

pub const IMAGEHLP_CBA_EVENTW = extern struct {
    severity: IMAGEHLP_CBA_EVENT_SEVERITY,
    code: u32,
    desc: ?[*:0]const u16,
    object: ?*c_void,
};

pub const IMAGEHLP_DEFERRED_SYMBOL_LOAD64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    CheckSum: u32,
    TimeDateStamp: u32,
    FileName: [260]CHAR,
    Reparse: BOOLEAN,
    hFile: ?HANDLE,
    Flags: u32,
};

pub const IMAGEHLP_DEFERRED_SYMBOL_LOADW64 = extern struct {
    SizeOfStruct: u32,
    BaseOfImage: u64,
    CheckSum: u32,
    TimeDateStamp: u32,
    FileName: [261]u16,
    Reparse: BOOLEAN,
    hFile: ?HANDLE,
    Flags: u32,
};

pub const IMAGEHLP_DUPLICATE_SYMBOL64 = extern struct {
    SizeOfStruct: u32,
    NumberOfDups: u32,
    Symbol: ?*IMAGEHLP_SYMBOL64,
    SelectedSymbol: u32,
};

pub const IMAGEHLP_HD_TYPE = enum(i32) {
    Base = 0,
    Sym = 1,
    Src = 2,
    Max = 3,
};
pub const hdBase = IMAGEHLP_HD_TYPE.Base;
pub const hdSym = IMAGEHLP_HD_TYPE.Sym;
pub const hdSrc = IMAGEHLP_HD_TYPE.Src;
pub const hdMax = IMAGEHLP_HD_TYPE.Max;

pub const OMAP = extern struct {
    rva: u32,
    rvaTo: u32,
};

pub const IMAGEHLP_EXTENDED_OPTIONS = enum(i32) {
    DISABLEACCESSTIMEUPDATE = 0,
    LASTVALIDDEBUGDIRECTORY = 1,
    MAX = 2,
};
pub const SYMOPT_EX_DISABLEACCESSTIMEUPDATE = IMAGEHLP_EXTENDED_OPTIONS.DISABLEACCESSTIMEUPDATE;
pub const SYMOPT_EX_LASTVALIDDEBUGDIRECTORY = IMAGEHLP_EXTENDED_OPTIONS.LASTVALIDDEBUGDIRECTORY;
pub const SYMOPT_EX_MAX = IMAGEHLP_EXTENDED_OPTIONS.MAX;

pub const PSYM_ENUMSOURCEFILES_CALLBACK = fn(
    pSourceFile: ?*SOURCEFILE,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYM_ENUMSOURCEFILES_CALLBACKW = fn(
    pSourceFile: ?*SOURCEFILEW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SRCCODEINFO = extern struct {
    SizeOfStruct: u32,
    Key: ?*c_void,
    ModBase: u64,
    Obj: [261]CHAR,
    FileName: [261]CHAR,
    LineNumber: u32,
    Address: u64,
};

pub const SRCCODEINFOW = extern struct {
    SizeOfStruct: u32,
    Key: ?*c_void,
    ModBase: u64,
    Obj: [261]u16,
    FileName: [261]u16,
    LineNumber: u32,
    Address: u64,
};

pub const PSYM_ENUMLINES_CALLBACK = fn(
    LineInfo: ?*SRCCODEINFO,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYM_ENUMLINES_CALLBACKW = fn(
    LineInfo: ?*SRCCODEINFOW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PENUMSOURCEFILETOKENSCALLBACK = fn(
    token: ?*c_void,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const IMAGEHLP_SYMBOL_SRC = extern struct {
    sizeofstruct: u32,
    type: u32,
    file: [260]CHAR,
};

pub const MODULE_TYPE_INFO = extern struct {
    dataLength: u16,
    leaf: u16,
    data: [1]u8,
};

pub const SYMBOL_INFO = extern struct {
    SizeOfStruct: u32,
    TypeIndex: u32,
    Reserved: [2]u64,
    Index: u32,
    Size: u32,
    ModBase: u64,
    Flags: SYMBOL_INFO_FLAGS,
    Value: u64,
    Address: u64,
    Register: u32,
    Scope: u32,
    Tag: u32,
    NameLen: u32,
    MaxNameLen: u32,
    Name: [1]CHAR,
};

pub const SYMBOL_INFO_PACKAGE = extern struct {
    si: SYMBOL_INFO,
    name: [2001]CHAR,
};

pub const SYMBOL_INFOW = extern struct {
    SizeOfStruct: u32,
    TypeIndex: u32,
    Reserved: [2]u64,
    Index: u32,
    Size: u32,
    ModBase: u64,
    Flags: SYMBOL_INFO_FLAGS,
    Value: u64,
    Address: u64,
    Register: u32,
    Scope: u32,
    Tag: u32,
    NameLen: u32,
    MaxNameLen: u32,
    Name: [1]u16,
};

pub const SYMBOL_INFO_PACKAGEW = extern struct {
    si: SYMBOL_INFOW,
    name: [2001]u16,
};

pub const IMAGEHLP_STACK_FRAME = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    BackingStoreOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [5]u64,
    Virtual: BOOL,
    Reserved2: u32,
};

pub const PSYM_ENUMPROCESSES_CALLBACK = fn(
    hProcess: ?HANDLE,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYM_ENUMERATESYMBOLS_CALLBACK = fn(
    pSymInfo: ?*SYMBOL_INFO,
    SymbolSize: u32,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYM_ENUMERATESYMBOLS_CALLBACKW = fn(
    pSymInfo: ?*SYMBOL_INFOW,
    SymbolSize: u32,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const IMAGEHLP_SYMBOL_TYPE_INFO = enum(i32) {
    TI_GET_SYMTAG = 0,
    TI_GET_SYMNAME = 1,
    TI_GET_LENGTH = 2,
    TI_GET_TYPE = 3,
    TI_GET_TYPEID = 4,
    TI_GET_BASETYPE = 5,
    TI_GET_ARRAYINDEXTYPEID = 6,
    TI_FINDCHILDREN = 7,
    TI_GET_DATAKIND = 8,
    TI_GET_ADDRESSOFFSET = 9,
    TI_GET_OFFSET = 10,
    TI_GET_VALUE = 11,
    TI_GET_COUNT = 12,
    TI_GET_CHILDRENCOUNT = 13,
    TI_GET_BITPOSITION = 14,
    TI_GET_VIRTUALBASECLASS = 15,
    TI_GET_VIRTUALTABLESHAPEID = 16,
    TI_GET_VIRTUALBASEPOINTEROFFSET = 17,
    TI_GET_CLASSPARENTID = 18,
    TI_GET_NESTED = 19,
    TI_GET_SYMINDEX = 20,
    TI_GET_LEXICALPARENT = 21,
    TI_GET_ADDRESS = 22,
    TI_GET_THISADJUST = 23,
    TI_GET_UDTKIND = 24,
    TI_IS_EQUIV_TO = 25,
    TI_GET_CALLING_CONVENTION = 26,
    TI_IS_CLOSE_EQUIV_TO = 27,
    TI_GTIEX_REQS_VALID = 28,
    TI_GET_VIRTUALBASEOFFSET = 29,
    TI_GET_VIRTUALBASEDISPINDEX = 30,
    TI_GET_IS_REFERENCE = 31,
    TI_GET_INDIRECTVIRTUALBASECLASS = 32,
    TI_GET_VIRTUALBASETABLETYPE = 33,
    IMAGEHLP_SYMBOL_TYPE_INFO_MAX = 34,
};
pub const TI_GET_SYMTAG = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMTAG;
pub const TI_GET_SYMNAME = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMNAME;
pub const TI_GET_LENGTH = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_LENGTH;
pub const TI_GET_TYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_TYPE;
pub const TI_GET_TYPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_TYPEID;
pub const TI_GET_BASETYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_BASETYPE;
pub const TI_GET_ARRAYINDEXTYPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ARRAYINDEXTYPEID;
pub const TI_FINDCHILDREN = IMAGEHLP_SYMBOL_TYPE_INFO.TI_FINDCHILDREN;
pub const TI_GET_DATAKIND = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_DATAKIND;
pub const TI_GET_ADDRESSOFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ADDRESSOFFSET;
pub const TI_GET_OFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_OFFSET;
pub const TI_GET_VALUE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VALUE;
pub const TI_GET_COUNT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_COUNT;
pub const TI_GET_CHILDRENCOUNT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CHILDRENCOUNT;
pub const TI_GET_BITPOSITION = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_BITPOSITION;
pub const TI_GET_VIRTUALBASECLASS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASECLASS;
pub const TI_GET_VIRTUALTABLESHAPEID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALTABLESHAPEID;
pub const TI_GET_VIRTUALBASEPOINTEROFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEPOINTEROFFSET;
pub const TI_GET_CLASSPARENTID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CLASSPARENTID;
pub const TI_GET_NESTED = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_NESTED;
pub const TI_GET_SYMINDEX = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_SYMINDEX;
pub const TI_GET_LEXICALPARENT = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_LEXICALPARENT;
pub const TI_GET_ADDRESS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_ADDRESS;
pub const TI_GET_THISADJUST = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_THISADJUST;
pub const TI_GET_UDTKIND = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_UDTKIND;
pub const TI_IS_EQUIV_TO = IMAGEHLP_SYMBOL_TYPE_INFO.TI_IS_EQUIV_TO;
pub const TI_GET_CALLING_CONVENTION = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_CALLING_CONVENTION;
pub const TI_IS_CLOSE_EQUIV_TO = IMAGEHLP_SYMBOL_TYPE_INFO.TI_IS_CLOSE_EQUIV_TO;
pub const TI_GTIEX_REQS_VALID = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GTIEX_REQS_VALID;
pub const TI_GET_VIRTUALBASEOFFSET = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEOFFSET;
pub const TI_GET_VIRTUALBASEDISPINDEX = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASEDISPINDEX;
pub const TI_GET_IS_REFERENCE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_IS_REFERENCE;
pub const TI_GET_INDIRECTVIRTUALBASECLASS = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_INDIRECTVIRTUALBASECLASS;
pub const TI_GET_VIRTUALBASETABLETYPE = IMAGEHLP_SYMBOL_TYPE_INFO.TI_GET_VIRTUALBASETABLETYPE;
pub const IMAGEHLP_SYMBOL_TYPE_INFO_MAX = IMAGEHLP_SYMBOL_TYPE_INFO.IMAGEHLP_SYMBOL_TYPE_INFO_MAX;

pub const TI_FINDCHILDREN_PARAMS = extern struct {
    Count: u32,
    Start: u32,
    ChildId: [1]u32,
};

pub const IMAGEHLP_GET_TYPE_INFO_PARAMS = extern struct {
    SizeOfStruct: u32,
    Flags: IMAGEHLP_GET_TYPE_INFO_FLAGS,
    NumIds: u32,
    TypeIds: ?*u32,
    TagFilter: u64,
    NumReqs: u32,
    ReqKinds: ?*IMAGEHLP_SYMBOL_TYPE_INFO,
    ReqOffsets: ?*usize,
    ReqSizes: ?*u32,
    ReqStride: usize,
    BufferSize: usize,
    Buffer: ?*c_void,
    EntriesMatched: u32,
    EntriesFilled: u32,
    TagsFound: u64,
    AllReqsValid: u64,
    NumReqsValid: u32,
    ReqsValid: ?*u64,
};

pub const SYMADDSOURCESTREAM = fn(
    param0: ?HANDLE,
    param1: u64,
    param2: ?[*:0]const u8,
    param3: ?*u8,
    param4: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SYMADDSOURCESTREAMA = fn(
    param0: ?HANDLE,
    param1: u64,
    param2: ?[*:0]const u8,
    param3: ?*u8,
    param4: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SYMSRV_INDEX_INFO = extern struct {
    sizeofstruct: u32,
    file: [261]CHAR,
    stripped: BOOL,
    timestamp: u32,
    size: u32,
    dbgfile: [261]CHAR,
    pdbfile: [261]CHAR,
    guid: Guid,
    sig: u32,
    age: u32,
};

pub const SYMSRV_INDEX_INFOW = extern struct {
    sizeofstruct: u32,
    file: [261]u16,
    stripped: BOOL,
    timestamp: u32,
    size: u32,
    dbgfile: [261]u16,
    pdbfile: [261]u16,
    guid: Guid,
    sig: u32,
    age: u32,
};

pub const IMAGEHLP_SF_TYPE = enum(i32) {
    Image = 0,
    Dbg = 1,
    Pdb = 2,
    Mpd = 3,
    Max = 4,
};
pub const sfImage = IMAGEHLP_SF_TYPE.Image;
pub const sfDbg = IMAGEHLP_SF_TYPE.Dbg;
pub const sfPdb = IMAGEHLP_SF_TYPE.Pdb;
pub const sfMpd = IMAGEHLP_SF_TYPE.Mpd;
pub const sfMax = IMAGEHLP_SF_TYPE.Max;

pub const PDBGHELP_CREATE_USER_DUMP_CALLBACK = fn(
    DataType: u32,
    Data: ?*?*c_void,
    DataLength: ?*u32,
    UserData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const SYMSRV_EXTENDED_OUTPUT_DATA = extern struct {
    sizeOfStruct: u32,
    version: u32,
    filePtrMsg: [261]u16,
};

pub const PSYMBOLSERVERPROC = fn(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?*c_void,
    param3: u32,
    param4: u32,
    param5: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERPROCA = fn(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?*c_void,
    param3: u32,
    param4: u32,
    param5: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERPROCW = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?*c_void,
    param3: u32,
    param4: u32,
    param5: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERBYINDEXPROC = fn(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERBYINDEXPROCA = fn(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERBYINDEXPROCW = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVEROPENPROC = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERCLOSEPROC = fn(
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERSETOPTIONSPROC = fn(
    param0: usize,
    param1: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERSETOPTIONSWPROC = fn(
    param0: usize,
    param1: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERCALLBACKPROC = fn(
    action: usize,
    data: u64,
    context: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERGETOPTIONSPROC = fn(
) callconv(@import("std").os.windows.WINAPI) usize;

pub const PSYMBOLSERVERPINGPROC = fn(
    param0: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERPINGPROCA = fn(
    param0: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERPINGPROCW = fn(
    param0: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERGETVERSION = fn(
    param0: ?*API_VERSION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERDELTANAME = fn(
    param0: ?[*:0]const u8,
    param1: ?*c_void,
    param2: u32,
    param3: u32,
    param4: ?*c_void,
    param5: u32,
    param6: u32,
    param7: ?PSTR,
    param8: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERDELTANAMEW = fn(
    param0: ?[*:0]const u16,
    param1: ?*c_void,
    param2: u32,
    param3: u32,
    param4: ?*c_void,
    param5: u32,
    param6: u32,
    param7: ?PWSTR,
    param8: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERGETSUPPLEMENT = fn(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: ?PSTR,
    param4: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERGETSUPPLEMENTW = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: ?PWSTR,
    param4: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERSTORESUPPLEMENT = fn(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?[*:0]const u8,
    param3: ?PSTR,
    param4: usize,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERSTORESUPPLEMENTW = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?[*:0]const u16,
    param3: ?PWSTR,
    param4: usize,
    param5: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERGETINDEXSTRING = fn(
    param0: ?*c_void,
    param1: u32,
    param2: u32,
    param3: ?PSTR,
    param4: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERGETINDEXSTRINGW = fn(
    param0: ?*c_void,
    param1: u32,
    param2: u32,
    param3: ?PWSTR,
    param4: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERSTOREFILE = fn(
    param0: ?[*:0]const u8,
    param1: ?[*:0]const u8,
    param2: ?*c_void,
    param3: u32,
    param4: u32,
    param5: ?PSTR,
    param6: usize,
    param7: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERSTOREFILEW = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?*c_void,
    param3: u32,
    param4: u32,
    param5: ?PWSTR,
    param6: usize,
    param7: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERISSTORE = fn(
    param0: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERISSTOREW = fn(
    param0: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERVERSION = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PSYMBOLSERVERMESSAGEPROC = fn(
    action: usize,
    data: u64,
    context: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERWEXPROC = fn(
    param0: ?[*:0]const u16,
    param1: ?[*:0]const u16,
    param2: ?*c_void,
    param3: u32,
    param4: u32,
    param5: ?PWSTR,
    param6: ?*SYMSRV_EXTENDED_OUTPUT_DATA,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERPINGPROCWEX = fn(
    param0: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERGETOPTIONDATAPROC = fn(
    param0: usize,
    param1: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const PSYMBOLSERVERSETHTTPAUTHHEADER = fn(
    pszAuthHeader: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub const LPCALL_BACK_USER_INTERRUPT_ROUTINE = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const DBGHELP_DATA_REPORT_STRUCT = extern struct {
    pBinPathNonExist: ?[*:0]const u16,
    pSymbolPathNonExist: ?[*:0]const u16,
};

pub const DEBUG_OFFSET_REGION = extern struct {
    Base: u64,
    Size: u64,
};

const IID_IDebugAdvanced_Value = @import("../../zig.zig").Guid.initString("f2df5f53-071f-47bd-9de6-5734c3fed689");
pub const IID_IDebugAdvanced = &IID_IDebugAdvanced_Value;
pub const IDebugAdvanced = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: fn(
            self: *const IDebugAdvanced,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetThreadContext: fn(
            self: *const IDebugAdvanced,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced_GetThreadContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced.VTable, self.vtable).GetThreadContext(@ptrCast(*const IDebugAdvanced, self), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced_SetThreadContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced.VTable, self.vtable).SetThreadContext(@ptrCast(*const IDebugAdvanced, self), Context, ContextSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_READ_USER_MINIDUMP_STREAM = extern struct {
    StreamType: u32,
    Flags: u32,
    Offset: u64,
    Buffer: ?*c_void,
    BufferSize: u32,
    BufferUsed: u32,
};

pub const DEBUG_GET_TEXT_COMPLETIONS_IN = extern struct {
    Flags: u32,
    MatchCountLimit: u32,
    Reserved: [3]u64,
};

pub const DEBUG_GET_TEXT_COMPLETIONS_OUT = extern struct {
    Flags: u32,
    ReplaceIndex: u32,
    MatchCount: u32,
    Reserved1: u32,
    Reserved2: [2]u64,
};

pub const DEBUG_CACHED_SYMBOL_INFO = extern struct {
    ModBase: u64,
    Arg1: u64,
    Arg2: u64,
    Id: u32,
    Arg3: u32,
};

pub const PROCESS_NAME_ENTRY = extern struct {
    ProcessId: u32,
    NameOffset: u32,
    NameSize: u32,
    NextEntry: u32,
};

pub const DEBUG_THREAD_BASIC_INFORMATION = extern struct {
    Valid: u32,
    ExitStatus: u32,
    PriorityClass: u32,
    Priority: u32,
    CreateTime: u64,
    ExitTime: u64,
    KernelTime: u64,
    UserTime: u64,
    StartOffset: u64,
    Affinity: u64,
};

const IID_IDebugAdvanced2_Value = @import("../../zig.zig").Guid.initString("716d14c9-119b-4ba5-af1f-0890e672416a");
pub const IID_IDebugAdvanced2 = &IID_IDebugAdvanced2_Value;
pub const IDebugAdvanced2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: fn(
            self: *const IDebugAdvanced2,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetThreadContext: fn(
            self: *const IDebugAdvanced2,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Request: fn(
            self: *const IDebugAdvanced2,
            Request: u32,
            // TODO: what to do with BytesParamIndex 2?
            InBuffer: ?*c_void,
            InBufferSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            OutBuffer: ?*c_void,
            OutBufferSize: u32,
            OutSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileInformation: fn(
            self: *const IDebugAdvanced2,
            Which: u32,
            SourceFile: ?PSTR,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFileAndToken: fn(
            self: *const IDebugAdvanced2,
            StartElement: u32,
            ModAddr: u64,
            File: ?[*:0]const u8,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 5?
            FileToken: ?*c_void,
            FileTokenSize: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolInformation: fn(
            self: *const IDebugAdvanced2,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
            StringBuffer: ?[*:0]u8,
            StringBufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemObjectInformation: fn(
            self: *const IDebugAdvanced2,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_GetThreadContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced2.VTable, self.vtable).GetThreadContext(@ptrCast(*const IDebugAdvanced2, self), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_SetThreadContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced2.VTable, self.vtable).SetThreadContext(@ptrCast(*const IDebugAdvanced2, self), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_Request(self: *const T, Request: u32, InBuffer: ?*c_void, InBufferSize: u32, OutBuffer: ?*c_void, OutBufferSize: u32, OutSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced2.VTable, self.vtable).Request(@ptrCast(*const IDebugAdvanced2, self), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced2.VTable, self.vtable).GetSourceFileInformation(@ptrCast(*const IDebugAdvanced2, self), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u8, Flags: u32, FileToken: ?*c_void, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced2.VTable, self.vtable).FindSourceFileAndToken(@ptrCast(*const IDebugAdvanced2, self), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced2.VTable, self.vtable).GetSymbolInformation(@ptrCast(*const IDebugAdvanced2, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced2_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced2.VTable, self.vtable).GetSystemObjectInformation(@ptrCast(*const IDebugAdvanced2, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugAdvanced3_Value = @import("../../zig.zig").Guid.initString("cba4abb4-84c4-444d-87ca-a04e13286739");
pub const IID_IDebugAdvanced3 = &IID_IDebugAdvanced3_Value;
pub const IDebugAdvanced3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: fn(
            self: *const IDebugAdvanced3,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetThreadContext: fn(
            self: *const IDebugAdvanced3,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Request: fn(
            self: *const IDebugAdvanced3,
            Request: u32,
            // TODO: what to do with BytesParamIndex 2?
            InBuffer: ?*c_void,
            InBufferSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            OutBuffer: ?*c_void,
            OutBufferSize: u32,
            OutSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileInformation: fn(
            self: *const IDebugAdvanced3,
            Which: u32,
            SourceFile: ?PSTR,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFileAndToken: fn(
            self: *const IDebugAdvanced3,
            StartElement: u32,
            ModAddr: u64,
            File: ?[*:0]const u8,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 5?
            FileToken: ?*c_void,
            FileTokenSize: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolInformation: fn(
            self: *const IDebugAdvanced3,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
            StringBuffer: ?[*:0]u8,
            StringBufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemObjectInformation: fn(
            self: *const IDebugAdvanced3,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileInformationWide: fn(
            self: *const IDebugAdvanced3,
            Which: u32,
            SourceFile: ?PWSTR,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFileAndTokenWide: fn(
            self: *const IDebugAdvanced3,
            StartElement: u32,
            ModAddr: u64,
            File: ?[*:0]const u16,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 5?
            FileToken: ?*c_void,
            FileTokenSize: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolInformationWide: fn(
            self: *const IDebugAdvanced3,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
            StringBuffer: ?[*:0]u16,
            StringBufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetThreadContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).GetThreadContext(@ptrCast(*const IDebugAdvanced3, self), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_SetThreadContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).SetThreadContext(@ptrCast(*const IDebugAdvanced3, self), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_Request(self: *const T, Request: u32, InBuffer: ?*c_void, InBufferSize: u32, OutBuffer: ?*c_void, OutBufferSize: u32, OutSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).Request(@ptrCast(*const IDebugAdvanced3, self), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).GetSourceFileInformation(@ptrCast(*const IDebugAdvanced3, self), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u8, Flags: u32, FileToken: ?*c_void, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).FindSourceFileAndToken(@ptrCast(*const IDebugAdvanced3, self), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).GetSymbolInformation(@ptrCast(*const IDebugAdvanced3, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).GetSystemObjectInformation(@ptrCast(*const IDebugAdvanced3, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSourceFileInformationWide(self: *const T, Which: u32, SourceFile: ?PWSTR, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).GetSourceFileInformationWide(@ptrCast(*const IDebugAdvanced3, self), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_FindSourceFileAndTokenWide(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u16, Flags: u32, FileToken: ?*c_void, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).FindSourceFileAndTokenWide(@ptrCast(*const IDebugAdvanced3, self), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced3_GetSymbolInformationWide(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced3.VTable, self.vtable).GetSymbolInformationWide(@ptrCast(*const IDebugAdvanced3, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SYMBOL_INFO_EX = extern struct {
    SizeOfStruct: u32,
    TypeOfInfo: u32,
    Offset: u64,
    Line: u32,
    Displacement: u32,
    Reserved: [4]u32,
};

const IID_IDebugAdvanced4_Value = @import("../../zig.zig").Guid.initString("d1069067-2a65-4bf0-ae97-76184b67856b");
pub const IID_IDebugAdvanced4 = &IID_IDebugAdvanced4_Value;
pub const IDebugAdvanced4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetThreadContext: fn(
            self: *const IDebugAdvanced4,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetThreadContext: fn(
            self: *const IDebugAdvanced4,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Request: fn(
            self: *const IDebugAdvanced4,
            Request: u32,
            // TODO: what to do with BytesParamIndex 2?
            InBuffer: ?*c_void,
            InBufferSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            OutBuffer: ?*c_void,
            OutBufferSize: u32,
            OutSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileInformation: fn(
            self: *const IDebugAdvanced4,
            Which: u32,
            SourceFile: ?PSTR,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFileAndToken: fn(
            self: *const IDebugAdvanced4,
            StartElement: u32,
            ModAddr: u64,
            File: ?[*:0]const u8,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 5?
            FileToken: ?*c_void,
            FileTokenSize: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolInformation: fn(
            self: *const IDebugAdvanced4,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
            StringBuffer: ?[*:0]u8,
            StringBufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemObjectInformation: fn(
            self: *const IDebugAdvanced4,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileInformationWide: fn(
            self: *const IDebugAdvanced4,
            Which: u32,
            SourceFile: ?PWSTR,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFileAndTokenWide: fn(
            self: *const IDebugAdvanced4,
            StartElement: u32,
            ModAddr: u64,
            File: ?[*:0]const u16,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 5?
            FileToken: ?*c_void,
            FileTokenSize: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolInformationWide: fn(
            self: *const IDebugAdvanced4,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
            StringBuffer: ?[*:0]u16,
            StringBufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolInformationWideEx: fn(
            self: *const IDebugAdvanced4,
            Which: u32,
            Arg64: u64,
            Arg32: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
            StringBuffer: ?[*:0]u16,
            StringBufferSize: u32,
            StringSize: ?*u32,
            pInfoEx: ?*SYMBOL_INFO_EX,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetThreadContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).GetThreadContext(@ptrCast(*const IDebugAdvanced4, self), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_SetThreadContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).SetThreadContext(@ptrCast(*const IDebugAdvanced4, self), Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_Request(self: *const T, Request: u32, InBuffer: ?*c_void, InBufferSize: u32, OutBuffer: ?*c_void, OutBufferSize: u32, OutSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).Request(@ptrCast(*const IDebugAdvanced4, self), Request, InBuffer, InBufferSize, OutBuffer, OutBufferSize, OutSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSourceFileInformation(self: *const T, Which: u32, SourceFile: ?PSTR, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).GetSourceFileInformation(@ptrCast(*const IDebugAdvanced4, self), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_FindSourceFileAndToken(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u8, Flags: u32, FileToken: ?*c_void, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).FindSourceFileAndToken(@ptrCast(*const IDebugAdvanced4, self), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSymbolInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u8, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).GetSymbolInformation(@ptrCast(*const IDebugAdvanced4, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSystemObjectInformation(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).GetSystemObjectInformation(@ptrCast(*const IDebugAdvanced4, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSourceFileInformationWide(self: *const T, Which: u32, SourceFile: ?PWSTR, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).GetSourceFileInformationWide(@ptrCast(*const IDebugAdvanced4, self), Which, SourceFile, Arg64, Arg32, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_FindSourceFileAndTokenWide(self: *const T, StartElement: u32, ModAddr: u64, File: ?[*:0]const u16, Flags: u32, FileToken: ?*c_void, FileTokenSize: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).FindSourceFileAndTokenWide(@ptrCast(*const IDebugAdvanced4, self), StartElement, ModAddr, File, Flags, FileToken, FileTokenSize, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSymbolInformationWide(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).GetSymbolInformationWide(@ptrCast(*const IDebugAdvanced4, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugAdvanced4_GetSymbolInformationWideEx(self: *const T, Which: u32, Arg64: u64, Arg32: u32, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32, StringBuffer: ?[*:0]u16, StringBufferSize: u32, StringSize: ?*u32, pInfoEx: ?*SYMBOL_INFO_EX) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugAdvanced4.VTable, self.vtable).GetSymbolInformationWideEx(@ptrCast(*const IDebugAdvanced4, self), Which, Arg64, Arg32, Buffer, BufferSize, InfoSize, StringBuffer, StringBufferSize, StringSize, pInfoEx);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_BREAKPOINT_PARAMETERS = extern struct {
    Offset: u64,
    Id: u32,
    BreakType: u32,
    ProcType: u32,
    Flags: u32,
    DataSize: u32,
    DataAccessType: u32,
    PassCount: u32,
    CurrentPassCount: u32,
    MatchThread: u32,
    CommandSize: u32,
    OffsetExpressionSize: u32,
};

const IID_IDebugBreakpoint_Value = @import("../../zig.zig").Guid.initString("5bd9d474-5975-423a-b88b-65a8e7110e65");
pub const IID_IDebugBreakpoint = &IID_IDebugBreakpoint_Value;
pub const IDebugBreakpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IDebugBreakpoint,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const IDebugBreakpoint,
            BreakType: ?*u32,
            ProcType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdder: fn(
            self: *const IDebugBreakpoint,
            Adder: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IDebugBreakpoint,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFlags: fn(
            self: *const IDebugBreakpoint,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFlags: fn(
            self: *const IDebugBreakpoint,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IDebugBreakpoint,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffset: fn(
            self: *const IDebugBreakpoint,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOffset: fn(
            self: *const IDebugBreakpoint,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataParameters: fn(
            self: *const IDebugBreakpoint,
            Size: ?*u32,
            AccessType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDataParameters: fn(
            self: *const IDebugBreakpoint,
            Size: u32,
            AccessType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassCount: fn(
            self: *const IDebugBreakpoint,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPassCount: fn(
            self: *const IDebugBreakpoint,
            Count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPassCount: fn(
            self: *const IDebugBreakpoint,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMatchThreadId: fn(
            self: *const IDebugBreakpoint,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMatchThreadId: fn(
            self: *const IDebugBreakpoint,
            Thread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCommand: fn(
            self: *const IDebugBreakpoint,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommand: fn(
            self: *const IDebugBreakpoint,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetExpression: fn(
            self: *const IDebugBreakpoint,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ExpressionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOffsetExpression: fn(
            self: *const IDebugBreakpoint,
            Expression: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameters: fn(
            self: *const IDebugBreakpoint,
            Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetId(@ptrCast(*const IDebugBreakpoint, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetType(@ptrCast(*const IDebugBreakpoint, self), BreakType, ProcType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetAdder(self: *const T, Adder: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetAdder(@ptrCast(*const IDebugBreakpoint, self), Adder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetFlags(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetFlags(@ptrCast(*const IDebugBreakpoint, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_AddFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).AddFlags(@ptrCast(*const IDebugBreakpoint, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_RemoveFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).RemoveFlags(@ptrCast(*const IDebugBreakpoint, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).SetFlags(@ptrCast(*const IDebugBreakpoint, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetOffset(@ptrCast(*const IDebugBreakpoint, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).SetOffset(@ptrCast(*const IDebugBreakpoint, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetDataParameters(@ptrCast(*const IDebugBreakpoint, self), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetDataParameters(self: *const T, Size: u32, AccessType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).SetDataParameters(@ptrCast(*const IDebugBreakpoint, self), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetPassCount(@ptrCast(*const IDebugBreakpoint, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetPassCount(self: *const T, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).SetPassCount(@ptrCast(*const IDebugBreakpoint, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetCurrentPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetCurrentPassCount(@ptrCast(*const IDebugBreakpoint, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetMatchThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetMatchThreadId(@ptrCast(*const IDebugBreakpoint, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetMatchThreadId(self: *const T, Thread: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).SetMatchThreadId(@ptrCast(*const IDebugBreakpoint, self), Thread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetCommand(@ptrCast(*const IDebugBreakpoint, self), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetCommand(self: *const T, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).SetCommand(@ptrCast(*const IDebugBreakpoint, self), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetOffsetExpression(@ptrCast(*const IDebugBreakpoint, self), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_SetOffsetExpression(self: *const T, Expression: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).SetOffsetExpression(@ptrCast(*const IDebugBreakpoint, self), Expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint.VTable, self.vtable).GetParameters(@ptrCast(*const IDebugBreakpoint, self), Params);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugBreakpoint2_Value = @import("../../zig.zig").Guid.initString("1b278d20-79f2-426e-a3f9-c1ddf375d48e");
pub const IID_IDebugBreakpoint2 = &IID_IDebugBreakpoint2_Value;
pub const IDebugBreakpoint2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IDebugBreakpoint2,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const IDebugBreakpoint2,
            BreakType: ?*u32,
            ProcType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdder: fn(
            self: *const IDebugBreakpoint2,
            Adder: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IDebugBreakpoint2,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFlags: fn(
            self: *const IDebugBreakpoint2,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFlags: fn(
            self: *const IDebugBreakpoint2,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IDebugBreakpoint2,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffset: fn(
            self: *const IDebugBreakpoint2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOffset: fn(
            self: *const IDebugBreakpoint2,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataParameters: fn(
            self: *const IDebugBreakpoint2,
            Size: ?*u32,
            AccessType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDataParameters: fn(
            self: *const IDebugBreakpoint2,
            Size: u32,
            AccessType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassCount: fn(
            self: *const IDebugBreakpoint2,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPassCount: fn(
            self: *const IDebugBreakpoint2,
            Count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPassCount: fn(
            self: *const IDebugBreakpoint2,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMatchThreadId: fn(
            self: *const IDebugBreakpoint2,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMatchThreadId: fn(
            self: *const IDebugBreakpoint2,
            Thread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCommand: fn(
            self: *const IDebugBreakpoint2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommand: fn(
            self: *const IDebugBreakpoint2,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetExpression: fn(
            self: *const IDebugBreakpoint2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ExpressionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOffsetExpression: fn(
            self: *const IDebugBreakpoint2,
            Expression: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameters: fn(
            self: *const IDebugBreakpoint2,
            Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCommandWide: fn(
            self: *const IDebugBreakpoint2,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommandWide: fn(
            self: *const IDebugBreakpoint2,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetExpressionWide: fn(
            self: *const IDebugBreakpoint2,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ExpressionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOffsetExpressionWide: fn(
            self: *const IDebugBreakpoint2,
            Expression: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetId(@ptrCast(*const IDebugBreakpoint2, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetType(@ptrCast(*const IDebugBreakpoint2, self), BreakType, ProcType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetAdder(self: *const T, Adder: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetAdder(@ptrCast(*const IDebugBreakpoint2, self), Adder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetFlags(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetFlags(@ptrCast(*const IDebugBreakpoint2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_AddFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).AddFlags(@ptrCast(*const IDebugBreakpoint2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_RemoveFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).RemoveFlags(@ptrCast(*const IDebugBreakpoint2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetFlags(@ptrCast(*const IDebugBreakpoint2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetOffset(@ptrCast(*const IDebugBreakpoint2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetOffset(@ptrCast(*const IDebugBreakpoint2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetDataParameters(@ptrCast(*const IDebugBreakpoint2, self), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetDataParameters(self: *const T, Size: u32, AccessType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetDataParameters(@ptrCast(*const IDebugBreakpoint2, self), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetPassCount(@ptrCast(*const IDebugBreakpoint2, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetPassCount(self: *const T, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetPassCount(@ptrCast(*const IDebugBreakpoint2, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetCurrentPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetCurrentPassCount(@ptrCast(*const IDebugBreakpoint2, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetMatchThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetMatchThreadId(@ptrCast(*const IDebugBreakpoint2, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetMatchThreadId(self: *const T, Thread: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetMatchThreadId(@ptrCast(*const IDebugBreakpoint2, self), Thread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetCommand(@ptrCast(*const IDebugBreakpoint2, self), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetCommand(self: *const T, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetCommand(@ptrCast(*const IDebugBreakpoint2, self), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetOffsetExpression(@ptrCast(*const IDebugBreakpoint2, self), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetOffsetExpression(self: *const T, Expression: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetOffsetExpression(@ptrCast(*const IDebugBreakpoint2, self), Expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetParameters(@ptrCast(*const IDebugBreakpoint2, self), Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetCommandWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetCommandWide(@ptrCast(*const IDebugBreakpoint2, self), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetCommandWide(self: *const T, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetCommandWide(@ptrCast(*const IDebugBreakpoint2, self), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_GetOffsetExpressionWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).GetOffsetExpressionWide(@ptrCast(*const IDebugBreakpoint2, self), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint2_SetOffsetExpressionWide(self: *const T, Expression: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint2.VTable, self.vtable).SetOffsetExpressionWide(@ptrCast(*const IDebugBreakpoint2, self), Expression);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugBreakpoint3_Value = @import("../../zig.zig").Guid.initString("38f5c249-b448-43bb-9835-579d4ec02249");
pub const IID_IDebugBreakpoint3 = &IID_IDebugBreakpoint3_Value;
pub const IDebugBreakpoint3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IDebugBreakpoint3,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const IDebugBreakpoint3,
            BreakType: ?*u32,
            ProcType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAdder: fn(
            self: *const IDebugBreakpoint3,
            Adder: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFlags: fn(
            self: *const IDebugBreakpoint3,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddFlags: fn(
            self: *const IDebugBreakpoint3,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveFlags: fn(
            self: *const IDebugBreakpoint3,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetFlags: fn(
            self: *const IDebugBreakpoint3,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffset: fn(
            self: *const IDebugBreakpoint3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOffset: fn(
            self: *const IDebugBreakpoint3,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDataParameters: fn(
            self: *const IDebugBreakpoint3,
            Size: ?*u32,
            AccessType: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetDataParameters: fn(
            self: *const IDebugBreakpoint3,
            Size: u32,
            AccessType: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPassCount: fn(
            self: *const IDebugBreakpoint3,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPassCount: fn(
            self: *const IDebugBreakpoint3,
            Count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentPassCount: fn(
            self: *const IDebugBreakpoint3,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMatchThreadId: fn(
            self: *const IDebugBreakpoint3,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetMatchThreadId: fn(
            self: *const IDebugBreakpoint3,
            Thread: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCommand: fn(
            self: *const IDebugBreakpoint3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommand: fn(
            self: *const IDebugBreakpoint3,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetExpression: fn(
            self: *const IDebugBreakpoint3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ExpressionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOffsetExpression: fn(
            self: *const IDebugBreakpoint3,
            Expression: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParameters: fn(
            self: *const IDebugBreakpoint3,
            Params: ?*DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCommandWide: fn(
            self: *const IDebugBreakpoint3,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCommandWide: fn(
            self: *const IDebugBreakpoint3,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetExpressionWide: fn(
            self: *const IDebugBreakpoint3,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ExpressionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOffsetExpressionWide: fn(
            self: *const IDebugBreakpoint3,
            Expression: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGuid: fn(
            self: *const IDebugBreakpoint3,
            Guid: ?*Guid,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetId(@ptrCast(*const IDebugBreakpoint3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetType(self: *const T, BreakType: ?*u32, ProcType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetType(@ptrCast(*const IDebugBreakpoint3, self), BreakType, ProcType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetAdder(self: *const T, Adder: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetAdder(@ptrCast(*const IDebugBreakpoint3, self), Adder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetFlags(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetFlags(@ptrCast(*const IDebugBreakpoint3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_AddFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).AddFlags(@ptrCast(*const IDebugBreakpoint3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_RemoveFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).RemoveFlags(@ptrCast(*const IDebugBreakpoint3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetFlags(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetFlags(@ptrCast(*const IDebugBreakpoint3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetOffset(@ptrCast(*const IDebugBreakpoint3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetOffset(@ptrCast(*const IDebugBreakpoint3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetDataParameters(self: *const T, Size: ?*u32, AccessType: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetDataParameters(@ptrCast(*const IDebugBreakpoint3, self), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetDataParameters(self: *const T, Size: u32, AccessType: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetDataParameters(@ptrCast(*const IDebugBreakpoint3, self), Size, AccessType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetPassCount(@ptrCast(*const IDebugBreakpoint3, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetPassCount(self: *const T, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetPassCount(@ptrCast(*const IDebugBreakpoint3, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetCurrentPassCount(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetCurrentPassCount(@ptrCast(*const IDebugBreakpoint3, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetMatchThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetMatchThreadId(@ptrCast(*const IDebugBreakpoint3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetMatchThreadId(self: *const T, Thread: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetMatchThreadId(@ptrCast(*const IDebugBreakpoint3, self), Thread);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetCommand(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetCommand(@ptrCast(*const IDebugBreakpoint3, self), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetCommand(self: *const T, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetCommand(@ptrCast(*const IDebugBreakpoint3, self), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetOffsetExpression(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetOffsetExpression(@ptrCast(*const IDebugBreakpoint3, self), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetOffsetExpression(self: *const T, Expression: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetOffsetExpression(@ptrCast(*const IDebugBreakpoint3, self), Expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetParameters(self: *const T, Params: ?*DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetParameters(@ptrCast(*const IDebugBreakpoint3, self), Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetCommandWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetCommandWide(@ptrCast(*const IDebugBreakpoint3, self), Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetCommandWide(self: *const T, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetCommandWide(@ptrCast(*const IDebugBreakpoint3, self), Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetOffsetExpressionWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExpressionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetOffsetExpressionWide(@ptrCast(*const IDebugBreakpoint3, self), Buffer, BufferSize, ExpressionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_SetOffsetExpressionWide(self: *const T, Expression: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).SetOffsetExpressionWide(@ptrCast(*const IDebugBreakpoint3, self), Expression);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugBreakpoint3_GetGuid(self: *const T, _param_Guid: ?*Guid) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugBreakpoint3.VTable, self.vtable).GetGuid(@ptrCast(*const IDebugBreakpoint3, self), _param_Guid);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_CREATE_PROCESS_OPTIONS = extern struct {
    CreateFlags: u32,
    EngCreateFlags: u32,
    VerifierFlags: u32,
    Reserved: u32,
};

pub const DEBUG_CLIENT_CONTEXT = extern struct {
    cbSize: u32,
    eClient: u32,
};

const IID_IDebugClient_Value = @import("../../zig.zig").Guid.initString("27fe5639-8407-4f47-8364-ee118fb08ac8");
pub const IID_IDebugClient = &IID_IDebugClient_Value;
pub const IDebugClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: fn(
            self: *const IDebugClient,
            Flags: u32,
            ConnectOptions: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptions: fn(
            self: *const IDebugClient,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptions: fn(
            self: *const IDebugClient,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServer: fn(
            self: *const IDebugClient,
            Flags: u32,
            Options: ?[*:0]const u8,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServer: fn(
            self: *const IDebugClient,
            RemoteOptions: ?[*:0]const u8,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectProcessServer: fn(
            self: *const IDebugClient,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIds: fn(
            self: *const IDebugClient,
            Server: u64,
            Ids: ?[*]u32,
            Count: u32,
            ActualCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableName: fn(
            self: *const IDebugClient,
            Server: u64,
            ExeName: ?[*:0]const u8,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescription: fn(
            self: *const IDebugClient,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u8,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachProcess: fn(
            self: *const IDebugClient,
            Server: u64,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugClient,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach: fn(
            self: *const IDebugClient,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessOptions: fn(
            self: *const IDebugClient,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProcessOptions: fn(
            self: *const IDebugClient,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProcessOptions: fn(
            self: *const IDebugClient,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcessOptions: fn(
            self: *const IDebugClient,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFile: fn(
            self: *const IDebugClient,
            DumpFile: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile: fn(
            self: *const IDebugClient,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectSession: fn(
            self: *const IDebugClient,
            Flags: u32,
            HistoryLimit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServer: fn(
            self: *const IDebugClient,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServers: fn(
            self: *const IDebugClient,
            OutputControl: u32,
            Machine: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateProcesses: fn(
            self: *const IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachProcesses: fn(
            self: *const IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSession: fn(
            self: *const IDebugClient,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExitCode: fn(
            self: *const IDebugClient,
            Code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchCallbacks: fn(
            self: *const IDebugClient,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitDispatch: fn(
            self: *const IDebugClient,
            Client: ?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateClient: fn(
            self: *const IDebugClient,
            Client: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCallbacks: fn(
            self: *const IDebugClient,
            Callbacks: ?*?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputCallbacks: fn(
            self: *const IDebugClient,
            Callbacks: ?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacks: fn(
            self: *const IDebugClient,
            Callbacks: ?*?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacks: fn(
            self: *const IDebugClient,
            Callbacks: ?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMask: fn(
            self: *const IDebugClient,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputMask: fn(
            self: *const IDebugClient,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherOutputMask: fn(
            self: *const IDebugClient,
            Client: ?*IDebugClient,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOtherOutputMask: fn(
            self: *const IDebugClient,
            Client: ?*IDebugClient,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputWidth: fn(
            self: *const IDebugClient,
            Columns: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputWidth: fn(
            self: *const IDebugClient,
            Columns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefix: fn(
            self: *const IDebugClient,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefix: fn(
            self: *const IDebugClient,
            Prefix: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentity: fn(
            self: *const IDebugClient,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentity: fn(
            self: *const IDebugClient,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacks: fn(
            self: *const IDebugClient,
            Callbacks: ?*?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacks: fn(
            self: *const IDebugClient,
            Callbacks: ?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCallbacks: fn(
            self: *const IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).AttachKernel(@ptrCast(*const IDebugClient, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetKernelConnectionOptions(@ptrCast(*const IDebugClient, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetKernelConnectionOptions(@ptrCast(*const IDebugClient, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).StartProcessServer(@ptrCast(*const IDebugClient, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).ConnectProcessServer(@ptrCast(*const IDebugClient, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).DisconnectProcessServer(@ptrCast(*const IDebugClient, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetRunningProcessSystemIds(@ptrCast(*const IDebugClient, self), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetRunningProcessSystemIdByExecutableName(@ptrCast(*const IDebugClient, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetRunningProcessDescription(@ptrCast(*const IDebugClient, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).AttachProcess(@ptrCast(*const IDebugClient, self), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugClient, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).CreateProcessAndAttach(@ptrCast(*const IDebugClient, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetProcessOptions(@ptrCast(*const IDebugClient, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).AddProcessOptions(@ptrCast(*const IDebugClient, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).RemoveProcessOptions(@ptrCast(*const IDebugClient, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetProcessOptions(@ptrCast(*const IDebugClient, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).OpenDumpFile(@ptrCast(*const IDebugClient, self), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).WriteDumpFile(@ptrCast(*const IDebugClient, self), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).ConnectSession(@ptrCast(*const IDebugClient, self), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_StartServer(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).StartServer(@ptrCast(*const IDebugClient, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).OutputServers(@ptrCast(*const IDebugClient, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).TerminateProcesses(@ptrCast(*const IDebugClient, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).DetachProcesses(@ptrCast(*const IDebugClient, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).EndSession(@ptrCast(*const IDebugClient, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetExitCode(@ptrCast(*const IDebugClient, self), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).DispatchCallbacks(@ptrCast(*const IDebugClient, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).ExitDispatch(@ptrCast(*const IDebugClient, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).CreateClient(@ptrCast(*const IDebugClient, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetInputCallbacks(@ptrCast(*const IDebugClient, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetInputCallbacks(@ptrCast(*const IDebugClient, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetOutputCallbacks(@ptrCast(*const IDebugClient, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetOutputCallbacks(@ptrCast(*const IDebugClient, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetOutputMask(@ptrCast(*const IDebugClient, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetOutputMask(@ptrCast(*const IDebugClient, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetOtherOutputMask(@ptrCast(*const IDebugClient, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetOtherOutputMask(@ptrCast(*const IDebugClient, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetOutputWidth(@ptrCast(*const IDebugClient, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetOutputWidth(@ptrCast(*const IDebugClient, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetOutputLinePrefix(@ptrCast(*const IDebugClient, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetOutputLinePrefix(@ptrCast(*const IDebugClient, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetIdentity(@ptrCast(*const IDebugClient, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).OutputIdentity(@ptrCast(*const IDebugClient, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).GetEventCallbacks(@ptrCast(*const IDebugClient, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).SetEventCallbacks(@ptrCast(*const IDebugClient, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient.VTable, self.vtable).FlushCallbacks(@ptrCast(*const IDebugClient, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient2_Value = @import("../../zig.zig").Guid.initString("edbed635-372e-4dab-bbfe-ed0d2f63be81");
pub const IID_IDebugClient2 = &IID_IDebugClient2_Value;
pub const IDebugClient2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: fn(
            self: *const IDebugClient2,
            Flags: u32,
            ConnectOptions: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptions: fn(
            self: *const IDebugClient2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptions: fn(
            self: *const IDebugClient2,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServer: fn(
            self: *const IDebugClient2,
            Flags: u32,
            Options: ?[*:0]const u8,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServer: fn(
            self: *const IDebugClient2,
            RemoteOptions: ?[*:0]const u8,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectProcessServer: fn(
            self: *const IDebugClient2,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIds: fn(
            self: *const IDebugClient2,
            Server: u64,
            Ids: ?[*]u32,
            Count: u32,
            ActualCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableName: fn(
            self: *const IDebugClient2,
            Server: u64,
            ExeName: ?[*:0]const u8,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescription: fn(
            self: *const IDebugClient2,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u8,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachProcess: fn(
            self: *const IDebugClient2,
            Server: u64,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugClient2,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach: fn(
            self: *const IDebugClient2,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessOptions: fn(
            self: *const IDebugClient2,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProcessOptions: fn(
            self: *const IDebugClient2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProcessOptions: fn(
            self: *const IDebugClient2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcessOptions: fn(
            self: *const IDebugClient2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFile: fn(
            self: *const IDebugClient2,
            DumpFile: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile: fn(
            self: *const IDebugClient2,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectSession: fn(
            self: *const IDebugClient2,
            Flags: u32,
            HistoryLimit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServer: fn(
            self: *const IDebugClient2,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServers: fn(
            self: *const IDebugClient2,
            OutputControl: u32,
            Machine: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateProcesses: fn(
            self: *const IDebugClient2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachProcesses: fn(
            self: *const IDebugClient2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSession: fn(
            self: *const IDebugClient2,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExitCode: fn(
            self: *const IDebugClient2,
            Code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchCallbacks: fn(
            self: *const IDebugClient2,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitDispatch: fn(
            self: *const IDebugClient2,
            Client: ?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateClient: fn(
            self: *const IDebugClient2,
            Client: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCallbacks: fn(
            self: *const IDebugClient2,
            Callbacks: ?*?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputCallbacks: fn(
            self: *const IDebugClient2,
            Callbacks: ?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacks: fn(
            self: *const IDebugClient2,
            Callbacks: ?*?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacks: fn(
            self: *const IDebugClient2,
            Callbacks: ?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMask: fn(
            self: *const IDebugClient2,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputMask: fn(
            self: *const IDebugClient2,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherOutputMask: fn(
            self: *const IDebugClient2,
            Client: ?*IDebugClient,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOtherOutputMask: fn(
            self: *const IDebugClient2,
            Client: ?*IDebugClient,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputWidth: fn(
            self: *const IDebugClient2,
            Columns: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputWidth: fn(
            self: *const IDebugClient2,
            Columns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefix: fn(
            self: *const IDebugClient2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefix: fn(
            self: *const IDebugClient2,
            Prefix: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentity: fn(
            self: *const IDebugClient2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentity: fn(
            self: *const IDebugClient2,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacks: fn(
            self: *const IDebugClient2,
            Callbacks: ?*?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacks: fn(
            self: *const IDebugClient2,
            Callbacks: ?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCallbacks: fn(
            self: *const IDebugClient2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile2: fn(
            self: *const IDebugClient2,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFile: fn(
            self: *const IDebugClient2,
            InfoFile: ?[*:0]const u8,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndProcessServer: fn(
            self: *const IDebugClient2,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForProcessServerEnd: fn(
            self: *const IDebugClient2,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKernelDebuggerEnabled: fn(
            self: *const IDebugClient2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateCurrentProcess: fn(
            self: *const IDebugClient2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachCurrentProcess: fn(
            self: *const IDebugClient2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbandonCurrentProcess: fn(
            self: *const IDebugClient2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).AttachKernel(@ptrCast(*const IDebugClient2, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetKernelConnectionOptions(@ptrCast(*const IDebugClient2, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetKernelConnectionOptions(@ptrCast(*const IDebugClient2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).StartProcessServer(@ptrCast(*const IDebugClient2, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).ConnectProcessServer(@ptrCast(*const IDebugClient2, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).DisconnectProcessServer(@ptrCast(*const IDebugClient2, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetRunningProcessSystemIds(@ptrCast(*const IDebugClient2, self), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetRunningProcessSystemIdByExecutableName(@ptrCast(*const IDebugClient2, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetRunningProcessDescription(@ptrCast(*const IDebugClient2, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).AttachProcess(@ptrCast(*const IDebugClient2, self), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugClient2, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).CreateProcessAndAttach(@ptrCast(*const IDebugClient2, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetProcessOptions(@ptrCast(*const IDebugClient2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).AddProcessOptions(@ptrCast(*const IDebugClient2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).RemoveProcessOptions(@ptrCast(*const IDebugClient2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetProcessOptions(@ptrCast(*const IDebugClient2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).OpenDumpFile(@ptrCast(*const IDebugClient2, self), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).WriteDumpFile(@ptrCast(*const IDebugClient2, self), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).ConnectSession(@ptrCast(*const IDebugClient2, self), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_StartServer(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).StartServer(@ptrCast(*const IDebugClient2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).OutputServers(@ptrCast(*const IDebugClient2, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).TerminateProcesses(@ptrCast(*const IDebugClient2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).DetachProcesses(@ptrCast(*const IDebugClient2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).EndSession(@ptrCast(*const IDebugClient2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetExitCode(@ptrCast(*const IDebugClient2, self), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).DispatchCallbacks(@ptrCast(*const IDebugClient2, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).ExitDispatch(@ptrCast(*const IDebugClient2, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).CreateClient(@ptrCast(*const IDebugClient2, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetInputCallbacks(@ptrCast(*const IDebugClient2, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetInputCallbacks(@ptrCast(*const IDebugClient2, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetOutputCallbacks(@ptrCast(*const IDebugClient2, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetOutputCallbacks(@ptrCast(*const IDebugClient2, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetOutputMask(@ptrCast(*const IDebugClient2, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetOutputMask(@ptrCast(*const IDebugClient2, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetOtherOutputMask(@ptrCast(*const IDebugClient2, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetOtherOutputMask(@ptrCast(*const IDebugClient2, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetOutputWidth(@ptrCast(*const IDebugClient2, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetOutputWidth(@ptrCast(*const IDebugClient2, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetOutputLinePrefix(@ptrCast(*const IDebugClient2, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetOutputLinePrefix(@ptrCast(*const IDebugClient2, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetIdentity(@ptrCast(*const IDebugClient2, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).OutputIdentity(@ptrCast(*const IDebugClient2, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).GetEventCallbacks(@ptrCast(*const IDebugClient2, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).SetEventCallbacks(@ptrCast(*const IDebugClient2, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).FlushCallbacks(@ptrCast(*const IDebugClient2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).WriteDumpFile2(@ptrCast(*const IDebugClient2, self), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).AddDumpInformationFile(@ptrCast(*const IDebugClient2, self), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).EndProcessServer(@ptrCast(*const IDebugClient2, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).WaitForProcessServerEnd(@ptrCast(*const IDebugClient2, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).IsKernelDebuggerEnabled(@ptrCast(*const IDebugClient2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).TerminateCurrentProcess(@ptrCast(*const IDebugClient2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).DetachCurrentProcess(@ptrCast(*const IDebugClient2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient2_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient2.VTable, self.vtable).AbandonCurrentProcess(@ptrCast(*const IDebugClient2, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient3_Value = @import("../../zig.zig").Guid.initString("dd492d7f-71b8-4ad6-a8dc-1c887479ff91");
pub const IID_IDebugClient3 = &IID_IDebugClient3_Value;
pub const IDebugClient3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: fn(
            self: *const IDebugClient3,
            Flags: u32,
            ConnectOptions: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptions: fn(
            self: *const IDebugClient3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptions: fn(
            self: *const IDebugClient3,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServer: fn(
            self: *const IDebugClient3,
            Flags: u32,
            Options: ?[*:0]const u8,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServer: fn(
            self: *const IDebugClient3,
            RemoteOptions: ?[*:0]const u8,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectProcessServer: fn(
            self: *const IDebugClient3,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIds: fn(
            self: *const IDebugClient3,
            Server: u64,
            Ids: ?[*]u32,
            Count: u32,
            ActualCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableName: fn(
            self: *const IDebugClient3,
            Server: u64,
            ExeName: ?[*:0]const u8,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescription: fn(
            self: *const IDebugClient3,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u8,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachProcess: fn(
            self: *const IDebugClient3,
            Server: u64,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugClient3,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach: fn(
            self: *const IDebugClient3,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessOptions: fn(
            self: *const IDebugClient3,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProcessOptions: fn(
            self: *const IDebugClient3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProcessOptions: fn(
            self: *const IDebugClient3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcessOptions: fn(
            self: *const IDebugClient3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFile: fn(
            self: *const IDebugClient3,
            DumpFile: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile: fn(
            self: *const IDebugClient3,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectSession: fn(
            self: *const IDebugClient3,
            Flags: u32,
            HistoryLimit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServer: fn(
            self: *const IDebugClient3,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServers: fn(
            self: *const IDebugClient3,
            OutputControl: u32,
            Machine: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateProcesses: fn(
            self: *const IDebugClient3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachProcesses: fn(
            self: *const IDebugClient3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSession: fn(
            self: *const IDebugClient3,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExitCode: fn(
            self: *const IDebugClient3,
            Code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchCallbacks: fn(
            self: *const IDebugClient3,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitDispatch: fn(
            self: *const IDebugClient3,
            Client: ?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateClient: fn(
            self: *const IDebugClient3,
            Client: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCallbacks: fn(
            self: *const IDebugClient3,
            Callbacks: ?*?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputCallbacks: fn(
            self: *const IDebugClient3,
            Callbacks: ?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacks: fn(
            self: *const IDebugClient3,
            Callbacks: ?*?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacks: fn(
            self: *const IDebugClient3,
            Callbacks: ?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMask: fn(
            self: *const IDebugClient3,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputMask: fn(
            self: *const IDebugClient3,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherOutputMask: fn(
            self: *const IDebugClient3,
            Client: ?*IDebugClient,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOtherOutputMask: fn(
            self: *const IDebugClient3,
            Client: ?*IDebugClient,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputWidth: fn(
            self: *const IDebugClient3,
            Columns: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputWidth: fn(
            self: *const IDebugClient3,
            Columns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefix: fn(
            self: *const IDebugClient3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefix: fn(
            self: *const IDebugClient3,
            Prefix: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentity: fn(
            self: *const IDebugClient3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentity: fn(
            self: *const IDebugClient3,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacks: fn(
            self: *const IDebugClient3,
            Callbacks: ?*?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacks: fn(
            self: *const IDebugClient3,
            Callbacks: ?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCallbacks: fn(
            self: *const IDebugClient3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile2: fn(
            self: *const IDebugClient3,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFile: fn(
            self: *const IDebugClient3,
            InfoFile: ?[*:0]const u8,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndProcessServer: fn(
            self: *const IDebugClient3,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForProcessServerEnd: fn(
            self: *const IDebugClient3,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKernelDebuggerEnabled: fn(
            self: *const IDebugClient3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateCurrentProcess: fn(
            self: *const IDebugClient3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachCurrentProcess: fn(
            self: *const IDebugClient3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbandonCurrentProcess: fn(
            self: *const IDebugClient3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableNameWide: fn(
            self: *const IDebugClient3,
            Server: u64,
            ExeName: ?[*:0]const u16,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescriptionWide: fn(
            self: *const IDebugClient3,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u16,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessWide: fn(
            self: *const IDebugClient3,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttachWide: fn(
            self: *const IDebugClient3,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).AttachKernel(@ptrCast(*const IDebugClient3, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetKernelConnectionOptions(@ptrCast(*const IDebugClient3, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetKernelConnectionOptions(@ptrCast(*const IDebugClient3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).StartProcessServer(@ptrCast(*const IDebugClient3, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).ConnectProcessServer(@ptrCast(*const IDebugClient3, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).DisconnectProcessServer(@ptrCast(*const IDebugClient3, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetRunningProcessSystemIds(@ptrCast(*const IDebugClient3, self), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetRunningProcessSystemIdByExecutableName(@ptrCast(*const IDebugClient3, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetRunningProcessDescription(@ptrCast(*const IDebugClient3, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).AttachProcess(@ptrCast(*const IDebugClient3, self), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugClient3, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).CreateProcessAndAttach(@ptrCast(*const IDebugClient3, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetProcessOptions(@ptrCast(*const IDebugClient3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).AddProcessOptions(@ptrCast(*const IDebugClient3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).RemoveProcessOptions(@ptrCast(*const IDebugClient3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetProcessOptions(@ptrCast(*const IDebugClient3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).OpenDumpFile(@ptrCast(*const IDebugClient3, self), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).WriteDumpFile(@ptrCast(*const IDebugClient3, self), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).ConnectSession(@ptrCast(*const IDebugClient3, self), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_StartServer(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).StartServer(@ptrCast(*const IDebugClient3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).OutputServers(@ptrCast(*const IDebugClient3, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).TerminateProcesses(@ptrCast(*const IDebugClient3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).DetachProcesses(@ptrCast(*const IDebugClient3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).EndSession(@ptrCast(*const IDebugClient3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetExitCode(@ptrCast(*const IDebugClient3, self), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).DispatchCallbacks(@ptrCast(*const IDebugClient3, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).ExitDispatch(@ptrCast(*const IDebugClient3, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).CreateClient(@ptrCast(*const IDebugClient3, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetInputCallbacks(@ptrCast(*const IDebugClient3, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetInputCallbacks(@ptrCast(*const IDebugClient3, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetOutputCallbacks(@ptrCast(*const IDebugClient3, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetOutputCallbacks(@ptrCast(*const IDebugClient3, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetOutputMask(@ptrCast(*const IDebugClient3, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetOutputMask(@ptrCast(*const IDebugClient3, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetOtherOutputMask(@ptrCast(*const IDebugClient3, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetOtherOutputMask(@ptrCast(*const IDebugClient3, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetOutputWidth(@ptrCast(*const IDebugClient3, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetOutputWidth(@ptrCast(*const IDebugClient3, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetOutputLinePrefix(@ptrCast(*const IDebugClient3, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetOutputLinePrefix(@ptrCast(*const IDebugClient3, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetIdentity(@ptrCast(*const IDebugClient3, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).OutputIdentity(@ptrCast(*const IDebugClient3, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetEventCallbacks(@ptrCast(*const IDebugClient3, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).SetEventCallbacks(@ptrCast(*const IDebugClient3, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).FlushCallbacks(@ptrCast(*const IDebugClient3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).WriteDumpFile2(@ptrCast(*const IDebugClient3, self), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).AddDumpInformationFile(@ptrCast(*const IDebugClient3, self), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).EndProcessServer(@ptrCast(*const IDebugClient3, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).WaitForProcessServerEnd(@ptrCast(*const IDebugClient3, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).IsKernelDebuggerEnabled(@ptrCast(*const IDebugClient3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).TerminateCurrentProcess(@ptrCast(*const IDebugClient3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).DetachCurrentProcess(@ptrCast(*const IDebugClient3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).AbandonCurrentProcess(@ptrCast(*const IDebugClient3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetRunningProcessSystemIdByExecutableNameWide(@ptrCast(*const IDebugClient3, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).GetRunningProcessDescriptionWide(@ptrCast(*const IDebugClient3, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).CreateProcessWide(@ptrCast(*const IDebugClient3, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient3_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient3.VTable, self.vtable).CreateProcessAndAttachWide(@ptrCast(*const IDebugClient3, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient4_Value = @import("../../zig.zig").Guid.initString("ca83c3de-5089-4cf8-93c8-d892387f2a5e");
pub const IID_IDebugClient4 = &IID_IDebugClient4_Value;
pub const IDebugClient4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: fn(
            self: *const IDebugClient4,
            Flags: u32,
            ConnectOptions: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptions: fn(
            self: *const IDebugClient4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptions: fn(
            self: *const IDebugClient4,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServer: fn(
            self: *const IDebugClient4,
            Flags: u32,
            Options: ?[*:0]const u8,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServer: fn(
            self: *const IDebugClient4,
            RemoteOptions: ?[*:0]const u8,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectProcessServer: fn(
            self: *const IDebugClient4,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIds: fn(
            self: *const IDebugClient4,
            Server: u64,
            Ids: ?[*]u32,
            Count: u32,
            ActualCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableName: fn(
            self: *const IDebugClient4,
            Server: u64,
            ExeName: ?[*:0]const u8,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescription: fn(
            self: *const IDebugClient4,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u8,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachProcess: fn(
            self: *const IDebugClient4,
            Server: u64,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugClient4,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach: fn(
            self: *const IDebugClient4,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessOptions: fn(
            self: *const IDebugClient4,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProcessOptions: fn(
            self: *const IDebugClient4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProcessOptions: fn(
            self: *const IDebugClient4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcessOptions: fn(
            self: *const IDebugClient4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFile: fn(
            self: *const IDebugClient4,
            DumpFile: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile: fn(
            self: *const IDebugClient4,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectSession: fn(
            self: *const IDebugClient4,
            Flags: u32,
            HistoryLimit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServer: fn(
            self: *const IDebugClient4,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServers: fn(
            self: *const IDebugClient4,
            OutputControl: u32,
            Machine: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateProcesses: fn(
            self: *const IDebugClient4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachProcesses: fn(
            self: *const IDebugClient4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSession: fn(
            self: *const IDebugClient4,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExitCode: fn(
            self: *const IDebugClient4,
            Code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchCallbacks: fn(
            self: *const IDebugClient4,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitDispatch: fn(
            self: *const IDebugClient4,
            Client: ?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateClient: fn(
            self: *const IDebugClient4,
            Client: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCallbacks: fn(
            self: *const IDebugClient4,
            Callbacks: ?*?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputCallbacks: fn(
            self: *const IDebugClient4,
            Callbacks: ?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacks: fn(
            self: *const IDebugClient4,
            Callbacks: ?*?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacks: fn(
            self: *const IDebugClient4,
            Callbacks: ?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMask: fn(
            self: *const IDebugClient4,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputMask: fn(
            self: *const IDebugClient4,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherOutputMask: fn(
            self: *const IDebugClient4,
            Client: ?*IDebugClient,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOtherOutputMask: fn(
            self: *const IDebugClient4,
            Client: ?*IDebugClient,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputWidth: fn(
            self: *const IDebugClient4,
            Columns: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputWidth: fn(
            self: *const IDebugClient4,
            Columns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefix: fn(
            self: *const IDebugClient4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefix: fn(
            self: *const IDebugClient4,
            Prefix: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentity: fn(
            self: *const IDebugClient4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentity: fn(
            self: *const IDebugClient4,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacks: fn(
            self: *const IDebugClient4,
            Callbacks: ?*?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacks: fn(
            self: *const IDebugClient4,
            Callbacks: ?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCallbacks: fn(
            self: *const IDebugClient4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile2: fn(
            self: *const IDebugClient4,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFile: fn(
            self: *const IDebugClient4,
            InfoFile: ?[*:0]const u8,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndProcessServer: fn(
            self: *const IDebugClient4,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForProcessServerEnd: fn(
            self: *const IDebugClient4,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKernelDebuggerEnabled: fn(
            self: *const IDebugClient4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateCurrentProcess: fn(
            self: *const IDebugClient4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachCurrentProcess: fn(
            self: *const IDebugClient4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbandonCurrentProcess: fn(
            self: *const IDebugClient4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableNameWide: fn(
            self: *const IDebugClient4,
            Server: u64,
            ExeName: ?[*:0]const u16,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescriptionWide: fn(
            self: *const IDebugClient4,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u16,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessWide: fn(
            self: *const IDebugClient4,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttachWide: fn(
            self: *const IDebugClient4,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFileWide: fn(
            self: *const IDebugClient4,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFileWide: fn(
            self: *const IDebugClient4,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFileWide: fn(
            self: *const IDebugClient4,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberDumpFiles: fn(
            self: *const IDebugClient4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFile: fn(
            self: *const IDebugClient4,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
            Handle: ?*u64,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFileWide: fn(
            self: *const IDebugClient4,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
            Handle: ?*u64,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).AttachKernel(@ptrCast(*const IDebugClient4, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetKernelConnectionOptions(@ptrCast(*const IDebugClient4, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetKernelConnectionOptions(@ptrCast(*const IDebugClient4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).StartProcessServer(@ptrCast(*const IDebugClient4, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).ConnectProcessServer(@ptrCast(*const IDebugClient4, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).DisconnectProcessServer(@ptrCast(*const IDebugClient4, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetRunningProcessSystemIds(@ptrCast(*const IDebugClient4, self), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetRunningProcessSystemIdByExecutableName(@ptrCast(*const IDebugClient4, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetRunningProcessDescription(@ptrCast(*const IDebugClient4, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).AttachProcess(@ptrCast(*const IDebugClient4, self), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugClient4, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).CreateProcessAndAttach(@ptrCast(*const IDebugClient4, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetProcessOptions(@ptrCast(*const IDebugClient4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).AddProcessOptions(@ptrCast(*const IDebugClient4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).RemoveProcessOptions(@ptrCast(*const IDebugClient4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetProcessOptions(@ptrCast(*const IDebugClient4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).OpenDumpFile(@ptrCast(*const IDebugClient4, self), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).WriteDumpFile(@ptrCast(*const IDebugClient4, self), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).ConnectSession(@ptrCast(*const IDebugClient4, self), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_StartServer(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).StartServer(@ptrCast(*const IDebugClient4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).OutputServers(@ptrCast(*const IDebugClient4, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).TerminateProcesses(@ptrCast(*const IDebugClient4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).DetachProcesses(@ptrCast(*const IDebugClient4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).EndSession(@ptrCast(*const IDebugClient4, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetExitCode(@ptrCast(*const IDebugClient4, self), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).DispatchCallbacks(@ptrCast(*const IDebugClient4, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).ExitDispatch(@ptrCast(*const IDebugClient4, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).CreateClient(@ptrCast(*const IDebugClient4, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetInputCallbacks(@ptrCast(*const IDebugClient4, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetInputCallbacks(@ptrCast(*const IDebugClient4, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetOutputCallbacks(@ptrCast(*const IDebugClient4, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetOutputCallbacks(@ptrCast(*const IDebugClient4, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetOutputMask(@ptrCast(*const IDebugClient4, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetOutputMask(@ptrCast(*const IDebugClient4, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetOtherOutputMask(@ptrCast(*const IDebugClient4, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetOtherOutputMask(@ptrCast(*const IDebugClient4, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetOutputWidth(@ptrCast(*const IDebugClient4, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetOutputWidth(@ptrCast(*const IDebugClient4, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetOutputLinePrefix(@ptrCast(*const IDebugClient4, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetOutputLinePrefix(@ptrCast(*const IDebugClient4, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetIdentity(@ptrCast(*const IDebugClient4, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).OutputIdentity(@ptrCast(*const IDebugClient4, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetEventCallbacks(@ptrCast(*const IDebugClient4, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).SetEventCallbacks(@ptrCast(*const IDebugClient4, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).FlushCallbacks(@ptrCast(*const IDebugClient4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).WriteDumpFile2(@ptrCast(*const IDebugClient4, self), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).AddDumpInformationFile(@ptrCast(*const IDebugClient4, self), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).EndProcessServer(@ptrCast(*const IDebugClient4, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).WaitForProcessServerEnd(@ptrCast(*const IDebugClient4, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).IsKernelDebuggerEnabled(@ptrCast(*const IDebugClient4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).TerminateCurrentProcess(@ptrCast(*const IDebugClient4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).DetachCurrentProcess(@ptrCast(*const IDebugClient4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).AbandonCurrentProcess(@ptrCast(*const IDebugClient4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetRunningProcessSystemIdByExecutableNameWide(@ptrCast(*const IDebugClient4, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetRunningProcessDescriptionWide(@ptrCast(*const IDebugClient4, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).CreateProcessWide(@ptrCast(*const IDebugClient4, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).CreateProcessAndAttachWide(@ptrCast(*const IDebugClient4, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).OpenDumpFileWide(@ptrCast(*const IDebugClient4, self), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).WriteDumpFileWide(@ptrCast(*const IDebugClient4, self), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).AddDumpInformationFileWide(@ptrCast(*const IDebugClient4, self), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetNumberDumpFiles(@ptrCast(*const IDebugClient4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetDumpFile(@ptrCast(*const IDebugClient4, self), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient4_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient4.VTable, self.vtable).GetDumpFileWide(@ptrCast(*const IDebugClient4, self), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient5_Value = @import("../../zig.zig").Guid.initString("e3acb9d7-7ec2-4f0c-a0da-e81e0cbbe628");
pub const IID_IDebugClient5 = &IID_IDebugClient5_Value;
pub const IDebugClient5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: fn(
            self: *const IDebugClient5,
            Flags: u32,
            ConnectOptions: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptions: fn(
            self: *const IDebugClient5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptions: fn(
            self: *const IDebugClient5,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServer: fn(
            self: *const IDebugClient5,
            Flags: u32,
            Options: ?[*:0]const u8,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServer: fn(
            self: *const IDebugClient5,
            RemoteOptions: ?[*:0]const u8,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectProcessServer: fn(
            self: *const IDebugClient5,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIds: fn(
            self: *const IDebugClient5,
            Server: u64,
            Ids: ?[*]u32,
            Count: u32,
            ActualCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableName: fn(
            self: *const IDebugClient5,
            Server: u64,
            ExeName: ?[*:0]const u8,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescription: fn(
            self: *const IDebugClient5,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u8,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachProcess: fn(
            self: *const IDebugClient5,
            Server: u64,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugClient5,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach: fn(
            self: *const IDebugClient5,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessOptions: fn(
            self: *const IDebugClient5,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProcessOptions: fn(
            self: *const IDebugClient5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProcessOptions: fn(
            self: *const IDebugClient5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcessOptions: fn(
            self: *const IDebugClient5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFile: fn(
            self: *const IDebugClient5,
            DumpFile: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile: fn(
            self: *const IDebugClient5,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectSession: fn(
            self: *const IDebugClient5,
            Flags: u32,
            HistoryLimit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServer: fn(
            self: *const IDebugClient5,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServers: fn(
            self: *const IDebugClient5,
            OutputControl: u32,
            Machine: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateProcesses: fn(
            self: *const IDebugClient5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachProcesses: fn(
            self: *const IDebugClient5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSession: fn(
            self: *const IDebugClient5,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExitCode: fn(
            self: *const IDebugClient5,
            Code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchCallbacks: fn(
            self: *const IDebugClient5,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitDispatch: fn(
            self: *const IDebugClient5,
            Client: ?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateClient: fn(
            self: *const IDebugClient5,
            Client: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCallbacks: fn(
            self: *const IDebugClient5,
            Callbacks: ?*?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputCallbacks: fn(
            self: *const IDebugClient5,
            Callbacks: ?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacks: fn(
            self: *const IDebugClient5,
            Callbacks: ?*?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacks: fn(
            self: *const IDebugClient5,
            Callbacks: ?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMask: fn(
            self: *const IDebugClient5,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputMask: fn(
            self: *const IDebugClient5,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherOutputMask: fn(
            self: *const IDebugClient5,
            Client: ?*IDebugClient,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOtherOutputMask: fn(
            self: *const IDebugClient5,
            Client: ?*IDebugClient,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputWidth: fn(
            self: *const IDebugClient5,
            Columns: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputWidth: fn(
            self: *const IDebugClient5,
            Columns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefix: fn(
            self: *const IDebugClient5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefix: fn(
            self: *const IDebugClient5,
            Prefix: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentity: fn(
            self: *const IDebugClient5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentity: fn(
            self: *const IDebugClient5,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacks: fn(
            self: *const IDebugClient5,
            Callbacks: ?*?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacks: fn(
            self: *const IDebugClient5,
            Callbacks: ?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCallbacks: fn(
            self: *const IDebugClient5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile2: fn(
            self: *const IDebugClient5,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFile: fn(
            self: *const IDebugClient5,
            InfoFile: ?[*:0]const u8,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndProcessServer: fn(
            self: *const IDebugClient5,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForProcessServerEnd: fn(
            self: *const IDebugClient5,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKernelDebuggerEnabled: fn(
            self: *const IDebugClient5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateCurrentProcess: fn(
            self: *const IDebugClient5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachCurrentProcess: fn(
            self: *const IDebugClient5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbandonCurrentProcess: fn(
            self: *const IDebugClient5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableNameWide: fn(
            self: *const IDebugClient5,
            Server: u64,
            ExeName: ?[*:0]const u16,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescriptionWide: fn(
            self: *const IDebugClient5,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u16,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessWide: fn(
            self: *const IDebugClient5,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttachWide: fn(
            self: *const IDebugClient5,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFileWide: fn(
            self: *const IDebugClient5,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFileWide: fn(
            self: *const IDebugClient5,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFileWide: fn(
            self: *const IDebugClient5,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberDumpFiles: fn(
            self: *const IDebugClient5,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFile: fn(
            self: *const IDebugClient5,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
            Handle: ?*u64,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFileWide: fn(
            self: *const IDebugClient5,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
            Handle: ?*u64,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachKernelWide: fn(
            self: *const IDebugClient5,
            Flags: u32,
            ConnectOptions: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptionsWide: fn(
            self: *const IDebugClient5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptionsWide: fn(
            self: *const IDebugClient5,
            Options: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServerWide: fn(
            self: *const IDebugClient5,
            Flags: u32,
            Options: ?[*:0]const u16,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServerWide: fn(
            self: *const IDebugClient5,
            RemoteOptions: ?[*:0]const u16,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServerWide: fn(
            self: *const IDebugClient5,
            Options: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServersWide: fn(
            self: *const IDebugClient5,
            OutputControl: u32,
            Machine: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacksWide: fn(
            self: *const IDebugClient5,
            Callbacks: ?*?*IDebugOutputCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacksWide: fn(
            self: *const IDebugClient5,
            Callbacks: ?*IDebugOutputCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefixWide: fn(
            self: *const IDebugClient5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefixWide: fn(
            self: *const IDebugClient5,
            Prefix: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentityWide: fn(
            self: *const IDebugClient5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentityWide: fn(
            self: *const IDebugClient5,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacksWide: fn(
            self: *const IDebugClient5,
            Callbacks: ?*?*IDebugEventCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacksWide: fn(
            self: *const IDebugClient5,
            Callbacks: ?*IDebugEventCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcess2: fn(
            self: *const IDebugClient5,
            Server: u64,
            CommandLine: ?PSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u8,
            Environment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcess2Wide: fn(
            self: *const IDebugClient5,
            Server: u64,
            CommandLine: ?PWSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u16,
            Environment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach2: fn(
            self: *const IDebugClient5,
            Server: u64,
            CommandLine: ?PSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u8,
            Environment: ?[*:0]const u8,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach2Wide: fn(
            self: *const IDebugClient5,
            Server: u64,
            CommandLine: ?PWSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u16,
            Environment: ?[*:0]const u16,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushOutputLinePrefix: fn(
            self: *const IDebugClient5,
            NewPrefix: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushOutputLinePrefixWide: fn(
            self: *const IDebugClient5,
            NewPrefix: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PopOutputLinePrefix: fn(
            self: *const IDebugClient5,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberInputCallbacks: fn(
            self: *const IDebugClient5,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOutputCallbacks: fn(
            self: *const IDebugClient5,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventCallbacks: fn(
            self: *const IDebugClient5,
            EventFlags: u32,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuitLockString: fn(
            self: *const IDebugClient5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuitLockString: fn(
            self: *const IDebugClient5,
            String: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuitLockStringWide: fn(
            self: *const IDebugClient5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuitLockStringWide: fn(
            self: *const IDebugClient5,
            String: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).AttachKernel(@ptrCast(*const IDebugClient5, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetKernelConnectionOptions(@ptrCast(*const IDebugClient5, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetKernelConnectionOptions(@ptrCast(*const IDebugClient5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).StartProcessServer(@ptrCast(*const IDebugClient5, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).ConnectProcessServer(@ptrCast(*const IDebugClient5, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).DisconnectProcessServer(@ptrCast(*const IDebugClient5, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetRunningProcessSystemIds(@ptrCast(*const IDebugClient5, self), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetRunningProcessSystemIdByExecutableName(@ptrCast(*const IDebugClient5, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetRunningProcessDescription(@ptrCast(*const IDebugClient5, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).AttachProcess(@ptrCast(*const IDebugClient5, self), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugClient5, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateProcessAndAttach(@ptrCast(*const IDebugClient5, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetProcessOptions(@ptrCast(*const IDebugClient5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).AddProcessOptions(@ptrCast(*const IDebugClient5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).RemoveProcessOptions(@ptrCast(*const IDebugClient5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetProcessOptions(@ptrCast(*const IDebugClient5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).OpenDumpFile(@ptrCast(*const IDebugClient5, self), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).WriteDumpFile(@ptrCast(*const IDebugClient5, self), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).ConnectSession(@ptrCast(*const IDebugClient5, self), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_StartServer(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).StartServer(@ptrCast(*const IDebugClient5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).OutputServers(@ptrCast(*const IDebugClient5, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).TerminateProcesses(@ptrCast(*const IDebugClient5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).DetachProcesses(@ptrCast(*const IDebugClient5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).EndSession(@ptrCast(*const IDebugClient5, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetExitCode(@ptrCast(*const IDebugClient5, self), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).DispatchCallbacks(@ptrCast(*const IDebugClient5, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).ExitDispatch(@ptrCast(*const IDebugClient5, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateClient(@ptrCast(*const IDebugClient5, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetInputCallbacks(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetInputCallbacks(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetOutputCallbacks(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetOutputCallbacks(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetOutputMask(@ptrCast(*const IDebugClient5, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetOutputMask(@ptrCast(*const IDebugClient5, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetOtherOutputMask(@ptrCast(*const IDebugClient5, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetOtherOutputMask(@ptrCast(*const IDebugClient5, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetOutputWidth(@ptrCast(*const IDebugClient5, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetOutputWidth(@ptrCast(*const IDebugClient5, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetOutputLinePrefix(@ptrCast(*const IDebugClient5, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetOutputLinePrefix(@ptrCast(*const IDebugClient5, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetIdentity(@ptrCast(*const IDebugClient5, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).OutputIdentity(@ptrCast(*const IDebugClient5, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetEventCallbacks(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetEventCallbacks(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).FlushCallbacks(@ptrCast(*const IDebugClient5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).WriteDumpFile2(@ptrCast(*const IDebugClient5, self), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).AddDumpInformationFile(@ptrCast(*const IDebugClient5, self), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).EndProcessServer(@ptrCast(*const IDebugClient5, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).WaitForProcessServerEnd(@ptrCast(*const IDebugClient5, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).IsKernelDebuggerEnabled(@ptrCast(*const IDebugClient5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).TerminateCurrentProcess(@ptrCast(*const IDebugClient5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).DetachCurrentProcess(@ptrCast(*const IDebugClient5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).AbandonCurrentProcess(@ptrCast(*const IDebugClient5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetRunningProcessSystemIdByExecutableNameWide(@ptrCast(*const IDebugClient5, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetRunningProcessDescriptionWide(@ptrCast(*const IDebugClient5, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateProcessWide(@ptrCast(*const IDebugClient5, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateProcessAndAttachWide(@ptrCast(*const IDebugClient5, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).OpenDumpFileWide(@ptrCast(*const IDebugClient5, self), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).WriteDumpFileWide(@ptrCast(*const IDebugClient5, self), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).AddDumpInformationFileWide(@ptrCast(*const IDebugClient5, self), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetNumberDumpFiles(@ptrCast(*const IDebugClient5, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetDumpFile(@ptrCast(*const IDebugClient5, self), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetDumpFileWide(@ptrCast(*const IDebugClient5, self), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).AttachKernelWide(@ptrCast(*const IDebugClient5, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetKernelConnectionOptionsWide(@ptrCast(*const IDebugClient5, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetKernelConnectionOptionsWide(@ptrCast(*const IDebugClient5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]const u16, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).StartProcessServerWide(@ptrCast(*const IDebugClient5, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]const u16, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).ConnectProcessServerWide(@ptrCast(*const IDebugClient5, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_StartServerWide(self: *const T, Options: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).StartServerWide(@ptrCast(*const IDebugClient5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).OutputServersWide(@ptrCast(*const IDebugClient5, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetOutputCallbacksWide(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetOutputCallbacksWide(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetOutputLinePrefixWide(@ptrCast(*const IDebugClient5, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetOutputLinePrefixWide(@ptrCast(*const IDebugClient5, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetIdentityWide(@ptrCast(*const IDebugClient5, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).OutputIdentityWide(@ptrCast(*const IDebugClient5, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetEventCallbacksWide(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetEventCallbacksWide(@ptrCast(*const IDebugClient5, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateProcess2(@ptrCast(*const IDebugClient5, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateProcess2Wide(@ptrCast(*const IDebugClient5, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateProcessAndAttach2(@ptrCast(*const IDebugClient5, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).CreateProcessAndAttach2Wide(@ptrCast(*const IDebugClient5, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).PushOutputLinePrefix(@ptrCast(*const IDebugClient5, self), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).PushOutputLinePrefixWide(@ptrCast(*const IDebugClient5, self), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_PopOutputLinePrefix(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).PopOutputLinePrefix(@ptrCast(*const IDebugClient5, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetNumberInputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetNumberInputCallbacks(@ptrCast(*const IDebugClient5, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetNumberOutputCallbacks(@ptrCast(*const IDebugClient5, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetNumberEventCallbacks(@ptrCast(*const IDebugClient5, self), EventFlags, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetQuitLockString(@ptrCast(*const IDebugClient5, self), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetQuitLockString(self: *const T, String: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetQuitLockString(@ptrCast(*const IDebugClient5, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).GetQuitLockStringWide(@ptrCast(*const IDebugClient5, self), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient5_SetQuitLockStringWide(self: *const T, String: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient5.VTable, self.vtable).SetQuitLockStringWide(@ptrCast(*const IDebugClient5, self), String);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient6_Value = @import("../../zig.zig").Guid.initString("fd28b4c5-c498-4686-a28e-62cad2154eb3");
pub const IID_IDebugClient6 = &IID_IDebugClient6_Value;
pub const IDebugClient6 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: fn(
            self: *const IDebugClient6,
            Flags: u32,
            ConnectOptions: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptions: fn(
            self: *const IDebugClient6,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptions: fn(
            self: *const IDebugClient6,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServer: fn(
            self: *const IDebugClient6,
            Flags: u32,
            Options: ?[*:0]const u8,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServer: fn(
            self: *const IDebugClient6,
            RemoteOptions: ?[*:0]const u8,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectProcessServer: fn(
            self: *const IDebugClient6,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIds: fn(
            self: *const IDebugClient6,
            Server: u64,
            Ids: ?[*]u32,
            Count: u32,
            ActualCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableName: fn(
            self: *const IDebugClient6,
            Server: u64,
            ExeName: ?[*:0]const u8,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescription: fn(
            self: *const IDebugClient6,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u8,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachProcess: fn(
            self: *const IDebugClient6,
            Server: u64,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugClient6,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach: fn(
            self: *const IDebugClient6,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessOptions: fn(
            self: *const IDebugClient6,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProcessOptions: fn(
            self: *const IDebugClient6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProcessOptions: fn(
            self: *const IDebugClient6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcessOptions: fn(
            self: *const IDebugClient6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFile: fn(
            self: *const IDebugClient6,
            DumpFile: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile: fn(
            self: *const IDebugClient6,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectSession: fn(
            self: *const IDebugClient6,
            Flags: u32,
            HistoryLimit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServer: fn(
            self: *const IDebugClient6,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServers: fn(
            self: *const IDebugClient6,
            OutputControl: u32,
            Machine: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateProcesses: fn(
            self: *const IDebugClient6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachProcesses: fn(
            self: *const IDebugClient6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSession: fn(
            self: *const IDebugClient6,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExitCode: fn(
            self: *const IDebugClient6,
            Code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchCallbacks: fn(
            self: *const IDebugClient6,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitDispatch: fn(
            self: *const IDebugClient6,
            Client: ?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateClient: fn(
            self: *const IDebugClient6,
            Client: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCallbacks: fn(
            self: *const IDebugClient6,
            Callbacks: ?*?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputCallbacks: fn(
            self: *const IDebugClient6,
            Callbacks: ?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacks: fn(
            self: *const IDebugClient6,
            Callbacks: ?*?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacks: fn(
            self: *const IDebugClient6,
            Callbacks: ?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMask: fn(
            self: *const IDebugClient6,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputMask: fn(
            self: *const IDebugClient6,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherOutputMask: fn(
            self: *const IDebugClient6,
            Client: ?*IDebugClient,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOtherOutputMask: fn(
            self: *const IDebugClient6,
            Client: ?*IDebugClient,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputWidth: fn(
            self: *const IDebugClient6,
            Columns: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputWidth: fn(
            self: *const IDebugClient6,
            Columns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefix: fn(
            self: *const IDebugClient6,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefix: fn(
            self: *const IDebugClient6,
            Prefix: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentity: fn(
            self: *const IDebugClient6,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentity: fn(
            self: *const IDebugClient6,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacks: fn(
            self: *const IDebugClient6,
            Callbacks: ?*?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacks: fn(
            self: *const IDebugClient6,
            Callbacks: ?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCallbacks: fn(
            self: *const IDebugClient6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile2: fn(
            self: *const IDebugClient6,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFile: fn(
            self: *const IDebugClient6,
            InfoFile: ?[*:0]const u8,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndProcessServer: fn(
            self: *const IDebugClient6,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForProcessServerEnd: fn(
            self: *const IDebugClient6,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKernelDebuggerEnabled: fn(
            self: *const IDebugClient6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateCurrentProcess: fn(
            self: *const IDebugClient6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachCurrentProcess: fn(
            self: *const IDebugClient6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbandonCurrentProcess: fn(
            self: *const IDebugClient6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableNameWide: fn(
            self: *const IDebugClient6,
            Server: u64,
            ExeName: ?[*:0]const u16,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescriptionWide: fn(
            self: *const IDebugClient6,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u16,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessWide: fn(
            self: *const IDebugClient6,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttachWide: fn(
            self: *const IDebugClient6,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFileWide: fn(
            self: *const IDebugClient6,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFileWide: fn(
            self: *const IDebugClient6,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFileWide: fn(
            self: *const IDebugClient6,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberDumpFiles: fn(
            self: *const IDebugClient6,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFile: fn(
            self: *const IDebugClient6,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
            Handle: ?*u64,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFileWide: fn(
            self: *const IDebugClient6,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
            Handle: ?*u64,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachKernelWide: fn(
            self: *const IDebugClient6,
            Flags: u32,
            ConnectOptions: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptionsWide: fn(
            self: *const IDebugClient6,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptionsWide: fn(
            self: *const IDebugClient6,
            Options: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServerWide: fn(
            self: *const IDebugClient6,
            Flags: u32,
            Options: ?[*:0]const u16,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServerWide: fn(
            self: *const IDebugClient6,
            RemoteOptions: ?[*:0]const u16,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServerWide: fn(
            self: *const IDebugClient6,
            Options: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServersWide: fn(
            self: *const IDebugClient6,
            OutputControl: u32,
            Machine: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacksWide: fn(
            self: *const IDebugClient6,
            Callbacks: ?*?*IDebugOutputCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacksWide: fn(
            self: *const IDebugClient6,
            Callbacks: ?*IDebugOutputCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefixWide: fn(
            self: *const IDebugClient6,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefixWide: fn(
            self: *const IDebugClient6,
            Prefix: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentityWide: fn(
            self: *const IDebugClient6,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentityWide: fn(
            self: *const IDebugClient6,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacksWide: fn(
            self: *const IDebugClient6,
            Callbacks: ?*?*IDebugEventCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacksWide: fn(
            self: *const IDebugClient6,
            Callbacks: ?*IDebugEventCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcess2: fn(
            self: *const IDebugClient6,
            Server: u64,
            CommandLine: ?PSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u8,
            Environment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcess2Wide: fn(
            self: *const IDebugClient6,
            Server: u64,
            CommandLine: ?PWSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u16,
            Environment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach2: fn(
            self: *const IDebugClient6,
            Server: u64,
            CommandLine: ?PSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u8,
            Environment: ?[*:0]const u8,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach2Wide: fn(
            self: *const IDebugClient6,
            Server: u64,
            CommandLine: ?PWSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u16,
            Environment: ?[*:0]const u16,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushOutputLinePrefix: fn(
            self: *const IDebugClient6,
            NewPrefix: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushOutputLinePrefixWide: fn(
            self: *const IDebugClient6,
            NewPrefix: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PopOutputLinePrefix: fn(
            self: *const IDebugClient6,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberInputCallbacks: fn(
            self: *const IDebugClient6,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOutputCallbacks: fn(
            self: *const IDebugClient6,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventCallbacks: fn(
            self: *const IDebugClient6,
            EventFlags: u32,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuitLockString: fn(
            self: *const IDebugClient6,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuitLockString: fn(
            self: *const IDebugClient6,
            String: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuitLockStringWide: fn(
            self: *const IDebugClient6,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuitLockStringWide: fn(
            self: *const IDebugClient6,
            String: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventContextCallbacks: fn(
            self: *const IDebugClient6,
            Callbacks: ?*IDebugEventContextCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).AttachKernel(@ptrCast(*const IDebugClient6, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetKernelConnectionOptions(@ptrCast(*const IDebugClient6, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetKernelConnectionOptions(@ptrCast(*const IDebugClient6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).StartProcessServer(@ptrCast(*const IDebugClient6, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).ConnectProcessServer(@ptrCast(*const IDebugClient6, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).DisconnectProcessServer(@ptrCast(*const IDebugClient6, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetRunningProcessSystemIds(@ptrCast(*const IDebugClient6, self), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetRunningProcessSystemIdByExecutableName(@ptrCast(*const IDebugClient6, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetRunningProcessDescription(@ptrCast(*const IDebugClient6, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).AttachProcess(@ptrCast(*const IDebugClient6, self), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugClient6, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateProcessAndAttach(@ptrCast(*const IDebugClient6, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetProcessOptions(@ptrCast(*const IDebugClient6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).AddProcessOptions(@ptrCast(*const IDebugClient6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).RemoveProcessOptions(@ptrCast(*const IDebugClient6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetProcessOptions(@ptrCast(*const IDebugClient6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).OpenDumpFile(@ptrCast(*const IDebugClient6, self), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).WriteDumpFile(@ptrCast(*const IDebugClient6, self), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).ConnectSession(@ptrCast(*const IDebugClient6, self), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_StartServer(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).StartServer(@ptrCast(*const IDebugClient6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).OutputServers(@ptrCast(*const IDebugClient6, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).TerminateProcesses(@ptrCast(*const IDebugClient6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).DetachProcesses(@ptrCast(*const IDebugClient6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).EndSession(@ptrCast(*const IDebugClient6, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetExitCode(@ptrCast(*const IDebugClient6, self), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).DispatchCallbacks(@ptrCast(*const IDebugClient6, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).ExitDispatch(@ptrCast(*const IDebugClient6, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateClient(@ptrCast(*const IDebugClient6, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetInputCallbacks(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetInputCallbacks(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetOutputCallbacks(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetOutputCallbacks(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetOutputMask(@ptrCast(*const IDebugClient6, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetOutputMask(@ptrCast(*const IDebugClient6, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetOtherOutputMask(@ptrCast(*const IDebugClient6, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetOtherOutputMask(@ptrCast(*const IDebugClient6, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetOutputWidth(@ptrCast(*const IDebugClient6, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetOutputWidth(@ptrCast(*const IDebugClient6, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetOutputLinePrefix(@ptrCast(*const IDebugClient6, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetOutputLinePrefix(@ptrCast(*const IDebugClient6, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetIdentity(@ptrCast(*const IDebugClient6, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).OutputIdentity(@ptrCast(*const IDebugClient6, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetEventCallbacks(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetEventCallbacks(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).FlushCallbacks(@ptrCast(*const IDebugClient6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).WriteDumpFile2(@ptrCast(*const IDebugClient6, self), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).AddDumpInformationFile(@ptrCast(*const IDebugClient6, self), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).EndProcessServer(@ptrCast(*const IDebugClient6, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).WaitForProcessServerEnd(@ptrCast(*const IDebugClient6, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).IsKernelDebuggerEnabled(@ptrCast(*const IDebugClient6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).TerminateCurrentProcess(@ptrCast(*const IDebugClient6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).DetachCurrentProcess(@ptrCast(*const IDebugClient6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).AbandonCurrentProcess(@ptrCast(*const IDebugClient6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetRunningProcessSystemIdByExecutableNameWide(@ptrCast(*const IDebugClient6, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetRunningProcessDescriptionWide(@ptrCast(*const IDebugClient6, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateProcessWide(@ptrCast(*const IDebugClient6, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateProcessAndAttachWide(@ptrCast(*const IDebugClient6, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).OpenDumpFileWide(@ptrCast(*const IDebugClient6, self), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).WriteDumpFileWide(@ptrCast(*const IDebugClient6, self), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).AddDumpInformationFileWide(@ptrCast(*const IDebugClient6, self), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetNumberDumpFiles(@ptrCast(*const IDebugClient6, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetDumpFile(@ptrCast(*const IDebugClient6, self), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetDumpFileWide(@ptrCast(*const IDebugClient6, self), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).AttachKernelWide(@ptrCast(*const IDebugClient6, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetKernelConnectionOptionsWide(@ptrCast(*const IDebugClient6, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetKernelConnectionOptionsWide(@ptrCast(*const IDebugClient6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]const u16, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).StartProcessServerWide(@ptrCast(*const IDebugClient6, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]const u16, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).ConnectProcessServerWide(@ptrCast(*const IDebugClient6, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_StartServerWide(self: *const T, Options: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).StartServerWide(@ptrCast(*const IDebugClient6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).OutputServersWide(@ptrCast(*const IDebugClient6, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetOutputCallbacksWide(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetOutputCallbacksWide(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetOutputLinePrefixWide(@ptrCast(*const IDebugClient6, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetOutputLinePrefixWide(@ptrCast(*const IDebugClient6, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetIdentityWide(@ptrCast(*const IDebugClient6, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).OutputIdentityWide(@ptrCast(*const IDebugClient6, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetEventCallbacksWide(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetEventCallbacksWide(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateProcess2(@ptrCast(*const IDebugClient6, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateProcess2Wide(@ptrCast(*const IDebugClient6, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateProcessAndAttach2(@ptrCast(*const IDebugClient6, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).CreateProcessAndAttach2Wide(@ptrCast(*const IDebugClient6, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).PushOutputLinePrefix(@ptrCast(*const IDebugClient6, self), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).PushOutputLinePrefixWide(@ptrCast(*const IDebugClient6, self), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_PopOutputLinePrefix(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).PopOutputLinePrefix(@ptrCast(*const IDebugClient6, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetNumberInputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetNumberInputCallbacks(@ptrCast(*const IDebugClient6, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetNumberOutputCallbacks(@ptrCast(*const IDebugClient6, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetNumberEventCallbacks(@ptrCast(*const IDebugClient6, self), EventFlags, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetQuitLockString(@ptrCast(*const IDebugClient6, self), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetQuitLockString(self: *const T, String: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetQuitLockString(@ptrCast(*const IDebugClient6, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).GetQuitLockStringWide(@ptrCast(*const IDebugClient6, self), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetQuitLockStringWide(self: *const T, String: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetQuitLockStringWide(@ptrCast(*const IDebugClient6, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient6_SetEventContextCallbacks(self: *const T, Callbacks: ?*IDebugEventContextCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient6.VTable, self.vtable).SetEventContextCallbacks(@ptrCast(*const IDebugClient6, self), Callbacks);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugClient7_Value = @import("../../zig.zig").Guid.initString("13586be3-542e-481e-b1f2-8497ba74f9a9");
pub const IID_IDebugClient7 = &IID_IDebugClient7_Value;
pub const IDebugClient7 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AttachKernel: fn(
            self: *const IDebugClient7,
            Flags: u32,
            ConnectOptions: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptions: fn(
            self: *const IDebugClient7,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptions: fn(
            self: *const IDebugClient7,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServer: fn(
            self: *const IDebugClient7,
            Flags: u32,
            Options: ?[*:0]const u8,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServer: fn(
            self: *const IDebugClient7,
            RemoteOptions: ?[*:0]const u8,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisconnectProcessServer: fn(
            self: *const IDebugClient7,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIds: fn(
            self: *const IDebugClient7,
            Server: u64,
            Ids: ?[*]u32,
            Count: u32,
            ActualCount: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableName: fn(
            self: *const IDebugClient7,
            Server: u64,
            ExeName: ?[*:0]const u8,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescription: fn(
            self: *const IDebugClient7,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u8,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachProcess: fn(
            self: *const IDebugClient7,
            Server: u64,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugClient7,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach: fn(
            self: *const IDebugClient7,
            Server: u64,
            CommandLine: ?PSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessOptions: fn(
            self: *const IDebugClient7,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddProcessOptions: fn(
            self: *const IDebugClient7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveProcessOptions: fn(
            self: *const IDebugClient7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetProcessOptions: fn(
            self: *const IDebugClient7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFile: fn(
            self: *const IDebugClient7,
            DumpFile: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile: fn(
            self: *const IDebugClient7,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectSession: fn(
            self: *const IDebugClient7,
            Flags: u32,
            HistoryLimit: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServer: fn(
            self: *const IDebugClient7,
            Options: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServers: fn(
            self: *const IDebugClient7,
            OutputControl: u32,
            Machine: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateProcesses: fn(
            self: *const IDebugClient7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachProcesses: fn(
            self: *const IDebugClient7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSession: fn(
            self: *const IDebugClient7,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExitCode: fn(
            self: *const IDebugClient7,
            Code: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DispatchCallbacks: fn(
            self: *const IDebugClient7,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitDispatch: fn(
            self: *const IDebugClient7,
            Client: ?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateClient: fn(
            self: *const IDebugClient7,
            Client: ?*?*IDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInputCallbacks: fn(
            self: *const IDebugClient7,
            Callbacks: ?*?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInputCallbacks: fn(
            self: *const IDebugClient7,
            Callbacks: ?*IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacks: fn(
            self: *const IDebugClient7,
            Callbacks: ?*?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacks: fn(
            self: *const IDebugClient7,
            Callbacks: ?*IDebugOutputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputMask: fn(
            self: *const IDebugClient7,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputMask: fn(
            self: *const IDebugClient7,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOtherOutputMask: fn(
            self: *const IDebugClient7,
            Client: ?*IDebugClient,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOtherOutputMask: fn(
            self: *const IDebugClient7,
            Client: ?*IDebugClient,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputWidth: fn(
            self: *const IDebugClient7,
            Columns: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputWidth: fn(
            self: *const IDebugClient7,
            Columns: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefix: fn(
            self: *const IDebugClient7,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefix: fn(
            self: *const IDebugClient7,
            Prefix: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentity: fn(
            self: *const IDebugClient7,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentity: fn(
            self: *const IDebugClient7,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacks: fn(
            self: *const IDebugClient7,
            Callbacks: ?*?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacks: fn(
            self: *const IDebugClient7,
            Callbacks: ?*IDebugEventCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FlushCallbacks: fn(
            self: *const IDebugClient7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFile2: fn(
            self: *const IDebugClient7,
            DumpFile: ?[*:0]const u8,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFile: fn(
            self: *const IDebugClient7,
            InfoFile: ?[*:0]const u8,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndProcessServer: fn(
            self: *const IDebugClient7,
            Server: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForProcessServerEnd: fn(
            self: *const IDebugClient7,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsKernelDebuggerEnabled: fn(
            self: *const IDebugClient7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminateCurrentProcess: fn(
            self: *const IDebugClient7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DetachCurrentProcess: fn(
            self: *const IDebugClient7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AbandonCurrentProcess: fn(
            self: *const IDebugClient7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessSystemIdByExecutableNameWide: fn(
            self: *const IDebugClient7,
            Server: u64,
            ExeName: ?[*:0]const u16,
            Flags: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRunningProcessDescriptionWide: fn(
            self: *const IDebugClient7,
            Server: u64,
            SystemId: u32,
            Flags: u32,
            ExeName: ?[*:0]u16,
            ExeNameSize: u32,
            ActualExeNameSize: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            ActualDescriptionSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessWide: fn(
            self: *const IDebugClient7,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttachWide: fn(
            self: *const IDebugClient7,
            Server: u64,
            CommandLine: ?PWSTR,
            CreateFlags: u32,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenDumpFileWide: fn(
            self: *const IDebugClient7,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteDumpFileWide: fn(
            self: *const IDebugClient7,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
            Qualifier: u32,
            FormatFlags: u32,
            Comment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddDumpInformationFileWide: fn(
            self: *const IDebugClient7,
            FileName: ?[*:0]const u16,
            FileHandle: u64,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberDumpFiles: fn(
            self: *const IDebugClient7,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFile: fn(
            self: *const IDebugClient7,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
            Handle: ?*u64,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFileWide: fn(
            self: *const IDebugClient7,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
            Handle: ?*u64,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AttachKernelWide: fn(
            self: *const IDebugClient7,
            Flags: u32,
            ConnectOptions: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKernelConnectionOptionsWide: fn(
            self: *const IDebugClient7,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            OptionsSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKernelConnectionOptionsWide: fn(
            self: *const IDebugClient7,
            Options: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartProcessServerWide: fn(
            self: *const IDebugClient7,
            Flags: u32,
            Options: ?[*:0]const u16,
            Reserved: ?*c_void,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ConnectProcessServerWide: fn(
            self: *const IDebugClient7,
            RemoteOptions: ?[*:0]const u16,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartServerWide: fn(
            self: *const IDebugClient7,
            Options: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputServersWide: fn(
            self: *const IDebugClient7,
            OutputControl: u32,
            Machine: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputCallbacksWide: fn(
            self: *const IDebugClient7,
            Callbacks: ?*?*IDebugOutputCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputCallbacksWide: fn(
            self: *const IDebugClient7,
            Callbacks: ?*IDebugOutputCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOutputLinePrefixWide: fn(
            self: *const IDebugClient7,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PrefixSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetOutputLinePrefixWide: fn(
            self: *const IDebugClient7,
            Prefix: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIdentityWide: fn(
            self: *const IDebugClient7,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            IdentitySize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputIdentityWide: fn(
            self: *const IDebugClient7,
            OutputControl: u32,
            Flags: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventCallbacksWide: fn(
            self: *const IDebugClient7,
            Callbacks: ?*?*IDebugEventCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventCallbacksWide: fn(
            self: *const IDebugClient7,
            Callbacks: ?*IDebugEventCallbacksWide,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcess2: fn(
            self: *const IDebugClient7,
            Server: u64,
            CommandLine: ?PSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u8,
            Environment: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcess2Wide: fn(
            self: *const IDebugClient7,
            Server: u64,
            CommandLine: ?PWSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u16,
            Environment: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach2: fn(
            self: *const IDebugClient7,
            Server: u64,
            CommandLine: ?PSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u8,
            Environment: ?[*:0]const u8,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessAndAttach2Wide: fn(
            self: *const IDebugClient7,
            Server: u64,
            CommandLine: ?PWSTR,
            // TODO: what to do with BytesParamIndex 3?
            OptionsBuffer: ?*c_void,
            OptionsBufferSize: u32,
            InitialDirectory: ?[*:0]const u16,
            Environment: ?[*:0]const u16,
            ProcessId: u32,
            AttachFlags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushOutputLinePrefix: fn(
            self: *const IDebugClient7,
            NewPrefix: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PushOutputLinePrefixWide: fn(
            self: *const IDebugClient7,
            NewPrefix: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        PopOutputLinePrefix: fn(
            self: *const IDebugClient7,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberInputCallbacks: fn(
            self: *const IDebugClient7,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOutputCallbacks: fn(
            self: *const IDebugClient7,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventCallbacks: fn(
            self: *const IDebugClient7,
            EventFlags: u32,
            Count: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuitLockString: fn(
            self: *const IDebugClient7,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuitLockString: fn(
            self: *const IDebugClient7,
            String: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetQuitLockStringWide: fn(
            self: *const IDebugClient7,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetQuitLockStringWide: fn(
            self: *const IDebugClient7,
            String: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventContextCallbacks: fn(
            self: *const IDebugClient7,
            Callbacks: ?*IDebugEventContextCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetClientContext: fn(
            self: *const IDebugClient7,
            // TODO: what to do with BytesParamIndex 1?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AttachKernel(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).AttachKernel(@ptrCast(*const IDebugClient7, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetKernelConnectionOptions(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetKernelConnectionOptions(@ptrCast(*const IDebugClient7, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetKernelConnectionOptions(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetKernelConnectionOptions(@ptrCast(*const IDebugClient7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_StartProcessServer(self: *const T, Flags: u32, Options: ?[*:0]const u8, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).StartProcessServer(@ptrCast(*const IDebugClient7, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_ConnectProcessServer(self: *const T, RemoteOptions: ?[*:0]const u8, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).ConnectProcessServer(@ptrCast(*const IDebugClient7, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_DisconnectProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).DisconnectProcessServer(@ptrCast(*const IDebugClient7, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessSystemIds(self: *const T, Server: u64, Ids: ?[*]u32, Count: u32, ActualCount: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetRunningProcessSystemIds(@ptrCast(*const IDebugClient7, self), Server, Ids, Count, ActualCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessSystemIdByExecutableName(self: *const T, Server: u64, ExeName: ?[*:0]const u8, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetRunningProcessSystemIdByExecutableName(@ptrCast(*const IDebugClient7, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessDescription(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u8, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetRunningProcessDescription(@ptrCast(*const IDebugClient7, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AttachProcess(self: *const T, Server: u64, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).AttachProcess(@ptrCast(*const IDebugClient7, self), Server, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessA(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugClient7, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessAndAttach(self: *const T, Server: u64, CommandLine: ?PSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateProcessAndAttach(@ptrCast(*const IDebugClient7, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetProcessOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetProcessOptions(@ptrCast(*const IDebugClient7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AddProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).AddProcessOptions(@ptrCast(*const IDebugClient7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_RemoveProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).RemoveProcessOptions(@ptrCast(*const IDebugClient7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetProcessOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetProcessOptions(@ptrCast(*const IDebugClient7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OpenDumpFile(self: *const T, DumpFile: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).OpenDumpFile(@ptrCast(*const IDebugClient7, self), DumpFile);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_WriteDumpFile(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).WriteDumpFile(@ptrCast(*const IDebugClient7, self), DumpFile, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_ConnectSession(self: *const T, Flags: u32, HistoryLimit: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).ConnectSession(@ptrCast(*const IDebugClient7, self), Flags, HistoryLimit);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_StartServer(self: *const T, Options: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).StartServer(@ptrCast(*const IDebugClient7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OutputServers(self: *const T, OutputControl: u32, Machine: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).OutputServers(@ptrCast(*const IDebugClient7, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_TerminateProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).TerminateProcesses(@ptrCast(*const IDebugClient7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_DetachProcesses(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).DetachProcesses(@ptrCast(*const IDebugClient7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_EndSession(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).EndSession(@ptrCast(*const IDebugClient7, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetExitCode(self: *const T, Code: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetExitCode(@ptrCast(*const IDebugClient7, self), Code);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_DispatchCallbacks(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).DispatchCallbacks(@ptrCast(*const IDebugClient7, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_ExitDispatch(self: *const T, Client: ?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).ExitDispatch(@ptrCast(*const IDebugClient7, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateClient(self: *const T, Client: ?*?*IDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateClient(@ptrCast(*const IDebugClient7, self), Client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetInputCallbacks(self: *const T, Callbacks: ?*?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetInputCallbacks(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetInputCallbacks(self: *const T, Callbacks: ?*IDebugInputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetInputCallbacks(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputCallbacks(self: *const T, Callbacks: ?*?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetOutputCallbacks(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputCallbacks(self: *const T, Callbacks: ?*IDebugOutputCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetOutputCallbacks(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetOutputMask(@ptrCast(*const IDebugClient7, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetOutputMask(@ptrCast(*const IDebugClient7, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetOtherOutputMask(@ptrCast(*const IDebugClient7, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOtherOutputMask(self: *const T, Client: ?*IDebugClient, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetOtherOutputMask(@ptrCast(*const IDebugClient7, self), Client, Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputWidth(self: *const T, Columns: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetOutputWidth(@ptrCast(*const IDebugClient7, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputWidth(self: *const T, Columns: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetOutputWidth(@ptrCast(*const IDebugClient7, self), Columns);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputLinePrefix(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetOutputLinePrefix(@ptrCast(*const IDebugClient7, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputLinePrefix(self: *const T, Prefix: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetOutputLinePrefix(@ptrCast(*const IDebugClient7, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetIdentity(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetIdentity(@ptrCast(*const IDebugClient7, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OutputIdentity(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).OutputIdentity(@ptrCast(*const IDebugClient7, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetEventCallbacks(self: *const T, Callbacks: ?*?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetEventCallbacks(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetEventCallbacks(self: *const T, Callbacks: ?*IDebugEventCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetEventCallbacks(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_FlushCallbacks(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).FlushCallbacks(@ptrCast(*const IDebugClient7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_WriteDumpFile2(self: *const T, DumpFile: ?[*:0]const u8, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).WriteDumpFile2(@ptrCast(*const IDebugClient7, self), DumpFile, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AddDumpInformationFile(self: *const T, InfoFile: ?[*:0]const u8, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).AddDumpInformationFile(@ptrCast(*const IDebugClient7, self), InfoFile, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_EndProcessServer(self: *const T, Server: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).EndProcessServer(@ptrCast(*const IDebugClient7, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_WaitForProcessServerEnd(self: *const T, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).WaitForProcessServerEnd(@ptrCast(*const IDebugClient7, self), Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_IsKernelDebuggerEnabled(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).IsKernelDebuggerEnabled(@ptrCast(*const IDebugClient7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_TerminateCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).TerminateCurrentProcess(@ptrCast(*const IDebugClient7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_DetachCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).DetachCurrentProcess(@ptrCast(*const IDebugClient7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AbandonCurrentProcess(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).AbandonCurrentProcess(@ptrCast(*const IDebugClient7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessSystemIdByExecutableNameWide(self: *const T, Server: u64, ExeName: ?[*:0]const u16, Flags: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetRunningProcessSystemIdByExecutableNameWide(@ptrCast(*const IDebugClient7, self), Server, ExeName, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetRunningProcessDescriptionWide(self: *const T, Server: u64, SystemId: u32, Flags: u32, ExeName: ?[*:0]u16, ExeNameSize: u32, ActualExeNameSize: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, ActualDescriptionSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetRunningProcessDescriptionWide(@ptrCast(*const IDebugClient7, self), Server, SystemId, Flags, ExeName, ExeNameSize, ActualExeNameSize, Description, DescriptionSize, ActualDescriptionSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateProcessWide(@ptrCast(*const IDebugClient7, self), Server, CommandLine, CreateFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessAndAttachWide(self: *const T, Server: u64, CommandLine: ?PWSTR, CreateFlags: u32, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateProcessAndAttachWide(@ptrCast(*const IDebugClient7, self), Server, CommandLine, CreateFlags, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OpenDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).OpenDumpFileWide(@ptrCast(*const IDebugClient7, self), FileName, FileHandle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_WriteDumpFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Qualifier: u32, FormatFlags: u32, Comment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).WriteDumpFileWide(@ptrCast(*const IDebugClient7, self), FileName, FileHandle, Qualifier, FormatFlags, Comment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AddDumpInformationFileWide(self: *const T, FileName: ?[*:0]const u16, FileHandle: u64, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).AddDumpInformationFileWide(@ptrCast(*const IDebugClient7, self), FileName, FileHandle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetNumberDumpFiles(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetNumberDumpFiles(@ptrCast(*const IDebugClient7, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetDumpFile(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetDumpFile(@ptrCast(*const IDebugClient7, self), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetDumpFileWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32, Handle: ?*u64, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetDumpFileWide(@ptrCast(*const IDebugClient7, self), Index, Buffer, BufferSize, NameSize, Handle, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_AttachKernelWide(self: *const T, Flags: u32, ConnectOptions: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).AttachKernelWide(@ptrCast(*const IDebugClient7, self), Flags, ConnectOptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetKernelConnectionOptionsWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, OptionsSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetKernelConnectionOptionsWide(@ptrCast(*const IDebugClient7, self), Buffer, BufferSize, OptionsSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetKernelConnectionOptionsWide(self: *const T, Options: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetKernelConnectionOptionsWide(@ptrCast(*const IDebugClient7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_StartProcessServerWide(self: *const T, Flags: u32, Options: ?[*:0]const u16, Reserved: ?*c_void) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).StartProcessServerWide(@ptrCast(*const IDebugClient7, self), Flags, Options, Reserved);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_ConnectProcessServerWide(self: *const T, RemoteOptions: ?[*:0]const u16, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).ConnectProcessServerWide(@ptrCast(*const IDebugClient7, self), RemoteOptions, Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_StartServerWide(self: *const T, Options: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).StartServerWide(@ptrCast(*const IDebugClient7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OutputServersWide(self: *const T, OutputControl: u32, Machine: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).OutputServersWide(@ptrCast(*const IDebugClient7, self), OutputControl, Machine, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputCallbacksWide(self: *const T, Callbacks: ?*?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetOutputCallbacksWide(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputCallbacksWide(self: *const T, Callbacks: ?*IDebugOutputCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetOutputCallbacksWide(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetOutputLinePrefixWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PrefixSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetOutputLinePrefixWide(@ptrCast(*const IDebugClient7, self), Buffer, BufferSize, PrefixSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetOutputLinePrefixWide(self: *const T, Prefix: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetOutputLinePrefixWide(@ptrCast(*const IDebugClient7, self), Prefix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetIdentityWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, IdentitySize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetIdentityWide(@ptrCast(*const IDebugClient7, self), Buffer, BufferSize, IdentitySize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_OutputIdentityWide(self: *const T, OutputControl: u32, Flags: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).OutputIdentityWide(@ptrCast(*const IDebugClient7, self), OutputControl, Flags, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetEventCallbacksWide(self: *const T, Callbacks: ?*?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetEventCallbacksWide(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetEventCallbacksWide(self: *const T, Callbacks: ?*IDebugEventCallbacksWide) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetEventCallbacksWide(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcess2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateProcess2(@ptrCast(*const IDebugClient7, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcess2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateProcess2Wide(@ptrCast(*const IDebugClient7, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessAndAttach2(self: *const T, Server: u64, CommandLine: ?PSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u8, Environment: ?[*:0]const u8, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateProcessAndAttach2(@ptrCast(*const IDebugClient7, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_CreateProcessAndAttach2Wide(self: *const T, Server: u64, CommandLine: ?PWSTR, OptionsBuffer: ?*c_void, OptionsBufferSize: u32, InitialDirectory: ?[*:0]const u16, Environment: ?[*:0]const u16, ProcessId: u32, AttachFlags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).CreateProcessAndAttach2Wide(@ptrCast(*const IDebugClient7, self), Server, CommandLine, OptionsBuffer, OptionsBufferSize, InitialDirectory, Environment, ProcessId, AttachFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_PushOutputLinePrefix(self: *const T, NewPrefix: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).PushOutputLinePrefix(@ptrCast(*const IDebugClient7, self), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_PushOutputLinePrefixWide(self: *const T, NewPrefix: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).PushOutputLinePrefixWide(@ptrCast(*const IDebugClient7, self), NewPrefix, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_PopOutputLinePrefix(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).PopOutputLinePrefix(@ptrCast(*const IDebugClient7, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetNumberInputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetNumberInputCallbacks(@ptrCast(*const IDebugClient7, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetNumberOutputCallbacks(self: *const T, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetNumberOutputCallbacks(@ptrCast(*const IDebugClient7, self), Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetNumberEventCallbacks(self: *const T, EventFlags: u32, Count: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetNumberEventCallbacks(@ptrCast(*const IDebugClient7, self), EventFlags, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetQuitLockString(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetQuitLockString(@ptrCast(*const IDebugClient7, self), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetQuitLockString(self: *const T, String: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetQuitLockString(@ptrCast(*const IDebugClient7, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_GetQuitLockStringWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).GetQuitLockStringWide(@ptrCast(*const IDebugClient7, self), Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetQuitLockStringWide(self: *const T, String: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetQuitLockStringWide(@ptrCast(*const IDebugClient7, self), String);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetEventContextCallbacks(self: *const T, Callbacks: ?*IDebugEventContextCallbacks) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetEventContextCallbacks(@ptrCast(*const IDebugClient7, self), Callbacks);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugClient7_SetClientContext(self: *const T, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugClient7.VTable, self.vtable).SetClientContext(@ptrCast(*const IDebugClient7, self), Context, ContextSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient_Value = @import("../../zig.zig").Guid.initString("a02b66c4-aea3-4234-a9f7-fe4c383d4e29");
pub const IID_IDebugPlmClient = &IID_IDebugPlmClient_Value;
pub const IDebugPlmClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: fn(
            self: *const IDebugPlmClient,
            Server: u64,
            Timeout: u32,
            PackageFullName: ?[*:0]const u16,
            AppName: ?[*:0]const u16,
            Arguments: ?[*:0]const u16,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, AppName: ?[*:0]const u16, Arguments: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient.VTable, self.vtable).LaunchPlmPackageForDebugWide(@ptrCast(*const IDebugPlmClient, self), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient2_Value = @import("../../zig.zig").Guid.initString("597c980d-e7bd-4309-962c-9d9b69a7372c");
pub const IID_IDebugPlmClient2 = &IID_IDebugPlmClient2_Value;
pub const IDebugPlmClient2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: fn(
            self: *const IDebugPlmClient2,
            Server: u64,
            Timeout: u32,
            PackageFullName: ?[*:0]const u16,
            AppName: ?[*:0]const u16,
            Arguments: ?[*:0]const u16,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchPlmBgTaskForDebugWide: fn(
            self: *const IDebugPlmClient2,
            Server: u64,
            Timeout: u32,
            PackageFullName: ?[*:0]const u16,
            BackgroundTaskId: ?[*:0]const u16,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient2_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, AppName: ?[*:0]const u16, Arguments: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient2.VTable, self.vtable).LaunchPlmPackageForDebugWide(@ptrCast(*const IDebugPlmClient2, self), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient2_LaunchPlmBgTaskForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, BackgroundTaskId: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient2.VTable, self.vtable).LaunchPlmBgTaskForDebugWide(@ptrCast(*const IDebugPlmClient2, self), Server, Timeout, PackageFullName, BackgroundTaskId, ProcessId, ThreadId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugPlmClient3_Value = @import("../../zig.zig").Guid.initString("d4a5dbd1-ca02-4d90-856a-2a92bfd0f20f");
pub const IID_IDebugPlmClient3 = &IID_IDebugPlmClient3_Value;
pub const IDebugPlmClient3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        LaunchPlmPackageForDebugWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            Timeout: u32,
            PackageFullName: ?[*:0]const u16,
            AppName: ?[*:0]const u16,
            Arguments: ?[*:0]const u16,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchPlmBgTaskForDebugWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            Timeout: u32,
            PackageFullName: ?[*:0]const u16,
            BackgroundTaskId: ?[*:0]const u16,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPlmPackageWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            PackageFullName: ?[*:0]const u16,
            Stream: ?*IDebugOutputStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryPlmPackageList: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            Stream: ?*IDebugOutputStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnablePlmPackageDebugWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            PackageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisablePlmPackageDebugWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            PackageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SuspendPlmPackageWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            PackageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResumePlmPackageWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            PackageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TerminatePlmPackageWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            PackageFullName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        LaunchAndDebugPlmAppWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            PackageFullName: ?[*:0]const u16,
            AppName: ?[*:0]const u16,
            Arguments: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ActivateAndDebugPlmBgTaskWide: fn(
            self: *const IDebugPlmClient3,
            Server: u64,
            PackageFullName: ?[*:0]const u16,
            BackgroundTaskId: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_LaunchPlmPackageForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, AppName: ?[*:0]const u16, Arguments: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).LaunchPlmPackageForDebugWide(@ptrCast(*const IDebugPlmClient3, self), Server, Timeout, PackageFullName, AppName, Arguments, ProcessId, ThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_LaunchPlmBgTaskForDebugWide(self: *const T, Server: u64, Timeout: u32, PackageFullName: ?[*:0]const u16, BackgroundTaskId: ?[*:0]const u16, ProcessId: ?*u32, ThreadId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).LaunchPlmBgTaskForDebugWide(@ptrCast(*const IDebugPlmClient3, self), Server, Timeout, PackageFullName, BackgroundTaskId, ProcessId, ThreadId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_QueryPlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16, Stream: ?*IDebugOutputStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).QueryPlmPackageWide(@ptrCast(*const IDebugPlmClient3, self), Server, PackageFullName, Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_QueryPlmPackageList(self: *const T, Server: u64, Stream: ?*IDebugOutputStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).QueryPlmPackageList(@ptrCast(*const IDebugPlmClient3, self), Server, Stream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_EnablePlmPackageDebugWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).EnablePlmPackageDebugWide(@ptrCast(*const IDebugPlmClient3, self), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_DisablePlmPackageDebugWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).DisablePlmPackageDebugWide(@ptrCast(*const IDebugPlmClient3, self), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_SuspendPlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).SuspendPlmPackageWide(@ptrCast(*const IDebugPlmClient3, self), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_ResumePlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).ResumePlmPackageWide(@ptrCast(*const IDebugPlmClient3, self), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_TerminatePlmPackageWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).TerminatePlmPackageWide(@ptrCast(*const IDebugPlmClient3, self), Server, PackageFullName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_LaunchAndDebugPlmAppWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16, AppName: ?[*:0]const u16, Arguments: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).LaunchAndDebugPlmAppWide(@ptrCast(*const IDebugPlmClient3, self), Server, PackageFullName, AppName, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugPlmClient3_ActivateAndDebugPlmBgTaskWide(self: *const T, Server: u64, PackageFullName: ?[*:0]const u16, BackgroundTaskId: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugPlmClient3.VTable, self.vtable).ActivateAndDebugPlmBgTaskWide(@ptrCast(*const IDebugPlmClient3, self), Server, PackageFullName, BackgroundTaskId);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputStream_Value = @import("../../zig.zig").Guid.initString("7782d8f2-2b85-4059-ab88-28ceddca1c80");
pub const IID_IDebugOutputStream = &IID_IDebugOutputStream_Value;
pub const IDebugOutputStream = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Write: fn(
            self: *const IDebugOutputStream,
            psz: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputStream_Write(self: *const T, psz: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugOutputStream.VTable, self.vtable).Write(@ptrCast(*const IDebugOutputStream, self), psz);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_STACK_FRAME = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [6]u64,
    Virtual: BOOL,
    FrameNumber: u32,
};

pub const DEBUG_STACK_FRAME_EX = extern struct {
    InstructionOffset: u64,
    ReturnOffset: u64,
    FrameOffset: u64,
    StackOffset: u64,
    FuncTableEntry: u64,
    Params: [4]u64,
    Reserved: [6]u64,
    Virtual: BOOL,
    FrameNumber: u32,
    InlineFrameContext: u32,
    Reserved1: u32,
};

pub const INLINE_FRAME_CONTEXT = extern union {
    ContextValue: u32,
    Anonymous: extern struct {
        FrameId: u8,
        FrameType: u8,
        FrameSignature: u16,
    },
};

pub const STACK_SRC_INFO = extern struct {
    ImagePath: ?[*:0]const u16,
    ModuleName: ?[*:0]const u16,
    Function: ?[*:0]const u16,
    Displacement: u32,
    Row: u32,
    Column: u32,
};

pub const STACK_SYM_FRAME_INFO = extern struct {
    StackFrameEx: DEBUG_STACK_FRAME_EX,
    SrcInfo: STACK_SRC_INFO,
};

pub const DEBUG_SPECIFIC_FILTER_PARAMETERS = extern struct {
    ExecutionOption: u32,
    ContinueOption: u32,
    TextSize: u32,
    CommandSize: u32,
    ArgumentSize: u32,
};

pub const DEBUG_EXCEPTION_FILTER_PARAMETERS = extern struct {
    ExecutionOption: u32,
    ContinueOption: u32,
    TextSize: u32,
    CommandSize: u32,
    SecondCommandSize: u32,
    ExceptionCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_BREAKPOINT = extern struct {
    Id: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXCEPTION = extern struct {
    ExceptionRecord: EXCEPTION_RECORD64,
    FirstChance: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXIT_THREAD = extern struct {
    ExitCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_EXIT_PROCESS = extern struct {
    ExitCode: u32,
};

pub const DEBUG_LAST_EVENT_INFO_LOAD_MODULE = extern struct {
    Base: u64,
};

pub const DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE = extern struct {
    Base: u64,
};

pub const DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR = extern struct {
    Error: u32,
    Level: u32,
};

pub const DEBUG_LAST_EVENT_INFO_SERVICE_EXCEPTION = extern struct {
    Kind: u32,
    DataSize: u32,
    Address: u64,
};

pub const DEBUG_VALUE = extern struct {
    Anonymous: extern union {
        I8: u8,
        I16: u16,
        I32: u32,
        Anonymous: extern struct {
            I64: u64,
            Nat: BOOL,
        },
        F32: f32,
        F64: f64,
        F80Bytes: [10]u8,
        F82Bytes: [11]u8,
        F128Bytes: [16]u8,
        VI8: [16]u8,
        VI16: [8]u16,
        VI32: [4]u32,
        VI64: [2]u64,
        VF32: [4]f32,
        VF64: [2]f64,
        I64Parts32: extern struct {
            LowPart: u32,
            HighPart: u32,
        },
        F128Parts64: extern struct {
            LowPart: u64,
            HighPart: i64,
        },
        RawBytes: [24]u8,
    },
    TailOfRawBytes: u32,
    Type: u32,
};

const IID_IDebugControl_Value = @import("../../zig.zig").Guid.initString("5182e668-105e-416e-ad92-24ef800424ba");
pub const IID_IDebugControl = &IID_IDebugControl_Value;
pub const IDebugControl = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: fn(
            self: *const IDebugControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterrupt: fn(
            self: *const IDebugControl,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterruptTimeout: fn(
            self: *const IDebugControl,
            Seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterruptTimeout: fn(
            self: *const IDebugControl,
            Seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile: fn(
            self: *const IDebugControl,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile: fn(
            self: *const IDebugControl,
            File: ?[*:0]const u8,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLogFile: fn(
            self: *const IDebugControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogMask: fn(
            self: *const IDebugControl,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogMask: fn(
            self: *const IDebugControl,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Input: fn(
            self: *const IDebugControl,
            Buffer: [*:0]u8,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInput: fn(
            self: *const IDebugControl,
            Buffer: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Output: fn(
            self: *const IDebugControl,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaList: fn(
            self: *const IDebugControl,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutput: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaList: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPrompt: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaList: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptText: fn(
            self: *const IDebugControl,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputCurrentState: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVersionInformation: fn(
            self: *const IDebugControl,
            OutputControl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyEventHandle: fn(
            self: *const IDebugControl,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyEventHandle: fn(
            self: *const IDebugControl,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Assemble: fn(
            self: *const IDebugControl,
            Offset: u64,
            Instr: ?[*:0]const u8,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassemble: fn(
            self: *const IDebugControl,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisassembleEffectiveOffset: fn(
            self: *const IDebugControl,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassembly: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            Offset: u64,
            Flags: u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassemblyLines: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            PreviousLines: u32,
            TotalLines: u32,
            Offset: u64,
            Flags: u32,
            OffsetLine: ?*u32,
            StartOffset: ?*u64,
            EndOffset: ?*u64,
            LineOffsets: ?[*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearInstruction: fn(
            self: *const IDebugControl,
            Offset: u64,
            Delta: i32,
            NearOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTrace: fn(
            self: *const IDebugControl,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReturnOffset: fn(
            self: *const IDebugControl,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTrace: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebuggeeType: fn(
            self: *const IDebugControl,
            Class: ?*u32,
            Qualifier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualProcessorType: fn(
            self: *const IDebugControl,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutingProcessorType: fn(
            self: *const IDebugControl,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcessors: fn(
            self: *const IDebugControl,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersion: fn(
            self: *const IDebugControl,
            PlatformId: ?*u32,
            Major: ?*u32,
            Minor: ?*u32,
            ServicePackString: ?[*:0]u8,
            ServicePackStringSize: u32,
            ServicePackStringUsed: ?*u32,
            ServicePackNumber: ?*u32,
            BuildString: ?[*:0]u8,
            BuildStringSize: u32,
            BuildStringUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageSize: fn(
            self: *const IDebugControl,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPointer64Bit: fn(
            self: *const IDebugControl,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBugCheckData: fn(
            self: *const IDebugControl,
            Code: ?*u32,
            Arg1: ?*u64,
            Arg2: ?*u64,
            Arg3: ?*u64,
            Arg4: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSupportedProcessorTypes: fn(
            self: *const IDebugControl,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProcessorTypes: fn(
            self: *const IDebugControl,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNames: fn(
            self: *const IDebugControl,
            Type: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectiveProcessorType: fn(
            self: *const IDebugControl,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectiveProcessorType: fn(
            self: *const IDebugControl,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatus: fn(
            self: *const IDebugControl,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExecutionStatus: fn(
            self: *const IDebugControl,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeLevel: fn(
            self: *const IDebugControl,
            Level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCodeLevel: fn(
            self: *const IDebugControl,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineOptions: fn(
            self: *const IDebugControl,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEngineOptions: fn(
            self: *const IDebugControl,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEngineOptions: fn(
            self: *const IDebugControl,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineOptions: fn(
            self: *const IDebugControl,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemErrorControl: fn(
            self: *const IDebugControl,
            OutputLevel: ?*u32,
            BreakLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSystemErrorControl: fn(
            self: *const IDebugControl,
            OutputLevel: u32,
            BreakLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacro: fn(
            self: *const IDebugControl,
            Slot: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacro: fn(
            self: *const IDebugControl,
            Slot: u32,
            Macro: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRadix: fn(
            self: *const IDebugControl,
            Radix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRadix: fn(
            self: *const IDebugControl,
            Radix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Evaluate: fn(
            self: *const IDebugControl,
            Expression: ?[*:0]const u8,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValue: fn(
            self: *const IDebugControl,
            In: ?*DEBUG_VALUE,
            OutType: u32,
            Out: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValues: fn(
            self: *const IDebugControl,
            Count: u32,
            In: [*]DEBUG_VALUE,
            OutTypes: [*]u32,
            Out: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            Command: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFile: fn(
            self: *const IDebugControl,
            OutputControl: u32,
            CommandFile: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberBreakpoints: fn(
            self: *const IDebugControl,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex: fn(
            self: *const IDebugControl,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById: fn(
            self: *const IDebugControl,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointParameters: fn(
            self: *const IDebugControl,
            Count: u32,
            Ids: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint: fn(
            self: *const IDebugControl,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint: fn(
            self: *const IDebugControl,
            Bp: ?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IDebugControl,
            Path: ?[*:0]const u8,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: fn(
            self: *const IDebugControl,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPath: fn(
            self: *const IDebugControl,
            Path: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtension: fn(
            self: *const IDebugControl,
            Handle: u64,
            Function: ?[*:0]const u8,
            Arguments: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunction: fn(
            self: *const IDebugControl,
            Handle: u64,
            FuncName: ?[*:0]const u8,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis32: fn(
            self: *const IDebugControl,
            Api: ?*WINDBG_EXTENSION_APIS32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis64: fn(
            self: *const IDebugControl,
            Api: ?*WINDBG_EXTENSION_APIS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventFilters: fn(
            self: *const IDebugControl,
            SpecificEvents: ?*u32,
            SpecificExceptions: ?*u32,
            ArbitraryExceptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterText: fn(
            self: *const IDebugControl,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommand: fn(
            self: *const IDebugControl,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommand: fn(
            self: *const IDebugControl,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterParameters: fn(
            self: *const IDebugControl,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterParameters: fn(
            self: *const IDebugControl,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgument: fn(
            self: *const IDebugControl,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgument: fn(
            self: *const IDebugControl,
            Index: u32,
            Argument: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterParameters: fn(
            self: *const IDebugControl,
            Count: u32,
            Codes: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterParameters: fn(
            self: *const IDebugControl,
            Count: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEvent: fn(
            self: *const IDebugControl,
            Flags: u32,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformation: fn(
            self: *const IDebugControl,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetInterrupt(@ptrCast(*const IDebugControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetInterrupt(@ptrCast(*const IDebugControl, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetInterruptTimeout(@ptrCast(*const IDebugControl, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetInterruptTimeout(@ptrCast(*const IDebugControl, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetLogFile(@ptrCast(*const IDebugControl, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OpenLogFile(@ptrCast(*const IDebugControl, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).CloseLogFile(@ptrCast(*const IDebugControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetLogMask(@ptrCast(*const IDebugControl, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetLogMask(@ptrCast(*const IDebugControl, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).Input(@ptrCast(*const IDebugControl, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).ReturnInput(@ptrCast(*const IDebugControl, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).Output(@ptrCast(*const IDebugControl, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OutputVaList(@ptrCast(*const IDebugControl, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).ControlledOutput(@ptrCast(*const IDebugControl, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).ControlledOutputVaList(@ptrCast(*const IDebugControl, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OutputPrompt(@ptrCast(*const IDebugControl, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OutputPromptVaList(@ptrCast(*const IDebugControl, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetPromptText(@ptrCast(*const IDebugControl, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OutputCurrentState(@ptrCast(*const IDebugControl, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OutputVersionInformation(@ptrCast(*const IDebugControl, self), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetNotifyEventHandle(@ptrCast(*const IDebugControl, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetNotifyEventHandle(@ptrCast(*const IDebugControl, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).Assemble(@ptrCast(*const IDebugControl, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).Disassemble(@ptrCast(*const IDebugControl, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetDisassembleEffectiveOffset(@ptrCast(*const IDebugControl, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OutputDisassembly(@ptrCast(*const IDebugControl, self), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OutputDisassemblyLines(@ptrCast(*const IDebugControl, self), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetNearInstruction(@ptrCast(*const IDebugControl, self), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetStackTrace(@ptrCast(*const IDebugControl, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetReturnOffset(@ptrCast(*const IDebugControl, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).OutputStackTrace(@ptrCast(*const IDebugControl, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetDebuggeeType(@ptrCast(*const IDebugControl, self), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetActualProcessorType(@ptrCast(*const IDebugControl, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetExecutingProcessorType(@ptrCast(*const IDebugControl, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetNumberPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetNumberProcessors(@ptrCast(*const IDebugControl, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetSystemVersion(@ptrCast(*const IDebugControl, self), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetPageSize(@ptrCast(*const IDebugControl, self), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).IsPointer64Bit(@ptrCast(*const IDebugControl, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).ReadBugCheckData(@ptrCast(*const IDebugControl, self), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetNumberSupportedProcessorTypes(@ptrCast(*const IDebugControl, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetSupportedProcessorTypes(@ptrCast(*const IDebugControl, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetProcessorTypeNames(@ptrCast(*const IDebugControl, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetEffectiveProcessorType(@ptrCast(*const IDebugControl, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetEffectiveProcessorType(@ptrCast(*const IDebugControl, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetExecutionStatus(@ptrCast(*const IDebugControl, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetExecutionStatus(@ptrCast(*const IDebugControl, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetCodeLevel(@ptrCast(*const IDebugControl, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetCodeLevel(@ptrCast(*const IDebugControl, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetEngineOptions(@ptrCast(*const IDebugControl, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).AddEngineOptions(@ptrCast(*const IDebugControl, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).RemoveEngineOptions(@ptrCast(*const IDebugControl, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetEngineOptions(@ptrCast(*const IDebugControl, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetSystemErrorControl(@ptrCast(*const IDebugControl, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetSystemErrorControl(@ptrCast(*const IDebugControl, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetTextMacro(@ptrCast(*const IDebugControl, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetTextMacro(@ptrCast(*const IDebugControl, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetRadix(@ptrCast(*const IDebugControl, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetRadix(@ptrCast(*const IDebugControl, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).Evaluate(@ptrCast(*const IDebugControl, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).CoerceValue(@ptrCast(*const IDebugControl, self), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).CoerceValues(@ptrCast(*const IDebugControl, self), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).Execute(@ptrCast(*const IDebugControl, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).ExecuteCommandFile(@ptrCast(*const IDebugControl, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetNumberBreakpoints(@ptrCast(*const IDebugControl, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetBreakpointByIndex(@ptrCast(*const IDebugControl, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetBreakpointById(@ptrCast(*const IDebugControl, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetBreakpointParameters(@ptrCast(*const IDebugControl, self), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).AddBreakpoint(@ptrCast(*const IDebugControl, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).RemoveBreakpoint(@ptrCast(*const IDebugControl, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).AddExtension(@ptrCast(*const IDebugControl, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).RemoveExtension(@ptrCast(*const IDebugControl, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetExtensionByPath(@ptrCast(*const IDebugControl, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).CallExtension(@ptrCast(*const IDebugControl, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetExtensionFunction(@ptrCast(*const IDebugControl, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetWindbgExtensionApis32(@ptrCast(*const IDebugControl, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetWindbgExtensionApis64(@ptrCast(*const IDebugControl, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetNumberEventFilters(@ptrCast(*const IDebugControl, self), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetEventFilterText(@ptrCast(*const IDebugControl, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetEventFilterCommand(@ptrCast(*const IDebugControl, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetEventFilterCommand(@ptrCast(*const IDebugControl, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetSpecificFilterParameters(@ptrCast(*const IDebugControl, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetSpecificFilterParameters(@ptrCast(*const IDebugControl, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetSpecificFilterArgument(@ptrCast(*const IDebugControl, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetSpecificFilterArgument(@ptrCast(*const IDebugControl, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetExceptionFilterParameters(@ptrCast(*const IDebugControl, self), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetExceptionFilterParameters(@ptrCast(*const IDebugControl, self), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).SetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).WaitForEvent(@ptrCast(*const IDebugControl, self), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl.VTable, self.vtable).GetLastEventInformation(@ptrCast(*const IDebugControl, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl2_Value = @import("../../zig.zig").Guid.initString("d4366723-44df-4bed-8c7e-4c05424f4588");
pub const IID_IDebugControl2 = &IID_IDebugControl2_Value;
pub const IDebugControl2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: fn(
            self: *const IDebugControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterrupt: fn(
            self: *const IDebugControl2,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterruptTimeout: fn(
            self: *const IDebugControl2,
            Seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterruptTimeout: fn(
            self: *const IDebugControl2,
            Seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile: fn(
            self: *const IDebugControl2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile: fn(
            self: *const IDebugControl2,
            File: ?[*:0]const u8,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLogFile: fn(
            self: *const IDebugControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogMask: fn(
            self: *const IDebugControl2,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogMask: fn(
            self: *const IDebugControl2,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Input: fn(
            self: *const IDebugControl2,
            Buffer: [*:0]u8,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInput: fn(
            self: *const IDebugControl2,
            Buffer: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Output: fn(
            self: *const IDebugControl2,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaList: fn(
            self: *const IDebugControl2,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutput: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaList: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPrompt: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaList: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptText: fn(
            self: *const IDebugControl2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputCurrentState: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVersionInformation: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyEventHandle: fn(
            self: *const IDebugControl2,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyEventHandle: fn(
            self: *const IDebugControl2,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Assemble: fn(
            self: *const IDebugControl2,
            Offset: u64,
            Instr: ?[*:0]const u8,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassemble: fn(
            self: *const IDebugControl2,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisassembleEffectiveOffset: fn(
            self: *const IDebugControl2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassembly: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Offset: u64,
            Flags: u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassemblyLines: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            PreviousLines: u32,
            TotalLines: u32,
            Offset: u64,
            Flags: u32,
            OffsetLine: ?*u32,
            StartOffset: ?*u64,
            EndOffset: ?*u64,
            LineOffsets: ?[*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearInstruction: fn(
            self: *const IDebugControl2,
            Offset: u64,
            Delta: i32,
            NearOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTrace: fn(
            self: *const IDebugControl2,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReturnOffset: fn(
            self: *const IDebugControl2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTrace: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebuggeeType: fn(
            self: *const IDebugControl2,
            Class: ?*u32,
            Qualifier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualProcessorType: fn(
            self: *const IDebugControl2,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutingProcessorType: fn(
            self: *const IDebugControl2,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl2,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcessors: fn(
            self: *const IDebugControl2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersion: fn(
            self: *const IDebugControl2,
            PlatformId: ?*u32,
            Major: ?*u32,
            Minor: ?*u32,
            ServicePackString: ?[*:0]u8,
            ServicePackStringSize: u32,
            ServicePackStringUsed: ?*u32,
            ServicePackNumber: ?*u32,
            BuildString: ?[*:0]u8,
            BuildStringSize: u32,
            BuildStringUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageSize: fn(
            self: *const IDebugControl2,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPointer64Bit: fn(
            self: *const IDebugControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBugCheckData: fn(
            self: *const IDebugControl2,
            Code: ?*u32,
            Arg1: ?*u64,
            Arg2: ?*u64,
            Arg3: ?*u64,
            Arg4: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSupportedProcessorTypes: fn(
            self: *const IDebugControl2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProcessorTypes: fn(
            self: *const IDebugControl2,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNames: fn(
            self: *const IDebugControl2,
            Type: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectiveProcessorType: fn(
            self: *const IDebugControl2,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectiveProcessorType: fn(
            self: *const IDebugControl2,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatus: fn(
            self: *const IDebugControl2,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExecutionStatus: fn(
            self: *const IDebugControl2,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeLevel: fn(
            self: *const IDebugControl2,
            Level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCodeLevel: fn(
            self: *const IDebugControl2,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineOptions: fn(
            self: *const IDebugControl2,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEngineOptions: fn(
            self: *const IDebugControl2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEngineOptions: fn(
            self: *const IDebugControl2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineOptions: fn(
            self: *const IDebugControl2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemErrorControl: fn(
            self: *const IDebugControl2,
            OutputLevel: ?*u32,
            BreakLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSystemErrorControl: fn(
            self: *const IDebugControl2,
            OutputLevel: u32,
            BreakLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacro: fn(
            self: *const IDebugControl2,
            Slot: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacro: fn(
            self: *const IDebugControl2,
            Slot: u32,
            Macro: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRadix: fn(
            self: *const IDebugControl2,
            Radix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRadix: fn(
            self: *const IDebugControl2,
            Radix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Evaluate: fn(
            self: *const IDebugControl2,
            Expression: ?[*:0]const u8,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValue: fn(
            self: *const IDebugControl2,
            In: ?*DEBUG_VALUE,
            OutType: u32,
            Out: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValues: fn(
            self: *const IDebugControl2,
            Count: u32,
            In: [*]DEBUG_VALUE,
            OutTypes: [*]u32,
            Out: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Command: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFile: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            CommandFile: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberBreakpoints: fn(
            self: *const IDebugControl2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex: fn(
            self: *const IDebugControl2,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById: fn(
            self: *const IDebugControl2,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointParameters: fn(
            self: *const IDebugControl2,
            Count: u32,
            Ids: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint: fn(
            self: *const IDebugControl2,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint: fn(
            self: *const IDebugControl2,
            Bp: ?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IDebugControl2,
            Path: ?[*:0]const u8,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: fn(
            self: *const IDebugControl2,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPath: fn(
            self: *const IDebugControl2,
            Path: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtension: fn(
            self: *const IDebugControl2,
            Handle: u64,
            Function: ?[*:0]const u8,
            Arguments: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunction: fn(
            self: *const IDebugControl2,
            Handle: u64,
            FuncName: ?[*:0]const u8,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis32: fn(
            self: *const IDebugControl2,
            Api: ?*WINDBG_EXTENSION_APIS32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis64: fn(
            self: *const IDebugControl2,
            Api: ?*WINDBG_EXTENSION_APIS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventFilters: fn(
            self: *const IDebugControl2,
            SpecificEvents: ?*u32,
            SpecificExceptions: ?*u32,
            ArbitraryExceptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterText: fn(
            self: *const IDebugControl2,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommand: fn(
            self: *const IDebugControl2,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommand: fn(
            self: *const IDebugControl2,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterParameters: fn(
            self: *const IDebugControl2,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterParameters: fn(
            self: *const IDebugControl2,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgument: fn(
            self: *const IDebugControl2,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgument: fn(
            self: *const IDebugControl2,
            Index: u32,
            Argument: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterParameters: fn(
            self: *const IDebugControl2,
            Count: u32,
            Codes: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterParameters: fn(
            self: *const IDebugControl2,
            Count: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl2,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl2,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEvent: fn(
            self: *const IDebugControl2,
            Flags: u32,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformation: fn(
            self: *const IDebugControl2,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTimeDate: fn(
            self: *const IDebugControl2,
            TimeDate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemUpTime: fn(
            self: *const IDebugControl2,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFormatFlags: fn(
            self: *const IDebugControl2,
            FormatFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberTextReplacements: fn(
            self: *const IDebugControl2,
            NumRepl: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacement: fn(
            self: *const IDebugControl2,
            SrcText: ?[*:0]const u8,
            Index: u32,
            SrcBuffer: ?[*:0]u8,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u8,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacement: fn(
            self: *const IDebugControl2,
            SrcText: ?[*:0]const u8,
            DstText: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextReplacements: fn(
            self: *const IDebugControl2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTextReplacements: fn(
            self: *const IDebugControl2,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetInterrupt(@ptrCast(*const IDebugControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetInterrupt(@ptrCast(*const IDebugControl2, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetInterruptTimeout(@ptrCast(*const IDebugControl2, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetInterruptTimeout(@ptrCast(*const IDebugControl2, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetLogFile(@ptrCast(*const IDebugControl2, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OpenLogFile(@ptrCast(*const IDebugControl2, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).CloseLogFile(@ptrCast(*const IDebugControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetLogMask(@ptrCast(*const IDebugControl2, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetLogMask(@ptrCast(*const IDebugControl2, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).Input(@ptrCast(*const IDebugControl2, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).ReturnInput(@ptrCast(*const IDebugControl2, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).Output(@ptrCast(*const IDebugControl2, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputVaList(@ptrCast(*const IDebugControl2, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).ControlledOutput(@ptrCast(*const IDebugControl2, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).ControlledOutputVaList(@ptrCast(*const IDebugControl2, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputPrompt(@ptrCast(*const IDebugControl2, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputPromptVaList(@ptrCast(*const IDebugControl2, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetPromptText(@ptrCast(*const IDebugControl2, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputCurrentState(@ptrCast(*const IDebugControl2, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputVersionInformation(@ptrCast(*const IDebugControl2, self), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetNotifyEventHandle(@ptrCast(*const IDebugControl2, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetNotifyEventHandle(@ptrCast(*const IDebugControl2, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).Assemble(@ptrCast(*const IDebugControl2, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).Disassemble(@ptrCast(*const IDebugControl2, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetDisassembleEffectiveOffset(@ptrCast(*const IDebugControl2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputDisassembly(@ptrCast(*const IDebugControl2, self), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputDisassemblyLines(@ptrCast(*const IDebugControl2, self), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetNearInstruction(@ptrCast(*const IDebugControl2, self), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetStackTrace(@ptrCast(*const IDebugControl2, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetReturnOffset(@ptrCast(*const IDebugControl2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputStackTrace(@ptrCast(*const IDebugControl2, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetDebuggeeType(@ptrCast(*const IDebugControl2, self), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetActualProcessorType(@ptrCast(*const IDebugControl2, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetExecutingProcessorType(@ptrCast(*const IDebugControl2, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetNumberPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl2, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetNumberProcessors(@ptrCast(*const IDebugControl2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetSystemVersion(@ptrCast(*const IDebugControl2, self), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetPageSize(@ptrCast(*const IDebugControl2, self), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).IsPointer64Bit(@ptrCast(*const IDebugControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).ReadBugCheckData(@ptrCast(*const IDebugControl2, self), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetNumberSupportedProcessorTypes(@ptrCast(*const IDebugControl2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetSupportedProcessorTypes(@ptrCast(*const IDebugControl2, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetProcessorTypeNames(@ptrCast(*const IDebugControl2, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetEffectiveProcessorType(@ptrCast(*const IDebugControl2, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetEffectiveProcessorType(@ptrCast(*const IDebugControl2, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetExecutionStatus(@ptrCast(*const IDebugControl2, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetExecutionStatus(@ptrCast(*const IDebugControl2, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetCodeLevel(@ptrCast(*const IDebugControl2, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetCodeLevel(@ptrCast(*const IDebugControl2, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetEngineOptions(@ptrCast(*const IDebugControl2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).AddEngineOptions(@ptrCast(*const IDebugControl2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).RemoveEngineOptions(@ptrCast(*const IDebugControl2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetEngineOptions(@ptrCast(*const IDebugControl2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetSystemErrorControl(@ptrCast(*const IDebugControl2, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetSystemErrorControl(@ptrCast(*const IDebugControl2, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetTextMacro(@ptrCast(*const IDebugControl2, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetTextMacro(@ptrCast(*const IDebugControl2, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetRadix(@ptrCast(*const IDebugControl2, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetRadix(@ptrCast(*const IDebugControl2, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).Evaluate(@ptrCast(*const IDebugControl2, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).CoerceValue(@ptrCast(*const IDebugControl2, self), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).CoerceValues(@ptrCast(*const IDebugControl2, self), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).Execute(@ptrCast(*const IDebugControl2, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).ExecuteCommandFile(@ptrCast(*const IDebugControl2, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetNumberBreakpoints(@ptrCast(*const IDebugControl2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetBreakpointByIndex(@ptrCast(*const IDebugControl2, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetBreakpointById(@ptrCast(*const IDebugControl2, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetBreakpointParameters(@ptrCast(*const IDebugControl2, self), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).AddBreakpoint(@ptrCast(*const IDebugControl2, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).RemoveBreakpoint(@ptrCast(*const IDebugControl2, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).AddExtension(@ptrCast(*const IDebugControl2, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).RemoveExtension(@ptrCast(*const IDebugControl2, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetExtensionByPath(@ptrCast(*const IDebugControl2, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).CallExtension(@ptrCast(*const IDebugControl2, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetExtensionFunction(@ptrCast(*const IDebugControl2, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetWindbgExtensionApis32(@ptrCast(*const IDebugControl2, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetWindbgExtensionApis64(@ptrCast(*const IDebugControl2, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetNumberEventFilters(@ptrCast(*const IDebugControl2, self), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetEventFilterText(@ptrCast(*const IDebugControl2, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetEventFilterCommand(@ptrCast(*const IDebugControl2, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetEventFilterCommand(@ptrCast(*const IDebugControl2, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetSpecificFilterParameters(@ptrCast(*const IDebugControl2, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetSpecificFilterParameters(@ptrCast(*const IDebugControl2, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetSpecificFilterArgument(@ptrCast(*const IDebugControl2, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetSpecificFilterArgument(@ptrCast(*const IDebugControl2, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetExceptionFilterParameters(@ptrCast(*const IDebugControl2, self), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetExceptionFilterParameters(@ptrCast(*const IDebugControl2, self), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl2, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl2, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).WaitForEvent(@ptrCast(*const IDebugControl2, self), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetLastEventInformation(@ptrCast(*const IDebugControl2, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetCurrentTimeDate(@ptrCast(*const IDebugControl2, self), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetCurrentSystemUpTime(@ptrCast(*const IDebugControl2, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetDumpFormatFlags(@ptrCast(*const IDebugControl2, self), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetNumberTextReplacements(@ptrCast(*const IDebugControl2, self), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).GetTextReplacement(@ptrCast(*const IDebugControl2, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).SetTextReplacement(@ptrCast(*const IDebugControl2, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).RemoveTextReplacements(@ptrCast(*const IDebugControl2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl2_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl2.VTable, self.vtable).OutputTextReplacements(@ptrCast(*const IDebugControl2, self), OutputControl, Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl3_Value = @import("../../zig.zig").Guid.initString("7df74a86-b03f-407f-90ab-a20dadcead08");
pub const IID_IDebugControl3 = &IID_IDebugControl3_Value;
pub const IDebugControl3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: fn(
            self: *const IDebugControl3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterrupt: fn(
            self: *const IDebugControl3,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterruptTimeout: fn(
            self: *const IDebugControl3,
            Seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterruptTimeout: fn(
            self: *const IDebugControl3,
            Seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile: fn(
            self: *const IDebugControl3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile: fn(
            self: *const IDebugControl3,
            File: ?[*:0]const u8,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLogFile: fn(
            self: *const IDebugControl3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogMask: fn(
            self: *const IDebugControl3,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogMask: fn(
            self: *const IDebugControl3,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Input: fn(
            self: *const IDebugControl3,
            Buffer: [*:0]u8,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInput: fn(
            self: *const IDebugControl3,
            Buffer: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Output: fn(
            self: *const IDebugControl3,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaList: fn(
            self: *const IDebugControl3,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutput: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaList: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPrompt: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaList: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptText: fn(
            self: *const IDebugControl3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputCurrentState: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVersionInformation: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyEventHandle: fn(
            self: *const IDebugControl3,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyEventHandle: fn(
            self: *const IDebugControl3,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Assemble: fn(
            self: *const IDebugControl3,
            Offset: u64,
            Instr: ?[*:0]const u8,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassemble: fn(
            self: *const IDebugControl3,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisassembleEffectiveOffset: fn(
            self: *const IDebugControl3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassembly: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Offset: u64,
            Flags: u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassemblyLines: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            PreviousLines: u32,
            TotalLines: u32,
            Offset: u64,
            Flags: u32,
            OffsetLine: ?*u32,
            StartOffset: ?*u64,
            EndOffset: ?*u64,
            LineOffsets: ?[*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearInstruction: fn(
            self: *const IDebugControl3,
            Offset: u64,
            Delta: i32,
            NearOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTrace: fn(
            self: *const IDebugControl3,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReturnOffset: fn(
            self: *const IDebugControl3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTrace: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebuggeeType: fn(
            self: *const IDebugControl3,
            Class: ?*u32,
            Qualifier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualProcessorType: fn(
            self: *const IDebugControl3,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutingProcessorType: fn(
            self: *const IDebugControl3,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl3,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl3,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcessors: fn(
            self: *const IDebugControl3,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersion: fn(
            self: *const IDebugControl3,
            PlatformId: ?*u32,
            Major: ?*u32,
            Minor: ?*u32,
            ServicePackString: ?[*:0]u8,
            ServicePackStringSize: u32,
            ServicePackStringUsed: ?*u32,
            ServicePackNumber: ?*u32,
            BuildString: ?[*:0]u8,
            BuildStringSize: u32,
            BuildStringUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageSize: fn(
            self: *const IDebugControl3,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPointer64Bit: fn(
            self: *const IDebugControl3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBugCheckData: fn(
            self: *const IDebugControl3,
            Code: ?*u32,
            Arg1: ?*u64,
            Arg2: ?*u64,
            Arg3: ?*u64,
            Arg4: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSupportedProcessorTypes: fn(
            self: *const IDebugControl3,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProcessorTypes: fn(
            self: *const IDebugControl3,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNames: fn(
            self: *const IDebugControl3,
            Type: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectiveProcessorType: fn(
            self: *const IDebugControl3,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectiveProcessorType: fn(
            self: *const IDebugControl3,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatus: fn(
            self: *const IDebugControl3,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExecutionStatus: fn(
            self: *const IDebugControl3,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeLevel: fn(
            self: *const IDebugControl3,
            Level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCodeLevel: fn(
            self: *const IDebugControl3,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineOptions: fn(
            self: *const IDebugControl3,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEngineOptions: fn(
            self: *const IDebugControl3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEngineOptions: fn(
            self: *const IDebugControl3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineOptions: fn(
            self: *const IDebugControl3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemErrorControl: fn(
            self: *const IDebugControl3,
            OutputLevel: ?*u32,
            BreakLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSystemErrorControl: fn(
            self: *const IDebugControl3,
            OutputLevel: u32,
            BreakLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacro: fn(
            self: *const IDebugControl3,
            Slot: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacro: fn(
            self: *const IDebugControl3,
            Slot: u32,
            Macro: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRadix: fn(
            self: *const IDebugControl3,
            Radix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRadix: fn(
            self: *const IDebugControl3,
            Radix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Evaluate: fn(
            self: *const IDebugControl3,
            Expression: ?[*:0]const u8,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValue: fn(
            self: *const IDebugControl3,
            In: ?*DEBUG_VALUE,
            OutType: u32,
            Out: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValues: fn(
            self: *const IDebugControl3,
            Count: u32,
            In: [*]DEBUG_VALUE,
            OutTypes: [*]u32,
            Out: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Command: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFile: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            CommandFile: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberBreakpoints: fn(
            self: *const IDebugControl3,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex: fn(
            self: *const IDebugControl3,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById: fn(
            self: *const IDebugControl3,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointParameters: fn(
            self: *const IDebugControl3,
            Count: u32,
            Ids: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint: fn(
            self: *const IDebugControl3,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint: fn(
            self: *const IDebugControl3,
            Bp: ?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IDebugControl3,
            Path: ?[*:0]const u8,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: fn(
            self: *const IDebugControl3,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPath: fn(
            self: *const IDebugControl3,
            Path: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtension: fn(
            self: *const IDebugControl3,
            Handle: u64,
            Function: ?[*:0]const u8,
            Arguments: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunction: fn(
            self: *const IDebugControl3,
            Handle: u64,
            FuncName: ?[*:0]const u8,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis32: fn(
            self: *const IDebugControl3,
            Api: ?*WINDBG_EXTENSION_APIS32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis64: fn(
            self: *const IDebugControl3,
            Api: ?*WINDBG_EXTENSION_APIS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventFilters: fn(
            self: *const IDebugControl3,
            SpecificEvents: ?*u32,
            SpecificExceptions: ?*u32,
            ArbitraryExceptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterText: fn(
            self: *const IDebugControl3,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommand: fn(
            self: *const IDebugControl3,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommand: fn(
            self: *const IDebugControl3,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterParameters: fn(
            self: *const IDebugControl3,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterParameters: fn(
            self: *const IDebugControl3,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgument: fn(
            self: *const IDebugControl3,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgument: fn(
            self: *const IDebugControl3,
            Index: u32,
            Argument: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterParameters: fn(
            self: *const IDebugControl3,
            Count: u32,
            Codes: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterParameters: fn(
            self: *const IDebugControl3,
            Count: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl3,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl3,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEvent: fn(
            self: *const IDebugControl3,
            Flags: u32,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformation: fn(
            self: *const IDebugControl3,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTimeDate: fn(
            self: *const IDebugControl3,
            TimeDate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemUpTime: fn(
            self: *const IDebugControl3,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFormatFlags: fn(
            self: *const IDebugControl3,
            FormatFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberTextReplacements: fn(
            self: *const IDebugControl3,
            NumRepl: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacement: fn(
            self: *const IDebugControl3,
            SrcText: ?[*:0]const u8,
            Index: u32,
            SrcBuffer: ?[*:0]u8,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u8,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacement: fn(
            self: *const IDebugControl3,
            SrcText: ?[*:0]const u8,
            DstText: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextReplacements: fn(
            self: *const IDebugControl3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTextReplacements: fn(
            self: *const IDebugControl3,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAssemblyOptions: fn(
            self: *const IDebugControl3,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAssemblyOptions: fn(
            self: *const IDebugControl3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAssemblyOptions: fn(
            self: *const IDebugControl3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAssemblyOptions: fn(
            self: *const IDebugControl3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntax: fn(
            self: *const IDebugControl3,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntax: fn(
            self: *const IDebugControl3,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByName: fn(
            self: *const IDebugControl3,
            AbbrevName: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberExpressionSyntaxes: fn(
            self: *const IDebugControl3,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNames: fn(
            self: *const IDebugControl3,
            Index: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEvents: fn(
            self: *const IDebugControl3,
            Events: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescription: fn(
            self: *const IDebugControl3,
            Index: u32,
            Which: u32,
            Buffer: ?PSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentEventIndex: fn(
            self: *const IDebugControl3,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNextEventIndex: fn(
            self: *const IDebugControl3,
            Relation: u32,
            Value: u32,
            NextIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetInterrupt(@ptrCast(*const IDebugControl3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetInterrupt(@ptrCast(*const IDebugControl3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetInterruptTimeout(@ptrCast(*const IDebugControl3, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetInterruptTimeout(@ptrCast(*const IDebugControl3, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetLogFile(@ptrCast(*const IDebugControl3, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OpenLogFile(@ptrCast(*const IDebugControl3, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).CloseLogFile(@ptrCast(*const IDebugControl3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetLogMask(@ptrCast(*const IDebugControl3, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetLogMask(@ptrCast(*const IDebugControl3, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).Input(@ptrCast(*const IDebugControl3, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).ReturnInput(@ptrCast(*const IDebugControl3, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).Output(@ptrCast(*const IDebugControl3, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputVaList(@ptrCast(*const IDebugControl3, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).ControlledOutput(@ptrCast(*const IDebugControl3, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).ControlledOutputVaList(@ptrCast(*const IDebugControl3, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputPrompt(@ptrCast(*const IDebugControl3, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputPromptVaList(@ptrCast(*const IDebugControl3, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetPromptText(@ptrCast(*const IDebugControl3, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputCurrentState(@ptrCast(*const IDebugControl3, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputVersionInformation(@ptrCast(*const IDebugControl3, self), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNotifyEventHandle(@ptrCast(*const IDebugControl3, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetNotifyEventHandle(@ptrCast(*const IDebugControl3, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).Assemble(@ptrCast(*const IDebugControl3, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).Disassemble(@ptrCast(*const IDebugControl3, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetDisassembleEffectiveOffset(@ptrCast(*const IDebugControl3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputDisassembly(@ptrCast(*const IDebugControl3, self), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputDisassemblyLines(@ptrCast(*const IDebugControl3, self), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNearInstruction(@ptrCast(*const IDebugControl3, self), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetStackTrace(@ptrCast(*const IDebugControl3, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetReturnOffset(@ptrCast(*const IDebugControl3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputStackTrace(@ptrCast(*const IDebugControl3, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetDebuggeeType(@ptrCast(*const IDebugControl3, self), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetActualProcessorType(@ptrCast(*const IDebugControl3, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetExecutingProcessorType(@ptrCast(*const IDebugControl3, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNumberPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl3, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl3, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNumberProcessors(@ptrCast(*const IDebugControl3, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetSystemVersion(@ptrCast(*const IDebugControl3, self), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetPageSize(@ptrCast(*const IDebugControl3, self), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).IsPointer64Bit(@ptrCast(*const IDebugControl3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).ReadBugCheckData(@ptrCast(*const IDebugControl3, self), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNumberSupportedProcessorTypes(@ptrCast(*const IDebugControl3, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetSupportedProcessorTypes(@ptrCast(*const IDebugControl3, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetProcessorTypeNames(@ptrCast(*const IDebugControl3, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetEffectiveProcessorType(@ptrCast(*const IDebugControl3, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetEffectiveProcessorType(@ptrCast(*const IDebugControl3, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetExecutionStatus(@ptrCast(*const IDebugControl3, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetExecutionStatus(@ptrCast(*const IDebugControl3, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetCodeLevel(@ptrCast(*const IDebugControl3, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetCodeLevel(@ptrCast(*const IDebugControl3, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetEngineOptions(@ptrCast(*const IDebugControl3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).AddEngineOptions(@ptrCast(*const IDebugControl3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).RemoveEngineOptions(@ptrCast(*const IDebugControl3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetEngineOptions(@ptrCast(*const IDebugControl3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetSystemErrorControl(@ptrCast(*const IDebugControl3, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetSystemErrorControl(@ptrCast(*const IDebugControl3, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetTextMacro(@ptrCast(*const IDebugControl3, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetTextMacro(@ptrCast(*const IDebugControl3, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetRadix(@ptrCast(*const IDebugControl3, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetRadix(@ptrCast(*const IDebugControl3, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).Evaluate(@ptrCast(*const IDebugControl3, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).CoerceValue(@ptrCast(*const IDebugControl3, self), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).CoerceValues(@ptrCast(*const IDebugControl3, self), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).Execute(@ptrCast(*const IDebugControl3, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).ExecuteCommandFile(@ptrCast(*const IDebugControl3, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNumberBreakpoints(@ptrCast(*const IDebugControl3, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetBreakpointByIndex(@ptrCast(*const IDebugControl3, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetBreakpointById(@ptrCast(*const IDebugControl3, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetBreakpointParameters(@ptrCast(*const IDebugControl3, self), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).AddBreakpoint(@ptrCast(*const IDebugControl3, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).RemoveBreakpoint(@ptrCast(*const IDebugControl3, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).AddExtension(@ptrCast(*const IDebugControl3, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).RemoveExtension(@ptrCast(*const IDebugControl3, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetExtensionByPath(@ptrCast(*const IDebugControl3, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).CallExtension(@ptrCast(*const IDebugControl3, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetExtensionFunction(@ptrCast(*const IDebugControl3, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetWindbgExtensionApis32(@ptrCast(*const IDebugControl3, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetWindbgExtensionApis64(@ptrCast(*const IDebugControl3, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNumberEventFilters(@ptrCast(*const IDebugControl3, self), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetEventFilterText(@ptrCast(*const IDebugControl3, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetEventFilterCommand(@ptrCast(*const IDebugControl3, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetEventFilterCommand(@ptrCast(*const IDebugControl3, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetSpecificFilterParameters(@ptrCast(*const IDebugControl3, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetSpecificFilterParameters(@ptrCast(*const IDebugControl3, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetSpecificFilterArgument(@ptrCast(*const IDebugControl3, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetSpecificFilterArgument(@ptrCast(*const IDebugControl3, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetExceptionFilterParameters(@ptrCast(*const IDebugControl3, self), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetExceptionFilterParameters(@ptrCast(*const IDebugControl3, self), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl3, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl3, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).WaitForEvent(@ptrCast(*const IDebugControl3, self), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetLastEventInformation(@ptrCast(*const IDebugControl3, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetCurrentTimeDate(@ptrCast(*const IDebugControl3, self), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetCurrentSystemUpTime(@ptrCast(*const IDebugControl3, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetDumpFormatFlags(@ptrCast(*const IDebugControl3, self), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNumberTextReplacements(@ptrCast(*const IDebugControl3, self), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetTextReplacement(@ptrCast(*const IDebugControl3, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetTextReplacement(@ptrCast(*const IDebugControl3, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).RemoveTextReplacements(@ptrCast(*const IDebugControl3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).OutputTextReplacements(@ptrCast(*const IDebugControl3, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetAssemblyOptions(@ptrCast(*const IDebugControl3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).AddAssemblyOptions(@ptrCast(*const IDebugControl3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).RemoveAssemblyOptions(@ptrCast(*const IDebugControl3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetAssemblyOptions(@ptrCast(*const IDebugControl3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetExpressionSyntax(@ptrCast(*const IDebugControl3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetExpressionSyntax(@ptrCast(*const IDebugControl3, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetExpressionSyntaxByName(@ptrCast(*const IDebugControl3, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNumberExpressionSyntaxes(@ptrCast(*const IDebugControl3, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetExpressionSyntaxNames(@ptrCast(*const IDebugControl3, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetNumberEvents(@ptrCast(*const IDebugControl3, self), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetEventIndexDescription(@ptrCast(*const IDebugControl3, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).GetCurrentEventIndex(@ptrCast(*const IDebugControl3, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl3_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl3.VTable, self.vtable).SetNextEventIndex(@ptrCast(*const IDebugControl3, self), Relation, Value, NextIndex);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl4_Value = @import("../../zig.zig").Guid.initString("94e60ce9-9b41-4b19-9fc0-6d9eb35272b3");
pub const IID_IDebugControl4 = &IID_IDebugControl4_Value;
pub const IDebugControl4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: fn(
            self: *const IDebugControl4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterrupt: fn(
            self: *const IDebugControl4,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterruptTimeout: fn(
            self: *const IDebugControl4,
            Seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterruptTimeout: fn(
            self: *const IDebugControl4,
            Seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile: fn(
            self: *const IDebugControl4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile: fn(
            self: *const IDebugControl4,
            File: ?[*:0]const u8,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLogFile: fn(
            self: *const IDebugControl4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogMask: fn(
            self: *const IDebugControl4,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogMask: fn(
            self: *const IDebugControl4,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Input: fn(
            self: *const IDebugControl4,
            Buffer: [*:0]u8,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInput: fn(
            self: *const IDebugControl4,
            Buffer: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Output: fn(
            self: *const IDebugControl4,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaList: fn(
            self: *const IDebugControl4,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutput: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaList: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPrompt: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaList: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptText: fn(
            self: *const IDebugControl4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputCurrentState: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVersionInformation: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyEventHandle: fn(
            self: *const IDebugControl4,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyEventHandle: fn(
            self: *const IDebugControl4,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Assemble: fn(
            self: *const IDebugControl4,
            Offset: u64,
            Instr: ?[*:0]const u8,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassemble: fn(
            self: *const IDebugControl4,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisassembleEffectiveOffset: fn(
            self: *const IDebugControl4,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassembly: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Offset: u64,
            Flags: u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassemblyLines: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            PreviousLines: u32,
            TotalLines: u32,
            Offset: u64,
            Flags: u32,
            OffsetLine: ?*u32,
            StartOffset: ?*u64,
            EndOffset: ?*u64,
            LineOffsets: ?[*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearInstruction: fn(
            self: *const IDebugControl4,
            Offset: u64,
            Delta: i32,
            NearOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTrace: fn(
            self: *const IDebugControl4,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReturnOffset: fn(
            self: *const IDebugControl4,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTrace: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebuggeeType: fn(
            self: *const IDebugControl4,
            Class: ?*u32,
            Qualifier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualProcessorType: fn(
            self: *const IDebugControl4,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutingProcessorType: fn(
            self: *const IDebugControl4,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl4,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcessors: fn(
            self: *const IDebugControl4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersion: fn(
            self: *const IDebugControl4,
            PlatformId: ?*u32,
            Major: ?*u32,
            Minor: ?*u32,
            ServicePackString: ?[*:0]u8,
            ServicePackStringSize: u32,
            ServicePackStringUsed: ?*u32,
            ServicePackNumber: ?*u32,
            BuildString: ?[*:0]u8,
            BuildStringSize: u32,
            BuildStringUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageSize: fn(
            self: *const IDebugControl4,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPointer64Bit: fn(
            self: *const IDebugControl4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBugCheckData: fn(
            self: *const IDebugControl4,
            Code: ?*u32,
            Arg1: ?*u64,
            Arg2: ?*u64,
            Arg3: ?*u64,
            Arg4: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSupportedProcessorTypes: fn(
            self: *const IDebugControl4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProcessorTypes: fn(
            self: *const IDebugControl4,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNames: fn(
            self: *const IDebugControl4,
            Type: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectiveProcessorType: fn(
            self: *const IDebugControl4,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectiveProcessorType: fn(
            self: *const IDebugControl4,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatus: fn(
            self: *const IDebugControl4,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExecutionStatus: fn(
            self: *const IDebugControl4,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeLevel: fn(
            self: *const IDebugControl4,
            Level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCodeLevel: fn(
            self: *const IDebugControl4,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineOptions: fn(
            self: *const IDebugControl4,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEngineOptions: fn(
            self: *const IDebugControl4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEngineOptions: fn(
            self: *const IDebugControl4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineOptions: fn(
            self: *const IDebugControl4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemErrorControl: fn(
            self: *const IDebugControl4,
            OutputLevel: ?*u32,
            BreakLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSystemErrorControl: fn(
            self: *const IDebugControl4,
            OutputLevel: u32,
            BreakLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacro: fn(
            self: *const IDebugControl4,
            Slot: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacro: fn(
            self: *const IDebugControl4,
            Slot: u32,
            Macro: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRadix: fn(
            self: *const IDebugControl4,
            Radix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRadix: fn(
            self: *const IDebugControl4,
            Radix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Evaluate: fn(
            self: *const IDebugControl4,
            Expression: ?[*:0]const u8,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValue: fn(
            self: *const IDebugControl4,
            In: ?*DEBUG_VALUE,
            OutType: u32,
            Out: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValues: fn(
            self: *const IDebugControl4,
            Count: u32,
            In: [*]DEBUG_VALUE,
            OutTypes: [*]u32,
            Out: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Command: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFile: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            CommandFile: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberBreakpoints: fn(
            self: *const IDebugControl4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex: fn(
            self: *const IDebugControl4,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById: fn(
            self: *const IDebugControl4,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointParameters: fn(
            self: *const IDebugControl4,
            Count: u32,
            Ids: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint: fn(
            self: *const IDebugControl4,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint: fn(
            self: *const IDebugControl4,
            Bp: ?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IDebugControl4,
            Path: ?[*:0]const u8,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: fn(
            self: *const IDebugControl4,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPath: fn(
            self: *const IDebugControl4,
            Path: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtension: fn(
            self: *const IDebugControl4,
            Handle: u64,
            Function: ?[*:0]const u8,
            Arguments: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunction: fn(
            self: *const IDebugControl4,
            Handle: u64,
            FuncName: ?[*:0]const u8,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis32: fn(
            self: *const IDebugControl4,
            Api: ?*WINDBG_EXTENSION_APIS32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis64: fn(
            self: *const IDebugControl4,
            Api: ?*WINDBG_EXTENSION_APIS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventFilters: fn(
            self: *const IDebugControl4,
            SpecificEvents: ?*u32,
            SpecificExceptions: ?*u32,
            ArbitraryExceptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterText: fn(
            self: *const IDebugControl4,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommand: fn(
            self: *const IDebugControl4,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommand: fn(
            self: *const IDebugControl4,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterParameters: fn(
            self: *const IDebugControl4,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterParameters: fn(
            self: *const IDebugControl4,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgument: fn(
            self: *const IDebugControl4,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgument: fn(
            self: *const IDebugControl4,
            Index: u32,
            Argument: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterParameters: fn(
            self: *const IDebugControl4,
            Count: u32,
            Codes: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterParameters: fn(
            self: *const IDebugControl4,
            Count: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl4,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl4,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEvent: fn(
            self: *const IDebugControl4,
            Flags: u32,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformation: fn(
            self: *const IDebugControl4,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTimeDate: fn(
            self: *const IDebugControl4,
            TimeDate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemUpTime: fn(
            self: *const IDebugControl4,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFormatFlags: fn(
            self: *const IDebugControl4,
            FormatFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberTextReplacements: fn(
            self: *const IDebugControl4,
            NumRepl: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacement: fn(
            self: *const IDebugControl4,
            SrcText: ?[*:0]const u8,
            Index: u32,
            SrcBuffer: ?[*:0]u8,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u8,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacement: fn(
            self: *const IDebugControl4,
            SrcText: ?[*:0]const u8,
            DstText: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextReplacements: fn(
            self: *const IDebugControl4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTextReplacements: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAssemblyOptions: fn(
            self: *const IDebugControl4,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAssemblyOptions: fn(
            self: *const IDebugControl4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAssemblyOptions: fn(
            self: *const IDebugControl4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAssemblyOptions: fn(
            self: *const IDebugControl4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntax: fn(
            self: *const IDebugControl4,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntax: fn(
            self: *const IDebugControl4,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByName: fn(
            self: *const IDebugControl4,
            AbbrevName: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberExpressionSyntaxes: fn(
            self: *const IDebugControl4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNames: fn(
            self: *const IDebugControl4,
            Index: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEvents: fn(
            self: *const IDebugControl4,
            Events: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescription: fn(
            self: *const IDebugControl4,
            Index: u32,
            Which: u32,
            Buffer: ?PSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentEventIndex: fn(
            self: *const IDebugControl4,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNextEventIndex: fn(
            self: *const IDebugControl4,
            Relation: u32,
            Value: u32,
            NextIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFileWide: fn(
            self: *const IDebugControl4,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFileWide: fn(
            self: *const IDebugControl4,
            File: ?[*:0]const u16,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InputWide: fn(
            self: *const IDebugControl4,
            Buffer: [*:0]u16,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInputWide: fn(
            self: *const IDebugControl4,
            Buffer: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputWide: fn(
            self: *const IDebugControl4,
            Mask: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaListWide: fn(
            self: *const IDebugControl4,
            Mask: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputWide: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaListWide: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptWide: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaListWide: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptTextWide: fn(
            self: *const IDebugControl4,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssembleWide: fn(
            self: *const IDebugControl4,
            Offset: u64,
            Instr: ?[*:0]const u16,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisassembleWide: fn(
            self: *const IDebugControl4,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNamesWide: fn(
            self: *const IDebugControl4,
            Type: u32,
            FullNameBuffer: ?[*:0]u16,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u16,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacroWide: fn(
            self: *const IDebugControl4,
            Slot: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacroWide: fn(
            self: *const IDebugControl4,
            Slot: u32,
            Macro: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EvaluateWide: fn(
            self: *const IDebugControl4,
            Expression: ?[*:0]const u16,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteWide: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Command: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFileWide: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            CommandFile: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex2: fn(
            self: *const IDebugControl4,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById2: fn(
            self: *const IDebugControl4,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint2: fn(
            self: *const IDebugControl4,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint2: fn(
            self: *const IDebugControl4,
            Bp: ?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtensionWide: fn(
            self: *const IDebugControl4,
            Path: ?[*:0]const u16,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPathWide: fn(
            self: *const IDebugControl4,
            Path: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtensionWide: fn(
            self: *const IDebugControl4,
            Handle: u64,
            Function: ?[*:0]const u16,
            Arguments: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunctionWide: fn(
            self: *const IDebugControl4,
            Handle: u64,
            FuncName: ?[*:0]const u16,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterTextWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommandWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommandWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgumentWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgumentWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            Argument: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommandWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommandWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformationWide: fn(
            self: *const IDebugControl4,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacementWide: fn(
            self: *const IDebugControl4,
            SrcText: ?[*:0]const u16,
            Index: u32,
            SrcBuffer: ?[*:0]u16,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u16,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacementWide: fn(
            self: *const IDebugControl4,
            SrcText: ?[*:0]const u16,
            DstText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByNameWide: fn(
            self: *const IDebugControl4,
            AbbrevName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNamesWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            FullNameBuffer: ?[*:0]u16,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u16,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescriptionWide: fn(
            self: *const IDebugControl4,
            Index: u32,
            Which: u32,
            Buffer: ?PWSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile2: fn(
            self: *const IDebugControl4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile2: fn(
            self: *const IDebugControl4,
            File: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile2Wide: fn(
            self: *const IDebugControl4,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FileSize: ?*u32,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile2Wide: fn(
            self: *const IDebugControl4,
            File: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionValues: fn(
            self: *const IDebugControl4,
            PlatformId: ?*u32,
            Win32Major: ?*u32,
            Win32Minor: ?*u32,
            KdMajor: ?*u32,
            KdMinor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionString: fn(
            self: *const IDebugControl4,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionStringWide: fn(
            self: *const IDebugControl4,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextStackTrace: fn(
            self: *const IDebugControl4,
            // TODO: what to do with BytesParamIndex 1?
            StartContext: ?*c_void,
            StartContextSize: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 5?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputContextStackTrace: fn(
            self: *const IDebugControl4,
            OutputControl: u32,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoredEventInformation: fn(
            self: *const IDebugControl4,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            Context: ?*c_void,
            ContextSize: u32,
            ContextUsed: ?*u32,
            // TODO: what to do with BytesParamIndex 7?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManagedStatus: fn(
            self: *const IDebugControl4,
            Flags: ?*u32,
            WhichString: u32,
            String: ?[*:0]u8,
            StringSize: u32,
            StringNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManagedStatusWide: fn(
            self: *const IDebugControl4,
            Flags: ?*u32,
            WhichString: u32,
            String: ?[*:0]u16,
            StringSize: u32,
            StringNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetManagedStatus: fn(
            self: *const IDebugControl4,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetInterrupt(@ptrCast(*const IDebugControl4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetInterrupt(@ptrCast(*const IDebugControl4, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetInterruptTimeout(@ptrCast(*const IDebugControl4, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetInterruptTimeout(@ptrCast(*const IDebugControl4, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetLogFile(@ptrCast(*const IDebugControl4, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OpenLogFile(@ptrCast(*const IDebugControl4, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).CloseLogFile(@ptrCast(*const IDebugControl4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetLogMask(@ptrCast(*const IDebugControl4, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetLogMask(@ptrCast(*const IDebugControl4, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).Input(@ptrCast(*const IDebugControl4, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ReturnInput(@ptrCast(*const IDebugControl4, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).Output(@ptrCast(*const IDebugControl4, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputVaList(@ptrCast(*const IDebugControl4, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ControlledOutput(@ptrCast(*const IDebugControl4, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ControlledOutputVaList(@ptrCast(*const IDebugControl4, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputPrompt(@ptrCast(*const IDebugControl4, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputPromptVaList(@ptrCast(*const IDebugControl4, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetPromptText(@ptrCast(*const IDebugControl4, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputCurrentState(@ptrCast(*const IDebugControl4, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputVersionInformation(@ptrCast(*const IDebugControl4, self), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNotifyEventHandle(@ptrCast(*const IDebugControl4, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetNotifyEventHandle(@ptrCast(*const IDebugControl4, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).Assemble(@ptrCast(*const IDebugControl4, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).Disassemble(@ptrCast(*const IDebugControl4, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetDisassembleEffectiveOffset(@ptrCast(*const IDebugControl4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputDisassembly(@ptrCast(*const IDebugControl4, self), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputDisassemblyLines(@ptrCast(*const IDebugControl4, self), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNearInstruction(@ptrCast(*const IDebugControl4, self), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetStackTrace(@ptrCast(*const IDebugControl4, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetReturnOffset(@ptrCast(*const IDebugControl4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputStackTrace(@ptrCast(*const IDebugControl4, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetDebuggeeType(@ptrCast(*const IDebugControl4, self), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetActualProcessorType(@ptrCast(*const IDebugControl4, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExecutingProcessorType(@ptrCast(*const IDebugControl4, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNumberPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl4, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNumberProcessors(@ptrCast(*const IDebugControl4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSystemVersion(@ptrCast(*const IDebugControl4, self), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetPageSize(@ptrCast(*const IDebugControl4, self), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).IsPointer64Bit(@ptrCast(*const IDebugControl4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ReadBugCheckData(@ptrCast(*const IDebugControl4, self), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNumberSupportedProcessorTypes(@ptrCast(*const IDebugControl4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSupportedProcessorTypes(@ptrCast(*const IDebugControl4, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetProcessorTypeNames(@ptrCast(*const IDebugControl4, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetEffectiveProcessorType(@ptrCast(*const IDebugControl4, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetEffectiveProcessorType(@ptrCast(*const IDebugControl4, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExecutionStatus(@ptrCast(*const IDebugControl4, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetExecutionStatus(@ptrCast(*const IDebugControl4, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetCodeLevel(@ptrCast(*const IDebugControl4, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetCodeLevel(@ptrCast(*const IDebugControl4, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetEngineOptions(@ptrCast(*const IDebugControl4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).AddEngineOptions(@ptrCast(*const IDebugControl4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).RemoveEngineOptions(@ptrCast(*const IDebugControl4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetEngineOptions(@ptrCast(*const IDebugControl4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSystemErrorControl(@ptrCast(*const IDebugControl4, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetSystemErrorControl(@ptrCast(*const IDebugControl4, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetTextMacro(@ptrCast(*const IDebugControl4, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetTextMacro(@ptrCast(*const IDebugControl4, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetRadix(@ptrCast(*const IDebugControl4, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetRadix(@ptrCast(*const IDebugControl4, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).Evaluate(@ptrCast(*const IDebugControl4, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).CoerceValue(@ptrCast(*const IDebugControl4, self), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).CoerceValues(@ptrCast(*const IDebugControl4, self), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).Execute(@ptrCast(*const IDebugControl4, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ExecuteCommandFile(@ptrCast(*const IDebugControl4, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNumberBreakpoints(@ptrCast(*const IDebugControl4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetBreakpointByIndex(@ptrCast(*const IDebugControl4, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetBreakpointById(@ptrCast(*const IDebugControl4, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetBreakpointParameters(@ptrCast(*const IDebugControl4, self), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).AddBreakpoint(@ptrCast(*const IDebugControl4, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).RemoveBreakpoint(@ptrCast(*const IDebugControl4, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).AddExtension(@ptrCast(*const IDebugControl4, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).RemoveExtension(@ptrCast(*const IDebugControl4, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExtensionByPath(@ptrCast(*const IDebugControl4, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).CallExtension(@ptrCast(*const IDebugControl4, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExtensionFunction(@ptrCast(*const IDebugControl4, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetWindbgExtensionApis32(@ptrCast(*const IDebugControl4, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetWindbgExtensionApis64(@ptrCast(*const IDebugControl4, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNumberEventFilters(@ptrCast(*const IDebugControl4, self), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetEventFilterText(@ptrCast(*const IDebugControl4, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetEventFilterCommand(@ptrCast(*const IDebugControl4, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetEventFilterCommand(@ptrCast(*const IDebugControl4, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSpecificFilterParameters(@ptrCast(*const IDebugControl4, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetSpecificFilterParameters(@ptrCast(*const IDebugControl4, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSpecificFilterArgument(@ptrCast(*const IDebugControl4, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetSpecificFilterArgument(@ptrCast(*const IDebugControl4, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExceptionFilterParameters(@ptrCast(*const IDebugControl4, self), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetExceptionFilterParameters(@ptrCast(*const IDebugControl4, self), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl4, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl4, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).WaitForEvent(@ptrCast(*const IDebugControl4, self), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetLastEventInformation(@ptrCast(*const IDebugControl4, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetCurrentTimeDate(@ptrCast(*const IDebugControl4, self), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetCurrentSystemUpTime(@ptrCast(*const IDebugControl4, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetDumpFormatFlags(@ptrCast(*const IDebugControl4, self), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNumberTextReplacements(@ptrCast(*const IDebugControl4, self), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetTextReplacement(@ptrCast(*const IDebugControl4, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetTextReplacement(@ptrCast(*const IDebugControl4, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).RemoveTextReplacements(@ptrCast(*const IDebugControl4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputTextReplacements(@ptrCast(*const IDebugControl4, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetAssemblyOptions(@ptrCast(*const IDebugControl4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).AddAssemblyOptions(@ptrCast(*const IDebugControl4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).RemoveAssemblyOptions(@ptrCast(*const IDebugControl4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetAssemblyOptions(@ptrCast(*const IDebugControl4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExpressionSyntax(@ptrCast(*const IDebugControl4, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetExpressionSyntax(@ptrCast(*const IDebugControl4, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetExpressionSyntaxByName(@ptrCast(*const IDebugControl4, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNumberExpressionSyntaxes(@ptrCast(*const IDebugControl4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExpressionSyntaxNames(@ptrCast(*const IDebugControl4, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetNumberEvents(@ptrCast(*const IDebugControl4, self), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetEventIndexDescription(@ptrCast(*const IDebugControl4, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetCurrentEventIndex(@ptrCast(*const IDebugControl4, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetNextEventIndex(@ptrCast(*const IDebugControl4, self), Relation, Value, NextIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetLogFileWide(@ptrCast(*const IDebugControl4, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OpenLogFileWide(self: *const T, File: ?[*:0]const u16, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OpenLogFileWide(@ptrCast(*const IDebugControl4, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).InputWide(@ptrCast(*const IDebugControl4, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ReturnInputWide(self: *const T, Buffer: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ReturnInputWide(@ptrCast(*const IDebugControl4, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputWide(@ptrCast(*const IDebugControl4, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputVaListWide(@ptrCast(*const IDebugControl4, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ControlledOutputWide(@ptrCast(*const IDebugControl4, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ControlledOutputVaListWide(@ptrCast(*const IDebugControl4, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputPromptWide(@ptrCast(*const IDebugControl4, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputPromptVaListWide(@ptrCast(*const IDebugControl4, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetPromptTextWide(@ptrCast(*const IDebugControl4, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]const u16, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).AssembleWide(@ptrCast(*const IDebugControl4, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).DisassembleWide(@ptrCast(*const IDebugControl4, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetProcessorTypeNamesWide(@ptrCast(*const IDebugControl4, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetTextMacroWide(@ptrCast(*const IDebugControl4, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetTextMacroWide(@ptrCast(*const IDebugControl4, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_EvaluateWide(self: *const T, Expression: ?[*:0]const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).EvaluateWide(@ptrCast(*const IDebugControl4, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ExecuteWide(@ptrCast(*const IDebugControl4, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ExecuteCommandFileWide(@ptrCast(*const IDebugControl4, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetBreakpointByIndex2(@ptrCast(*const IDebugControl4, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetBreakpointById2(@ptrCast(*const IDebugControl4, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).AddBreakpoint2(@ptrCast(*const IDebugControl4, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).RemoveBreakpoint2(@ptrCast(*const IDebugControl4, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_AddExtensionWide(self: *const T, Path: ?[*:0]const u16, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).AddExtensionWide(@ptrCast(*const IDebugControl4, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExtensionByPathWide(self: *const T, Path: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExtensionByPathWide(@ptrCast(*const IDebugControl4, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]const u16, Arguments: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).CallExtensionWide(@ptrCast(*const IDebugControl4, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]const u16, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExtensionFunctionWide(@ptrCast(*const IDebugControl4, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetEventFilterTextWide(@ptrCast(*const IDebugControl4, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetEventFilterCommandWide(@ptrCast(*const IDebugControl4, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetEventFilterCommandWide(@ptrCast(*const IDebugControl4, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSpecificFilterArgumentWide(@ptrCast(*const IDebugControl4, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetSpecificFilterArgumentWide(@ptrCast(*const IDebugControl4, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExceptionFilterSecondCommandWide(@ptrCast(*const IDebugControl4, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetExceptionFilterSecondCommandWide(@ptrCast(*const IDebugControl4, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetLastEventInformationWide(@ptrCast(*const IDebugControl4, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetTextReplacementWide(@ptrCast(*const IDebugControl4, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, DstText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetTextReplacementWide(@ptrCast(*const IDebugControl4, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).SetExpressionSyntaxByNameWide(@ptrCast(*const IDebugControl4, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetExpressionSyntaxNamesWide(@ptrCast(*const IDebugControl4, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetEventIndexDescriptionWide(@ptrCast(*const IDebugControl4, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetLogFile2(@ptrCast(*const IDebugControl4, self), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OpenLogFile2(self: *const T, File: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OpenLogFile2(@ptrCast(*const IDebugControl4, self), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetLogFile2Wide(@ptrCast(*const IDebugControl4, self), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OpenLogFile2Wide(self: *const T, File: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OpenLogFile2Wide(@ptrCast(*const IDebugControl4, self), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSystemVersionValues(@ptrCast(*const IDebugControl4, self), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSystemVersionString(@ptrCast(*const IDebugControl4, self), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetSystemVersionStringWide(@ptrCast(*const IDebugControl4, self), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetContextStackTrace(self: *const T, StartContext: ?*c_void, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetContextStackTrace(@ptrCast(*const IDebugControl4, self), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).OutputContextStackTrace(@ptrCast(*const IDebugControl4, self), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*c_void, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetStoredEventInformation(@ptrCast(*const IDebugControl4, self), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetManagedStatus(@ptrCast(*const IDebugControl4, self), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).GetManagedStatusWide(@ptrCast(*const IDebugControl4, self), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl4_ResetManagedStatus(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl4.VTable, self.vtable).ResetManagedStatus(@ptrCast(*const IDebugControl4, self), Flags);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl5_Value = @import("../../zig.zig").Guid.initString("b2ffe162-2412-429f-8d1d-5bf6dd824696");
pub const IID_IDebugControl5 = &IID_IDebugControl5_Value;
pub const IDebugControl5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: fn(
            self: *const IDebugControl5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterrupt: fn(
            self: *const IDebugControl5,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterruptTimeout: fn(
            self: *const IDebugControl5,
            Seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterruptTimeout: fn(
            self: *const IDebugControl5,
            Seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile: fn(
            self: *const IDebugControl5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile: fn(
            self: *const IDebugControl5,
            File: ?[*:0]const u8,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLogFile: fn(
            self: *const IDebugControl5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogMask: fn(
            self: *const IDebugControl5,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogMask: fn(
            self: *const IDebugControl5,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Input: fn(
            self: *const IDebugControl5,
            Buffer: [*:0]u8,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInput: fn(
            self: *const IDebugControl5,
            Buffer: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Output: fn(
            self: *const IDebugControl5,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaList: fn(
            self: *const IDebugControl5,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutput: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaList: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPrompt: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaList: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptText: fn(
            self: *const IDebugControl5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputCurrentState: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVersionInformation: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyEventHandle: fn(
            self: *const IDebugControl5,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyEventHandle: fn(
            self: *const IDebugControl5,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Assemble: fn(
            self: *const IDebugControl5,
            Offset: u64,
            Instr: ?[*:0]const u8,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassemble: fn(
            self: *const IDebugControl5,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisassembleEffectiveOffset: fn(
            self: *const IDebugControl5,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassembly: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Offset: u64,
            Flags: u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassemblyLines: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            PreviousLines: u32,
            TotalLines: u32,
            Offset: u64,
            Flags: u32,
            OffsetLine: ?*u32,
            StartOffset: ?*u64,
            EndOffset: ?*u64,
            LineOffsets: ?[*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearInstruction: fn(
            self: *const IDebugControl5,
            Offset: u64,
            Delta: i32,
            NearOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTrace: fn(
            self: *const IDebugControl5,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReturnOffset: fn(
            self: *const IDebugControl5,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTrace: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebuggeeType: fn(
            self: *const IDebugControl5,
            Class: ?*u32,
            Qualifier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualProcessorType: fn(
            self: *const IDebugControl5,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutingProcessorType: fn(
            self: *const IDebugControl5,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl5,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl5,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcessors: fn(
            self: *const IDebugControl5,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersion: fn(
            self: *const IDebugControl5,
            PlatformId: ?*u32,
            Major: ?*u32,
            Minor: ?*u32,
            ServicePackString: ?[*:0]u8,
            ServicePackStringSize: u32,
            ServicePackStringUsed: ?*u32,
            ServicePackNumber: ?*u32,
            BuildString: ?[*:0]u8,
            BuildStringSize: u32,
            BuildStringUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageSize: fn(
            self: *const IDebugControl5,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPointer64Bit: fn(
            self: *const IDebugControl5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBugCheckData: fn(
            self: *const IDebugControl5,
            Code: ?*u32,
            Arg1: ?*u64,
            Arg2: ?*u64,
            Arg3: ?*u64,
            Arg4: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSupportedProcessorTypes: fn(
            self: *const IDebugControl5,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProcessorTypes: fn(
            self: *const IDebugControl5,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNames: fn(
            self: *const IDebugControl5,
            Type: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectiveProcessorType: fn(
            self: *const IDebugControl5,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectiveProcessorType: fn(
            self: *const IDebugControl5,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatus: fn(
            self: *const IDebugControl5,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExecutionStatus: fn(
            self: *const IDebugControl5,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeLevel: fn(
            self: *const IDebugControl5,
            Level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCodeLevel: fn(
            self: *const IDebugControl5,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineOptions: fn(
            self: *const IDebugControl5,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEngineOptions: fn(
            self: *const IDebugControl5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEngineOptions: fn(
            self: *const IDebugControl5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineOptions: fn(
            self: *const IDebugControl5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemErrorControl: fn(
            self: *const IDebugControl5,
            OutputLevel: ?*u32,
            BreakLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSystemErrorControl: fn(
            self: *const IDebugControl5,
            OutputLevel: u32,
            BreakLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacro: fn(
            self: *const IDebugControl5,
            Slot: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacro: fn(
            self: *const IDebugControl5,
            Slot: u32,
            Macro: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRadix: fn(
            self: *const IDebugControl5,
            Radix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRadix: fn(
            self: *const IDebugControl5,
            Radix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Evaluate: fn(
            self: *const IDebugControl5,
            Expression: ?[*:0]const u8,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValue: fn(
            self: *const IDebugControl5,
            In: ?*DEBUG_VALUE,
            OutType: u32,
            Out: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValues: fn(
            self: *const IDebugControl5,
            Count: u32,
            In: [*]DEBUG_VALUE,
            OutTypes: [*]u32,
            Out: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Command: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFile: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            CommandFile: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberBreakpoints: fn(
            self: *const IDebugControl5,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex: fn(
            self: *const IDebugControl5,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById: fn(
            self: *const IDebugControl5,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointParameters: fn(
            self: *const IDebugControl5,
            Count: u32,
            Ids: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint: fn(
            self: *const IDebugControl5,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint: fn(
            self: *const IDebugControl5,
            Bp: ?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IDebugControl5,
            Path: ?[*:0]const u8,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: fn(
            self: *const IDebugControl5,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPath: fn(
            self: *const IDebugControl5,
            Path: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtension: fn(
            self: *const IDebugControl5,
            Handle: u64,
            Function: ?[*:0]const u8,
            Arguments: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunction: fn(
            self: *const IDebugControl5,
            Handle: u64,
            FuncName: ?[*:0]const u8,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis32: fn(
            self: *const IDebugControl5,
            Api: ?*WINDBG_EXTENSION_APIS32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis64: fn(
            self: *const IDebugControl5,
            Api: ?*WINDBG_EXTENSION_APIS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventFilters: fn(
            self: *const IDebugControl5,
            SpecificEvents: ?*u32,
            SpecificExceptions: ?*u32,
            ArbitraryExceptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterText: fn(
            self: *const IDebugControl5,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommand: fn(
            self: *const IDebugControl5,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommand: fn(
            self: *const IDebugControl5,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterParameters: fn(
            self: *const IDebugControl5,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterParameters: fn(
            self: *const IDebugControl5,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgument: fn(
            self: *const IDebugControl5,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgument: fn(
            self: *const IDebugControl5,
            Index: u32,
            Argument: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterParameters: fn(
            self: *const IDebugControl5,
            Count: u32,
            Codes: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterParameters: fn(
            self: *const IDebugControl5,
            Count: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl5,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl5,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEvent: fn(
            self: *const IDebugControl5,
            Flags: u32,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformation: fn(
            self: *const IDebugControl5,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTimeDate: fn(
            self: *const IDebugControl5,
            TimeDate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemUpTime: fn(
            self: *const IDebugControl5,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFormatFlags: fn(
            self: *const IDebugControl5,
            FormatFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberTextReplacements: fn(
            self: *const IDebugControl5,
            NumRepl: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacement: fn(
            self: *const IDebugControl5,
            SrcText: ?[*:0]const u8,
            Index: u32,
            SrcBuffer: ?[*:0]u8,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u8,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacement: fn(
            self: *const IDebugControl5,
            SrcText: ?[*:0]const u8,
            DstText: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextReplacements: fn(
            self: *const IDebugControl5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTextReplacements: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAssemblyOptions: fn(
            self: *const IDebugControl5,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAssemblyOptions: fn(
            self: *const IDebugControl5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAssemblyOptions: fn(
            self: *const IDebugControl5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAssemblyOptions: fn(
            self: *const IDebugControl5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntax: fn(
            self: *const IDebugControl5,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntax: fn(
            self: *const IDebugControl5,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByName: fn(
            self: *const IDebugControl5,
            AbbrevName: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberExpressionSyntaxes: fn(
            self: *const IDebugControl5,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNames: fn(
            self: *const IDebugControl5,
            Index: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEvents: fn(
            self: *const IDebugControl5,
            Events: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescription: fn(
            self: *const IDebugControl5,
            Index: u32,
            Which: u32,
            Buffer: ?PSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentEventIndex: fn(
            self: *const IDebugControl5,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNextEventIndex: fn(
            self: *const IDebugControl5,
            Relation: u32,
            Value: u32,
            NextIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFileWide: fn(
            self: *const IDebugControl5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFileWide: fn(
            self: *const IDebugControl5,
            File: ?[*:0]const u16,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InputWide: fn(
            self: *const IDebugControl5,
            Buffer: [*:0]u16,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInputWide: fn(
            self: *const IDebugControl5,
            Buffer: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputWide: fn(
            self: *const IDebugControl5,
            Mask: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaListWide: fn(
            self: *const IDebugControl5,
            Mask: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputWide: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaListWide: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptWide: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaListWide: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptTextWide: fn(
            self: *const IDebugControl5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssembleWide: fn(
            self: *const IDebugControl5,
            Offset: u64,
            Instr: ?[*:0]const u16,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisassembleWide: fn(
            self: *const IDebugControl5,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNamesWide: fn(
            self: *const IDebugControl5,
            Type: u32,
            FullNameBuffer: ?[*:0]u16,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u16,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacroWide: fn(
            self: *const IDebugControl5,
            Slot: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacroWide: fn(
            self: *const IDebugControl5,
            Slot: u32,
            Macro: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EvaluateWide: fn(
            self: *const IDebugControl5,
            Expression: ?[*:0]const u16,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteWide: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Command: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFileWide: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            CommandFile: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex2: fn(
            self: *const IDebugControl5,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById2: fn(
            self: *const IDebugControl5,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint2: fn(
            self: *const IDebugControl5,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint2: fn(
            self: *const IDebugControl5,
            Bp: ?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtensionWide: fn(
            self: *const IDebugControl5,
            Path: ?[*:0]const u16,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPathWide: fn(
            self: *const IDebugControl5,
            Path: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtensionWide: fn(
            self: *const IDebugControl5,
            Handle: u64,
            Function: ?[*:0]const u16,
            Arguments: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunctionWide: fn(
            self: *const IDebugControl5,
            Handle: u64,
            FuncName: ?[*:0]const u16,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterTextWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommandWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommandWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgumentWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgumentWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            Argument: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommandWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommandWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformationWide: fn(
            self: *const IDebugControl5,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacementWide: fn(
            self: *const IDebugControl5,
            SrcText: ?[*:0]const u16,
            Index: u32,
            SrcBuffer: ?[*:0]u16,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u16,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacementWide: fn(
            self: *const IDebugControl5,
            SrcText: ?[*:0]const u16,
            DstText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByNameWide: fn(
            self: *const IDebugControl5,
            AbbrevName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNamesWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            FullNameBuffer: ?[*:0]u16,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u16,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescriptionWide: fn(
            self: *const IDebugControl5,
            Index: u32,
            Which: u32,
            Buffer: ?PWSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile2: fn(
            self: *const IDebugControl5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile2: fn(
            self: *const IDebugControl5,
            File: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile2Wide: fn(
            self: *const IDebugControl5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FileSize: ?*u32,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile2Wide: fn(
            self: *const IDebugControl5,
            File: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionValues: fn(
            self: *const IDebugControl5,
            PlatformId: ?*u32,
            Win32Major: ?*u32,
            Win32Minor: ?*u32,
            KdMajor: ?*u32,
            KdMinor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionString: fn(
            self: *const IDebugControl5,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionStringWide: fn(
            self: *const IDebugControl5,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextStackTrace: fn(
            self: *const IDebugControl5,
            // TODO: what to do with BytesParamIndex 1?
            StartContext: ?*c_void,
            StartContextSize: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 5?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputContextStackTrace: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoredEventInformation: fn(
            self: *const IDebugControl5,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            Context: ?*c_void,
            ContextSize: u32,
            ContextUsed: ?*u32,
            // TODO: what to do with BytesParamIndex 7?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManagedStatus: fn(
            self: *const IDebugControl5,
            Flags: ?*u32,
            WhichString: u32,
            String: ?[*:0]u8,
            StringSize: u32,
            StringNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManagedStatusWide: fn(
            self: *const IDebugControl5,
            Flags: ?*u32,
            WhichString: u32,
            String: ?[*:0]u16,
            StringSize: u32,
            StringNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetManagedStatus: fn(
            self: *const IDebugControl5,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTraceEx: fn(
            self: *const IDebugControl5,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTraceEx: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextStackTraceEx: fn(
            self: *const IDebugControl5,
            // TODO: what to do with BytesParamIndex 1?
            StartContext: ?*c_void,
            StartContextSize: u32,
            Frames: ?[*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 5?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputContextStackTraceEx: fn(
            self: *const IDebugControl5,
            OutputControl: u32,
            Frames: [*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByGuid: fn(
            self: *const IDebugControl5,
            Guid: ?*Guid,
            Bp: ?*?*IDebugBreakpoint3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetInterrupt(@ptrCast(*const IDebugControl5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetInterrupt(@ptrCast(*const IDebugControl5, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetInterruptTimeout(@ptrCast(*const IDebugControl5, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetInterruptTimeout(@ptrCast(*const IDebugControl5, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetLogFile(@ptrCast(*const IDebugControl5, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OpenLogFile(@ptrCast(*const IDebugControl5, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).CloseLogFile(@ptrCast(*const IDebugControl5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetLogMask(@ptrCast(*const IDebugControl5, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetLogMask(@ptrCast(*const IDebugControl5, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).Input(@ptrCast(*const IDebugControl5, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ReturnInput(@ptrCast(*const IDebugControl5, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).Output(@ptrCast(*const IDebugControl5, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputVaList(@ptrCast(*const IDebugControl5, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ControlledOutput(@ptrCast(*const IDebugControl5, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ControlledOutputVaList(@ptrCast(*const IDebugControl5, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputPrompt(@ptrCast(*const IDebugControl5, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputPromptVaList(@ptrCast(*const IDebugControl5, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetPromptText(@ptrCast(*const IDebugControl5, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputCurrentState(@ptrCast(*const IDebugControl5, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputVersionInformation(@ptrCast(*const IDebugControl5, self), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNotifyEventHandle(@ptrCast(*const IDebugControl5, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetNotifyEventHandle(@ptrCast(*const IDebugControl5, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).Assemble(@ptrCast(*const IDebugControl5, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).Disassemble(@ptrCast(*const IDebugControl5, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetDisassembleEffectiveOffset(@ptrCast(*const IDebugControl5, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputDisassembly(@ptrCast(*const IDebugControl5, self), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputDisassemblyLines(@ptrCast(*const IDebugControl5, self), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNearInstruction(@ptrCast(*const IDebugControl5, self), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetStackTrace(@ptrCast(*const IDebugControl5, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetReturnOffset(@ptrCast(*const IDebugControl5, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputStackTrace(@ptrCast(*const IDebugControl5, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetDebuggeeType(@ptrCast(*const IDebugControl5, self), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetActualProcessorType(@ptrCast(*const IDebugControl5, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExecutingProcessorType(@ptrCast(*const IDebugControl5, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNumberPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl5, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl5, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNumberProcessors(@ptrCast(*const IDebugControl5, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSystemVersion(@ptrCast(*const IDebugControl5, self), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetPageSize(@ptrCast(*const IDebugControl5, self), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).IsPointer64Bit(@ptrCast(*const IDebugControl5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ReadBugCheckData(@ptrCast(*const IDebugControl5, self), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNumberSupportedProcessorTypes(@ptrCast(*const IDebugControl5, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSupportedProcessorTypes(@ptrCast(*const IDebugControl5, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetProcessorTypeNames(@ptrCast(*const IDebugControl5, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetEffectiveProcessorType(@ptrCast(*const IDebugControl5, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetEffectiveProcessorType(@ptrCast(*const IDebugControl5, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExecutionStatus(@ptrCast(*const IDebugControl5, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetExecutionStatus(@ptrCast(*const IDebugControl5, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetCodeLevel(@ptrCast(*const IDebugControl5, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetCodeLevel(@ptrCast(*const IDebugControl5, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetEngineOptions(@ptrCast(*const IDebugControl5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).AddEngineOptions(@ptrCast(*const IDebugControl5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).RemoveEngineOptions(@ptrCast(*const IDebugControl5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetEngineOptions(@ptrCast(*const IDebugControl5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSystemErrorControl(@ptrCast(*const IDebugControl5, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetSystemErrorControl(@ptrCast(*const IDebugControl5, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetTextMacro(@ptrCast(*const IDebugControl5, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetTextMacro(@ptrCast(*const IDebugControl5, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetRadix(@ptrCast(*const IDebugControl5, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetRadix(@ptrCast(*const IDebugControl5, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).Evaluate(@ptrCast(*const IDebugControl5, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).CoerceValue(@ptrCast(*const IDebugControl5, self), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).CoerceValues(@ptrCast(*const IDebugControl5, self), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).Execute(@ptrCast(*const IDebugControl5, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ExecuteCommandFile(@ptrCast(*const IDebugControl5, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNumberBreakpoints(@ptrCast(*const IDebugControl5, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetBreakpointByIndex(@ptrCast(*const IDebugControl5, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetBreakpointById(@ptrCast(*const IDebugControl5, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetBreakpointParameters(@ptrCast(*const IDebugControl5, self), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).AddBreakpoint(@ptrCast(*const IDebugControl5, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).RemoveBreakpoint(@ptrCast(*const IDebugControl5, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).AddExtension(@ptrCast(*const IDebugControl5, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).RemoveExtension(@ptrCast(*const IDebugControl5, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExtensionByPath(@ptrCast(*const IDebugControl5, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).CallExtension(@ptrCast(*const IDebugControl5, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExtensionFunction(@ptrCast(*const IDebugControl5, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetWindbgExtensionApis32(@ptrCast(*const IDebugControl5, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetWindbgExtensionApis64(@ptrCast(*const IDebugControl5, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNumberEventFilters(@ptrCast(*const IDebugControl5, self), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetEventFilterText(@ptrCast(*const IDebugControl5, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetEventFilterCommand(@ptrCast(*const IDebugControl5, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetEventFilterCommand(@ptrCast(*const IDebugControl5, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSpecificFilterParameters(@ptrCast(*const IDebugControl5, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetSpecificFilterParameters(@ptrCast(*const IDebugControl5, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSpecificFilterArgument(@ptrCast(*const IDebugControl5, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetSpecificFilterArgument(@ptrCast(*const IDebugControl5, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExceptionFilterParameters(@ptrCast(*const IDebugControl5, self), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetExceptionFilterParameters(@ptrCast(*const IDebugControl5, self), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl5, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl5, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).WaitForEvent(@ptrCast(*const IDebugControl5, self), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetLastEventInformation(@ptrCast(*const IDebugControl5, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetCurrentTimeDate(@ptrCast(*const IDebugControl5, self), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetCurrentSystemUpTime(@ptrCast(*const IDebugControl5, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetDumpFormatFlags(@ptrCast(*const IDebugControl5, self), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNumberTextReplacements(@ptrCast(*const IDebugControl5, self), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetTextReplacement(@ptrCast(*const IDebugControl5, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetTextReplacement(@ptrCast(*const IDebugControl5, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).RemoveTextReplacements(@ptrCast(*const IDebugControl5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputTextReplacements(@ptrCast(*const IDebugControl5, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetAssemblyOptions(@ptrCast(*const IDebugControl5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).AddAssemblyOptions(@ptrCast(*const IDebugControl5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).RemoveAssemblyOptions(@ptrCast(*const IDebugControl5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetAssemblyOptions(@ptrCast(*const IDebugControl5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExpressionSyntax(@ptrCast(*const IDebugControl5, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetExpressionSyntax(@ptrCast(*const IDebugControl5, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetExpressionSyntaxByName(@ptrCast(*const IDebugControl5, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNumberExpressionSyntaxes(@ptrCast(*const IDebugControl5, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExpressionSyntaxNames(@ptrCast(*const IDebugControl5, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetNumberEvents(@ptrCast(*const IDebugControl5, self), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetEventIndexDescription(@ptrCast(*const IDebugControl5, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetCurrentEventIndex(@ptrCast(*const IDebugControl5, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetNextEventIndex(@ptrCast(*const IDebugControl5, self), Relation, Value, NextIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetLogFileWide(@ptrCast(*const IDebugControl5, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OpenLogFileWide(self: *const T, File: ?[*:0]const u16, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OpenLogFileWide(@ptrCast(*const IDebugControl5, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).InputWide(@ptrCast(*const IDebugControl5, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ReturnInputWide(self: *const T, Buffer: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ReturnInputWide(@ptrCast(*const IDebugControl5, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputWide(@ptrCast(*const IDebugControl5, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputVaListWide(@ptrCast(*const IDebugControl5, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ControlledOutputWide(@ptrCast(*const IDebugControl5, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ControlledOutputVaListWide(@ptrCast(*const IDebugControl5, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputPromptWide(@ptrCast(*const IDebugControl5, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputPromptVaListWide(@ptrCast(*const IDebugControl5, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetPromptTextWide(@ptrCast(*const IDebugControl5, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]const u16, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).AssembleWide(@ptrCast(*const IDebugControl5, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).DisassembleWide(@ptrCast(*const IDebugControl5, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetProcessorTypeNamesWide(@ptrCast(*const IDebugControl5, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetTextMacroWide(@ptrCast(*const IDebugControl5, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetTextMacroWide(@ptrCast(*const IDebugControl5, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_EvaluateWide(self: *const T, Expression: ?[*:0]const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).EvaluateWide(@ptrCast(*const IDebugControl5, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ExecuteWide(@ptrCast(*const IDebugControl5, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ExecuteCommandFileWide(@ptrCast(*const IDebugControl5, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetBreakpointByIndex2(@ptrCast(*const IDebugControl5, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetBreakpointById2(@ptrCast(*const IDebugControl5, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).AddBreakpoint2(@ptrCast(*const IDebugControl5, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).RemoveBreakpoint2(@ptrCast(*const IDebugControl5, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_AddExtensionWide(self: *const T, Path: ?[*:0]const u16, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).AddExtensionWide(@ptrCast(*const IDebugControl5, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExtensionByPathWide(self: *const T, Path: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExtensionByPathWide(@ptrCast(*const IDebugControl5, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]const u16, Arguments: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).CallExtensionWide(@ptrCast(*const IDebugControl5, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]const u16, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExtensionFunctionWide(@ptrCast(*const IDebugControl5, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetEventFilterTextWide(@ptrCast(*const IDebugControl5, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetEventFilterCommandWide(@ptrCast(*const IDebugControl5, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetEventFilterCommandWide(@ptrCast(*const IDebugControl5, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSpecificFilterArgumentWide(@ptrCast(*const IDebugControl5, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetSpecificFilterArgumentWide(@ptrCast(*const IDebugControl5, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExceptionFilterSecondCommandWide(@ptrCast(*const IDebugControl5, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetExceptionFilterSecondCommandWide(@ptrCast(*const IDebugControl5, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetLastEventInformationWide(@ptrCast(*const IDebugControl5, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetTextReplacementWide(@ptrCast(*const IDebugControl5, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, DstText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetTextReplacementWide(@ptrCast(*const IDebugControl5, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).SetExpressionSyntaxByNameWide(@ptrCast(*const IDebugControl5, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetExpressionSyntaxNamesWide(@ptrCast(*const IDebugControl5, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetEventIndexDescriptionWide(@ptrCast(*const IDebugControl5, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetLogFile2(@ptrCast(*const IDebugControl5, self), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OpenLogFile2(self: *const T, File: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OpenLogFile2(@ptrCast(*const IDebugControl5, self), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetLogFile2Wide(@ptrCast(*const IDebugControl5, self), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OpenLogFile2Wide(self: *const T, File: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OpenLogFile2Wide(@ptrCast(*const IDebugControl5, self), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSystemVersionValues(@ptrCast(*const IDebugControl5, self), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSystemVersionString(@ptrCast(*const IDebugControl5, self), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetSystemVersionStringWide(@ptrCast(*const IDebugControl5, self), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetContextStackTrace(self: *const T, StartContext: ?*c_void, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetContextStackTrace(@ptrCast(*const IDebugControl5, self), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputContextStackTrace(@ptrCast(*const IDebugControl5, self), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*c_void, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetStoredEventInformation(@ptrCast(*const IDebugControl5, self), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetManagedStatus(@ptrCast(*const IDebugControl5, self), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetManagedStatusWide(@ptrCast(*const IDebugControl5, self), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_ResetManagedStatus(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).ResetManagedStatus(@ptrCast(*const IDebugControl5, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetStackTraceEx(@ptrCast(*const IDebugControl5, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputStackTraceEx(@ptrCast(*const IDebugControl5, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetContextStackTraceEx(self: *const T, StartContext: ?*c_void, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetContextStackTraceEx(@ptrCast(*const IDebugControl5, self), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).OutputContextStackTraceEx(@ptrCast(*const IDebugControl5, self), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl5_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl5.VTable, self.vtable).GetBreakpointByGuid(@ptrCast(*const IDebugControl5, self), _param_Guid, Bp);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl6_Value = @import("../../zig.zig").Guid.initString("bc0d583f-126d-43a1-9cc4-a860ab1d537b");
pub const IID_IDebugControl6 = &IID_IDebugControl6_Value;
pub const IDebugControl6 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: fn(
            self: *const IDebugControl6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterrupt: fn(
            self: *const IDebugControl6,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterruptTimeout: fn(
            self: *const IDebugControl6,
            Seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterruptTimeout: fn(
            self: *const IDebugControl6,
            Seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile: fn(
            self: *const IDebugControl6,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile: fn(
            self: *const IDebugControl6,
            File: ?[*:0]const u8,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLogFile: fn(
            self: *const IDebugControl6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogMask: fn(
            self: *const IDebugControl6,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogMask: fn(
            self: *const IDebugControl6,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Input: fn(
            self: *const IDebugControl6,
            Buffer: [*:0]u8,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInput: fn(
            self: *const IDebugControl6,
            Buffer: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Output: fn(
            self: *const IDebugControl6,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaList: fn(
            self: *const IDebugControl6,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutput: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaList: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPrompt: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaList: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptText: fn(
            self: *const IDebugControl6,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputCurrentState: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVersionInformation: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyEventHandle: fn(
            self: *const IDebugControl6,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyEventHandle: fn(
            self: *const IDebugControl6,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Assemble: fn(
            self: *const IDebugControl6,
            Offset: u64,
            Instr: ?[*:0]const u8,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassemble: fn(
            self: *const IDebugControl6,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisassembleEffectiveOffset: fn(
            self: *const IDebugControl6,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassembly: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Offset: u64,
            Flags: u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassemblyLines: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            PreviousLines: u32,
            TotalLines: u32,
            Offset: u64,
            Flags: u32,
            OffsetLine: ?*u32,
            StartOffset: ?*u64,
            EndOffset: ?*u64,
            LineOffsets: ?[*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearInstruction: fn(
            self: *const IDebugControl6,
            Offset: u64,
            Delta: i32,
            NearOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTrace: fn(
            self: *const IDebugControl6,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReturnOffset: fn(
            self: *const IDebugControl6,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTrace: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebuggeeType: fn(
            self: *const IDebugControl6,
            Class: ?*u32,
            Qualifier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualProcessorType: fn(
            self: *const IDebugControl6,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutingProcessorType: fn(
            self: *const IDebugControl6,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl6,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl6,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcessors: fn(
            self: *const IDebugControl6,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersion: fn(
            self: *const IDebugControl6,
            PlatformId: ?*u32,
            Major: ?*u32,
            Minor: ?*u32,
            ServicePackString: ?[*:0]u8,
            ServicePackStringSize: u32,
            ServicePackStringUsed: ?*u32,
            ServicePackNumber: ?*u32,
            BuildString: ?[*:0]u8,
            BuildStringSize: u32,
            BuildStringUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageSize: fn(
            self: *const IDebugControl6,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPointer64Bit: fn(
            self: *const IDebugControl6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBugCheckData: fn(
            self: *const IDebugControl6,
            Code: ?*u32,
            Arg1: ?*u64,
            Arg2: ?*u64,
            Arg3: ?*u64,
            Arg4: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSupportedProcessorTypes: fn(
            self: *const IDebugControl6,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProcessorTypes: fn(
            self: *const IDebugControl6,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNames: fn(
            self: *const IDebugControl6,
            Type: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectiveProcessorType: fn(
            self: *const IDebugControl6,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectiveProcessorType: fn(
            self: *const IDebugControl6,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatus: fn(
            self: *const IDebugControl6,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExecutionStatus: fn(
            self: *const IDebugControl6,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeLevel: fn(
            self: *const IDebugControl6,
            Level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCodeLevel: fn(
            self: *const IDebugControl6,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineOptions: fn(
            self: *const IDebugControl6,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEngineOptions: fn(
            self: *const IDebugControl6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEngineOptions: fn(
            self: *const IDebugControl6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineOptions: fn(
            self: *const IDebugControl6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemErrorControl: fn(
            self: *const IDebugControl6,
            OutputLevel: ?*u32,
            BreakLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSystemErrorControl: fn(
            self: *const IDebugControl6,
            OutputLevel: u32,
            BreakLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacro: fn(
            self: *const IDebugControl6,
            Slot: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacro: fn(
            self: *const IDebugControl6,
            Slot: u32,
            Macro: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRadix: fn(
            self: *const IDebugControl6,
            Radix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRadix: fn(
            self: *const IDebugControl6,
            Radix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Evaluate: fn(
            self: *const IDebugControl6,
            Expression: ?[*:0]const u8,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValue: fn(
            self: *const IDebugControl6,
            In: ?*DEBUG_VALUE,
            OutType: u32,
            Out: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValues: fn(
            self: *const IDebugControl6,
            Count: u32,
            In: [*]DEBUG_VALUE,
            OutTypes: [*]u32,
            Out: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Command: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFile: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            CommandFile: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberBreakpoints: fn(
            self: *const IDebugControl6,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex: fn(
            self: *const IDebugControl6,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById: fn(
            self: *const IDebugControl6,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointParameters: fn(
            self: *const IDebugControl6,
            Count: u32,
            Ids: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint: fn(
            self: *const IDebugControl6,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint: fn(
            self: *const IDebugControl6,
            Bp: ?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IDebugControl6,
            Path: ?[*:0]const u8,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: fn(
            self: *const IDebugControl6,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPath: fn(
            self: *const IDebugControl6,
            Path: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtension: fn(
            self: *const IDebugControl6,
            Handle: u64,
            Function: ?[*:0]const u8,
            Arguments: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunction: fn(
            self: *const IDebugControl6,
            Handle: u64,
            FuncName: ?[*:0]const u8,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis32: fn(
            self: *const IDebugControl6,
            Api: ?*WINDBG_EXTENSION_APIS32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis64: fn(
            self: *const IDebugControl6,
            Api: ?*WINDBG_EXTENSION_APIS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventFilters: fn(
            self: *const IDebugControl6,
            SpecificEvents: ?*u32,
            SpecificExceptions: ?*u32,
            ArbitraryExceptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterText: fn(
            self: *const IDebugControl6,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommand: fn(
            self: *const IDebugControl6,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommand: fn(
            self: *const IDebugControl6,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterParameters: fn(
            self: *const IDebugControl6,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterParameters: fn(
            self: *const IDebugControl6,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgument: fn(
            self: *const IDebugControl6,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgument: fn(
            self: *const IDebugControl6,
            Index: u32,
            Argument: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterParameters: fn(
            self: *const IDebugControl6,
            Count: u32,
            Codes: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterParameters: fn(
            self: *const IDebugControl6,
            Count: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl6,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl6,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEvent: fn(
            self: *const IDebugControl6,
            Flags: u32,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformation: fn(
            self: *const IDebugControl6,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTimeDate: fn(
            self: *const IDebugControl6,
            TimeDate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemUpTime: fn(
            self: *const IDebugControl6,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFormatFlags: fn(
            self: *const IDebugControl6,
            FormatFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberTextReplacements: fn(
            self: *const IDebugControl6,
            NumRepl: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacement: fn(
            self: *const IDebugControl6,
            SrcText: ?[*:0]const u8,
            Index: u32,
            SrcBuffer: ?[*:0]u8,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u8,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacement: fn(
            self: *const IDebugControl6,
            SrcText: ?[*:0]const u8,
            DstText: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextReplacements: fn(
            self: *const IDebugControl6,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTextReplacements: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAssemblyOptions: fn(
            self: *const IDebugControl6,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAssemblyOptions: fn(
            self: *const IDebugControl6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAssemblyOptions: fn(
            self: *const IDebugControl6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAssemblyOptions: fn(
            self: *const IDebugControl6,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntax: fn(
            self: *const IDebugControl6,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntax: fn(
            self: *const IDebugControl6,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByName: fn(
            self: *const IDebugControl6,
            AbbrevName: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberExpressionSyntaxes: fn(
            self: *const IDebugControl6,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNames: fn(
            self: *const IDebugControl6,
            Index: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEvents: fn(
            self: *const IDebugControl6,
            Events: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescription: fn(
            self: *const IDebugControl6,
            Index: u32,
            Which: u32,
            Buffer: ?PSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentEventIndex: fn(
            self: *const IDebugControl6,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNextEventIndex: fn(
            self: *const IDebugControl6,
            Relation: u32,
            Value: u32,
            NextIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFileWide: fn(
            self: *const IDebugControl6,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFileWide: fn(
            self: *const IDebugControl6,
            File: ?[*:0]const u16,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InputWide: fn(
            self: *const IDebugControl6,
            Buffer: [*:0]u16,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInputWide: fn(
            self: *const IDebugControl6,
            Buffer: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputWide: fn(
            self: *const IDebugControl6,
            Mask: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaListWide: fn(
            self: *const IDebugControl6,
            Mask: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputWide: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaListWide: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptWide: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaListWide: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptTextWide: fn(
            self: *const IDebugControl6,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssembleWide: fn(
            self: *const IDebugControl6,
            Offset: u64,
            Instr: ?[*:0]const u16,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisassembleWide: fn(
            self: *const IDebugControl6,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNamesWide: fn(
            self: *const IDebugControl6,
            Type: u32,
            FullNameBuffer: ?[*:0]u16,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u16,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacroWide: fn(
            self: *const IDebugControl6,
            Slot: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacroWide: fn(
            self: *const IDebugControl6,
            Slot: u32,
            Macro: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EvaluateWide: fn(
            self: *const IDebugControl6,
            Expression: ?[*:0]const u16,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteWide: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Command: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFileWide: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            CommandFile: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex2: fn(
            self: *const IDebugControl6,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById2: fn(
            self: *const IDebugControl6,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint2: fn(
            self: *const IDebugControl6,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint2: fn(
            self: *const IDebugControl6,
            Bp: ?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtensionWide: fn(
            self: *const IDebugControl6,
            Path: ?[*:0]const u16,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPathWide: fn(
            self: *const IDebugControl6,
            Path: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtensionWide: fn(
            self: *const IDebugControl6,
            Handle: u64,
            Function: ?[*:0]const u16,
            Arguments: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunctionWide: fn(
            self: *const IDebugControl6,
            Handle: u64,
            FuncName: ?[*:0]const u16,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterTextWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommandWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommandWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgumentWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgumentWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            Argument: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommandWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommandWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformationWide: fn(
            self: *const IDebugControl6,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacementWide: fn(
            self: *const IDebugControl6,
            SrcText: ?[*:0]const u16,
            Index: u32,
            SrcBuffer: ?[*:0]u16,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u16,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacementWide: fn(
            self: *const IDebugControl6,
            SrcText: ?[*:0]const u16,
            DstText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByNameWide: fn(
            self: *const IDebugControl6,
            AbbrevName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNamesWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            FullNameBuffer: ?[*:0]u16,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u16,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescriptionWide: fn(
            self: *const IDebugControl6,
            Index: u32,
            Which: u32,
            Buffer: ?PWSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile2: fn(
            self: *const IDebugControl6,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile2: fn(
            self: *const IDebugControl6,
            File: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile2Wide: fn(
            self: *const IDebugControl6,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FileSize: ?*u32,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile2Wide: fn(
            self: *const IDebugControl6,
            File: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionValues: fn(
            self: *const IDebugControl6,
            PlatformId: ?*u32,
            Win32Major: ?*u32,
            Win32Minor: ?*u32,
            KdMajor: ?*u32,
            KdMinor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionString: fn(
            self: *const IDebugControl6,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionStringWide: fn(
            self: *const IDebugControl6,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextStackTrace: fn(
            self: *const IDebugControl6,
            // TODO: what to do with BytesParamIndex 1?
            StartContext: ?*c_void,
            StartContextSize: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 5?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputContextStackTrace: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoredEventInformation: fn(
            self: *const IDebugControl6,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            Context: ?*c_void,
            ContextSize: u32,
            ContextUsed: ?*u32,
            // TODO: what to do with BytesParamIndex 7?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManagedStatus: fn(
            self: *const IDebugControl6,
            Flags: ?*u32,
            WhichString: u32,
            String: ?[*:0]u8,
            StringSize: u32,
            StringNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManagedStatusWide: fn(
            self: *const IDebugControl6,
            Flags: ?*u32,
            WhichString: u32,
            String: ?[*:0]u16,
            StringSize: u32,
            StringNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetManagedStatus: fn(
            self: *const IDebugControl6,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTraceEx: fn(
            self: *const IDebugControl6,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTraceEx: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextStackTraceEx: fn(
            self: *const IDebugControl6,
            // TODO: what to do with BytesParamIndex 1?
            StartContext: ?*c_void,
            StartContextSize: u32,
            Frames: ?[*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 5?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputContextStackTraceEx: fn(
            self: *const IDebugControl6,
            OutputControl: u32,
            Frames: [*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByGuid: fn(
            self: *const IDebugControl6,
            Guid: ?*Guid,
            Bp: ?*?*IDebugBreakpoint3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatusEx: fn(
            self: *const IDebugControl6,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSynchronizationStatus: fn(
            self: *const IDebugControl6,
            SendsAttempted: ?*u32,
            SecondsSinceLastResponse: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetInterrupt(@ptrCast(*const IDebugControl6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetInterrupt(@ptrCast(*const IDebugControl6, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetInterruptTimeout(@ptrCast(*const IDebugControl6, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetInterruptTimeout(@ptrCast(*const IDebugControl6, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetLogFile(@ptrCast(*const IDebugControl6, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OpenLogFile(@ptrCast(*const IDebugControl6, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).CloseLogFile(@ptrCast(*const IDebugControl6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetLogMask(@ptrCast(*const IDebugControl6, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetLogMask(@ptrCast(*const IDebugControl6, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).Input(@ptrCast(*const IDebugControl6, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ReturnInput(@ptrCast(*const IDebugControl6, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).Output(@ptrCast(*const IDebugControl6, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputVaList(@ptrCast(*const IDebugControl6, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ControlledOutput(@ptrCast(*const IDebugControl6, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ControlledOutputVaList(@ptrCast(*const IDebugControl6, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputPrompt(@ptrCast(*const IDebugControl6, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputPromptVaList(@ptrCast(*const IDebugControl6, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetPromptText(@ptrCast(*const IDebugControl6, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputCurrentState(@ptrCast(*const IDebugControl6, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputVersionInformation(@ptrCast(*const IDebugControl6, self), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNotifyEventHandle(@ptrCast(*const IDebugControl6, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetNotifyEventHandle(@ptrCast(*const IDebugControl6, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).Assemble(@ptrCast(*const IDebugControl6, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).Disassemble(@ptrCast(*const IDebugControl6, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetDisassembleEffectiveOffset(@ptrCast(*const IDebugControl6, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputDisassembly(@ptrCast(*const IDebugControl6, self), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputDisassemblyLines(@ptrCast(*const IDebugControl6, self), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNearInstruction(@ptrCast(*const IDebugControl6, self), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetStackTrace(@ptrCast(*const IDebugControl6, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetReturnOffset(@ptrCast(*const IDebugControl6, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputStackTrace(@ptrCast(*const IDebugControl6, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetDebuggeeType(@ptrCast(*const IDebugControl6, self), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetActualProcessorType(@ptrCast(*const IDebugControl6, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExecutingProcessorType(@ptrCast(*const IDebugControl6, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNumberPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl6, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl6, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNumberProcessors(@ptrCast(*const IDebugControl6, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSystemVersion(@ptrCast(*const IDebugControl6, self), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetPageSize(@ptrCast(*const IDebugControl6, self), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).IsPointer64Bit(@ptrCast(*const IDebugControl6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ReadBugCheckData(@ptrCast(*const IDebugControl6, self), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNumberSupportedProcessorTypes(@ptrCast(*const IDebugControl6, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSupportedProcessorTypes(@ptrCast(*const IDebugControl6, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetProcessorTypeNames(@ptrCast(*const IDebugControl6, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetEffectiveProcessorType(@ptrCast(*const IDebugControl6, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetEffectiveProcessorType(@ptrCast(*const IDebugControl6, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExecutionStatus(@ptrCast(*const IDebugControl6, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetExecutionStatus(@ptrCast(*const IDebugControl6, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetCodeLevel(@ptrCast(*const IDebugControl6, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetCodeLevel(@ptrCast(*const IDebugControl6, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetEngineOptions(@ptrCast(*const IDebugControl6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).AddEngineOptions(@ptrCast(*const IDebugControl6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).RemoveEngineOptions(@ptrCast(*const IDebugControl6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetEngineOptions(@ptrCast(*const IDebugControl6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSystemErrorControl(@ptrCast(*const IDebugControl6, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetSystemErrorControl(@ptrCast(*const IDebugControl6, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetTextMacro(@ptrCast(*const IDebugControl6, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetTextMacro(@ptrCast(*const IDebugControl6, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetRadix(@ptrCast(*const IDebugControl6, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetRadix(@ptrCast(*const IDebugControl6, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).Evaluate(@ptrCast(*const IDebugControl6, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).CoerceValue(@ptrCast(*const IDebugControl6, self), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).CoerceValues(@ptrCast(*const IDebugControl6, self), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).Execute(@ptrCast(*const IDebugControl6, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ExecuteCommandFile(@ptrCast(*const IDebugControl6, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNumberBreakpoints(@ptrCast(*const IDebugControl6, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetBreakpointByIndex(@ptrCast(*const IDebugControl6, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetBreakpointById(@ptrCast(*const IDebugControl6, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetBreakpointParameters(@ptrCast(*const IDebugControl6, self), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).AddBreakpoint(@ptrCast(*const IDebugControl6, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).RemoveBreakpoint(@ptrCast(*const IDebugControl6, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).AddExtension(@ptrCast(*const IDebugControl6, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).RemoveExtension(@ptrCast(*const IDebugControl6, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExtensionByPath(@ptrCast(*const IDebugControl6, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).CallExtension(@ptrCast(*const IDebugControl6, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExtensionFunction(@ptrCast(*const IDebugControl6, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetWindbgExtensionApis32(@ptrCast(*const IDebugControl6, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetWindbgExtensionApis64(@ptrCast(*const IDebugControl6, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNumberEventFilters(@ptrCast(*const IDebugControl6, self), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetEventFilterText(@ptrCast(*const IDebugControl6, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetEventFilterCommand(@ptrCast(*const IDebugControl6, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetEventFilterCommand(@ptrCast(*const IDebugControl6, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSpecificFilterParameters(@ptrCast(*const IDebugControl6, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetSpecificFilterParameters(@ptrCast(*const IDebugControl6, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSpecificFilterArgument(@ptrCast(*const IDebugControl6, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetSpecificFilterArgument(@ptrCast(*const IDebugControl6, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExceptionFilterParameters(@ptrCast(*const IDebugControl6, self), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetExceptionFilterParameters(@ptrCast(*const IDebugControl6, self), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl6, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl6, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).WaitForEvent(@ptrCast(*const IDebugControl6, self), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetLastEventInformation(@ptrCast(*const IDebugControl6, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetCurrentTimeDate(@ptrCast(*const IDebugControl6, self), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetCurrentSystemUpTime(@ptrCast(*const IDebugControl6, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetDumpFormatFlags(@ptrCast(*const IDebugControl6, self), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNumberTextReplacements(@ptrCast(*const IDebugControl6, self), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetTextReplacement(@ptrCast(*const IDebugControl6, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetTextReplacement(@ptrCast(*const IDebugControl6, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).RemoveTextReplacements(@ptrCast(*const IDebugControl6, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputTextReplacements(@ptrCast(*const IDebugControl6, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetAssemblyOptions(@ptrCast(*const IDebugControl6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).AddAssemblyOptions(@ptrCast(*const IDebugControl6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).RemoveAssemblyOptions(@ptrCast(*const IDebugControl6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetAssemblyOptions(@ptrCast(*const IDebugControl6, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExpressionSyntax(@ptrCast(*const IDebugControl6, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetExpressionSyntax(@ptrCast(*const IDebugControl6, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetExpressionSyntaxByName(@ptrCast(*const IDebugControl6, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNumberExpressionSyntaxes(@ptrCast(*const IDebugControl6, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExpressionSyntaxNames(@ptrCast(*const IDebugControl6, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetNumberEvents(@ptrCast(*const IDebugControl6, self), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetEventIndexDescription(@ptrCast(*const IDebugControl6, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetCurrentEventIndex(@ptrCast(*const IDebugControl6, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetNextEventIndex(@ptrCast(*const IDebugControl6, self), Relation, Value, NextIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetLogFileWide(@ptrCast(*const IDebugControl6, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OpenLogFileWide(self: *const T, File: ?[*:0]const u16, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OpenLogFileWide(@ptrCast(*const IDebugControl6, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).InputWide(@ptrCast(*const IDebugControl6, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ReturnInputWide(self: *const T, Buffer: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ReturnInputWide(@ptrCast(*const IDebugControl6, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputWide(@ptrCast(*const IDebugControl6, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputVaListWide(@ptrCast(*const IDebugControl6, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ControlledOutputWide(@ptrCast(*const IDebugControl6, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ControlledOutputVaListWide(@ptrCast(*const IDebugControl6, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputPromptWide(@ptrCast(*const IDebugControl6, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputPromptVaListWide(@ptrCast(*const IDebugControl6, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetPromptTextWide(@ptrCast(*const IDebugControl6, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]const u16, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).AssembleWide(@ptrCast(*const IDebugControl6, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).DisassembleWide(@ptrCast(*const IDebugControl6, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetProcessorTypeNamesWide(@ptrCast(*const IDebugControl6, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetTextMacroWide(@ptrCast(*const IDebugControl6, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetTextMacroWide(@ptrCast(*const IDebugControl6, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_EvaluateWide(self: *const T, Expression: ?[*:0]const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).EvaluateWide(@ptrCast(*const IDebugControl6, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ExecuteWide(@ptrCast(*const IDebugControl6, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ExecuteCommandFileWide(@ptrCast(*const IDebugControl6, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetBreakpointByIndex2(@ptrCast(*const IDebugControl6, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetBreakpointById2(@ptrCast(*const IDebugControl6, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).AddBreakpoint2(@ptrCast(*const IDebugControl6, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).RemoveBreakpoint2(@ptrCast(*const IDebugControl6, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_AddExtensionWide(self: *const T, Path: ?[*:0]const u16, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).AddExtensionWide(@ptrCast(*const IDebugControl6, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExtensionByPathWide(self: *const T, Path: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExtensionByPathWide(@ptrCast(*const IDebugControl6, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]const u16, Arguments: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).CallExtensionWide(@ptrCast(*const IDebugControl6, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]const u16, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExtensionFunctionWide(@ptrCast(*const IDebugControl6, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetEventFilterTextWide(@ptrCast(*const IDebugControl6, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetEventFilterCommandWide(@ptrCast(*const IDebugControl6, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetEventFilterCommandWide(@ptrCast(*const IDebugControl6, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSpecificFilterArgumentWide(@ptrCast(*const IDebugControl6, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetSpecificFilterArgumentWide(@ptrCast(*const IDebugControl6, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExceptionFilterSecondCommandWide(@ptrCast(*const IDebugControl6, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetExceptionFilterSecondCommandWide(@ptrCast(*const IDebugControl6, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetLastEventInformationWide(@ptrCast(*const IDebugControl6, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetTextReplacementWide(@ptrCast(*const IDebugControl6, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, DstText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetTextReplacementWide(@ptrCast(*const IDebugControl6, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).SetExpressionSyntaxByNameWide(@ptrCast(*const IDebugControl6, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExpressionSyntaxNamesWide(@ptrCast(*const IDebugControl6, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetEventIndexDescriptionWide(@ptrCast(*const IDebugControl6, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetLogFile2(@ptrCast(*const IDebugControl6, self), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OpenLogFile2(self: *const T, File: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OpenLogFile2(@ptrCast(*const IDebugControl6, self), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetLogFile2Wide(@ptrCast(*const IDebugControl6, self), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OpenLogFile2Wide(self: *const T, File: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OpenLogFile2Wide(@ptrCast(*const IDebugControl6, self), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSystemVersionValues(@ptrCast(*const IDebugControl6, self), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSystemVersionString(@ptrCast(*const IDebugControl6, self), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSystemVersionStringWide(@ptrCast(*const IDebugControl6, self), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetContextStackTrace(self: *const T, StartContext: ?*c_void, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetContextStackTrace(@ptrCast(*const IDebugControl6, self), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputContextStackTrace(@ptrCast(*const IDebugControl6, self), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*c_void, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetStoredEventInformation(@ptrCast(*const IDebugControl6, self), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetManagedStatus(@ptrCast(*const IDebugControl6, self), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetManagedStatusWide(@ptrCast(*const IDebugControl6, self), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_ResetManagedStatus(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).ResetManagedStatus(@ptrCast(*const IDebugControl6, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetStackTraceEx(@ptrCast(*const IDebugControl6, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputStackTraceEx(@ptrCast(*const IDebugControl6, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetContextStackTraceEx(self: *const T, StartContext: ?*c_void, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetContextStackTraceEx(@ptrCast(*const IDebugControl6, self), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).OutputContextStackTraceEx(@ptrCast(*const IDebugControl6, self), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetBreakpointByGuid(@ptrCast(*const IDebugControl6, self), _param_Guid, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetExecutionStatusEx(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetExecutionStatusEx(@ptrCast(*const IDebugControl6, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl6_GetSynchronizationStatus(self: *const T, SendsAttempted: ?*u32, SecondsSinceLastResponse: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl6.VTable, self.vtable).GetSynchronizationStatus(@ptrCast(*const IDebugControl6, self), SendsAttempted, SecondsSinceLastResponse);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugControl7_Value = @import("../../zig.zig").Guid.initString("b86fb3b1-80d4-475b-aea3-cf06539cf63a");
pub const IID_IDebugControl7 = &IID_IDebugControl7_Value;
pub const IDebugControl7 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterrupt: fn(
            self: *const IDebugControl7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterrupt: fn(
            self: *const IDebugControl7,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterruptTimeout: fn(
            self: *const IDebugControl7,
            Seconds: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetInterruptTimeout: fn(
            self: *const IDebugControl7,
            Seconds: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile: fn(
            self: *const IDebugControl7,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile: fn(
            self: *const IDebugControl7,
            File: ?[*:0]const u8,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CloseLogFile: fn(
            self: *const IDebugControl7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogMask: fn(
            self: *const IDebugControl7,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetLogMask: fn(
            self: *const IDebugControl7,
            Mask: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Input: fn(
            self: *const IDebugControl7,
            Buffer: [*:0]u8,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInput: fn(
            self: *const IDebugControl7,
            Buffer: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Output: fn(
            self: *const IDebugControl7,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaList: fn(
            self: *const IDebugControl7,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutput: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaList: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPrompt: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Format: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaList: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Format: ?[*:0]const u8,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptText: fn(
            self: *const IDebugControl7,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputCurrentState: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVersionInformation: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNotifyEventHandle: fn(
            self: *const IDebugControl7,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNotifyEventHandle: fn(
            self: *const IDebugControl7,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Assemble: fn(
            self: *const IDebugControl7,
            Offset: u64,
            Instr: ?[*:0]const u8,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Disassemble: fn(
            self: *const IDebugControl7,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisassembleEffectiveOffset: fn(
            self: *const IDebugControl7,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassembly: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Offset: u64,
            Flags: u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputDisassemblyLines: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            PreviousLines: u32,
            TotalLines: u32,
            Offset: u64,
            Flags: u32,
            OffsetLine: ?*u32,
            StartOffset: ?*u64,
            EndOffset: ?*u64,
            LineOffsets: ?[*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearInstruction: fn(
            self: *const IDebugControl7,
            Offset: u64,
            Delta: i32,
            NearOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTrace: fn(
            self: *const IDebugControl7,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetReturnOffset: fn(
            self: *const IDebugControl7,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTrace: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebuggeeType: fn(
            self: *const IDebugControl7,
            Class: ?*u32,
            Qualifier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetActualProcessorType: fn(
            self: *const IDebugControl7,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutingProcessorType: fn(
            self: *const IDebugControl7,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl7,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPossibleExecutingProcessorTypes: fn(
            self: *const IDebugControl7,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcessors: fn(
            self: *const IDebugControl7,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersion: fn(
            self: *const IDebugControl7,
            PlatformId: ?*u32,
            Major: ?*u32,
            Minor: ?*u32,
            ServicePackString: ?[*:0]u8,
            ServicePackStringSize: u32,
            ServicePackStringUsed: ?*u32,
            ServicePackNumber: ?*u32,
            BuildString: ?[*:0]u8,
            BuildStringSize: u32,
            BuildStringUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPageSize: fn(
            self: *const IDebugControl7,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsPointer64Bit: fn(
            self: *const IDebugControl7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBugCheckData: fn(
            self: *const IDebugControl7,
            Code: ?*u32,
            Arg1: ?*u64,
            Arg2: ?*u64,
            Arg3: ?*u64,
            Arg4: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSupportedProcessorTypes: fn(
            self: *const IDebugControl7,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSupportedProcessorTypes: fn(
            self: *const IDebugControl7,
            Start: u32,
            Count: u32,
            Types: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNames: fn(
            self: *const IDebugControl7,
            Type: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEffectiveProcessorType: fn(
            self: *const IDebugControl7,
            Type: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEffectiveProcessorType: fn(
            self: *const IDebugControl7,
            Type: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatus: fn(
            self: *const IDebugControl7,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExecutionStatus: fn(
            self: *const IDebugControl7,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCodeLevel: fn(
            self: *const IDebugControl7,
            Level: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCodeLevel: fn(
            self: *const IDebugControl7,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEngineOptions: fn(
            self: *const IDebugControl7,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddEngineOptions: fn(
            self: *const IDebugControl7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveEngineOptions: fn(
            self: *const IDebugControl7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEngineOptions: fn(
            self: *const IDebugControl7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemErrorControl: fn(
            self: *const IDebugControl7,
            OutputLevel: ?*u32,
            BreakLevel: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSystemErrorControl: fn(
            self: *const IDebugControl7,
            OutputLevel: u32,
            BreakLevel: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacro: fn(
            self: *const IDebugControl7,
            Slot: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacro: fn(
            self: *const IDebugControl7,
            Slot: u32,
            Macro: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRadix: fn(
            self: *const IDebugControl7,
            Radix: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetRadix: fn(
            self: *const IDebugControl7,
            Radix: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Evaluate: fn(
            self: *const IDebugControl7,
            Expression: ?[*:0]const u8,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValue: fn(
            self: *const IDebugControl7,
            In: ?*DEBUG_VALUE,
            OutType: u32,
            Out: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CoerceValues: fn(
            self: *const IDebugControl7,
            Count: u32,
            In: [*]DEBUG_VALUE,
            OutTypes: [*]u32,
            Out: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Command: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFile: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            CommandFile: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberBreakpoints: fn(
            self: *const IDebugControl7,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex: fn(
            self: *const IDebugControl7,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById: fn(
            self: *const IDebugControl7,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointParameters: fn(
            self: *const IDebugControl7,
            Count: u32,
            Ids: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_BREAKPOINT_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint: fn(
            self: *const IDebugControl7,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint: fn(
            self: *const IDebugControl7,
            Bp: ?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtension: fn(
            self: *const IDebugControl7,
            Path: ?[*:0]const u8,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveExtension: fn(
            self: *const IDebugControl7,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPath: fn(
            self: *const IDebugControl7,
            Path: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtension: fn(
            self: *const IDebugControl7,
            Handle: u64,
            Function: ?[*:0]const u8,
            Arguments: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunction: fn(
            self: *const IDebugControl7,
            Handle: u64,
            FuncName: ?[*:0]const u8,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis32: fn(
            self: *const IDebugControl7,
            Api: ?*WINDBG_EXTENSION_APIS32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetWindbgExtensionApis64: fn(
            self: *const IDebugControl7,
            Api: ?*WINDBG_EXTENSION_APIS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEventFilters: fn(
            self: *const IDebugControl7,
            SpecificEvents: ?*u32,
            SpecificExceptions: ?*u32,
            ArbitraryExceptions: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterText: fn(
            self: *const IDebugControl7,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommand: fn(
            self: *const IDebugControl7,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommand: fn(
            self: *const IDebugControl7,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterParameters: fn(
            self: *const IDebugControl7,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterParameters: fn(
            self: *const IDebugControl7,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgument: fn(
            self: *const IDebugControl7,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgument: fn(
            self: *const IDebugControl7,
            Index: u32,
            Argument: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterParameters: fn(
            self: *const IDebugControl7,
            Count: u32,
            Codes: ?[*]u32,
            Start: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterParameters: fn(
            self: *const IDebugControl7,
            Count: u32,
            Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl7,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommand: fn(
            self: *const IDebugControl7,
            Index: u32,
            Command: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WaitForEvent: fn(
            self: *const IDebugControl7,
            Flags: u32,
            Timeout: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformation: fn(
            self: *const IDebugControl7,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u8,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentTimeDate: fn(
            self: *const IDebugControl7,
            TimeDate: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemUpTime: fn(
            self: *const IDebugControl7,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDumpFormatFlags: fn(
            self: *const IDebugControl7,
            FormatFlags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberTextReplacements: fn(
            self: *const IDebugControl7,
            NumRepl: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacement: fn(
            self: *const IDebugControl7,
            SrcText: ?[*:0]const u8,
            Index: u32,
            SrcBuffer: ?[*:0]u8,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u8,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacement: fn(
            self: *const IDebugControl7,
            SrcText: ?[*:0]const u8,
            DstText: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTextReplacements: fn(
            self: *const IDebugControl7,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTextReplacements: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAssemblyOptions: fn(
            self: *const IDebugControl7,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddAssemblyOptions: fn(
            self: *const IDebugControl7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveAssemblyOptions: fn(
            self: *const IDebugControl7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAssemblyOptions: fn(
            self: *const IDebugControl7,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntax: fn(
            self: *const IDebugControl7,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntax: fn(
            self: *const IDebugControl7,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByName: fn(
            self: *const IDebugControl7,
            AbbrevName: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberExpressionSyntaxes: fn(
            self: *const IDebugControl7,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNames: fn(
            self: *const IDebugControl7,
            Index: u32,
            FullNameBuffer: ?[*:0]u8,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u8,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberEvents: fn(
            self: *const IDebugControl7,
            Events: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescription: fn(
            self: *const IDebugControl7,
            Index: u32,
            Which: u32,
            Buffer: ?PSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentEventIndex: fn(
            self: *const IDebugControl7,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetNextEventIndex: fn(
            self: *const IDebugControl7,
            Relation: u32,
            Value: u32,
            NextIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFileWide: fn(
            self: *const IDebugControl7,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FileSize: ?*u32,
            Append: ?*BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFileWide: fn(
            self: *const IDebugControl7,
            File: ?[*:0]const u16,
            Append: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InputWide: fn(
            self: *const IDebugControl7,
            Buffer: [*:0]u16,
            BufferSize: u32,
            InputSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReturnInputWide: fn(
            self: *const IDebugControl7,
            Buffer: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputWide: fn(
            self: *const IDebugControl7,
            Mask: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputVaListWide: fn(
            self: *const IDebugControl7,
            Mask: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputWide: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ControlledOutputVaListWide: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Mask: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptWide: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Format: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputPromptVaListWide: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Format: ?[*:0]const u16,
            Args: ?*i8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPromptTextWide: fn(
            self: *const IDebugControl7,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AssembleWide: fn(
            self: *const IDebugControl7,
            Offset: u64,
            Instr: ?[*:0]const u16,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DisassembleWide: fn(
            self: *const IDebugControl7,
            Offset: u64,
            Flags: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            DisassemblySize: ?*u32,
            EndOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessorTypeNamesWide: fn(
            self: *const IDebugControl7,
            Type: u32,
            FullNameBuffer: ?[*:0]u16,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u16,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextMacroWide: fn(
            self: *const IDebugControl7,
            Slot: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            MacroSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextMacroWide: fn(
            self: *const IDebugControl7,
            Slot: u32,
            Macro: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EvaluateWide: fn(
            self: *const IDebugControl7,
            Expression: ?[*:0]const u16,
            DesiredType: u32,
            Value: ?*DEBUG_VALUE,
            RemainderIndex: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteWide: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Command: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExecuteCommandFileWide: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            CommandFile: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByIndex2: fn(
            self: *const IDebugControl7,
            Index: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointById2: fn(
            self: *const IDebugControl7,
            Id: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddBreakpoint2: fn(
            self: *const IDebugControl7,
            Type: u32,
            DesiredId: u32,
            Bp: ?*?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveBreakpoint2: fn(
            self: *const IDebugControl7,
            Bp: ?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddExtensionWide: fn(
            self: *const IDebugControl7,
            Path: ?[*:0]const u16,
            Flags: u32,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionByPathWide: fn(
            self: *const IDebugControl7,
            Path: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CallExtensionWide: fn(
            self: *const IDebugControl7,
            Handle: u64,
            Function: ?[*:0]const u16,
            Arguments: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtensionFunctionWide: fn(
            self: *const IDebugControl7,
            Handle: u64,
            FuncName: ?[*:0]const u16,
            Function: ?*?FARPROC,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterTextWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            TextSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilterCommandWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilterCommandWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSpecificFilterArgumentWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ArgumentSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSpecificFilterArgumentWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            Argument: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExceptionFilterSecondCommandWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            CommandSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExceptionFilterSecondCommandWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            Command: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLastEventInformationWide: fn(
            self: *const IDebugControl7,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
            Description: ?[*:0]u16,
            DescriptionSize: u32,
            DescriptionUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTextReplacementWide: fn(
            self: *const IDebugControl7,
            SrcText: ?[*:0]const u16,
            Index: u32,
            SrcBuffer: ?[*:0]u16,
            SrcBufferSize: u32,
            SrcSize: ?*u32,
            DstBuffer: ?[*:0]u16,
            DstBufferSize: u32,
            DstSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTextReplacementWide: fn(
            self: *const IDebugControl7,
            SrcText: ?[*:0]const u16,
            DstText: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetExpressionSyntaxByNameWide: fn(
            self: *const IDebugControl7,
            AbbrevName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExpressionSyntaxNamesWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            FullNameBuffer: ?[*:0]u16,
            FullNameBufferSize: u32,
            FullNameSize: ?*u32,
            AbbrevNameBuffer: ?[*:0]u16,
            AbbrevNameBufferSize: u32,
            AbbrevNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventIndexDescriptionWide: fn(
            self: *const IDebugControl7,
            Index: u32,
            Which: u32,
            Buffer: ?PWSTR,
            BufferSize: u32,
            DescSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile2: fn(
            self: *const IDebugControl7,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FileSize: ?*u32,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile2: fn(
            self: *const IDebugControl7,
            File: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLogFile2Wide: fn(
            self: *const IDebugControl7,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FileSize: ?*u32,
            Flags: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OpenLogFile2Wide: fn(
            self: *const IDebugControl7,
            File: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionValues: fn(
            self: *const IDebugControl7,
            PlatformId: ?*u32,
            Win32Major: ?*u32,
            Win32Minor: ?*u32,
            KdMajor: ?*u32,
            KdMinor: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionString: fn(
            self: *const IDebugControl7,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemVersionStringWide: fn(
            self: *const IDebugControl7,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextStackTrace: fn(
            self: *const IDebugControl7,
            // TODO: what to do with BytesParamIndex 1?
            StartContext: ?*c_void,
            StartContextSize: u32,
            Frames: ?[*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 5?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputContextStackTrace: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Frames: [*]DEBUG_STACK_FRAME,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStoredEventInformation: fn(
            self: *const IDebugControl7,
            Type: ?*u32,
            ProcessId: ?*u32,
            ThreadId: ?*u32,
            // TODO: what to do with BytesParamIndex 4?
            Context: ?*c_void,
            ContextSize: u32,
            ContextUsed: ?*u32,
            // TODO: what to do with BytesParamIndex 7?
            ExtraInformation: ?*c_void,
            ExtraInformationSize: u32,
            ExtraInformationUsed: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManagedStatus: fn(
            self: *const IDebugControl7,
            Flags: ?*u32,
            WhichString: u32,
            String: ?[*:0]u8,
            StringSize: u32,
            StringNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetManagedStatusWide: fn(
            self: *const IDebugControl7,
            Flags: ?*u32,
            WhichString: u32,
            String: ?[*:0]u16,
            StringSize: u32,
            StringNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetManagedStatus: fn(
            self: *const IDebugControl7,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackTraceEx: fn(
            self: *const IDebugControl7,
            FrameOffset: u64,
            StackOffset: u64,
            InstructionOffset: u64,
            Frames: [*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputStackTraceEx: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Frames: ?[*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextStackTraceEx: fn(
            self: *const IDebugControl7,
            // TODO: what to do with BytesParamIndex 1?
            StartContext: ?*c_void,
            StartContextSize: u32,
            Frames: ?[*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 5?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            FramesFilled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputContextStackTraceEx: fn(
            self: *const IDebugControl7,
            OutputControl: u32,
            Frames: [*]DEBUG_STACK_FRAME_EX,
            FramesSize: u32,
            // TODO: what to do with BytesParamIndex 4?
            FrameContexts: ?*c_void,
            FrameContextsSize: u32,
            FrameContextsEntrySize: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBreakpointByGuid: fn(
            self: *const IDebugControl7,
            Guid: ?*Guid,
            Bp: ?*?*IDebugBreakpoint3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExecutionStatusEx: fn(
            self: *const IDebugControl7,
            Status: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSynchronizationStatus: fn(
            self: *const IDebugControl7,
            SendsAttempted: ?*u32,
            SecondsSinceLastResponse: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDebuggeeType2: fn(
            self: *const IDebugControl7,
            Flags: u32,
            Class: ?*u32,
            Qualifier: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetInterrupt(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetInterrupt(@ptrCast(*const IDebugControl7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetInterrupt(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetInterrupt(@ptrCast(*const IDebugControl7, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetInterruptTimeout(self: *const T, Seconds: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetInterruptTimeout(@ptrCast(*const IDebugControl7, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetInterruptTimeout(self: *const T, Seconds: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetInterruptTimeout(@ptrCast(*const IDebugControl7, self), Seconds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogFile(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetLogFile(@ptrCast(*const IDebugControl7, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OpenLogFile(self: *const T, File: ?[*:0]const u8, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OpenLogFile(@ptrCast(*const IDebugControl7, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CloseLogFile(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).CloseLogFile(@ptrCast(*const IDebugControl7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetLogMask(@ptrCast(*const IDebugControl7, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetLogMask(self: *const T, Mask: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetLogMask(@ptrCast(*const IDebugControl7, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Input(self: *const T, Buffer: [*:0]u8, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).Input(@ptrCast(*const IDebugControl7, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ReturnInput(self: *const T, Buffer: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ReturnInput(@ptrCast(*const IDebugControl7, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Output(self: *const T, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).Output(@ptrCast(*const IDebugControl7, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputVaList(self: *const T, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputVaList(@ptrCast(*const IDebugControl7, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ControlledOutput(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ControlledOutput(@ptrCast(*const IDebugControl7, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ControlledOutputVaList(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ControlledOutputVaList(@ptrCast(*const IDebugControl7, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputPrompt(self: *const T, OutputControl: u32, Format: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputPrompt(@ptrCast(*const IDebugControl7, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputPromptVaList(self: *const T, OutputControl: u32, Format: ?[*:0]const u8, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputPromptVaList(@ptrCast(*const IDebugControl7, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetPromptText(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetPromptText(@ptrCast(*const IDebugControl7, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputCurrentState(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputCurrentState(@ptrCast(*const IDebugControl7, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputVersionInformation(self: *const T, OutputControl: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputVersionInformation(@ptrCast(*const IDebugControl7, self), OutputControl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNotifyEventHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNotifyEventHandle(@ptrCast(*const IDebugControl7, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetNotifyEventHandle(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetNotifyEventHandle(@ptrCast(*const IDebugControl7, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Assemble(self: *const T, Offset: u64, Instr: ?[*:0]const u8, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).Assemble(@ptrCast(*const IDebugControl7, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Disassemble(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u8, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).Disassemble(@ptrCast(*const IDebugControl7, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetDisassembleEffectiveOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetDisassembleEffectiveOffset(@ptrCast(*const IDebugControl7, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputDisassembly(self: *const T, OutputControl: u32, Offset: u64, Flags: u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputDisassembly(@ptrCast(*const IDebugControl7, self), OutputControl, Offset, Flags, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputDisassemblyLines(self: *const T, OutputControl: u32, PreviousLines: u32, TotalLines: u32, Offset: u64, Flags: u32, OffsetLine: ?*u32, StartOffset: ?*u64, EndOffset: ?*u64, LineOffsets: ?[*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputDisassemblyLines(@ptrCast(*const IDebugControl7, self), OutputControl, PreviousLines, TotalLines, Offset, Flags, OffsetLine, StartOffset, EndOffset, LineOffsets);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNearInstruction(self: *const T, Offset: u64, Delta: i32, NearOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNearInstruction(@ptrCast(*const IDebugControl7, self), Offset, Delta, NearOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetStackTrace(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetStackTrace(@ptrCast(*const IDebugControl7, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetReturnOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetReturnOffset(@ptrCast(*const IDebugControl7, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputStackTrace(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputStackTrace(@ptrCast(*const IDebugControl7, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetDebuggeeType(self: *const T, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetDebuggeeType(@ptrCast(*const IDebugControl7, self), Class, Qualifier);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetActualProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetActualProcessorType(@ptrCast(*const IDebugControl7, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExecutingProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExecutingProcessorType(@ptrCast(*const IDebugControl7, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberPossibleExecutingProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNumberPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl7, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetPossibleExecutingProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetPossibleExecutingProcessorTypes(@ptrCast(*const IDebugControl7, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberProcessors(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNumberProcessors(@ptrCast(*const IDebugControl7, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemVersion(self: *const T, PlatformId: ?*u32, Major: ?*u32, Minor: ?*u32, ServicePackString: ?[*:0]u8, ServicePackStringSize: u32, ServicePackStringUsed: ?*u32, ServicePackNumber: ?*u32, BuildString: ?[*:0]u8, BuildStringSize: u32, BuildStringUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSystemVersion(@ptrCast(*const IDebugControl7, self), PlatformId, Major, Minor, ServicePackString, ServicePackStringSize, ServicePackStringUsed, ServicePackNumber, BuildString, BuildStringSize, BuildStringUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetPageSize(self: *const T, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetPageSize(@ptrCast(*const IDebugControl7, self), Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_IsPointer64Bit(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).IsPointer64Bit(@ptrCast(*const IDebugControl7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ReadBugCheckData(self: *const T, Code: ?*u32, Arg1: ?*u64, Arg2: ?*u64, Arg3: ?*u64, Arg4: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ReadBugCheckData(@ptrCast(*const IDebugControl7, self), Code, Arg1, Arg2, Arg3, Arg4);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberSupportedProcessorTypes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNumberSupportedProcessorTypes(@ptrCast(*const IDebugControl7, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSupportedProcessorTypes(self: *const T, Start: u32, Count: u32, Types: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSupportedProcessorTypes(@ptrCast(*const IDebugControl7, self), Start, Count, Types);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetProcessorTypeNames(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetProcessorTypeNames(@ptrCast(*const IDebugControl7, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEffectiveProcessorType(self: *const T, Type: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetEffectiveProcessorType(@ptrCast(*const IDebugControl7, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetEffectiveProcessorType(self: *const T, Type: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetEffectiveProcessorType(@ptrCast(*const IDebugControl7, self), Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExecutionStatus(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExecutionStatus(@ptrCast(*const IDebugControl7, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExecutionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetExecutionStatus(@ptrCast(*const IDebugControl7, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetCodeLevel(self: *const T, Level: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetCodeLevel(@ptrCast(*const IDebugControl7, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetCodeLevel(self: *const T, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetCodeLevel(@ptrCast(*const IDebugControl7, self), Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEngineOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetEngineOptions(@ptrCast(*const IDebugControl7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).AddEngineOptions(@ptrCast(*const IDebugControl7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).RemoveEngineOptions(@ptrCast(*const IDebugControl7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetEngineOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetEngineOptions(@ptrCast(*const IDebugControl7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemErrorControl(self: *const T, OutputLevel: ?*u32, BreakLevel: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSystemErrorControl(@ptrCast(*const IDebugControl7, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetSystemErrorControl(self: *const T, OutputLevel: u32, BreakLevel: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetSystemErrorControl(@ptrCast(*const IDebugControl7, self), OutputLevel, BreakLevel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetTextMacro(self: *const T, Slot: u32, Buffer: ?[*:0]u8, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetTextMacro(@ptrCast(*const IDebugControl7, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetTextMacro(self: *const T, Slot: u32, Macro: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetTextMacro(@ptrCast(*const IDebugControl7, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetRadix(self: *const T, Radix: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetRadix(@ptrCast(*const IDebugControl7, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetRadix(self: *const T, Radix: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetRadix(@ptrCast(*const IDebugControl7, self), Radix);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Evaluate(self: *const T, Expression: ?[*:0]const u8, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).Evaluate(@ptrCast(*const IDebugControl7, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CoerceValue(self: *const T, In: ?*DEBUG_VALUE, OutType: u32, Out: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).CoerceValue(@ptrCast(*const IDebugControl7, self), In, OutType, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CoerceValues(self: *const T, Count: u32, In: [*]DEBUG_VALUE, OutTypes: [*]u32, Out: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).CoerceValues(@ptrCast(*const IDebugControl7, self), Count, In, OutTypes, Out);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_Execute(self: *const T, OutputControl: u32, Command: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).Execute(@ptrCast(*const IDebugControl7, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ExecuteCommandFile(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ExecuteCommandFile(@ptrCast(*const IDebugControl7, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberBreakpoints(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNumberBreakpoints(@ptrCast(*const IDebugControl7, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointByIndex(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetBreakpointByIndex(@ptrCast(*const IDebugControl7, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointById(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetBreakpointById(@ptrCast(*const IDebugControl7, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointParameters(self: *const T, Count: u32, Ids: ?[*]u32, Start: u32, Params: [*]DEBUG_BREAKPOINT_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetBreakpointParameters(@ptrCast(*const IDebugControl7, self), Count, Ids, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddBreakpoint(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).AddBreakpoint(@ptrCast(*const IDebugControl7, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveBreakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).RemoveBreakpoint(@ptrCast(*const IDebugControl7, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddExtension(self: *const T, Path: ?[*:0]const u8, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).AddExtension(@ptrCast(*const IDebugControl7, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveExtension(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).RemoveExtension(@ptrCast(*const IDebugControl7, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExtensionByPath(self: *const T, Path: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExtensionByPath(@ptrCast(*const IDebugControl7, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CallExtension(self: *const T, Handle: u64, Function: ?[*:0]const u8, Arguments: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).CallExtension(@ptrCast(*const IDebugControl7, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExtensionFunction(self: *const T, Handle: u64, FuncName: ?[*:0]const u8, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExtensionFunction(@ptrCast(*const IDebugControl7, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetWindbgExtensionApis32(self: *const T, Api: ?*WINDBG_EXTENSION_APIS32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetWindbgExtensionApis32(@ptrCast(*const IDebugControl7, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetWindbgExtensionApis64(self: *const T, Api: ?*WINDBG_EXTENSION_APIS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetWindbgExtensionApis64(@ptrCast(*const IDebugControl7, self), Api);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberEventFilters(self: *const T, SpecificEvents: ?*u32, SpecificExceptions: ?*u32, ArbitraryExceptions: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNumberEventFilters(@ptrCast(*const IDebugControl7, self), SpecificEvents, SpecificExceptions, ArbitraryExceptions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventFilterText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetEventFilterText(@ptrCast(*const IDebugControl7, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventFilterCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetEventFilterCommand(@ptrCast(*const IDebugControl7, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetEventFilterCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetEventFilterCommand(@ptrCast(*const IDebugControl7, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSpecificFilterParameters(@ptrCast(*const IDebugControl7, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetSpecificFilterParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SPECIFIC_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetSpecificFilterParameters(@ptrCast(*const IDebugControl7, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSpecificFilterArgument(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSpecificFilterArgument(@ptrCast(*const IDebugControl7, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetSpecificFilterArgument(self: *const T, Index: u32, Argument: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetSpecificFilterArgument(@ptrCast(*const IDebugControl7, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExceptionFilterParameters(self: *const T, Count: u32, Codes: ?[*]u32, Start: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExceptionFilterParameters(@ptrCast(*const IDebugControl7, self), Count, Codes, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExceptionFilterParameters(self: *const T, Count: u32, Params: [*]DEBUG_EXCEPTION_FILTER_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetExceptionFilterParameters(@ptrCast(*const IDebugControl7, self), Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExceptionFilterSecondCommand(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl7, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExceptionFilterSecondCommand(self: *const T, Index: u32, Command: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetExceptionFilterSecondCommand(@ptrCast(*const IDebugControl7, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_WaitForEvent(self: *const T, Flags: u32, Timeout: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).WaitForEvent(@ptrCast(*const IDebugControl7, self), Flags, Timeout);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLastEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u8, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetLastEventInformation(@ptrCast(*const IDebugControl7, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetCurrentTimeDate(self: *const T, TimeDate: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetCurrentTimeDate(@ptrCast(*const IDebugControl7, self), TimeDate);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetCurrentSystemUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetCurrentSystemUpTime(@ptrCast(*const IDebugControl7, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetDumpFormatFlags(self: *const T, FormatFlags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetDumpFormatFlags(@ptrCast(*const IDebugControl7, self), FormatFlags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberTextReplacements(self: *const T, NumRepl: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNumberTextReplacements(@ptrCast(*const IDebugControl7, self), NumRepl);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, Index: u32, SrcBuffer: ?[*:0]u8, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u8, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetTextReplacement(@ptrCast(*const IDebugControl7, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetTextReplacement(self: *const T, SrcText: ?[*:0]const u8, DstText: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetTextReplacement(@ptrCast(*const IDebugControl7, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveTextReplacements(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).RemoveTextReplacements(@ptrCast(*const IDebugControl7, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputTextReplacements(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputTextReplacements(@ptrCast(*const IDebugControl7, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetAssemblyOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetAssemblyOptions(@ptrCast(*const IDebugControl7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).AddAssemblyOptions(@ptrCast(*const IDebugControl7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).RemoveAssemblyOptions(@ptrCast(*const IDebugControl7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetAssemblyOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetAssemblyOptions(@ptrCast(*const IDebugControl7, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExpressionSyntax(self: *const T, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExpressionSyntax(@ptrCast(*const IDebugControl7, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExpressionSyntax(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetExpressionSyntax(@ptrCast(*const IDebugControl7, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExpressionSyntaxByName(self: *const T, AbbrevName: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetExpressionSyntaxByName(@ptrCast(*const IDebugControl7, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberExpressionSyntaxes(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNumberExpressionSyntaxes(@ptrCast(*const IDebugControl7, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExpressionSyntaxNames(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u8, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u8, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExpressionSyntaxNames(@ptrCast(*const IDebugControl7, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetNumberEvents(self: *const T, Events: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetNumberEvents(@ptrCast(*const IDebugControl7, self), Events);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventIndexDescription(self: *const T, Index: u32, Which: u32, Buffer: ?PSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetEventIndexDescription(@ptrCast(*const IDebugControl7, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetCurrentEventIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetCurrentEventIndex(@ptrCast(*const IDebugControl7, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetNextEventIndex(self: *const T, Relation: u32, Value: u32, NextIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetNextEventIndex(@ptrCast(*const IDebugControl7, self), Relation, Value, NextIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogFileWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Append: ?*BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetLogFileWide(@ptrCast(*const IDebugControl7, self), Buffer, BufferSize, FileSize, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OpenLogFileWide(self: *const T, File: ?[*:0]const u16, Append: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OpenLogFileWide(@ptrCast(*const IDebugControl7, self), File, Append);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_InputWide(self: *const T, Buffer: [*:0]u16, BufferSize: u32, InputSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).InputWide(@ptrCast(*const IDebugControl7, self), Buffer, BufferSize, InputSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ReturnInputWide(self: *const T, Buffer: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ReturnInputWide(@ptrCast(*const IDebugControl7, self), Buffer);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputWide(self: *const T, Mask: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputWide(@ptrCast(*const IDebugControl7, self), Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputVaListWide(self: *const T, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputVaListWide(@ptrCast(*const IDebugControl7, self), Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ControlledOutputWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ControlledOutputWide(@ptrCast(*const IDebugControl7, self), OutputControl, Mask, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ControlledOutputVaListWide(self: *const T, OutputControl: u32, Mask: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ControlledOutputVaListWide(@ptrCast(*const IDebugControl7, self), OutputControl, Mask, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputPromptWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputPromptWide(@ptrCast(*const IDebugControl7, self), OutputControl, Format);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputPromptVaListWide(self: *const T, OutputControl: u32, Format: ?[*:0]const u16, Args: ?*i8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputPromptVaListWide(@ptrCast(*const IDebugControl7, self), OutputControl, Format, Args);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetPromptTextWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetPromptTextWide(@ptrCast(*const IDebugControl7, self), Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AssembleWide(self: *const T, Offset: u64, Instr: ?[*:0]const u16, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).AssembleWide(@ptrCast(*const IDebugControl7, self), Offset, Instr, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_DisassembleWide(self: *const T, Offset: u64, Flags: u32, Buffer: ?[*:0]u16, BufferSize: u32, DisassemblySize: ?*u32, EndOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).DisassembleWide(@ptrCast(*const IDebugControl7, self), Offset, Flags, Buffer, BufferSize, DisassemblySize, EndOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetProcessorTypeNamesWide(self: *const T, Type: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetProcessorTypeNamesWide(@ptrCast(*const IDebugControl7, self), Type, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetTextMacroWide(self: *const T, Slot: u32, Buffer: ?[*:0]u16, BufferSize: u32, MacroSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetTextMacroWide(@ptrCast(*const IDebugControl7, self), Slot, Buffer, BufferSize, MacroSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetTextMacroWide(self: *const T, Slot: u32, Macro: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetTextMacroWide(@ptrCast(*const IDebugControl7, self), Slot, Macro);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_EvaluateWide(self: *const T, Expression: ?[*:0]const u16, DesiredType: u32, Value: ?*DEBUG_VALUE, RemainderIndex: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).EvaluateWide(@ptrCast(*const IDebugControl7, self), Expression, DesiredType, Value, RemainderIndex);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ExecuteWide(self: *const T, OutputControl: u32, Command: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ExecuteWide(@ptrCast(*const IDebugControl7, self), OutputControl, Command, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ExecuteCommandFileWide(self: *const T, OutputControl: u32, CommandFile: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ExecuteCommandFileWide(@ptrCast(*const IDebugControl7, self), OutputControl, CommandFile, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointByIndex2(self: *const T, Index: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetBreakpointByIndex2(@ptrCast(*const IDebugControl7, self), Index, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointById2(self: *const T, Id: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetBreakpointById2(@ptrCast(*const IDebugControl7, self), Id, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddBreakpoint2(self: *const T, Type: u32, DesiredId: u32, Bp: ?*?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).AddBreakpoint2(@ptrCast(*const IDebugControl7, self), Type, DesiredId, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_RemoveBreakpoint2(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).RemoveBreakpoint2(@ptrCast(*const IDebugControl7, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_AddExtensionWide(self: *const T, Path: ?[*:0]const u16, Flags: u32, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).AddExtensionWide(@ptrCast(*const IDebugControl7, self), Path, Flags, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExtensionByPathWide(self: *const T, Path: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExtensionByPathWide(@ptrCast(*const IDebugControl7, self), Path, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_CallExtensionWide(self: *const T, Handle: u64, Function: ?[*:0]const u16, Arguments: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).CallExtensionWide(@ptrCast(*const IDebugControl7, self), Handle, Function, Arguments);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExtensionFunctionWide(self: *const T, Handle: u64, FuncName: ?[*:0]const u16, Function: ?*?FARPROC) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExtensionFunctionWide(@ptrCast(*const IDebugControl7, self), Handle, FuncName, Function);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventFilterTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, TextSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetEventFilterTextWide(@ptrCast(*const IDebugControl7, self), Index, Buffer, BufferSize, TextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventFilterCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetEventFilterCommandWide(@ptrCast(*const IDebugControl7, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetEventFilterCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetEventFilterCommandWide(@ptrCast(*const IDebugControl7, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSpecificFilterArgumentWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ArgumentSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSpecificFilterArgumentWide(@ptrCast(*const IDebugControl7, self), Index, Buffer, BufferSize, ArgumentSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetSpecificFilterArgumentWide(self: *const T, Index: u32, Argument: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetSpecificFilterArgumentWide(@ptrCast(*const IDebugControl7, self), Index, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, CommandSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExceptionFilterSecondCommandWide(@ptrCast(*const IDebugControl7, self), Index, Buffer, BufferSize, CommandSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExceptionFilterSecondCommandWide(self: *const T, Index: u32, Command: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetExceptionFilterSecondCommandWide(@ptrCast(*const IDebugControl7, self), Index, Command);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLastEventInformationWide(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32, Description: ?[*:0]u16, DescriptionSize: u32, DescriptionUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetLastEventInformationWide(@ptrCast(*const IDebugControl7, self), Type, ProcessId, ThreadId, ExtraInformation, ExtraInformationSize, ExtraInformationUsed, Description, DescriptionSize, DescriptionUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, Index: u32, SrcBuffer: ?[*:0]u16, SrcBufferSize: u32, SrcSize: ?*u32, DstBuffer: ?[*:0]u16, DstBufferSize: u32, DstSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetTextReplacementWide(@ptrCast(*const IDebugControl7, self), SrcText, Index, SrcBuffer, SrcBufferSize, SrcSize, DstBuffer, DstBufferSize, DstSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetTextReplacementWide(self: *const T, SrcText: ?[*:0]const u16, DstText: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetTextReplacementWide(@ptrCast(*const IDebugControl7, self), SrcText, DstText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_SetExpressionSyntaxByNameWide(self: *const T, AbbrevName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).SetExpressionSyntaxByNameWide(@ptrCast(*const IDebugControl7, self), AbbrevName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExpressionSyntaxNamesWide(self: *const T, Index: u32, FullNameBuffer: ?[*:0]u16, FullNameBufferSize: u32, FullNameSize: ?*u32, AbbrevNameBuffer: ?[*:0]u16, AbbrevNameBufferSize: u32, AbbrevNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExpressionSyntaxNamesWide(@ptrCast(*const IDebugControl7, self), Index, FullNameBuffer, FullNameBufferSize, FullNameSize, AbbrevNameBuffer, AbbrevNameBufferSize, AbbrevNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetEventIndexDescriptionWide(self: *const T, Index: u32, Which: u32, Buffer: ?PWSTR, BufferSize: u32, DescSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetEventIndexDescriptionWide(@ptrCast(*const IDebugControl7, self), Index, Which, Buffer, BufferSize, DescSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogFile2(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetLogFile2(@ptrCast(*const IDebugControl7, self), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OpenLogFile2(self: *const T, File: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OpenLogFile2(@ptrCast(*const IDebugControl7, self), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetLogFile2Wide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, FileSize: ?*u32, Flags: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetLogFile2Wide(@ptrCast(*const IDebugControl7, self), Buffer, BufferSize, FileSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OpenLogFile2Wide(self: *const T, File: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OpenLogFile2Wide(@ptrCast(*const IDebugControl7, self), File, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemVersionValues(self: *const T, PlatformId: ?*u32, Win32Major: ?*u32, Win32Minor: ?*u32, KdMajor: ?*u32, KdMinor: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSystemVersionValues(@ptrCast(*const IDebugControl7, self), PlatformId, Win32Major, Win32Minor, KdMajor, KdMinor);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemVersionString(self: *const T, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSystemVersionString(@ptrCast(*const IDebugControl7, self), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSystemVersionStringWide(self: *const T, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSystemVersionStringWide(@ptrCast(*const IDebugControl7, self), Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetContextStackTrace(self: *const T, StartContext: ?*c_void, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetContextStackTrace(@ptrCast(*const IDebugControl7, self), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputContextStackTrace(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputContextStackTrace(@ptrCast(*const IDebugControl7, self), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetStoredEventInformation(self: *const T, Type: ?*u32, ProcessId: ?*u32, ThreadId: ?*u32, Context: ?*c_void, ContextSize: u32, ContextUsed: ?*u32, ExtraInformation: ?*c_void, ExtraInformationSize: u32, ExtraInformationUsed: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetStoredEventInformation(@ptrCast(*const IDebugControl7, self), Type, ProcessId, ThreadId, Context, ContextSize, ContextUsed, ExtraInformation, ExtraInformationSize, ExtraInformationUsed);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetManagedStatus(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u8, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetManagedStatus(@ptrCast(*const IDebugControl7, self), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetManagedStatusWide(self: *const T, Flags: ?*u32, WhichString: u32, String: ?[*:0]u16, StringSize: u32, StringNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetManagedStatusWide(@ptrCast(*const IDebugControl7, self), Flags, WhichString, String, StringSize, StringNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_ResetManagedStatus(self: *const T, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).ResetManagedStatus(@ptrCast(*const IDebugControl7, self), Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetStackTraceEx(self: *const T, FrameOffset: u64, StackOffset: u64, InstructionOffset: u64, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetStackTraceEx(@ptrCast(*const IDebugControl7, self), FrameOffset, StackOffset, InstructionOffset, Frames, FramesSize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputStackTraceEx(self: *const T, OutputControl: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputStackTraceEx(@ptrCast(*const IDebugControl7, self), OutputControl, Frames, FramesSize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetContextStackTraceEx(self: *const T, StartContext: ?*c_void, StartContextSize: u32, Frames: ?[*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, FramesFilled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetContextStackTraceEx(@ptrCast(*const IDebugControl7, self), StartContext, StartContextSize, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, FramesFilled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_OutputContextStackTraceEx(self: *const T, OutputControl: u32, Frames: [*]DEBUG_STACK_FRAME_EX, FramesSize: u32, FrameContexts: ?*c_void, FrameContextsSize: u32, FrameContextsEntrySize: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).OutputContextStackTraceEx(@ptrCast(*const IDebugControl7, self), OutputControl, Frames, FramesSize, FrameContexts, FrameContextsSize, FrameContextsEntrySize, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetBreakpointByGuid(self: *const T, _param_Guid: ?*Guid, Bp: ?*?*IDebugBreakpoint3) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetBreakpointByGuid(@ptrCast(*const IDebugControl7, self), _param_Guid, Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetExecutionStatusEx(self: *const T, Status: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetExecutionStatusEx(@ptrCast(*const IDebugControl7, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetSynchronizationStatus(self: *const T, SendsAttempted: ?*u32, SecondsSinceLastResponse: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetSynchronizationStatus(@ptrCast(*const IDebugControl7, self), SendsAttempted, SecondsSinceLastResponse);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugControl7_GetDebuggeeType2(self: *const T, Flags: u32, Class: ?*u32, Qualifier: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugControl7.VTable, self.vtable).GetDebuggeeType2(@ptrCast(*const IDebugControl7, self), Flags, Class, Qualifier);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ALPHA = extern struct {
    Type: u32,
    Revision: u32,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_AMD64 = extern struct {
    Family: u32,
    Model: u32,
    Stepping: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_IA64 = extern struct {
    Model: u32,
    Revision: u32,
    Family: u32,
    ArchRev: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_X86 = extern struct {
    Family: u32,
    Model: u32,
    Stepping: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ARM = extern struct {
    Model: u32,
    Revision: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ARM64 = extern struct {
    Model: u32,
    Revision: u32,
    VendorString: [16]CHAR,
};

pub const DEBUG_PROCESSOR_IDENTIFICATION_ALL = extern union {
    Alpha: DEBUG_PROCESSOR_IDENTIFICATION_ALPHA,
    Amd64: DEBUG_PROCESSOR_IDENTIFICATION_AMD64,
    Ia64: DEBUG_PROCESSOR_IDENTIFICATION_IA64,
    X86: DEBUG_PROCESSOR_IDENTIFICATION_X86,
    Arm: DEBUG_PROCESSOR_IDENTIFICATION_ARM,
    Arm64: DEBUG_PROCESSOR_IDENTIFICATION_ARM64,
};

const IID_IDebugDataSpaces_Value = @import("../../zig.zig").Guid.initString("88f7dfab-3ea7-4c3a-aefb-c4e8106173aa");
pub const IID_IDebugDataSpaces = &IID_IDebugDataSpaces_Value;
pub const IDebugDataSpaces = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: fn(
            self: *const IDebugDataSpaces,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteVirtual: fn(
            self: *const IDebugDataSpaces,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SearchVirtual: fn(
            self: *const IDebugDataSpaces,
            Offset: u64,
            Length: u64,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            PatternGranularity: u32,
            MatchOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadVirtualUncached: fn(
            self: *const IDebugDataSpaces,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteVirtualUncached: fn(
            self: *const IDebugDataSpaces,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPointersVirtual: fn(
            self: *const IDebugDataSpaces,
            Count: u32,
            Offset: u64,
            Ptrs: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePointersVirtual: fn(
            self: *const IDebugDataSpaces,
            Count: u32,
            Offset: u64,
            Ptrs: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPhysical: fn(
            self: *const IDebugDataSpaces,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePhysical: fn(
            self: *const IDebugDataSpaces,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadControl: fn(
            self: *const IDebugDataSpaces,
            Processor: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteControl: fn(
            self: *const IDebugDataSpaces,
            Processor: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadIo: fn(
            self: *const IDebugDataSpaces,
            InterfaceType: u32,
            BusNumber: u32,
            AddressSpace: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteIo: fn(
            self: *const IDebugDataSpaces,
            InterfaceType: u32,
            BusNumber: u32,
            AddressSpace: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadMsr: fn(
            self: *const IDebugDataSpaces,
            Msr: u32,
            Value: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMsr: fn(
            self: *const IDebugDataSpaces,
            Msr: u32,
            Value: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBusData: fn(
            self: *const IDebugDataSpaces,
            BusDataType: u32,
            BusNumber: u32,
            SlotNumber: u32,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteBusData: fn(
            self: *const IDebugDataSpaces,
            BusDataType: u32,
            BusNumber: u32,
            SlotNumber: u32,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckLowMemory: fn(
            self: *const IDebugDataSpaces,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadDebuggerData: fn(
            self: *const IDebugDataSpaces,
            Index: u32,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadProcessorSystemData: fn(
            self: *const IDebugDataSpaces,
            Processor: u32,
            Index: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadVirtual(@ptrCast(*const IDebugDataSpaces, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).WriteVirtual(@ptrCast(*const IDebugDataSpaces, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*c_void, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).SearchVirtual(@ptrCast(*const IDebugDataSpaces, self), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadVirtualUncached(@ptrCast(*const IDebugDataSpaces, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).WriteVirtualUncached(@ptrCast(*const IDebugDataSpaces, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadPointersVirtual(@ptrCast(*const IDebugDataSpaces, self), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).WritePointersVirtual(@ptrCast(*const IDebugDataSpaces, self), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadPhysical(@ptrCast(*const IDebugDataSpaces, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WritePhysical(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).WritePhysical(@ptrCast(*const IDebugDataSpaces, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadControl(@ptrCast(*const IDebugDataSpaces, self), Processor, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).WriteControl(@ptrCast(*const IDebugDataSpaces, self), Processor, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadIo(@ptrCast(*const IDebugDataSpaces, self), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).WriteIo(@ptrCast(*const IDebugDataSpaces, self), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadMsr(@ptrCast(*const IDebugDataSpaces, self), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteMsr(self: *const T, Msr: u32, Value: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).WriteMsr(@ptrCast(*const IDebugDataSpaces, self), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadBusData(@ptrCast(*const IDebugDataSpaces, self), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).WriteBusData(@ptrCast(*const IDebugDataSpaces, self), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_CheckLowMemory(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).CheckLowMemory(@ptrCast(*const IDebugDataSpaces, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadDebuggerData(@ptrCast(*const IDebugDataSpaces, self), Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces.VTable, self.vtable).ReadProcessorSystemData(@ptrCast(*const IDebugDataSpaces, self), Processor, Index, Buffer, BufferSize, DataSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_HANDLE_DATA_BASIC = extern struct {
    TypeNameSize: u32,
    ObjectNameSize: u32,
    Attributes: u32,
    GrantedAccess: u32,
    HandleCount: u32,
    PointerCount: u32,
};

const IID_IDebugDataSpaces2_Value = @import("../../zig.zig").Guid.initString("7a5e852f-96e9-468f-ac1b-0b3addc4a049");
pub const IID_IDebugDataSpaces2 = &IID_IDebugDataSpaces2_Value;
pub const IDebugDataSpaces2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: fn(
            self: *const IDebugDataSpaces2,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteVirtual: fn(
            self: *const IDebugDataSpaces2,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SearchVirtual: fn(
            self: *const IDebugDataSpaces2,
            Offset: u64,
            Length: u64,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            PatternGranularity: u32,
            MatchOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadVirtualUncached: fn(
            self: *const IDebugDataSpaces2,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteVirtualUncached: fn(
            self: *const IDebugDataSpaces2,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPointersVirtual: fn(
            self: *const IDebugDataSpaces2,
            Count: u32,
            Offset: u64,
            Ptrs: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePointersVirtual: fn(
            self: *const IDebugDataSpaces2,
            Count: u32,
            Offset: u64,
            Ptrs: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPhysical: fn(
            self: *const IDebugDataSpaces2,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePhysical: fn(
            self: *const IDebugDataSpaces2,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadControl: fn(
            self: *const IDebugDataSpaces2,
            Processor: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteControl: fn(
            self: *const IDebugDataSpaces2,
            Processor: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadIo: fn(
            self: *const IDebugDataSpaces2,
            InterfaceType: u32,
            BusNumber: u32,
            AddressSpace: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteIo: fn(
            self: *const IDebugDataSpaces2,
            InterfaceType: u32,
            BusNumber: u32,
            AddressSpace: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadMsr: fn(
            self: *const IDebugDataSpaces2,
            Msr: u32,
            Value: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMsr: fn(
            self: *const IDebugDataSpaces2,
            Msr: u32,
            Value: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBusData: fn(
            self: *const IDebugDataSpaces2,
            BusDataType: u32,
            BusNumber: u32,
            SlotNumber: u32,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteBusData: fn(
            self: *const IDebugDataSpaces2,
            BusDataType: u32,
            BusNumber: u32,
            SlotNumber: u32,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckLowMemory: fn(
            self: *const IDebugDataSpaces2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadDebuggerData: fn(
            self: *const IDebugDataSpaces2,
            Index: u32,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadProcessorSystemData: fn(
            self: *const IDebugDataSpaces2,
            Processor: u32,
            Index: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VirtualToPhysical: fn(
            self: *const IDebugDataSpaces2,
            Virtual: u64,
            Physical: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualTranslationPhysicalOffsets: fn(
            self: *const IDebugDataSpaces2,
            Virtual: u64,
            Offsets: ?[*]u64,
            OffsetsSize: u32,
            Levels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadHandleData: fn(
            self: *const IDebugDataSpaces2,
            Handle: u64,
            DataType: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillVirtual: fn(
            self: *const IDebugDataSpaces2,
            Start: u64,
            Size: u32,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            Filled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillPhysical: fn(
            self: *const IDebugDataSpaces2,
            Start: u64,
            Size: u32,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            Filled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVirtual: fn(
            self: *const IDebugDataSpaces2,
            Offset: u64,
            Info: ?*MEMORY_BASIC_INFORMATION64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadVirtual(@ptrCast(*const IDebugDataSpaces2, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).WriteVirtual(@ptrCast(*const IDebugDataSpaces2, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*c_void, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).SearchVirtual(@ptrCast(*const IDebugDataSpaces2, self), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadVirtualUncached(@ptrCast(*const IDebugDataSpaces2, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).WriteVirtualUncached(@ptrCast(*const IDebugDataSpaces2, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadPointersVirtual(@ptrCast(*const IDebugDataSpaces2, self), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).WritePointersVirtual(@ptrCast(*const IDebugDataSpaces2, self), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadPhysical(@ptrCast(*const IDebugDataSpaces2, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WritePhysical(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).WritePhysical(@ptrCast(*const IDebugDataSpaces2, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadControl(@ptrCast(*const IDebugDataSpaces2, self), Processor, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).WriteControl(@ptrCast(*const IDebugDataSpaces2, self), Processor, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadIo(@ptrCast(*const IDebugDataSpaces2, self), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).WriteIo(@ptrCast(*const IDebugDataSpaces2, self), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadMsr(@ptrCast(*const IDebugDataSpaces2, self), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteMsr(self: *const T, Msr: u32, Value: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).WriteMsr(@ptrCast(*const IDebugDataSpaces2, self), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadBusData(@ptrCast(*const IDebugDataSpaces2, self), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).WriteBusData(@ptrCast(*const IDebugDataSpaces2, self), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_CheckLowMemory(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).CheckLowMemory(@ptrCast(*const IDebugDataSpaces2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadDebuggerData(@ptrCast(*const IDebugDataSpaces2, self), Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadProcessorSystemData(@ptrCast(*const IDebugDataSpaces2, self), Processor, Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).VirtualToPhysical(@ptrCast(*const IDebugDataSpaces2, self), Virtual, Physical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).GetVirtualTranslationPhysicalOffsets(@ptrCast(*const IDebugDataSpaces2, self), Virtual, Offsets, OffsetsSize, Levels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).ReadHandleData(@ptrCast(*const IDebugDataSpaces2, self), Handle, DataType, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*c_void, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).FillVirtual(@ptrCast(*const IDebugDataSpaces2, self), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*c_void, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).FillPhysical(@ptrCast(*const IDebugDataSpaces2, self), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces2_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces2.VTable, self.vtable).QueryVirtual(@ptrCast(*const IDebugDataSpaces2, self), Offset, Info);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDataSpaces3_Value = @import("../../zig.zig").Guid.initString("23f79d6c-8aaf-4f7c-a607-9995f5407e63");
pub const IID_IDebugDataSpaces3 = &IID_IDebugDataSpaces3_Value;
pub const IDebugDataSpaces3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: fn(
            self: *const IDebugDataSpaces3,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteVirtual: fn(
            self: *const IDebugDataSpaces3,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SearchVirtual: fn(
            self: *const IDebugDataSpaces3,
            Offset: u64,
            Length: u64,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            PatternGranularity: u32,
            MatchOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadVirtualUncached: fn(
            self: *const IDebugDataSpaces3,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteVirtualUncached: fn(
            self: *const IDebugDataSpaces3,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPointersVirtual: fn(
            self: *const IDebugDataSpaces3,
            Count: u32,
            Offset: u64,
            Ptrs: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePointersVirtual: fn(
            self: *const IDebugDataSpaces3,
            Count: u32,
            Offset: u64,
            Ptrs: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPhysical: fn(
            self: *const IDebugDataSpaces3,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePhysical: fn(
            self: *const IDebugDataSpaces3,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadControl: fn(
            self: *const IDebugDataSpaces3,
            Processor: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteControl: fn(
            self: *const IDebugDataSpaces3,
            Processor: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadIo: fn(
            self: *const IDebugDataSpaces3,
            InterfaceType: u32,
            BusNumber: u32,
            AddressSpace: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteIo: fn(
            self: *const IDebugDataSpaces3,
            InterfaceType: u32,
            BusNumber: u32,
            AddressSpace: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadMsr: fn(
            self: *const IDebugDataSpaces3,
            Msr: u32,
            Value: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMsr: fn(
            self: *const IDebugDataSpaces3,
            Msr: u32,
            Value: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBusData: fn(
            self: *const IDebugDataSpaces3,
            BusDataType: u32,
            BusNumber: u32,
            SlotNumber: u32,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteBusData: fn(
            self: *const IDebugDataSpaces3,
            BusDataType: u32,
            BusNumber: u32,
            SlotNumber: u32,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckLowMemory: fn(
            self: *const IDebugDataSpaces3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadDebuggerData: fn(
            self: *const IDebugDataSpaces3,
            Index: u32,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadProcessorSystemData: fn(
            self: *const IDebugDataSpaces3,
            Processor: u32,
            Index: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VirtualToPhysical: fn(
            self: *const IDebugDataSpaces3,
            Virtual: u64,
            Physical: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualTranslationPhysicalOffsets: fn(
            self: *const IDebugDataSpaces3,
            Virtual: u64,
            Offsets: ?[*]u64,
            OffsetsSize: u32,
            Levels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadHandleData: fn(
            self: *const IDebugDataSpaces3,
            Handle: u64,
            DataType: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillVirtual: fn(
            self: *const IDebugDataSpaces3,
            Start: u64,
            Size: u32,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            Filled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillPhysical: fn(
            self: *const IDebugDataSpaces3,
            Start: u64,
            Size: u32,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            Filled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVirtual: fn(
            self: *const IDebugDataSpaces3,
            Offset: u64,
            Info: ?*MEMORY_BASIC_INFORMATION64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadImageNtHeaders: fn(
            self: *const IDebugDataSpaces3,
            ImageBase: u64,
            Headers: ?*IMAGE_NT_HEADERS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTagged: fn(
            self: *const IDebugDataSpaces3,
            Tag: ?*Guid,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            TotalSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartEnumTagged: fn(
            self: *const IDebugDataSpaces3,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTagged: fn(
            self: *const IDebugDataSpaces3,
            Handle: u64,
            Tag: ?*Guid,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndEnumTagged: fn(
            self: *const IDebugDataSpaces3,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadVirtual(@ptrCast(*const IDebugDataSpaces3, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).WriteVirtual(@ptrCast(*const IDebugDataSpaces3, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*c_void, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).SearchVirtual(@ptrCast(*const IDebugDataSpaces3, self), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadVirtualUncached(@ptrCast(*const IDebugDataSpaces3, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).WriteVirtualUncached(@ptrCast(*const IDebugDataSpaces3, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadPointersVirtual(@ptrCast(*const IDebugDataSpaces3, self), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).WritePointersVirtual(@ptrCast(*const IDebugDataSpaces3, self), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadPhysical(@ptrCast(*const IDebugDataSpaces3, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WritePhysical(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).WritePhysical(@ptrCast(*const IDebugDataSpaces3, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadControl(@ptrCast(*const IDebugDataSpaces3, self), Processor, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).WriteControl(@ptrCast(*const IDebugDataSpaces3, self), Processor, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadIo(@ptrCast(*const IDebugDataSpaces3, self), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).WriteIo(@ptrCast(*const IDebugDataSpaces3, self), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadMsr(@ptrCast(*const IDebugDataSpaces3, self), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteMsr(self: *const T, Msr: u32, Value: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).WriteMsr(@ptrCast(*const IDebugDataSpaces3, self), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadBusData(@ptrCast(*const IDebugDataSpaces3, self), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).WriteBusData(@ptrCast(*const IDebugDataSpaces3, self), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_CheckLowMemory(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).CheckLowMemory(@ptrCast(*const IDebugDataSpaces3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadDebuggerData(@ptrCast(*const IDebugDataSpaces3, self), Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadProcessorSystemData(@ptrCast(*const IDebugDataSpaces3, self), Processor, Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).VirtualToPhysical(@ptrCast(*const IDebugDataSpaces3, self), Virtual, Physical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).GetVirtualTranslationPhysicalOffsets(@ptrCast(*const IDebugDataSpaces3, self), Virtual, Offsets, OffsetsSize, Levels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadHandleData(@ptrCast(*const IDebugDataSpaces3, self), Handle, DataType, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*c_void, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).FillVirtual(@ptrCast(*const IDebugDataSpaces3, self), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*c_void, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).FillPhysical(@ptrCast(*const IDebugDataSpaces3, self), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).QueryVirtual(@ptrCast(*const IDebugDataSpaces3, self), Offset, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadImageNtHeaders(self: *const T, ImageBase: u64, Headers: ?*IMAGE_NT_HEADERS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadImageNtHeaders(@ptrCast(*const IDebugDataSpaces3, self), ImageBase, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_ReadTagged(self: *const T, Tag: ?*Guid, Offset: u32, Buffer: ?*c_void, BufferSize: u32, TotalSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).ReadTagged(@ptrCast(*const IDebugDataSpaces3, self), Tag, Offset, Buffer, BufferSize, TotalSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_StartEnumTagged(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).StartEnumTagged(@ptrCast(*const IDebugDataSpaces3, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_GetNextTagged(self: *const T, Handle: u64, Tag: ?*Guid, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).GetNextTagged(@ptrCast(*const IDebugDataSpaces3, self), Handle, Tag, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces3_EndEnumTagged(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces3.VTable, self.vtable).EndEnumTagged(@ptrCast(*const IDebugDataSpaces3, self), Handle);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugDataSpaces4_Value = @import("../../zig.zig").Guid.initString("d98ada1f-29e9-4ef5-a6c0-e53349883212");
pub const IID_IDebugDataSpaces4 = &IID_IDebugDataSpaces4_Value;
pub const IDebugDataSpaces4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadVirtual: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteVirtual: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SearchVirtual: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            Length: u64,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            PatternGranularity: u32,
            MatchOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadVirtualUncached: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteVirtualUncached: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPointersVirtual: fn(
            self: *const IDebugDataSpaces4,
            Count: u32,
            Offset: u64,
            Ptrs: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePointersVirtual: fn(
            self: *const IDebugDataSpaces4,
            Count: u32,
            Offset: u64,
            Ptrs: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPhysical: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePhysical: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadControl: fn(
            self: *const IDebugDataSpaces4,
            Processor: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteControl: fn(
            self: *const IDebugDataSpaces4,
            Processor: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadIo: fn(
            self: *const IDebugDataSpaces4,
            InterfaceType: u32,
            BusNumber: u32,
            AddressSpace: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteIo: fn(
            self: *const IDebugDataSpaces4,
            InterfaceType: u32,
            BusNumber: u32,
            AddressSpace: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadMsr: fn(
            self: *const IDebugDataSpaces4,
            Msr: u32,
            Value: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteMsr: fn(
            self: *const IDebugDataSpaces4,
            Msr: u32,
            Value: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadBusData: fn(
            self: *const IDebugDataSpaces4,
            BusDataType: u32,
            BusNumber: u32,
            SlotNumber: u32,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteBusData: fn(
            self: *const IDebugDataSpaces4,
            BusDataType: u32,
            BusNumber: u32,
            SlotNumber: u32,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 5?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CheckLowMemory: fn(
            self: *const IDebugDataSpaces4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadDebuggerData: fn(
            self: *const IDebugDataSpaces4,
            Index: u32,
            // TODO: what to do with BytesParamIndex 2?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadProcessorSystemData: fn(
            self: *const IDebugDataSpaces4,
            Processor: u32,
            Index: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        VirtualToPhysical: fn(
            self: *const IDebugDataSpaces4,
            Virtual: u64,
            Physical: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVirtualTranslationPhysicalOffsets: fn(
            self: *const IDebugDataSpaces4,
            Virtual: u64,
            Offsets: ?[*]u64,
            OffsetsSize: u32,
            Levels: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadHandleData: fn(
            self: *const IDebugDataSpaces4,
            Handle: u64,
            DataType: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            DataSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillVirtual: fn(
            self: *const IDebugDataSpaces4,
            Start: u64,
            Size: u32,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            Filled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FillPhysical: fn(
            self: *const IDebugDataSpaces4,
            Start: u64,
            Size: u32,
            // TODO: what to do with BytesParamIndex 3?
            Pattern: ?*c_void,
            PatternSize: u32,
            Filled: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        QueryVirtual: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            Info: ?*MEMORY_BASIC_INFORMATION64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadImageNtHeaders: fn(
            self: *const IDebugDataSpaces4,
            ImageBase: u64,
            Headers: ?*IMAGE_NT_HEADERS64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTagged: fn(
            self: *const IDebugDataSpaces4,
            Tag: ?*Guid,
            Offset: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            TotalSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartEnumTagged: fn(
            self: *const IDebugDataSpaces4,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextTagged: fn(
            self: *const IDebugDataSpaces4,
            Handle: u64,
            Tag: ?*Guid,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndEnumTagged: fn(
            self: *const IDebugDataSpaces4,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetInformation: fn(
            self: *const IDebugDataSpaces4,
            Space: u32,
            Which: u32,
            Offset: u64,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            InfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextDifferentlyValidOffsetVirtual: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            NextOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValidRegionVirtual: fn(
            self: *const IDebugDataSpaces4,
            Base: u64,
            Size: u32,
            ValidBase: ?*u64,
            ValidSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SearchVirtual2: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            Length: u64,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 4?
            Pattern: ?*c_void,
            PatternSize: u32,
            PatternGranularity: u32,
            MatchOffset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadMultiByteStringVirtual: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            MaxBytes: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringBytes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadMultiByteStringVirtualWide: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            MaxBytes: u32,
            CodePage: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringBytes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadUnicodeStringVirtual: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            MaxBytes: u32,
            CodePage: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringBytes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadUnicodeStringVirtualWide: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            MaxBytes: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringBytes: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPhysical2: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePhysical2: fn(
            self: *const IDebugDataSpaces4,
            Offset: u64,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadVirtual(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadVirtual(@ptrCast(*const IDebugDataSpaces4, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteVirtual(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WriteVirtual(@ptrCast(*const IDebugDataSpaces4, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_SearchVirtual(self: *const T, Offset: u64, Length: u64, Pattern: ?*c_void, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).SearchVirtual(@ptrCast(*const IDebugDataSpaces4, self), Offset, Length, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadVirtualUncached(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadVirtualUncached(@ptrCast(*const IDebugDataSpaces4, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteVirtualUncached(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WriteVirtualUncached(@ptrCast(*const IDebugDataSpaces4, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadPointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadPointersVirtual(@ptrCast(*const IDebugDataSpaces4, self), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WritePointersVirtual(self: *const T, Count: u32, Offset: u64, Ptrs: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WritePointersVirtual(@ptrCast(*const IDebugDataSpaces4, self), Count, Offset, Ptrs);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadPhysical(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadPhysical(@ptrCast(*const IDebugDataSpaces4, self), Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WritePhysical(self: *const T, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WritePhysical(@ptrCast(*const IDebugDataSpaces4, self), Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadControl(@ptrCast(*const IDebugDataSpaces4, self), Processor, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteControl(self: *const T, Processor: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WriteControl(@ptrCast(*const IDebugDataSpaces4, self), Processor, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadIo(@ptrCast(*const IDebugDataSpaces4, self), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteIo(self: *const T, InterfaceType: u32, BusNumber: u32, AddressSpace: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WriteIo(@ptrCast(*const IDebugDataSpaces4, self), InterfaceType, BusNumber, AddressSpace, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadMsr(self: *const T, Msr: u32, Value: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadMsr(@ptrCast(*const IDebugDataSpaces4, self), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteMsr(self: *const T, Msr: u32, Value: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WriteMsr(@ptrCast(*const IDebugDataSpaces4, self), Msr, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadBusData(@ptrCast(*const IDebugDataSpaces4, self), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WriteBusData(self: *const T, BusDataType: u32, BusNumber: u32, SlotNumber: u32, Offset: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WriteBusData(@ptrCast(*const IDebugDataSpaces4, self), BusDataType, BusNumber, SlotNumber, Offset, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_CheckLowMemory(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).CheckLowMemory(@ptrCast(*const IDebugDataSpaces4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadDebuggerData(self: *const T, Index: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadDebuggerData(@ptrCast(*const IDebugDataSpaces4, self), Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadProcessorSystemData(self: *const T, Processor: u32, Index: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadProcessorSystemData(@ptrCast(*const IDebugDataSpaces4, self), Processor, Index, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_VirtualToPhysical(self: *const T, Virtual: u64, Physical: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).VirtualToPhysical(@ptrCast(*const IDebugDataSpaces4, self), Virtual, Physical);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetVirtualTranslationPhysicalOffsets(self: *const T, Virtual: u64, Offsets: ?[*]u64, OffsetsSize: u32, Levels: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).GetVirtualTranslationPhysicalOffsets(@ptrCast(*const IDebugDataSpaces4, self), Virtual, Offsets, OffsetsSize, Levels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadHandleData(self: *const T, Handle: u64, DataType: u32, Buffer: ?*c_void, BufferSize: u32, DataSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadHandleData(@ptrCast(*const IDebugDataSpaces4, self), Handle, DataType, Buffer, BufferSize, DataSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_FillVirtual(self: *const T, Start: u64, Size: u32, Pattern: ?*c_void, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).FillVirtual(@ptrCast(*const IDebugDataSpaces4, self), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_FillPhysical(self: *const T, Start: u64, Size: u32, Pattern: ?*c_void, PatternSize: u32, Filled: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).FillPhysical(@ptrCast(*const IDebugDataSpaces4, self), Start, Size, Pattern, PatternSize, Filled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_QueryVirtual(self: *const T, Offset: u64, Info: ?*MEMORY_BASIC_INFORMATION64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).QueryVirtual(@ptrCast(*const IDebugDataSpaces4, self), Offset, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadImageNtHeaders(self: *const T, ImageBase: u64, Headers: ?*IMAGE_NT_HEADERS64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadImageNtHeaders(@ptrCast(*const IDebugDataSpaces4, self), ImageBase, Headers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadTagged(self: *const T, Tag: ?*Guid, Offset: u32, Buffer: ?*c_void, BufferSize: u32, TotalSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadTagged(@ptrCast(*const IDebugDataSpaces4, self), Tag, Offset, Buffer, BufferSize, TotalSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_StartEnumTagged(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).StartEnumTagged(@ptrCast(*const IDebugDataSpaces4, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetNextTagged(self: *const T, Handle: u64, Tag: ?*Guid, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).GetNextTagged(@ptrCast(*const IDebugDataSpaces4, self), Handle, Tag, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_EndEnumTagged(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).EndEnumTagged(@ptrCast(*const IDebugDataSpaces4, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetOffsetInformation(self: *const T, Space: u32, Which: u32, Offset: u64, Buffer: ?*c_void, BufferSize: u32, InfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).GetOffsetInformation(@ptrCast(*const IDebugDataSpaces4, self), Space, Which, Offset, Buffer, BufferSize, InfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetNextDifferentlyValidOffsetVirtual(self: *const T, Offset: u64, NextOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).GetNextDifferentlyValidOffsetVirtual(@ptrCast(*const IDebugDataSpaces4, self), Offset, NextOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_GetValidRegionVirtual(self: *const T, Base: u64, Size: u32, ValidBase: ?*u64, ValidSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).GetValidRegionVirtual(@ptrCast(*const IDebugDataSpaces4, self), Base, Size, ValidBase, ValidSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_SearchVirtual2(self: *const T, Offset: u64, Length: u64, Flags: u32, Pattern: ?*c_void, PatternSize: u32, PatternGranularity: u32, MatchOffset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).SearchVirtual2(@ptrCast(*const IDebugDataSpaces4, self), Offset, Length, Flags, Pattern, PatternSize, PatternGranularity, MatchOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadMultiByteStringVirtual(self: *const T, Offset: u64, MaxBytes: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringBytes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadMultiByteStringVirtual(@ptrCast(*const IDebugDataSpaces4, self), Offset, MaxBytes, Buffer, BufferSize, StringBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadMultiByteStringVirtualWide(self: *const T, Offset: u64, MaxBytes: u32, CodePage: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringBytes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadMultiByteStringVirtualWide(@ptrCast(*const IDebugDataSpaces4, self), Offset, MaxBytes, CodePage, Buffer, BufferSize, StringBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadUnicodeStringVirtual(self: *const T, Offset: u64, MaxBytes: u32, CodePage: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringBytes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadUnicodeStringVirtual(@ptrCast(*const IDebugDataSpaces4, self), Offset, MaxBytes, CodePage, Buffer, BufferSize, StringBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadUnicodeStringVirtualWide(self: *const T, Offset: u64, MaxBytes: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringBytes: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadUnicodeStringVirtualWide(@ptrCast(*const IDebugDataSpaces4, self), Offset, MaxBytes, Buffer, BufferSize, StringBytes);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_ReadPhysical2(self: *const T, Offset: u64, Flags: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).ReadPhysical2(@ptrCast(*const IDebugDataSpaces4, self), Offset, Flags, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugDataSpaces4_WritePhysical2(self: *const T, Offset: u64, Flags: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugDataSpaces4.VTable, self.vtable).WritePhysical2(@ptrCast(*const IDebugDataSpaces4, self), Offset, Flags, Buffer, BufferSize, BytesWritten);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugEventCallbacks_Value = @import("../../zig.zig").Guid.initString("337be28b-5036-4d72-b6bf-c45fbb9f2eaa");
pub const IID_IDebugEventCallbacks = &IID_IDebugEventCallbacks_Value;
pub const IDebugEventCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: fn(
            self: *const IDebugEventCallbacks,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Breakpoint: fn(
            self: *const IDebugEventCallbacks,
            Bp: ?*IDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Exception: fn(
            self: *const IDebugEventCallbacks,
            Exception: ?*EXCEPTION_RECORD64,
            FirstChance: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateThread: fn(
            self: *const IDebugEventCallbacks,
            Handle: u64,
            DataOffset: u64,
            StartOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitThread: fn(
            self: *const IDebugEventCallbacks,
            ExitCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugEventCallbacks,
            ImageFileHandle: u64,
            Handle: u64,
            BaseOffset: u64,
            ModuleSize: u32,
            ModuleName: ?[*:0]const u8,
            ImageName: ?[*:0]const u8,
            CheckSum: u32,
            TimeDateStamp: u32,
            InitialThreadHandle: u64,
            ThreadDataOffset: u64,
            StartOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitProcess: fn(
            self: *const IDebugEventCallbacks,
            ExitCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) noreturn,
        LoadModule: fn(
            self: *const IDebugEventCallbacks,
            ImageFileHandle: u64,
            BaseOffset: u64,
            ModuleSize: u32,
            ModuleName: ?[*:0]const u8,
            ImageName: ?[*:0]const u8,
            CheckSum: u32,
            TimeDateStamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnloadModule: fn(
            self: *const IDebugEventCallbacks,
            ImageBaseName: ?[*:0]const u8,
            BaseOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SystemError: fn(
            self: *const IDebugEventCallbacks,
            Error: u32,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionStatus: fn(
            self: *const IDebugEventCallbacks,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDebuggeeState: fn(
            self: *const IDebugEventCallbacks,
            Flags: u32,
            Argument: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeEngineState: fn(
            self: *const IDebugEventCallbacks,
            Flags: u32,
            Argument: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeSymbolState: fn(
            self: *const IDebugEventCallbacks,
            Flags: u32,
            Argument: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_GetInterestMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).GetInterestMask(@ptrCast(*const IDebugEventCallbacks, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).Breakpoint(@ptrCast(*const IDebugEventCallbacks, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).Exception(@ptrCast(*const IDebugEventCallbacks, self), Exception, FirstChance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).CreateThread(@ptrCast(*const IDebugEventCallbacks, self), Handle, DataOffset, StartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ExitThread(self: *const T, ExitCode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).ExitThread(@ptrCast(*const IDebugEventCallbacks, self), ExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u8, ImageName: ?[*:0]const u8, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugEventCallbacks, self), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ExitProcess(self: *const T, ExitCode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).ExitProcess(@ptrCast(*const IDebugEventCallbacks, self), ExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u8, ImageName: ?[*:0]const u8, CheckSum: u32, TimeDateStamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).LoadModule(@ptrCast(*const IDebugEventCallbacks, self), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_UnloadModule(self: *const T, ImageBaseName: ?[*:0]const u8, BaseOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).UnloadModule(@ptrCast(*const IDebugEventCallbacks, self), ImageBaseName, BaseOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_SystemError(self: *const T, Error: u32, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).SystemError(@ptrCast(*const IDebugEventCallbacks, self), Error, Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_SessionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).SessionStatus(@ptrCast(*const IDebugEventCallbacks, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).ChangeDebuggeeState(@ptrCast(*const IDebugEventCallbacks, self), Flags, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ChangeEngineState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).ChangeEngineState(@ptrCast(*const IDebugEventCallbacks, self), Flags, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacks_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacks.VTable, self.vtable).ChangeSymbolState(@ptrCast(*const IDebugEventCallbacks, self), Flags, Argument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugEventCallbacksWide_Value = @import("../../zig.zig").Guid.initString("0690e046-9c23-45ac-a04f-987ac29ad0d3");
pub const IID_IDebugEventCallbacksWide = &IID_IDebugEventCallbacksWide_Value;
pub const IDebugEventCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: fn(
            self: *const IDebugEventCallbacksWide,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Breakpoint: fn(
            self: *const IDebugEventCallbacksWide,
            Bp: ?*IDebugBreakpoint2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Exception: fn(
            self: *const IDebugEventCallbacksWide,
            Exception: ?*EXCEPTION_RECORD64,
            FirstChance: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateThread: fn(
            self: *const IDebugEventCallbacksWide,
            Handle: u64,
            DataOffset: u64,
            StartOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitThread: fn(
            self: *const IDebugEventCallbacksWide,
            ExitCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugEventCallbacksWide,
            ImageFileHandle: u64,
            Handle: u64,
            BaseOffset: u64,
            ModuleSize: u32,
            ModuleName: ?[*:0]const u16,
            ImageName: ?[*:0]const u16,
            CheckSum: u32,
            TimeDateStamp: u32,
            InitialThreadHandle: u64,
            ThreadDataOffset: u64,
            StartOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitProcess: fn(
            self: *const IDebugEventCallbacksWide,
            ExitCode: u32,
        ) callconv(@import("std").os.windows.WINAPI) noreturn,
        LoadModule: fn(
            self: *const IDebugEventCallbacksWide,
            ImageFileHandle: u64,
            BaseOffset: u64,
            ModuleSize: u32,
            ModuleName: ?[*:0]const u16,
            ImageName: ?[*:0]const u16,
            CheckSum: u32,
            TimeDateStamp: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnloadModule: fn(
            self: *const IDebugEventCallbacksWide,
            ImageBaseName: ?[*:0]const u16,
            BaseOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SystemError: fn(
            self: *const IDebugEventCallbacksWide,
            Error: u32,
            Level: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionStatus: fn(
            self: *const IDebugEventCallbacksWide,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDebuggeeState: fn(
            self: *const IDebugEventCallbacksWide,
            Flags: u32,
            Argument: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeEngineState: fn(
            self: *const IDebugEventCallbacksWide,
            Flags: u32,
            Argument: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeSymbolState: fn(
            self: *const IDebugEventCallbacksWide,
            Flags: u32,
            Argument: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_GetInterestMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).GetInterestMask(@ptrCast(*const IDebugEventCallbacksWide, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).Breakpoint(@ptrCast(*const IDebugEventCallbacksWide, self), Bp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).Exception(@ptrCast(*const IDebugEventCallbacksWide, self), Exception, FirstChance);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).CreateThread(@ptrCast(*const IDebugEventCallbacksWide, self), Handle, DataOffset, StartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ExitThread(self: *const T, ExitCode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).ExitThread(@ptrCast(*const IDebugEventCallbacksWide, self), ExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u16, ImageName: ?[*:0]const u16, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugEventCallbacksWide, self), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ExitProcess(self: *const T, ExitCode: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).ExitProcess(@ptrCast(*const IDebugEventCallbacksWide, self), ExitCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u16, ImageName: ?[*:0]const u16, CheckSum: u32, TimeDateStamp: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).LoadModule(@ptrCast(*const IDebugEventCallbacksWide, self), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_UnloadModule(self: *const T, ImageBaseName: ?[*:0]const u16, BaseOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).UnloadModule(@ptrCast(*const IDebugEventCallbacksWide, self), ImageBaseName, BaseOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_SystemError(self: *const T, Error: u32, Level: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).SystemError(@ptrCast(*const IDebugEventCallbacksWide, self), Error, Level);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_SessionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).SessionStatus(@ptrCast(*const IDebugEventCallbacksWide, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).ChangeDebuggeeState(@ptrCast(*const IDebugEventCallbacksWide, self), Flags, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ChangeEngineState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).ChangeEngineState(@ptrCast(*const IDebugEventCallbacksWide, self), Flags, Argument);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventCallbacksWide_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventCallbacksWide.VTable, self.vtable).ChangeSymbolState(@ptrCast(*const IDebugEventCallbacksWide, self), Flags, Argument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_EVENT_CONTEXT = extern struct {
    Size: u32,
    ProcessEngineId: u32,
    ThreadEngineId: u32,
    FrameEngineId: u32,
};

const IID_IDebugEventContextCallbacks_Value = @import("../../zig.zig").Guid.initString("61a4905b-23f9-4247-b3c5-53d087529ab7");
pub const IID_IDebugEventContextCallbacks = &IID_IDebugEventContextCallbacks_Value;
pub const IDebugEventContextCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetInterestMask: fn(
            self: *const IDebugEventContextCallbacks,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Breakpoint: fn(
            self: *const IDebugEventContextCallbacks,
            Bp: ?*IDebugBreakpoint2,
            // TODO: what to do with BytesParamIndex 2?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Exception: fn(
            self: *const IDebugEventContextCallbacks,
            Exception: ?*EXCEPTION_RECORD64,
            FirstChance: u32,
            // TODO: what to do with BytesParamIndex 3?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateThread: fn(
            self: *const IDebugEventContextCallbacks,
            Handle: u64,
            DataOffset: u64,
            StartOffset: u64,
            // TODO: what to do with BytesParamIndex 4?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitThread: fn(
            self: *const IDebugEventContextCallbacks,
            ExitCode: u32,
            // TODO: what to do with BytesParamIndex 2?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateProcessA: fn(
            self: *const IDebugEventContextCallbacks,
            ImageFileHandle: u64,
            Handle: u64,
            BaseOffset: u64,
            ModuleSize: u32,
            ModuleName: ?[*:0]const u16,
            ImageName: ?[*:0]const u16,
            CheckSum: u32,
            TimeDateStamp: u32,
            InitialThreadHandle: u64,
            ThreadDataOffset: u64,
            StartOffset: u64,
            // TODO: what to do with BytesParamIndex 12?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExitProcess: fn(
            self: *const IDebugEventContextCallbacks,
            ExitCode: u32,
            // TODO: what to do with BytesParamIndex 2?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) noreturn,
        LoadModule: fn(
            self: *const IDebugEventContextCallbacks,
            ImageFileHandle: u64,
            BaseOffset: u64,
            ModuleSize: u32,
            ModuleName: ?[*:0]const u16,
            ImageName: ?[*:0]const u16,
            CheckSum: u32,
            TimeDateStamp: u32,
            // TODO: what to do with BytesParamIndex 8?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnloadModule: fn(
            self: *const IDebugEventContextCallbacks,
            ImageBaseName: ?[*:0]const u16,
            BaseOffset: u64,
            // TODO: what to do with BytesParamIndex 3?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SystemError: fn(
            self: *const IDebugEventContextCallbacks,
            Error: u32,
            Level: u32,
            // TODO: what to do with BytesParamIndex 3?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SessionStatus: fn(
            self: *const IDebugEventContextCallbacks,
            Status: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeDebuggeeState: fn(
            self: *const IDebugEventContextCallbacks,
            Flags: u32,
            Argument: u64,
            // TODO: what to do with BytesParamIndex 3?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeEngineState: fn(
            self: *const IDebugEventContextCallbacks,
            Flags: u32,
            Argument: u64,
            // TODO: what to do with BytesParamIndex 3?
            Context: ?*c_void,
            ContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ChangeSymbolState: fn(
            self: *const IDebugEventContextCallbacks,
            Flags: u32,
            Argument: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_GetInterestMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).GetInterestMask(@ptrCast(*const IDebugEventContextCallbacks, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_Breakpoint(self: *const T, Bp: ?*IDebugBreakpoint2, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).Breakpoint(@ptrCast(*const IDebugEventContextCallbacks, self), Bp, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_Exception(self: *const T, Exception: ?*EXCEPTION_RECORD64, FirstChance: u32, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).Exception(@ptrCast(*const IDebugEventContextCallbacks, self), Exception, FirstChance, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_CreateThread(self: *const T, Handle: u64, DataOffset: u64, StartOffset: u64, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).CreateThread(@ptrCast(*const IDebugEventContextCallbacks, self), Handle, DataOffset, StartOffset, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ExitThread(self: *const T, ExitCode: u32, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).ExitThread(@ptrCast(*const IDebugEventContextCallbacks, self), ExitCode, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_CreateProcessA(self: *const T, ImageFileHandle: u64, Handle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u16, ImageName: ?[*:0]const u16, CheckSum: u32, TimeDateStamp: u32, InitialThreadHandle: u64, ThreadDataOffset: u64, StartOffset: u64, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).CreateProcessA(@ptrCast(*const IDebugEventContextCallbacks, self), ImageFileHandle, Handle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, InitialThreadHandle, ThreadDataOffset, StartOffset, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ExitProcess(self: *const T, ExitCode: u32, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).ExitProcess(@ptrCast(*const IDebugEventContextCallbacks, self), ExitCode, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_LoadModule(self: *const T, ImageFileHandle: u64, BaseOffset: u64, ModuleSize: u32, ModuleName: ?[*:0]const u16, ImageName: ?[*:0]const u16, CheckSum: u32, TimeDateStamp: u32, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).LoadModule(@ptrCast(*const IDebugEventContextCallbacks, self), ImageFileHandle, BaseOffset, ModuleSize, ModuleName, ImageName, CheckSum, TimeDateStamp, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_UnloadModule(self: *const T, ImageBaseName: ?[*:0]const u16, BaseOffset: u64, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).UnloadModule(@ptrCast(*const IDebugEventContextCallbacks, self), ImageBaseName, BaseOffset, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_SystemError(self: *const T, Error: u32, Level: u32, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).SystemError(@ptrCast(*const IDebugEventContextCallbacks, self), Error, Level, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_SessionStatus(self: *const T, Status: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).SessionStatus(@ptrCast(*const IDebugEventContextCallbacks, self), Status);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ChangeDebuggeeState(self: *const T, Flags: u32, Argument: u64, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).ChangeDebuggeeState(@ptrCast(*const IDebugEventContextCallbacks, self), Flags, Argument, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ChangeEngineState(self: *const T, Flags: u32, Argument: u64, Context: ?*c_void, ContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).ChangeEngineState(@ptrCast(*const IDebugEventContextCallbacks, self), Flags, Argument, Context, ContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugEventContextCallbacks_ChangeSymbolState(self: *const T, Flags: u32, Argument: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugEventContextCallbacks.VTable, self.vtable).ChangeSymbolState(@ptrCast(*const IDebugEventContextCallbacks, self), Flags, Argument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugInputCallbacks_Value = @import("../../zig.zig").Guid.initString("9f50e42c-f136-499e-9a97-73036c94ed2d");
pub const IID_IDebugInputCallbacks = &IID_IDebugInputCallbacks_Value;
pub const IDebugInputCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        StartInput: fn(
            self: *const IDebugInputCallbacks,
            BufferSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndInput: fn(
            self: *const IDebugInputCallbacks,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugInputCallbacks_StartInput(self: *const T, BufferSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugInputCallbacks.VTable, self.vtable).StartInput(@ptrCast(*const IDebugInputCallbacks, self), BufferSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugInputCallbacks_EndInput(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugInputCallbacks.VTable, self.vtable).EndInput(@ptrCast(*const IDebugInputCallbacks, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacks_Value = @import("../../zig.zig").Guid.initString("4bf58045-d654-4c40-b0af-683090f356dc");
pub const IID_IDebugOutputCallbacks = &IID_IDebugOutputCallbacks_Value;
pub const IDebugOutputCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: fn(
            self: *const IDebugOutputCallbacks,
            Mask: u32,
            Text: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacks_Output(self: *const T, Mask: u32, Text: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugOutputCallbacks.VTable, self.vtable).Output(@ptrCast(*const IDebugOutputCallbacks, self), Mask, Text);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacksWide_Value = @import("../../zig.zig").Guid.initString("4c7fd663-c394-4e26-8ef1-34ad5ed3764c");
pub const IID_IDebugOutputCallbacksWide = &IID_IDebugOutputCallbacksWide_Value;
pub const IDebugOutputCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: fn(
            self: *const IDebugOutputCallbacksWide,
            Mask: u32,
            Text: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacksWide_Output(self: *const T, Mask: u32, Text: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugOutputCallbacksWide.VTable, self.vtable).Output(@ptrCast(*const IDebugOutputCallbacksWide, self), Mask, Text);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugOutputCallbacks2_Value = @import("../../zig.zig").Guid.initString("67721fe9-56d2-4a44-a325-2b65513ce6eb");
pub const IID_IDebugOutputCallbacks2 = &IID_IDebugOutputCallbacks2_Value;
pub const IDebugOutputCallbacks2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Output: fn(
            self: *const IDebugOutputCallbacks2,
            Mask: u32,
            Text: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInterestMask: fn(
            self: *const IDebugOutputCallbacks2,
            Mask: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Output2: fn(
            self: *const IDebugOutputCallbacks2,
            Which: u32,
            Flags: u32,
            Arg: u64,
            Text: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacks2_Output(self: *const T, Mask: u32, Text: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugOutputCallbacks2.VTable, self.vtable).Output(@ptrCast(*const IDebugOutputCallbacks2, self), Mask, Text);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacks2_GetInterestMask(self: *const T, Mask: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugOutputCallbacks2.VTable, self.vtable).GetInterestMask(@ptrCast(*const IDebugOutputCallbacks2, self), Mask);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugOutputCallbacks2_Output2(self: *const T, Which: u32, Flags: u32, Arg: u64, Text: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugOutputCallbacks2.VTable, self.vtable).Output2(@ptrCast(*const IDebugOutputCallbacks2, self), Which, Flags, Arg, Text);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_REGISTER_DESCRIPTION = extern struct {
    Type: u32,
    Flags: u32,
    SubregMaster: u32,
    SubregLength: u32,
    SubregMask: u64,
    SubregShift: u32,
    Reserved0: u32,
};

const IID_IDebugRegisters_Value = @import("../../zig.zig").Guid.initString("ce289126-9e84-45a7-937e-67bb18691493");
pub const IID_IDebugRegisters = &IID_IDebugRegisters_Value;
pub const IDebugRegisters = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberRegisters: fn(
            self: *const IDebugRegisters,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IDebugRegisters,
            Register: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Desc: ?*DEBUG_REGISTER_DESCRIPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexByName: fn(
            self: *const IDebugRegisters,
            Name: ?[*:0]const u8,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IDebugRegisters,
            Register: u32,
            Value: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IDebugRegisters,
            Register: u32,
            Value: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValues: fn(
            self: *const IDebugRegisters,
            Count: u32,
            Indices: ?[*]u32,
            Start: u32,
            Values: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValues: fn(
            self: *const IDebugRegisters,
            Count: u32,
            Indices: ?[*]u32,
            Start: u32,
            Values: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputRegisters: fn(
            self: *const IDebugRegisters,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInstructionOffset: fn(
            self: *const IDebugRegisters,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackOffset: fn(
            self: *const IDebugRegisters,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameOffset: fn(
            self: *const IDebugRegisters,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetNumberRegisters(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).GetNumberRegisters(@ptrCast(*const IDebugRegisters, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).GetDescription(@ptrCast(*const IDebugRegisters, self), Register, NameBuffer, NameBufferSize, NameSize, Desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetIndexByName(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).GetIndexByName(@ptrCast(*const IDebugRegisters, self), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).GetValue(@ptrCast(*const IDebugRegisters, self), Register, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_SetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).SetValue(@ptrCast(*const IDebugRegisters, self), Register, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).GetValues(@ptrCast(*const IDebugRegisters, self), Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_SetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).SetValues(@ptrCast(*const IDebugRegisters, self), Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_OutputRegisters(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).OutputRegisters(@ptrCast(*const IDebugRegisters, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetInstructionOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).GetInstructionOffset(@ptrCast(*const IDebugRegisters, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetStackOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).GetStackOffset(@ptrCast(*const IDebugRegisters, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters_GetFrameOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters.VTable, self.vtable).GetFrameOffset(@ptrCast(*const IDebugRegisters, self), Offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugRegisters2_Value = @import("../../zig.zig").Guid.initString("1656afa9-19c6-4e3a-97e7-5dc9160cf9c4");
pub const IID_IDebugRegisters2 = &IID_IDebugRegisters2_Value;
pub const IDebugRegisters2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberRegisters: fn(
            self: *const IDebugRegisters2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IDebugRegisters2,
            Register: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Desc: ?*DEBUG_REGISTER_DESCRIPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexByName: fn(
            self: *const IDebugRegisters2,
            Name: ?[*:0]const u8,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IDebugRegisters2,
            Register: u32,
            Value: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IDebugRegisters2,
            Register: u32,
            Value: ?*DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValues: fn(
            self: *const IDebugRegisters2,
            Count: u32,
            Indices: ?[*]u32,
            Start: u32,
            Values: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValues: fn(
            self: *const IDebugRegisters2,
            Count: u32,
            Indices: ?[*]u32,
            Start: u32,
            Values: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputRegisters: fn(
            self: *const IDebugRegisters2,
            OutputControl: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInstructionOffset: fn(
            self: *const IDebugRegisters2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackOffset: fn(
            self: *const IDebugRegisters2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameOffset: fn(
            self: *const IDebugRegisters2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescriptionWide: fn(
            self: *const IDebugRegisters2,
            Register: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Desc: ?*DEBUG_REGISTER_DESCRIPTION,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIndexByNameWide: fn(
            self: *const IDebugRegisters2,
            Name: ?[*:0]const u16,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberPseudoRegisters: fn(
            self: *const IDebugRegisters2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPseudoDescription: fn(
            self: *const IDebugRegisters2,
            Register: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            TypeModule: ?*u64,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPseudoDescriptionWide: fn(
            self: *const IDebugRegisters2,
            Register: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            TypeModule: ?*u64,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPseudoIndexByName: fn(
            self: *const IDebugRegisters2,
            Name: ?[*:0]const u8,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPseudoIndexByNameWide: fn(
            self: *const IDebugRegisters2,
            Name: ?[*:0]const u16,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPseudoValues: fn(
            self: *const IDebugRegisters2,
            Source: u32,
            Count: u32,
            Indices: ?[*]u32,
            Start: u32,
            Values: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetPseudoValues: fn(
            self: *const IDebugRegisters2,
            Source: u32,
            Count: u32,
            Indices: ?[*]u32,
            Start: u32,
            Values: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValues2: fn(
            self: *const IDebugRegisters2,
            Source: u32,
            Count: u32,
            Indices: ?[*]u32,
            Start: u32,
            Values: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValues2: fn(
            self: *const IDebugRegisters2,
            Source: u32,
            Count: u32,
            Indices: ?[*]u32,
            Start: u32,
            Values: [*]DEBUG_VALUE,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputRegisters2: fn(
            self: *const IDebugRegisters2,
            OutputControl: u32,
            Source: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetInstructionOffset2: fn(
            self: *const IDebugRegisters2,
            Source: u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStackOffset2: fn(
            self: *const IDebugRegisters2,
            Source: u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFrameOffset2: fn(
            self: *const IDebugRegisters2,
            Source: u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetNumberRegisters(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetNumberRegisters(@ptrCast(*const IDebugRegisters2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetDescription(@ptrCast(*const IDebugRegisters2, self), Register, NameBuffer, NameBufferSize, NameSize, Desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetIndexByName(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetIndexByName(@ptrCast(*const IDebugRegisters2, self), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetValue(@ptrCast(*const IDebugRegisters2, self), Register, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_SetValue(self: *const T, Register: u32, Value: ?*DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).SetValue(@ptrCast(*const IDebugRegisters2, self), Register, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetValues(@ptrCast(*const IDebugRegisters2, self), Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_SetValues(self: *const T, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).SetValues(@ptrCast(*const IDebugRegisters2, self), Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_OutputRegisters(self: *const T, OutputControl: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).OutputRegisters(@ptrCast(*const IDebugRegisters2, self), OutputControl, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetInstructionOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetInstructionOffset(@ptrCast(*const IDebugRegisters2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetStackOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetStackOffset(@ptrCast(*const IDebugRegisters2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetFrameOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetFrameOffset(@ptrCast(*const IDebugRegisters2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetDescriptionWide(self: *const T, Register: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Desc: ?*DEBUG_REGISTER_DESCRIPTION) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetDescriptionWide(@ptrCast(*const IDebugRegisters2, self), Register, NameBuffer, NameBufferSize, NameSize, Desc);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetIndexByNameWide(self: *const T, Name: ?[*:0]const u16, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetIndexByNameWide(@ptrCast(*const IDebugRegisters2, self), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetNumberPseudoRegisters(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetNumberPseudoRegisters(@ptrCast(*const IDebugRegisters2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoDescription(self: *const T, Register: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, TypeModule: ?*u64, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetPseudoDescription(@ptrCast(*const IDebugRegisters2, self), Register, NameBuffer, NameBufferSize, NameSize, TypeModule, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoDescriptionWide(self: *const T, Register: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, TypeModule: ?*u64, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetPseudoDescriptionWide(@ptrCast(*const IDebugRegisters2, self), Register, NameBuffer, NameBufferSize, NameSize, TypeModule, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoIndexByName(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetPseudoIndexByName(@ptrCast(*const IDebugRegisters2, self), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoIndexByNameWide(self: *const T, Name: ?[*:0]const u16, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetPseudoIndexByNameWide(@ptrCast(*const IDebugRegisters2, self), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetPseudoValues(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetPseudoValues(@ptrCast(*const IDebugRegisters2, self), Source, Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_SetPseudoValues(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).SetPseudoValues(@ptrCast(*const IDebugRegisters2, self), Source, Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetValues2(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetValues2(@ptrCast(*const IDebugRegisters2, self), Source, Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_SetValues2(self: *const T, Source: u32, Count: u32, Indices: ?[*]u32, Start: u32, Values: [*]DEBUG_VALUE) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).SetValues2(@ptrCast(*const IDebugRegisters2, self), Source, Count, Indices, Start, Values);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_OutputRegisters2(self: *const T, OutputControl: u32, Source: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).OutputRegisters2(@ptrCast(*const IDebugRegisters2, self), OutputControl, Source, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetInstructionOffset2(self: *const T, Source: u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetInstructionOffset2(@ptrCast(*const IDebugRegisters2, self), Source, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetStackOffset2(self: *const T, Source: u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetStackOffset2(@ptrCast(*const IDebugRegisters2, self), Source, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugRegisters2_GetFrameOffset2(self: *const T, Source: u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugRegisters2.VTable, self.vtable).GetFrameOffset2(@ptrCast(*const IDebugRegisters2, self), Source, Offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_SYMBOL_PARAMETERS = extern struct {
    Module: u64,
    TypeId: u32,
    ParentSymbol: u32,
    SubElements: u32,
    Flags: u32,
    Reserved: u64,
};

const IID_IDebugSymbolGroup_Value = @import("../../zig.zig").Guid.initString("f2528316-0f1a-4431-aeed-11d096e1e2ab");
pub const IID_IDebugSymbolGroup = &IID_IDebugSymbolGroup_Value;
pub const IDebugSymbolGroup = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberSymbols: fn(
            self: *const IDebugSymbolGroup,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSymbol: fn(
            self: *const IDebugSymbolGroup,
            Name: ?[*:0]const u8,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolByName: fn(
            self: *const IDebugSymbolGroup,
            Name: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolByIndex: fn(
            self: *const IDebugSymbolGroup,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolName: fn(
            self: *const IDebugSymbolGroup,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolParameters: fn(
            self: *const IDebugSymbolGroup,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SYMBOL_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExpandSymbol: fn(
            self: *const IDebugSymbolGroup,
            Index: u32,
            Expand: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputSymbols: fn(
            self: *const IDebugSymbolGroup,
            OutputControl: u32,
            Flags: u32,
            Start: u32,
            Count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSymbol: fn(
            self: *const IDebugSymbolGroup,
            Index: u32,
            Value: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputAsType: fn(
            self: *const IDebugSymbolGroup,
            Index: u32,
            Type: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_GetNumberSymbols(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).GetNumberSymbols(@ptrCast(*const IDebugSymbolGroup, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_AddSymbol(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).AddSymbol(@ptrCast(*const IDebugSymbolGroup, self), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_RemoveSymbolByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).RemoveSymbolByName(@ptrCast(*const IDebugSymbolGroup, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_RemoveSymbolByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).RemoveSymbolByIndex(@ptrCast(*const IDebugSymbolGroup, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_GetSymbolName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).GetSymbolName(@ptrCast(*const IDebugSymbolGroup, self), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_GetSymbolParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SYMBOL_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).GetSymbolParameters(@ptrCast(*const IDebugSymbolGroup, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_ExpandSymbol(self: *const T, Index: u32, Expand: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).ExpandSymbol(@ptrCast(*const IDebugSymbolGroup, self), Index, Expand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_OutputSymbols(self: *const T, OutputControl: u32, Flags: u32, Start: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).OutputSymbols(@ptrCast(*const IDebugSymbolGroup, self), OutputControl, Flags, Start, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_WriteSymbol(self: *const T, Index: u32, Value: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).WriteSymbol(@ptrCast(*const IDebugSymbolGroup, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup_OutputAsType(self: *const T, Index: u32, Type: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup.VTable, self.vtable).OutputAsType(@ptrCast(*const IDebugSymbolGroup, self), Index, Type);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_SYMBOL_ENTRY = extern struct {
    ModuleBase: u64,
    Offset: u64,
    Id: u64,
    Arg64: u64,
    Size: u32,
    Flags: u32,
    TypeId: u32,
    NameSize: u32,
    Token: u32,
    Tag: u32,
    Arg32: u32,
    Reserved: u32,
};

const IID_IDebugSymbolGroup2_Value = @import("../../zig.zig").Guid.initString("6a7ccc5f-fb5e-4dcc-b41c-6c20307bccc7");
pub const IID_IDebugSymbolGroup2 = &IID_IDebugSymbolGroup2_Value;
pub const IDebugSymbolGroup2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetNumberSymbols: fn(
            self: *const IDebugSymbolGroup2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSymbol: fn(
            self: *const IDebugSymbolGroup2,
            Name: ?[*:0]const u8,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolByName: fn(
            self: *const IDebugSymbolGroup2,
            Name: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolByIndex: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolName: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolParameters: fn(
            self: *const IDebugSymbolGroup2,
            Start: u32,
            Count: u32,
            Params: [*]DEBUG_SYMBOL_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ExpandSymbol: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Expand: BOOL,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputSymbols: fn(
            self: *const IDebugSymbolGroup2,
            OutputControl: u32,
            Flags: u32,
            Start: u32,
            Count: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSymbol: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Value: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputAsType: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Type: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSymbolWide: fn(
            self: *const IDebugSymbolGroup2,
            Name: ?[*:0]const u16,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolByNameWide: fn(
            self: *const IDebugSymbolGroup2,
            Name: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolNameWide: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteSymbolWide: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Value: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputAsTypeWide: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Type: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeName: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeNameWide: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolSize: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolOffset: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolRegister: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Register: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolValueText: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolValueTextWide: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryInformation: fn(
            self: *const IDebugSymbolGroup2,
            Index: u32,
            Entry: ?*DEBUG_SYMBOL_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetNumberSymbols(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetNumberSymbols(@ptrCast(*const IDebugSymbolGroup2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_AddSymbol(self: *const T, Name: ?[*:0]const u8, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).AddSymbol(@ptrCast(*const IDebugSymbolGroup2, self), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_RemoveSymbolByName(self: *const T, Name: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).RemoveSymbolByName(@ptrCast(*const IDebugSymbolGroup2, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_RemoveSymbolByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).RemoveSymbolByIndex(@ptrCast(*const IDebugSymbolGroup2, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolName(@ptrCast(*const IDebugSymbolGroup2, self), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolParameters(self: *const T, Start: u32, Count: u32, Params: [*]DEBUG_SYMBOL_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolParameters(@ptrCast(*const IDebugSymbolGroup2, self), Start, Count, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_ExpandSymbol(self: *const T, Index: u32, Expand: BOOL) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).ExpandSymbol(@ptrCast(*const IDebugSymbolGroup2, self), Index, Expand);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_OutputSymbols(self: *const T, OutputControl: u32, Flags: u32, Start: u32, Count: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).OutputSymbols(@ptrCast(*const IDebugSymbolGroup2, self), OutputControl, Flags, Start, Count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_WriteSymbol(self: *const T, Index: u32, Value: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).WriteSymbol(@ptrCast(*const IDebugSymbolGroup2, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_OutputAsType(self: *const T, Index: u32, Type: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).OutputAsType(@ptrCast(*const IDebugSymbolGroup2, self), Index, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_AddSymbolWide(self: *const T, Name: ?[*:0]const u16, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).AddSymbolWide(@ptrCast(*const IDebugSymbolGroup2, self), Name, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_RemoveSymbolByNameWide(self: *const T, Name: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).RemoveSymbolByNameWide(@ptrCast(*const IDebugSymbolGroup2, self), Name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolNameWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolNameWide(@ptrCast(*const IDebugSymbolGroup2, self), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_WriteSymbolWide(self: *const T, Index: u32, Value: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).WriteSymbolWide(@ptrCast(*const IDebugSymbolGroup2, self), Index, Value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_OutputAsTypeWide(self: *const T, Index: u32, Type: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).OutputAsTypeWide(@ptrCast(*const IDebugSymbolGroup2, self), Index, Type);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolTypeName(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolTypeName(@ptrCast(*const IDebugSymbolGroup2, self), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolTypeNameWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolTypeNameWide(@ptrCast(*const IDebugSymbolGroup2, self), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolSize(self: *const T, Index: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolSize(@ptrCast(*const IDebugSymbolGroup2, self), Index, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolOffset(self: *const T, Index: u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolOffset(@ptrCast(*const IDebugSymbolGroup2, self), Index, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolRegister(self: *const T, Index: u32, Register: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolRegister(@ptrCast(*const IDebugSymbolGroup2, self), Index, Register);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolValueText(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolValueText(@ptrCast(*const IDebugSymbolGroup2, self), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolValueTextWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolValueTextWide(@ptrCast(*const IDebugSymbolGroup2, self), Index, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbolGroup2_GetSymbolEntryInformation(self: *const T, Index: u32, Entry: ?*DEBUG_SYMBOL_ENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbolGroup2.VTable, self.vtable).GetSymbolEntryInformation(@ptrCast(*const IDebugSymbolGroup2, self), Index, Entry);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_MODULE_PARAMETERS = extern struct {
    Base: u64,
    Size: u32,
    TimeDateStamp: u32,
    Checksum: u32,
    Flags: u32,
    SymbolType: u32,
    ImageNameSize: u32,
    ModuleNameSize: u32,
    LoadedImageNameSize: u32,
    SymbolFileNameSize: u32,
    MappedImageNameSize: u32,
    Reserved: [2]u64,
};

const IID_IDebugSymbols_Value = @import("../../zig.zig").Guid.initString("8c31e98c-983a-48a5-9016-6fe5d667a950");
pub const IID_IDebugSymbols = &IID_IDebugSymbols_Value;
pub const IDebugSymbols = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: fn(
            self: *const IDebugSymbols,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSymbolOptions: fn(
            self: *const IDebugSymbols,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolOptions: fn(
            self: *const IDebugSymbols,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolOptions: fn(
            self: *const IDebugSymbols,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByOffset: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByName: fn(
            self: *const IDebugSymbols,
            Symbol: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearNameByOffset: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            Delta: i32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByOffset: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            Line: ?*u32,
            FileBuffer: ?[*:0]u8,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByLine: fn(
            self: *const IDebugSymbols,
            Line: u32,
            File: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberModules: fn(
            self: *const IDebugSymbols,
            Loaded: ?*u32,
            Unloaded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByIndex: fn(
            self: *const IDebugSymbols,
            Index: u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName: fn(
            self: *const IDebugSymbols,
            Name: ?[*:0]const u8,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByOffset: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNames: fn(
            self: *const IDebugSymbols,
            Index: u32,
            Base: u64,
            ImageNameBuffer: ?[*:0]u8,
            ImageNameBufferSize: u32,
            ImageNameSize: ?*u32,
            ModuleNameBuffer: ?[*:0]u8,
            ModuleNameBufferSize: u32,
            ModuleNameSize: ?*u32,
            LoadedImageNameBuffer: ?[*:0]u8,
            LoadedImageNameBufferSize: u32,
            LoadedImageNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleParameters: fn(
            self: *const IDebugSymbols,
            Count: u32,
            Bases: ?[*]u64,
            Start: u32,
            Params: [*]DEBUG_MODULE_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolModule: fn(
            self: *const IDebugSymbols,
            Symbol: ?[*:0]const u8,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeName: fn(
            self: *const IDebugSymbols,
            Module: u64,
            TypeId: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeId: fn(
            self: *const IDebugSymbols,
            Module: u64,
            Name: ?[*:0]const u8,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeSize: fn(
            self: *const IDebugSymbols,
            Module: u64,
            TypeId: u32,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldOffset: fn(
            self: *const IDebugSymbols,
            Module: u64,
            TypeId: u32,
            Field: ?[*:0]const u8,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeId: fn(
            self: *const IDebugSymbols,
            Symbol: ?[*:0]const u8,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetTypeId: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataVirtual: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataVirtual: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataVirtual: fn(
            self: *const IDebugSymbols,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataPhysical: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataPhysical: fn(
            self: *const IDebugSymbols,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataPhysical: fn(
            self: *const IDebugSymbols,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScope: fn(
            self: *const IDebugSymbols,
            InstructionOffset: ?*u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScope: fn(
            self: *const IDebugSymbols,
            InstructionOffset: u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetScope: fn(
            self: *const IDebugSymbols,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeSymbolGroup: fn(
            self: *const IDebugSymbols,
            Flags: u32,
            Update: ?*IDebugSymbolGroup,
            Symbols: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSymbolGroup: fn(
            self: *const IDebugSymbols,
            Group: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSymbolMatch: fn(
            self: *const IDebugSymbols,
            Pattern: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSymbolMatch: fn(
            self: *const IDebugSymbols,
            Handle: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MatchSize: ?*u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSymbolMatch: fn(
            self: *const IDebugSymbols,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reload: fn(
            self: *const IDebugSymbols,
            Module: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolPath: fn(
            self: *const IDebugSymbols,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolPath: fn(
            self: *const IDebugSymbols,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSymbolPath: fn(
            self: *const IDebugSymbols,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImagePath: fn(
            self: *const IDebugSymbols,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImagePath: fn(
            self: *const IDebugSymbols,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendImagePath: fn(
            self: *const IDebugSymbols,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePath: fn(
            self: *const IDebugSymbols,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathElement: fn(
            self: *const IDebugSymbols,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ElementSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePath: fn(
            self: *const IDebugSymbols,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSourcePath: fn(
            self: *const IDebugSymbols,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFile: fn(
            self: *const IDebugSymbols,
            StartElement: u32,
            File: ?[*:0]const u8,
            Flags: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileLineOffsets: fn(
            self: *const IDebugSymbols,
            File: ?[*:0]const u8,
            Buffer: ?[*]u64,
            BufferLines: u32,
            FileLines: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetSymbolOptions(@ptrCast(*const IDebugSymbols, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).AddSymbolOptions(@ptrCast(*const IDebugSymbols, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).RemoveSymbolOptions(@ptrCast(*const IDebugSymbols, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).SetSymbolOptions(@ptrCast(*const IDebugSymbols, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetNameByOffset(@ptrCast(*const IDebugSymbols, self), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetOffsetByName(@ptrCast(*const IDebugSymbols, self), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetNearNameByOffset(@ptrCast(*const IDebugSymbols, self), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetLineByOffset(@ptrCast(*const IDebugSymbols, self), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetOffsetByLine(@ptrCast(*const IDebugSymbols, self), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetNumberModules(@ptrCast(*const IDebugSymbols, self), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetModuleByIndex(@ptrCast(*const IDebugSymbols, self), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetModuleByModuleName(@ptrCast(*const IDebugSymbols, self), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetModuleByOffset(@ptrCast(*const IDebugSymbols, self), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetModuleNames(@ptrCast(*const IDebugSymbols, self), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetModuleParameters(@ptrCast(*const IDebugSymbols, self), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetSymbolModule(@ptrCast(*const IDebugSymbols, self), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetTypeName(@ptrCast(*const IDebugSymbols, self), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetTypeId(@ptrCast(*const IDebugSymbols, self), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetTypeSize(@ptrCast(*const IDebugSymbols, self), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetFieldOffset(@ptrCast(*const IDebugSymbols, self), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetSymbolTypeId(@ptrCast(*const IDebugSymbols, self), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetOffsetTypeId(@ptrCast(*const IDebugSymbols, self), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).ReadTypedDataVirtual(@ptrCast(*const IDebugSymbols, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).WriteTypedDataVirtual(@ptrCast(*const IDebugSymbols, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).OutputTypedDataVirtual(@ptrCast(*const IDebugSymbols, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).ReadTypedDataPhysical(@ptrCast(*const IDebugSymbols, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).WriteTypedDataPhysical(@ptrCast(*const IDebugSymbols, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).OutputTypedDataPhysical(@ptrCast(*const IDebugSymbols, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetScope(@ptrCast(*const IDebugSymbols, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).SetScope(@ptrCast(*const IDebugSymbols, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).ResetScope(@ptrCast(*const IDebugSymbols, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetScopeSymbolGroup(@ptrCast(*const IDebugSymbols, self), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).CreateSymbolGroup(@ptrCast(*const IDebugSymbols, self), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).StartSymbolMatch(@ptrCast(*const IDebugSymbols, self), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetNextSymbolMatch(@ptrCast(*const IDebugSymbols, self), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).EndSymbolMatch(@ptrCast(*const IDebugSymbols, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_Reload(self: *const T, Module: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).Reload(@ptrCast(*const IDebugSymbols, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetSymbolPath(@ptrCast(*const IDebugSymbols, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).SetSymbolPath(@ptrCast(*const IDebugSymbols, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).AppendSymbolPath(@ptrCast(*const IDebugSymbols, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetImagePath(@ptrCast(*const IDebugSymbols, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetImagePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).SetImagePath(@ptrCast(*const IDebugSymbols, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).AppendImagePath(@ptrCast(*const IDebugSymbols, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetSourcePath(@ptrCast(*const IDebugSymbols, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetSourcePathElement(@ptrCast(*const IDebugSymbols, self), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_SetSourcePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).SetSourcePath(@ptrCast(*const IDebugSymbols, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).AppendSourcePath(@ptrCast(*const IDebugSymbols, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).FindSourceFile(@ptrCast(*const IDebugSymbols, self), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols.VTable, self.vtable).GetSourceFileLineOffsets(@ptrCast(*const IDebugSymbols, self), File, Buffer, BufferLines, FileLines);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols2_Value = @import("../../zig.zig").Guid.initString("3a707211-afdd-4495-ad4f-56fecdf8163f");
pub const IID_IDebugSymbols2 = &IID_IDebugSymbols2_Value;
pub const IDebugSymbols2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: fn(
            self: *const IDebugSymbols2,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSymbolOptions: fn(
            self: *const IDebugSymbols2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolOptions: fn(
            self: *const IDebugSymbols2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolOptions: fn(
            self: *const IDebugSymbols2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByOffset: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByName: fn(
            self: *const IDebugSymbols2,
            Symbol: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearNameByOffset: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            Delta: i32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByOffset: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            Line: ?*u32,
            FileBuffer: ?[*:0]u8,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByLine: fn(
            self: *const IDebugSymbols2,
            Line: u32,
            File: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberModules: fn(
            self: *const IDebugSymbols2,
            Loaded: ?*u32,
            Unloaded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByIndex: fn(
            self: *const IDebugSymbols2,
            Index: u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName: fn(
            self: *const IDebugSymbols2,
            Name: ?[*:0]const u8,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByOffset: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNames: fn(
            self: *const IDebugSymbols2,
            Index: u32,
            Base: u64,
            ImageNameBuffer: ?[*:0]u8,
            ImageNameBufferSize: u32,
            ImageNameSize: ?*u32,
            ModuleNameBuffer: ?[*:0]u8,
            ModuleNameBufferSize: u32,
            ModuleNameSize: ?*u32,
            LoadedImageNameBuffer: ?[*:0]u8,
            LoadedImageNameBufferSize: u32,
            LoadedImageNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleParameters: fn(
            self: *const IDebugSymbols2,
            Count: u32,
            Bases: ?[*]u64,
            Start: u32,
            Params: [*]DEBUG_MODULE_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolModule: fn(
            self: *const IDebugSymbols2,
            Symbol: ?[*:0]const u8,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeName: fn(
            self: *const IDebugSymbols2,
            Module: u64,
            TypeId: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeId: fn(
            self: *const IDebugSymbols2,
            Module: u64,
            Name: ?[*:0]const u8,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeSize: fn(
            self: *const IDebugSymbols2,
            Module: u64,
            TypeId: u32,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldOffset: fn(
            self: *const IDebugSymbols2,
            Module: u64,
            TypeId: u32,
            Field: ?[*:0]const u8,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeId: fn(
            self: *const IDebugSymbols2,
            Symbol: ?[*:0]const u8,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetTypeId: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataVirtual: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataVirtual: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataVirtual: fn(
            self: *const IDebugSymbols2,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataPhysical: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataPhysical: fn(
            self: *const IDebugSymbols2,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataPhysical: fn(
            self: *const IDebugSymbols2,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScope: fn(
            self: *const IDebugSymbols2,
            InstructionOffset: ?*u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScope: fn(
            self: *const IDebugSymbols2,
            InstructionOffset: u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetScope: fn(
            self: *const IDebugSymbols2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeSymbolGroup: fn(
            self: *const IDebugSymbols2,
            Flags: u32,
            Update: ?*IDebugSymbolGroup,
            Symbols: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSymbolGroup: fn(
            self: *const IDebugSymbols2,
            Group: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSymbolMatch: fn(
            self: *const IDebugSymbols2,
            Pattern: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSymbolMatch: fn(
            self: *const IDebugSymbols2,
            Handle: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MatchSize: ?*u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSymbolMatch: fn(
            self: *const IDebugSymbols2,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reload: fn(
            self: *const IDebugSymbols2,
            Module: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolPath: fn(
            self: *const IDebugSymbols2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolPath: fn(
            self: *const IDebugSymbols2,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSymbolPath: fn(
            self: *const IDebugSymbols2,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImagePath: fn(
            self: *const IDebugSymbols2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImagePath: fn(
            self: *const IDebugSymbols2,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendImagePath: fn(
            self: *const IDebugSymbols2,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePath: fn(
            self: *const IDebugSymbols2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathElement: fn(
            self: *const IDebugSymbols2,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ElementSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePath: fn(
            self: *const IDebugSymbols2,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSourcePath: fn(
            self: *const IDebugSymbols2,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFile: fn(
            self: *const IDebugSymbols2,
            StartElement: u32,
            File: ?[*:0]const u8,
            Flags: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileLineOffsets: fn(
            self: *const IDebugSymbols2,
            File: ?[*:0]const u8,
            Buffer: ?[*]u64,
            BufferLines: u32,
            FileLines: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleVersionInformation: fn(
            self: *const IDebugSymbols2,
            Index: u32,
            Base: u64,
            Item: ?[*:0]const u8,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            VerInfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNameString: fn(
            self: *const IDebugSymbols2,
            Which: u32,
            Index: u32,
            Base: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstantName: fn(
            self: *const IDebugSymbols2,
            Module: u64,
            TypeId: u32,
            Value: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldName: fn(
            self: *const IDebugSymbols2,
            Module: u64,
            TypeId: u32,
            FieldIndex: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeOptions: fn(
            self: *const IDebugSymbols2,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTypeOptions: fn(
            self: *const IDebugSymbols2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTypeOptions: fn(
            self: *const IDebugSymbols2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypeOptions: fn(
            self: *const IDebugSymbols2,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetSymbolOptions(@ptrCast(*const IDebugSymbols2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).AddSymbolOptions(@ptrCast(*const IDebugSymbols2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).RemoveSymbolOptions(@ptrCast(*const IDebugSymbols2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).SetSymbolOptions(@ptrCast(*const IDebugSymbols2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetNameByOffset(@ptrCast(*const IDebugSymbols2, self), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetOffsetByName(@ptrCast(*const IDebugSymbols2, self), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetNearNameByOffset(@ptrCast(*const IDebugSymbols2, self), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetLineByOffset(@ptrCast(*const IDebugSymbols2, self), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetOffsetByLine(@ptrCast(*const IDebugSymbols2, self), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetNumberModules(@ptrCast(*const IDebugSymbols2, self), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetModuleByIndex(@ptrCast(*const IDebugSymbols2, self), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetModuleByModuleName(@ptrCast(*const IDebugSymbols2, self), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetModuleByOffset(@ptrCast(*const IDebugSymbols2, self), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetModuleNames(@ptrCast(*const IDebugSymbols2, self), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetModuleParameters(@ptrCast(*const IDebugSymbols2, self), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetSymbolModule(@ptrCast(*const IDebugSymbols2, self), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetTypeName(@ptrCast(*const IDebugSymbols2, self), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetTypeId(@ptrCast(*const IDebugSymbols2, self), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetTypeSize(@ptrCast(*const IDebugSymbols2, self), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetFieldOffset(@ptrCast(*const IDebugSymbols2, self), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetSymbolTypeId(@ptrCast(*const IDebugSymbols2, self), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetOffsetTypeId(@ptrCast(*const IDebugSymbols2, self), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).ReadTypedDataVirtual(@ptrCast(*const IDebugSymbols2, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).WriteTypedDataVirtual(@ptrCast(*const IDebugSymbols2, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).OutputTypedDataVirtual(@ptrCast(*const IDebugSymbols2, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).ReadTypedDataPhysical(@ptrCast(*const IDebugSymbols2, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).WriteTypedDataPhysical(@ptrCast(*const IDebugSymbols2, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).OutputTypedDataPhysical(@ptrCast(*const IDebugSymbols2, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetScope(@ptrCast(*const IDebugSymbols2, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).SetScope(@ptrCast(*const IDebugSymbols2, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).ResetScope(@ptrCast(*const IDebugSymbols2, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetScopeSymbolGroup(@ptrCast(*const IDebugSymbols2, self), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).CreateSymbolGroup(@ptrCast(*const IDebugSymbols2, self), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).StartSymbolMatch(@ptrCast(*const IDebugSymbols2, self), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetNextSymbolMatch(@ptrCast(*const IDebugSymbols2, self), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).EndSymbolMatch(@ptrCast(*const IDebugSymbols2, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_Reload(self: *const T, Module: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).Reload(@ptrCast(*const IDebugSymbols2, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetSymbolPath(@ptrCast(*const IDebugSymbols2, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).SetSymbolPath(@ptrCast(*const IDebugSymbols2, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).AppendSymbolPath(@ptrCast(*const IDebugSymbols2, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetImagePath(@ptrCast(*const IDebugSymbols2, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetImagePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).SetImagePath(@ptrCast(*const IDebugSymbols2, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).AppendImagePath(@ptrCast(*const IDebugSymbols2, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetSourcePath(@ptrCast(*const IDebugSymbols2, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetSourcePathElement(@ptrCast(*const IDebugSymbols2, self), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetSourcePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).SetSourcePath(@ptrCast(*const IDebugSymbols2, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).AppendSourcePath(@ptrCast(*const IDebugSymbols2, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).FindSourceFile(@ptrCast(*const IDebugSymbols2, self), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetSourceFileLineOffsets(@ptrCast(*const IDebugSymbols2, self), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u8, Buffer: ?*c_void, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetModuleVersionInformation(@ptrCast(*const IDebugSymbols2, self), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetModuleNameString(@ptrCast(*const IDebugSymbols2, self), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetConstantName(@ptrCast(*const IDebugSymbols2, self), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetFieldName(@ptrCast(*const IDebugSymbols2, self), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_GetTypeOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).GetTypeOptions(@ptrCast(*const IDebugSymbols2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_AddTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).AddTypeOptions(@ptrCast(*const IDebugSymbols2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_RemoveTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).RemoveTypeOptions(@ptrCast(*const IDebugSymbols2, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols2_SetTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols2.VTable, self.vtable).SetTypeOptions(@ptrCast(*const IDebugSymbols2, self), Options);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DEBUG_MODULE_AND_ID = extern struct {
    ModuleBase: u64,
    Id: u64,
};

pub const DEBUG_SYMBOL_SOURCE_ENTRY = extern struct {
    ModuleBase: u64,
    Offset: u64,
    FileNameId: u64,
    EngineInternal: u64,
    Size: u32,
    Flags: u32,
    FileNameSize: u32,
    StartLine: u32,
    EndLine: u32,
    StartColumn: u32,
    EndColumn: u32,
    Reserved: u32,
};

const IID_IDebugSymbols3_Value = @import("../../zig.zig").Guid.initString("f02fbecc-50ac-4f36-9ad9-c975e8f32ff8");
pub const IID_IDebugSymbols3 = &IID_IDebugSymbols3_Value;
pub const IDebugSymbols3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: fn(
            self: *const IDebugSymbols3,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSymbolOptions: fn(
            self: *const IDebugSymbols3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolOptions: fn(
            self: *const IDebugSymbols3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolOptions: fn(
            self: *const IDebugSymbols3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByOffset: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByName: fn(
            self: *const IDebugSymbols3,
            Symbol: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearNameByOffset: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Delta: i32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByOffset: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Line: ?*u32,
            FileBuffer: ?[*:0]u8,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByLine: fn(
            self: *const IDebugSymbols3,
            Line: u32,
            File: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberModules: fn(
            self: *const IDebugSymbols3,
            Loaded: ?*u32,
            Unloaded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByIndex: fn(
            self: *const IDebugSymbols3,
            Index: u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName: fn(
            self: *const IDebugSymbols3,
            Name: ?[*:0]const u8,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByOffset: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNames: fn(
            self: *const IDebugSymbols3,
            Index: u32,
            Base: u64,
            ImageNameBuffer: ?[*:0]u8,
            ImageNameBufferSize: u32,
            ImageNameSize: ?*u32,
            ModuleNameBuffer: ?[*:0]u8,
            ModuleNameBufferSize: u32,
            ModuleNameSize: ?*u32,
            LoadedImageNameBuffer: ?[*:0]u8,
            LoadedImageNameBufferSize: u32,
            LoadedImageNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleParameters: fn(
            self: *const IDebugSymbols3,
            Count: u32,
            Bases: ?[*]u64,
            Start: u32,
            Params: [*]DEBUG_MODULE_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolModule: fn(
            self: *const IDebugSymbols3,
            Symbol: ?[*:0]const u8,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeName: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeId: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            Name: ?[*:0]const u8,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeSize: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldOffset: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            Field: ?[*:0]const u8,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeId: fn(
            self: *const IDebugSymbols3,
            Symbol: ?[*:0]const u8,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetTypeId: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataVirtual: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataVirtual: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataVirtual: fn(
            self: *const IDebugSymbols3,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataPhysical: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataPhysical: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataPhysical: fn(
            self: *const IDebugSymbols3,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScope: fn(
            self: *const IDebugSymbols3,
            InstructionOffset: ?*u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScope: fn(
            self: *const IDebugSymbols3,
            InstructionOffset: u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetScope: fn(
            self: *const IDebugSymbols3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeSymbolGroup: fn(
            self: *const IDebugSymbols3,
            Flags: u32,
            Update: ?*IDebugSymbolGroup,
            Symbols: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSymbolGroup: fn(
            self: *const IDebugSymbols3,
            Group: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSymbolMatch: fn(
            self: *const IDebugSymbols3,
            Pattern: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSymbolMatch: fn(
            self: *const IDebugSymbols3,
            Handle: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MatchSize: ?*u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSymbolMatch: fn(
            self: *const IDebugSymbols3,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reload: fn(
            self: *const IDebugSymbols3,
            Module: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolPath: fn(
            self: *const IDebugSymbols3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolPath: fn(
            self: *const IDebugSymbols3,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSymbolPath: fn(
            self: *const IDebugSymbols3,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImagePath: fn(
            self: *const IDebugSymbols3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImagePath: fn(
            self: *const IDebugSymbols3,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendImagePath: fn(
            self: *const IDebugSymbols3,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePath: fn(
            self: *const IDebugSymbols3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathElement: fn(
            self: *const IDebugSymbols3,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ElementSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePath: fn(
            self: *const IDebugSymbols3,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSourcePath: fn(
            self: *const IDebugSymbols3,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFile: fn(
            self: *const IDebugSymbols3,
            StartElement: u32,
            File: ?[*:0]const u8,
            Flags: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileLineOffsets: fn(
            self: *const IDebugSymbols3,
            File: ?[*:0]const u8,
            Buffer: ?[*]u64,
            BufferLines: u32,
            FileLines: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleVersionInformation: fn(
            self: *const IDebugSymbols3,
            Index: u32,
            Base: u64,
            Item: ?[*:0]const u8,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            VerInfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNameString: fn(
            self: *const IDebugSymbols3,
            Which: u32,
            Index: u32,
            Base: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstantName: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            Value: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldName: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            FieldIndex: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeOptions: fn(
            self: *const IDebugSymbols3,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTypeOptions: fn(
            self: *const IDebugSymbols3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTypeOptions: fn(
            self: *const IDebugSymbols3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypeOptions: fn(
            self: *const IDebugSymbols3,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByOffsetWide: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByNameWide: fn(
            self: *const IDebugSymbols3,
            Symbol: ?[*:0]const u16,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearNameByOffsetWide: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Delta: i32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByOffsetWide: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Line: ?*u32,
            FileBuffer: ?[*:0]u16,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByLineWide: fn(
            self: *const IDebugSymbols3,
            Line: u32,
            File: ?[*:0]const u16,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleNameWide: fn(
            self: *const IDebugSymbols3,
            Name: ?[*:0]const u16,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolModuleWide: fn(
            self: *const IDebugSymbols3,
            Symbol: ?[*:0]const u16,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeNameWide: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeIdWide: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            Name: ?[*:0]const u16,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldOffsetWide: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            Field: ?[*:0]const u16,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeIdWide: fn(
            self: *const IDebugSymbols3,
            Symbol: ?[*:0]const u16,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeSymbolGroup2: fn(
            self: *const IDebugSymbols3,
            Flags: u32,
            Update: ?*IDebugSymbolGroup2,
            Symbols: ?*?*IDebugSymbolGroup2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSymbolGroup2: fn(
            self: *const IDebugSymbols3,
            Group: ?*?*IDebugSymbolGroup2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSymbolMatchWide: fn(
            self: *const IDebugSymbols3,
            Pattern: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSymbolMatchWide: fn(
            self: *const IDebugSymbols3,
            Handle: u64,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            MatchSize: ?*u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReloadWide: fn(
            self: *const IDebugSymbols3,
            Module: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolPathWide: fn(
            self: *const IDebugSymbols3,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolPathWide: fn(
            self: *const IDebugSymbols3,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSymbolPathWide: fn(
            self: *const IDebugSymbols3,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImagePathWide: fn(
            self: *const IDebugSymbols3,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImagePathWide: fn(
            self: *const IDebugSymbols3,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendImagePathWide: fn(
            self: *const IDebugSymbols3,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathWide: fn(
            self: *const IDebugSymbols3,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathElementWide: fn(
            self: *const IDebugSymbols3,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ElementSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePathWide: fn(
            self: *const IDebugSymbols3,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSourcePathWide: fn(
            self: *const IDebugSymbols3,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFileWide: fn(
            self: *const IDebugSymbols3,
            StartElement: u32,
            File: ?[*:0]const u16,
            Flags: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileLineOffsetsWide: fn(
            self: *const IDebugSymbols3,
            File: ?[*:0]const u16,
            Buffer: ?[*]u64,
            BufferLines: u32,
            FileLines: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleVersionInformationWide: fn(
            self: *const IDebugSymbols3,
            Index: u32,
            Base: u64,
            Item: ?[*:0]const u16,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            VerInfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNameStringWide: fn(
            self: *const IDebugSymbols3,
            Which: u32,
            Index: u32,
            Base: u64,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstantNameWide: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            Value: u64,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldNameWide: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            TypeId: u32,
            FieldIndex: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsManagedModule: fn(
            self: *const IDebugSymbols3,
            Index: u32,
            Base: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName2: fn(
            self: *const IDebugSymbols3,
            Name: ?[*:0]const u8,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName2Wide: fn(
            self: *const IDebugSymbols3,
            Name: ?[*:0]const u16,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByOffset2: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticModule: fn(
            self: *const IDebugSymbols3,
            Base: u64,
            Size: u32,
            ImagePath: ?[*:0]const u8,
            ModuleName: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticModuleWide: fn(
            self: *const IDebugSymbols3,
            Base: u64,
            Size: u32,
            ImagePath: ?[*:0]const u16,
            ModuleName: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSyntheticModule: fn(
            self: *const IDebugSymbols3,
            Base: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentScopeFrameIndex: fn(
            self: *const IDebugSymbols3,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFrameByIndex: fn(
            self: *const IDebugSymbols3,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFromJitDebugInfo: fn(
            self: *const IDebugSymbols3,
            OutputControl: u32,
            InfoOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFromStoredEvent: fn(
            self: *const IDebugSymbols3,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputSymbolByOffset: fn(
            self: *const IDebugSymbols3,
            OutputControl: u32,
            Flags: u32,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionEntryByOffset: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BufferNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldTypeAndOffset: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            ContainerTypeId: u32,
            Field: ?[*:0]const u8,
            FieldTypeId: ?*u32,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldTypeAndOffsetWide: fn(
            self: *const IDebugSymbols3,
            Module: u64,
            ContainerTypeId: u32,
            Field: ?[*:0]const u16,
            FieldTypeId: ?*u32,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticSymbol: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Size: u32,
            Name: ?[*:0]const u8,
            Flags: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticSymbolWide: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Size: u32,
            Name: ?[*:0]const u16,
            Flags: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSyntheticSymbol: fn(
            self: *const IDebugSymbols3,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByOffset: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            Displacements: ?[*]u64,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByName: fn(
            self: *const IDebugSymbols3,
            Symbol: ?[*:0]const u8,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByNameWide: fn(
            self: *const IDebugSymbols3,
            Symbol: ?[*:0]const u16,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryByToken: fn(
            self: *const IDebugSymbols3,
            ModuleBase: u64,
            Token: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryInformation: fn(
            self: *const IDebugSymbols3,
            Id: ?*DEBUG_MODULE_AND_ID,
            Info: ?*DEBUG_SYMBOL_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryString: fn(
            self: *const IDebugSymbols3,
            Id: ?*DEBUG_MODULE_AND_ID,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryStringWide: fn(
            self: *const IDebugSymbols3,
            Id: ?*DEBUG_MODULE_AND_ID,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryOffsetRegions: fn(
            self: *const IDebugSymbols3,
            Id: ?*DEBUG_MODULE_AND_ID,
            Flags: u32,
            Regions: ?[*]DEBUG_OFFSET_REGION,
            RegionsCount: u32,
            RegionsAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryBySymbolEntry: fn(
            self: *const IDebugSymbols3,
            FromId: ?*DEBUG_MODULE_AND_ID,
            Flags: u32,
            ToId: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByOffset: fn(
            self: *const IDebugSymbols3,
            Offset: u64,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByLine: fn(
            self: *const IDebugSymbols3,
            Line: u32,
            File: ?[*:0]const u8,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByLineWide: fn(
            self: *const IDebugSymbols3,
            Line: u32,
            File: ?[*:0]const u16,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryString: fn(
            self: *const IDebugSymbols3,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryStringWide: fn(
            self: *const IDebugSymbols3,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryOffsetRegions: fn(
            self: *const IDebugSymbols3,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Flags: u32,
            Regions: ?[*]DEBUG_OFFSET_REGION,
            RegionsCount: u32,
            RegionsAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryBySourceEntry: fn(
            self: *const IDebugSymbols3,
            FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Flags: u32,
            ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolOptions(@ptrCast(*const IDebugSymbols3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AddSymbolOptions(@ptrCast(*const IDebugSymbols3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).RemoveSymbolOptions(@ptrCast(*const IDebugSymbols3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetSymbolOptions(@ptrCast(*const IDebugSymbols3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetNameByOffset(@ptrCast(*const IDebugSymbols3, self), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetOffsetByName(@ptrCast(*const IDebugSymbols3, self), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetNearNameByOffset(@ptrCast(*const IDebugSymbols3, self), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetLineByOffset(@ptrCast(*const IDebugSymbols3, self), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetOffsetByLine(@ptrCast(*const IDebugSymbols3, self), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetNumberModules(@ptrCast(*const IDebugSymbols3, self), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleByIndex(@ptrCast(*const IDebugSymbols3, self), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleByModuleName(@ptrCast(*const IDebugSymbols3, self), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleByOffset(@ptrCast(*const IDebugSymbols3, self), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleNames(@ptrCast(*const IDebugSymbols3, self), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleParameters(@ptrCast(*const IDebugSymbols3, self), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolModule(@ptrCast(*const IDebugSymbols3, self), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetTypeName(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetTypeId(@ptrCast(*const IDebugSymbols3, self), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetTypeSize(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetFieldOffset(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolTypeId(@ptrCast(*const IDebugSymbols3, self), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetOffsetTypeId(@ptrCast(*const IDebugSymbols3, self), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).ReadTypedDataVirtual(@ptrCast(*const IDebugSymbols3, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).WriteTypedDataVirtual(@ptrCast(*const IDebugSymbols3, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).OutputTypedDataVirtual(@ptrCast(*const IDebugSymbols3, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).ReadTypedDataPhysical(@ptrCast(*const IDebugSymbols3, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).WriteTypedDataPhysical(@ptrCast(*const IDebugSymbols3, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).OutputTypedDataPhysical(@ptrCast(*const IDebugSymbols3, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetScope(@ptrCast(*const IDebugSymbols3, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetScope(@ptrCast(*const IDebugSymbols3, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).ResetScope(@ptrCast(*const IDebugSymbols3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetScopeSymbolGroup(@ptrCast(*const IDebugSymbols3, self), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).CreateSymbolGroup(@ptrCast(*const IDebugSymbols3, self), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).StartSymbolMatch(@ptrCast(*const IDebugSymbols3, self), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetNextSymbolMatch(@ptrCast(*const IDebugSymbols3, self), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).EndSymbolMatch(@ptrCast(*const IDebugSymbols3, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_Reload(self: *const T, Module: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).Reload(@ptrCast(*const IDebugSymbols3, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolPath(@ptrCast(*const IDebugSymbols3, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetSymbolPath(@ptrCast(*const IDebugSymbols3, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AppendSymbolPath(@ptrCast(*const IDebugSymbols3, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetImagePath(@ptrCast(*const IDebugSymbols3, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetImagePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetImagePath(@ptrCast(*const IDebugSymbols3, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AppendImagePath(@ptrCast(*const IDebugSymbols3, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourcePath(@ptrCast(*const IDebugSymbols3, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourcePathElement(@ptrCast(*const IDebugSymbols3, self), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSourcePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetSourcePath(@ptrCast(*const IDebugSymbols3, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AppendSourcePath(@ptrCast(*const IDebugSymbols3, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).FindSourceFile(@ptrCast(*const IDebugSymbols3, self), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceFileLineOffsets(@ptrCast(*const IDebugSymbols3, self), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u8, Buffer: ?*c_void, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleVersionInformation(@ptrCast(*const IDebugSymbols3, self), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleNameString(@ptrCast(*const IDebugSymbols3, self), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetConstantName(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetFieldName(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetTypeOptions(@ptrCast(*const IDebugSymbols3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AddTypeOptions(@ptrCast(*const IDebugSymbols3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_RemoveTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).RemoveTypeOptions(@ptrCast(*const IDebugSymbols3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetTypeOptions(@ptrCast(*const IDebugSymbols3, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetNameByOffsetWide(@ptrCast(*const IDebugSymbols3, self), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetOffsetByNameWide(@ptrCast(*const IDebugSymbols3, self), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetNearNameByOffsetWide(@ptrCast(*const IDebugSymbols3, self), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetLineByOffsetWide(@ptrCast(*const IDebugSymbols3, self), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetOffsetByLineWide(@ptrCast(*const IDebugSymbols3, self), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleByModuleNameWide(@ptrCast(*const IDebugSymbols3, self), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]const u16, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolModuleWide(@ptrCast(*const IDebugSymbols3, self), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetTypeNameWide(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]const u16, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetTypeIdWide(@ptrCast(*const IDebugSymbols3, self), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u16, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetFieldOffsetWide(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]const u16, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolTypeIdWide(@ptrCast(*const IDebugSymbols3, self), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetScopeSymbolGroup2(@ptrCast(*const IDebugSymbols3, self), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).CreateSymbolGroup2(@ptrCast(*const IDebugSymbols3, self), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).StartSymbolMatchWide(@ptrCast(*const IDebugSymbols3, self), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetNextSymbolMatchWide(@ptrCast(*const IDebugSymbols3, self), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_ReloadWide(self: *const T, Module: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).ReloadWide(@ptrCast(*const IDebugSymbols3, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolPathWide(@ptrCast(*const IDebugSymbols3, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSymbolPathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetSymbolPathWide(@ptrCast(*const IDebugSymbols3, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AppendSymbolPathWide(@ptrCast(*const IDebugSymbols3, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetImagePathWide(@ptrCast(*const IDebugSymbols3, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetImagePathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetImagePathWide(@ptrCast(*const IDebugSymbols3, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendImagePathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AppendImagePathWide(@ptrCast(*const IDebugSymbols3, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourcePathWide(@ptrCast(*const IDebugSymbols3, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourcePathElementWide(@ptrCast(*const IDebugSymbols3, self), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetSourcePathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetSourcePathWide(@ptrCast(*const IDebugSymbols3, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AppendSourcePathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AppendSourcePathWide(@ptrCast(*const IDebugSymbols3, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).FindSourceFileWide(@ptrCast(*const IDebugSymbols3, self), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceFileLineOffsetsWide(@ptrCast(*const IDebugSymbols3, self), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u16, Buffer: ?*c_void, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleVersionInformationWide(@ptrCast(*const IDebugSymbols3, self), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleNameStringWide(@ptrCast(*const IDebugSymbols3, self), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetConstantNameWide(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetFieldNameWide(@ptrCast(*const IDebugSymbols3, self), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_IsManagedModule(self: *const T, Index: u32, Base: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).IsManagedModule(@ptrCast(*const IDebugSymbols3, self), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByModuleName2(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleByModuleName2(@ptrCast(*const IDebugSymbols3, self), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleByModuleName2Wide(@ptrCast(*const IDebugSymbols3, self), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetModuleByOffset2(@ptrCast(*const IDebugSymbols3, self), Offset, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u8, ModuleName: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AddSyntheticModule(@ptrCast(*const IDebugSymbols3, self), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u16, ModuleName: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AddSyntheticModuleWide(@ptrCast(*const IDebugSymbols3, self), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_RemoveSyntheticModule(self: *const T, Base: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).RemoveSyntheticModule(@ptrCast(*const IDebugSymbols3, self), Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetCurrentScopeFrameIndex(@ptrCast(*const IDebugSymbols3, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetScopeFrameByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetScopeFrameByIndex(@ptrCast(*const IDebugSymbols3, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetScopeFromJitDebugInfo(@ptrCast(*const IDebugSymbols3, self), OutputControl, InfoOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_SetScopeFromStoredEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).SetScopeFromStoredEvent(@ptrCast(*const IDebugSymbols3, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).OutputSymbolByOffset(@ptrCast(*const IDebugSymbols3, self), OutputControl, Flags, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*c_void, BufferSize: u32, BufferNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetFunctionEntryByOffset(@ptrCast(*const IDebugSymbols3, self), Offset, Flags, Buffer, BufferSize, BufferNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u8, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetFieldTypeAndOffset(@ptrCast(*const IDebugSymbols3, self), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u16, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetFieldTypeAndOffsetWide(@ptrCast(*const IDebugSymbols3, self), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AddSyntheticSymbol(@ptrCast(*const IDebugSymbols3, self), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).AddSyntheticSymbolWide(@ptrCast(*const IDebugSymbols3, self), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).RemoveSyntheticSymbol(@ptrCast(*const IDebugSymbols3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntriesByOffset(@ptrCast(*const IDebugSymbols3, self), Offset, Flags, Ids, Displacements, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntriesByName(@ptrCast(*const IDebugSymbols3, self), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntriesByNameWide(@ptrCast(*const IDebugSymbols3, self), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntryByToken(@ptrCast(*const IDebugSymbols3, self), ModuleBase, Token, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntryInformation(@ptrCast(*const IDebugSymbols3, self), Id, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntryString(@ptrCast(*const IDebugSymbols3, self), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntryStringWide(@ptrCast(*const IDebugSymbols3, self), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntryOffsetRegions(@ptrCast(*const IDebugSymbols3, self), Id, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSymbolEntryBySymbolEntry(@ptrCast(*const IDebugSymbols3, self), FromId, Flags, ToId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceEntriesByOffset(@ptrCast(*const IDebugSymbols3, self), Offset, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceEntriesByLine(@ptrCast(*const IDebugSymbols3, self), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceEntriesByLineWide(@ptrCast(*const IDebugSymbols3, self), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceEntryString(@ptrCast(*const IDebugSymbols3, self), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceEntryStringWide(@ptrCast(*const IDebugSymbols3, self), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceEntryOffsetRegions(@ptrCast(*const IDebugSymbols3, self), Entry, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols3_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols3.VTable, self.vtable).GetSourceEntryBySourceEntry(@ptrCast(*const IDebugSymbols3, self), FromEntry, Flags, ToEntry);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols4_Value = @import("../../zig.zig").Guid.initString("e391bbd8-9d8c-4418-840b-c006592a1752");
pub const IID_IDebugSymbols4 = &IID_IDebugSymbols4_Value;
pub const IDebugSymbols4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: fn(
            self: *const IDebugSymbols4,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSymbolOptions: fn(
            self: *const IDebugSymbols4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolOptions: fn(
            self: *const IDebugSymbols4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolOptions: fn(
            self: *const IDebugSymbols4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByOffset: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByName: fn(
            self: *const IDebugSymbols4,
            Symbol: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearNameByOffset: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Delta: i32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByOffset: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Line: ?*u32,
            FileBuffer: ?[*:0]u8,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByLine: fn(
            self: *const IDebugSymbols4,
            Line: u32,
            File: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberModules: fn(
            self: *const IDebugSymbols4,
            Loaded: ?*u32,
            Unloaded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByIndex: fn(
            self: *const IDebugSymbols4,
            Index: u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName: fn(
            self: *const IDebugSymbols4,
            Name: ?[*:0]const u8,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByOffset: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNames: fn(
            self: *const IDebugSymbols4,
            Index: u32,
            Base: u64,
            ImageNameBuffer: ?[*:0]u8,
            ImageNameBufferSize: u32,
            ImageNameSize: ?*u32,
            ModuleNameBuffer: ?[*:0]u8,
            ModuleNameBufferSize: u32,
            ModuleNameSize: ?*u32,
            LoadedImageNameBuffer: ?[*:0]u8,
            LoadedImageNameBufferSize: u32,
            LoadedImageNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleParameters: fn(
            self: *const IDebugSymbols4,
            Count: u32,
            Bases: ?[*]u64,
            Start: u32,
            Params: [*]DEBUG_MODULE_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolModule: fn(
            self: *const IDebugSymbols4,
            Symbol: ?[*:0]const u8,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeName: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeId: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            Name: ?[*:0]const u8,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeSize: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldOffset: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            Field: ?[*:0]const u8,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeId: fn(
            self: *const IDebugSymbols4,
            Symbol: ?[*:0]const u8,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetTypeId: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataVirtual: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataVirtual: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataVirtual: fn(
            self: *const IDebugSymbols4,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataPhysical: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataPhysical: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataPhysical: fn(
            self: *const IDebugSymbols4,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScope: fn(
            self: *const IDebugSymbols4,
            InstructionOffset: ?*u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScope: fn(
            self: *const IDebugSymbols4,
            InstructionOffset: u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetScope: fn(
            self: *const IDebugSymbols4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeSymbolGroup: fn(
            self: *const IDebugSymbols4,
            Flags: u32,
            Update: ?*IDebugSymbolGroup,
            Symbols: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSymbolGroup: fn(
            self: *const IDebugSymbols4,
            Group: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSymbolMatch: fn(
            self: *const IDebugSymbols4,
            Pattern: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSymbolMatch: fn(
            self: *const IDebugSymbols4,
            Handle: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MatchSize: ?*u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSymbolMatch: fn(
            self: *const IDebugSymbols4,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reload: fn(
            self: *const IDebugSymbols4,
            Module: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolPath: fn(
            self: *const IDebugSymbols4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolPath: fn(
            self: *const IDebugSymbols4,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSymbolPath: fn(
            self: *const IDebugSymbols4,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImagePath: fn(
            self: *const IDebugSymbols4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImagePath: fn(
            self: *const IDebugSymbols4,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendImagePath: fn(
            self: *const IDebugSymbols4,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePath: fn(
            self: *const IDebugSymbols4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathElement: fn(
            self: *const IDebugSymbols4,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ElementSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePath: fn(
            self: *const IDebugSymbols4,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSourcePath: fn(
            self: *const IDebugSymbols4,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFile: fn(
            self: *const IDebugSymbols4,
            StartElement: u32,
            File: ?[*:0]const u8,
            Flags: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileLineOffsets: fn(
            self: *const IDebugSymbols4,
            File: ?[*:0]const u8,
            Buffer: ?[*]u64,
            BufferLines: u32,
            FileLines: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleVersionInformation: fn(
            self: *const IDebugSymbols4,
            Index: u32,
            Base: u64,
            Item: ?[*:0]const u8,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            VerInfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNameString: fn(
            self: *const IDebugSymbols4,
            Which: u32,
            Index: u32,
            Base: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstantName: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            Value: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldName: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            FieldIndex: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeOptions: fn(
            self: *const IDebugSymbols4,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTypeOptions: fn(
            self: *const IDebugSymbols4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTypeOptions: fn(
            self: *const IDebugSymbols4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypeOptions: fn(
            self: *const IDebugSymbols4,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByOffsetWide: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByNameWide: fn(
            self: *const IDebugSymbols4,
            Symbol: ?[*:0]const u16,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearNameByOffsetWide: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Delta: i32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByOffsetWide: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Line: ?*u32,
            FileBuffer: ?[*:0]u16,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByLineWide: fn(
            self: *const IDebugSymbols4,
            Line: u32,
            File: ?[*:0]const u16,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleNameWide: fn(
            self: *const IDebugSymbols4,
            Name: ?[*:0]const u16,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolModuleWide: fn(
            self: *const IDebugSymbols4,
            Symbol: ?[*:0]const u16,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeNameWide: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeIdWide: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            Name: ?[*:0]const u16,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldOffsetWide: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            Field: ?[*:0]const u16,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeIdWide: fn(
            self: *const IDebugSymbols4,
            Symbol: ?[*:0]const u16,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeSymbolGroup2: fn(
            self: *const IDebugSymbols4,
            Flags: u32,
            Update: ?*IDebugSymbolGroup2,
            Symbols: ?*?*IDebugSymbolGroup2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSymbolGroup2: fn(
            self: *const IDebugSymbols4,
            Group: ?*?*IDebugSymbolGroup2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSymbolMatchWide: fn(
            self: *const IDebugSymbols4,
            Pattern: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSymbolMatchWide: fn(
            self: *const IDebugSymbols4,
            Handle: u64,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            MatchSize: ?*u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReloadWide: fn(
            self: *const IDebugSymbols4,
            Module: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolPathWide: fn(
            self: *const IDebugSymbols4,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolPathWide: fn(
            self: *const IDebugSymbols4,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSymbolPathWide: fn(
            self: *const IDebugSymbols4,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImagePathWide: fn(
            self: *const IDebugSymbols4,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImagePathWide: fn(
            self: *const IDebugSymbols4,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendImagePathWide: fn(
            self: *const IDebugSymbols4,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathWide: fn(
            self: *const IDebugSymbols4,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathElementWide: fn(
            self: *const IDebugSymbols4,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ElementSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePathWide: fn(
            self: *const IDebugSymbols4,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSourcePathWide: fn(
            self: *const IDebugSymbols4,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFileWide: fn(
            self: *const IDebugSymbols4,
            StartElement: u32,
            File: ?[*:0]const u16,
            Flags: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileLineOffsetsWide: fn(
            self: *const IDebugSymbols4,
            File: ?[*:0]const u16,
            Buffer: ?[*]u64,
            BufferLines: u32,
            FileLines: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleVersionInformationWide: fn(
            self: *const IDebugSymbols4,
            Index: u32,
            Base: u64,
            Item: ?[*:0]const u16,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            VerInfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNameStringWide: fn(
            self: *const IDebugSymbols4,
            Which: u32,
            Index: u32,
            Base: u64,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstantNameWide: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            Value: u64,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldNameWide: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            TypeId: u32,
            FieldIndex: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsManagedModule: fn(
            self: *const IDebugSymbols4,
            Index: u32,
            Base: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName2: fn(
            self: *const IDebugSymbols4,
            Name: ?[*:0]const u8,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName2Wide: fn(
            self: *const IDebugSymbols4,
            Name: ?[*:0]const u16,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByOffset2: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticModule: fn(
            self: *const IDebugSymbols4,
            Base: u64,
            Size: u32,
            ImagePath: ?[*:0]const u8,
            ModuleName: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticModuleWide: fn(
            self: *const IDebugSymbols4,
            Base: u64,
            Size: u32,
            ImagePath: ?[*:0]const u16,
            ModuleName: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSyntheticModule: fn(
            self: *const IDebugSymbols4,
            Base: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentScopeFrameIndex: fn(
            self: *const IDebugSymbols4,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFrameByIndex: fn(
            self: *const IDebugSymbols4,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFromJitDebugInfo: fn(
            self: *const IDebugSymbols4,
            OutputControl: u32,
            InfoOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFromStoredEvent: fn(
            self: *const IDebugSymbols4,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputSymbolByOffset: fn(
            self: *const IDebugSymbols4,
            OutputControl: u32,
            Flags: u32,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionEntryByOffset: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BufferNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldTypeAndOffset: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            ContainerTypeId: u32,
            Field: ?[*:0]const u8,
            FieldTypeId: ?*u32,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldTypeAndOffsetWide: fn(
            self: *const IDebugSymbols4,
            Module: u64,
            ContainerTypeId: u32,
            Field: ?[*:0]const u16,
            FieldTypeId: ?*u32,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticSymbol: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Size: u32,
            Name: ?[*:0]const u8,
            Flags: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticSymbolWide: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Size: u32,
            Name: ?[*:0]const u16,
            Flags: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSyntheticSymbol: fn(
            self: *const IDebugSymbols4,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByOffset: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            Displacements: ?[*]u64,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByName: fn(
            self: *const IDebugSymbols4,
            Symbol: ?[*:0]const u8,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByNameWide: fn(
            self: *const IDebugSymbols4,
            Symbol: ?[*:0]const u16,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryByToken: fn(
            self: *const IDebugSymbols4,
            ModuleBase: u64,
            Token: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryInformation: fn(
            self: *const IDebugSymbols4,
            Id: ?*DEBUG_MODULE_AND_ID,
            Info: ?*DEBUG_SYMBOL_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryString: fn(
            self: *const IDebugSymbols4,
            Id: ?*DEBUG_MODULE_AND_ID,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryStringWide: fn(
            self: *const IDebugSymbols4,
            Id: ?*DEBUG_MODULE_AND_ID,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryOffsetRegions: fn(
            self: *const IDebugSymbols4,
            Id: ?*DEBUG_MODULE_AND_ID,
            Flags: u32,
            Regions: ?[*]DEBUG_OFFSET_REGION,
            RegionsCount: u32,
            RegionsAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryBySymbolEntry: fn(
            self: *const IDebugSymbols4,
            FromId: ?*DEBUG_MODULE_AND_ID,
            Flags: u32,
            ToId: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByOffset: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByLine: fn(
            self: *const IDebugSymbols4,
            Line: u32,
            File: ?[*:0]const u8,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByLineWide: fn(
            self: *const IDebugSymbols4,
            Line: u32,
            File: ?[*:0]const u16,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryString: fn(
            self: *const IDebugSymbols4,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryStringWide: fn(
            self: *const IDebugSymbols4,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryOffsetRegions: fn(
            self: *const IDebugSymbols4,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Flags: u32,
            Regions: ?[*]DEBUG_OFFSET_REGION,
            RegionsCount: u32,
            RegionsAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryBySourceEntry: fn(
            self: *const IDebugSymbols4,
            FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Flags: u32,
            ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeEx: fn(
            self: *const IDebugSymbols4,
            InstructionOffset: ?*u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeEx: fn(
            self: *const IDebugSymbols4,
            InstructionOffset: u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByInlineContext: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            InlineContext: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByInlineContextWide: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            InlineContext: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByInlineContext: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            InlineContext: u32,
            Line: ?*u32,
            FileBuffer: ?[*:0]u8,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByInlineContextWide: fn(
            self: *const IDebugSymbols4,
            Offset: u64,
            InlineContext: u32,
            Line: ?*u32,
            FileBuffer: ?[*:0]u16,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputSymbolByInlineContext: fn(
            self: *const IDebugSymbols4,
            OutputControl: u32,
            Flags: u32,
            Offset: u64,
            InlineContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolOptions(@ptrCast(*const IDebugSymbols4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AddSymbolOptions(@ptrCast(*const IDebugSymbols4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).RemoveSymbolOptions(@ptrCast(*const IDebugSymbols4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetSymbolOptions(@ptrCast(*const IDebugSymbols4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNameByOffset(@ptrCast(*const IDebugSymbols4, self), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetOffsetByName(@ptrCast(*const IDebugSymbols4, self), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNearNameByOffset(@ptrCast(*const IDebugSymbols4, self), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetLineByOffset(@ptrCast(*const IDebugSymbols4, self), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetOffsetByLine(@ptrCast(*const IDebugSymbols4, self), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNumberModules(@ptrCast(*const IDebugSymbols4, self), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleByIndex(@ptrCast(*const IDebugSymbols4, self), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleByModuleName(@ptrCast(*const IDebugSymbols4, self), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleByOffset(@ptrCast(*const IDebugSymbols4, self), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleNames(@ptrCast(*const IDebugSymbols4, self), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleParameters(@ptrCast(*const IDebugSymbols4, self), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolModule(@ptrCast(*const IDebugSymbols4, self), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetTypeName(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetTypeId(@ptrCast(*const IDebugSymbols4, self), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetTypeSize(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetFieldOffset(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolTypeId(@ptrCast(*const IDebugSymbols4, self), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetOffsetTypeId(@ptrCast(*const IDebugSymbols4, self), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).ReadTypedDataVirtual(@ptrCast(*const IDebugSymbols4, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).WriteTypedDataVirtual(@ptrCast(*const IDebugSymbols4, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).OutputTypedDataVirtual(@ptrCast(*const IDebugSymbols4, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).ReadTypedDataPhysical(@ptrCast(*const IDebugSymbols4, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).WriteTypedDataPhysical(@ptrCast(*const IDebugSymbols4, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).OutputTypedDataPhysical(@ptrCast(*const IDebugSymbols4, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetScope(@ptrCast(*const IDebugSymbols4, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetScope(@ptrCast(*const IDebugSymbols4, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).ResetScope(@ptrCast(*const IDebugSymbols4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetScopeSymbolGroup(@ptrCast(*const IDebugSymbols4, self), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).CreateSymbolGroup(@ptrCast(*const IDebugSymbols4, self), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).StartSymbolMatch(@ptrCast(*const IDebugSymbols4, self), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNextSymbolMatch(@ptrCast(*const IDebugSymbols4, self), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).EndSymbolMatch(@ptrCast(*const IDebugSymbols4, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_Reload(self: *const T, Module: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).Reload(@ptrCast(*const IDebugSymbols4, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolPath(@ptrCast(*const IDebugSymbols4, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetSymbolPath(@ptrCast(*const IDebugSymbols4, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AppendSymbolPath(@ptrCast(*const IDebugSymbols4, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetImagePath(@ptrCast(*const IDebugSymbols4, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetImagePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetImagePath(@ptrCast(*const IDebugSymbols4, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AppendImagePath(@ptrCast(*const IDebugSymbols4, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourcePath(@ptrCast(*const IDebugSymbols4, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourcePathElement(@ptrCast(*const IDebugSymbols4, self), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSourcePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetSourcePath(@ptrCast(*const IDebugSymbols4, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AppendSourcePath(@ptrCast(*const IDebugSymbols4, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).FindSourceFile(@ptrCast(*const IDebugSymbols4, self), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceFileLineOffsets(@ptrCast(*const IDebugSymbols4, self), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u8, Buffer: ?*c_void, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleVersionInformation(@ptrCast(*const IDebugSymbols4, self), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleNameString(@ptrCast(*const IDebugSymbols4, self), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetConstantName(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetFieldName(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetTypeOptions(@ptrCast(*const IDebugSymbols4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AddTypeOptions(@ptrCast(*const IDebugSymbols4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_RemoveTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).RemoveTypeOptions(@ptrCast(*const IDebugSymbols4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetTypeOptions(@ptrCast(*const IDebugSymbols4, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNameByOffsetWide(@ptrCast(*const IDebugSymbols4, self), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetOffsetByNameWide(@ptrCast(*const IDebugSymbols4, self), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNearNameByOffsetWide(@ptrCast(*const IDebugSymbols4, self), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetLineByOffsetWide(@ptrCast(*const IDebugSymbols4, self), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetOffsetByLineWide(@ptrCast(*const IDebugSymbols4, self), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleByModuleNameWide(@ptrCast(*const IDebugSymbols4, self), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]const u16, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolModuleWide(@ptrCast(*const IDebugSymbols4, self), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetTypeNameWide(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]const u16, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetTypeIdWide(@ptrCast(*const IDebugSymbols4, self), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u16, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetFieldOffsetWide(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]const u16, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolTypeIdWide(@ptrCast(*const IDebugSymbols4, self), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetScopeSymbolGroup2(@ptrCast(*const IDebugSymbols4, self), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).CreateSymbolGroup2(@ptrCast(*const IDebugSymbols4, self), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).StartSymbolMatchWide(@ptrCast(*const IDebugSymbols4, self), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNextSymbolMatchWide(@ptrCast(*const IDebugSymbols4, self), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_ReloadWide(self: *const T, Module: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).ReloadWide(@ptrCast(*const IDebugSymbols4, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolPathWide(@ptrCast(*const IDebugSymbols4, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSymbolPathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetSymbolPathWide(@ptrCast(*const IDebugSymbols4, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AppendSymbolPathWide(@ptrCast(*const IDebugSymbols4, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetImagePathWide(@ptrCast(*const IDebugSymbols4, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetImagePathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetImagePathWide(@ptrCast(*const IDebugSymbols4, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendImagePathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AppendImagePathWide(@ptrCast(*const IDebugSymbols4, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourcePathWide(@ptrCast(*const IDebugSymbols4, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourcePathElementWide(@ptrCast(*const IDebugSymbols4, self), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetSourcePathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetSourcePathWide(@ptrCast(*const IDebugSymbols4, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AppendSourcePathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AppendSourcePathWide(@ptrCast(*const IDebugSymbols4, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).FindSourceFileWide(@ptrCast(*const IDebugSymbols4, self), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceFileLineOffsetsWide(@ptrCast(*const IDebugSymbols4, self), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u16, Buffer: ?*c_void, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleVersionInformationWide(@ptrCast(*const IDebugSymbols4, self), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleNameStringWide(@ptrCast(*const IDebugSymbols4, self), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetConstantNameWide(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetFieldNameWide(@ptrCast(*const IDebugSymbols4, self), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_IsManagedModule(self: *const T, Index: u32, Base: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).IsManagedModule(@ptrCast(*const IDebugSymbols4, self), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByModuleName2(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleByModuleName2(@ptrCast(*const IDebugSymbols4, self), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleByModuleName2Wide(@ptrCast(*const IDebugSymbols4, self), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetModuleByOffset2(@ptrCast(*const IDebugSymbols4, self), Offset, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u8, ModuleName: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AddSyntheticModule(@ptrCast(*const IDebugSymbols4, self), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u16, ModuleName: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AddSyntheticModuleWide(@ptrCast(*const IDebugSymbols4, self), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_RemoveSyntheticModule(self: *const T, Base: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).RemoveSyntheticModule(@ptrCast(*const IDebugSymbols4, self), Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetCurrentScopeFrameIndex(@ptrCast(*const IDebugSymbols4, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScopeFrameByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetScopeFrameByIndex(@ptrCast(*const IDebugSymbols4, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetScopeFromJitDebugInfo(@ptrCast(*const IDebugSymbols4, self), OutputControl, InfoOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScopeFromStoredEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetScopeFromStoredEvent(@ptrCast(*const IDebugSymbols4, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).OutputSymbolByOffset(@ptrCast(*const IDebugSymbols4, self), OutputControl, Flags, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*c_void, BufferSize: u32, BufferNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetFunctionEntryByOffset(@ptrCast(*const IDebugSymbols4, self), Offset, Flags, Buffer, BufferSize, BufferNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u8, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetFieldTypeAndOffset(@ptrCast(*const IDebugSymbols4, self), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u16, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetFieldTypeAndOffsetWide(@ptrCast(*const IDebugSymbols4, self), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AddSyntheticSymbol(@ptrCast(*const IDebugSymbols4, self), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).AddSyntheticSymbolWide(@ptrCast(*const IDebugSymbols4, self), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).RemoveSyntheticSymbol(@ptrCast(*const IDebugSymbols4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntriesByOffset(@ptrCast(*const IDebugSymbols4, self), Offset, Flags, Ids, Displacements, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntriesByName(@ptrCast(*const IDebugSymbols4, self), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntriesByNameWide(@ptrCast(*const IDebugSymbols4, self), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntryByToken(@ptrCast(*const IDebugSymbols4, self), ModuleBase, Token, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntryInformation(@ptrCast(*const IDebugSymbols4, self), Id, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntryString(@ptrCast(*const IDebugSymbols4, self), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntryStringWide(@ptrCast(*const IDebugSymbols4, self), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntryOffsetRegions(@ptrCast(*const IDebugSymbols4, self), Id, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSymbolEntryBySymbolEntry(@ptrCast(*const IDebugSymbols4, self), FromId, Flags, ToId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceEntriesByOffset(@ptrCast(*const IDebugSymbols4, self), Offset, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceEntriesByLine(@ptrCast(*const IDebugSymbols4, self), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceEntriesByLineWide(@ptrCast(*const IDebugSymbols4, self), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceEntryString(@ptrCast(*const IDebugSymbols4, self), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceEntryStringWide(@ptrCast(*const IDebugSymbols4, self), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceEntryOffsetRegions(@ptrCast(*const IDebugSymbols4, self), Entry, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetSourceEntryBySourceEntry(@ptrCast(*const IDebugSymbols4, self), FromEntry, Flags, ToEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetScopeEx(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetScopeEx(@ptrCast(*const IDebugSymbols4, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_SetScopeEx(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).SetScopeEx(@ptrCast(*const IDebugSymbols4, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNameByInlineContext(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNameByInlineContext(@ptrCast(*const IDebugSymbols4, self), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetNameByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetNameByInlineContextWide(@ptrCast(*const IDebugSymbols4, self), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetLineByInlineContext(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetLineByInlineContext(@ptrCast(*const IDebugSymbols4, self), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_GetLineByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).GetLineByInlineContextWide(@ptrCast(*const IDebugSymbols4, self), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols4_OutputSymbolByInlineContext(self: *const T, OutputControl: u32, Flags: u32, Offset: u64, InlineContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols4.VTable, self.vtable).OutputSymbolByInlineContext(@ptrCast(*const IDebugSymbols4, self), OutputControl, Flags, Offset, InlineContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSymbols5_Value = @import("../../zig.zig").Guid.initString("c65fa83e-1e69-475e-8e0e-b5d79e9cc17e");
pub const IID_IDebugSymbols5 = &IID_IDebugSymbols5_Value;
pub const IDebugSymbols5 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetSymbolOptions: fn(
            self: *const IDebugSymbols5,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSymbolOptions: fn(
            self: *const IDebugSymbols5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSymbolOptions: fn(
            self: *const IDebugSymbols5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolOptions: fn(
            self: *const IDebugSymbols5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByOffset: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByName: fn(
            self: *const IDebugSymbols5,
            Symbol: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearNameByOffset: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Delta: i32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByOffset: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Line: ?*u32,
            FileBuffer: ?[*:0]u8,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByLine: fn(
            self: *const IDebugSymbols5,
            Line: u32,
            File: ?[*:0]const u8,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberModules: fn(
            self: *const IDebugSymbols5,
            Loaded: ?*u32,
            Unloaded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByIndex: fn(
            self: *const IDebugSymbols5,
            Index: u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName: fn(
            self: *const IDebugSymbols5,
            Name: ?[*:0]const u8,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByOffset: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNames: fn(
            self: *const IDebugSymbols5,
            Index: u32,
            Base: u64,
            ImageNameBuffer: ?[*:0]u8,
            ImageNameBufferSize: u32,
            ImageNameSize: ?*u32,
            ModuleNameBuffer: ?[*:0]u8,
            ModuleNameBufferSize: u32,
            ModuleNameSize: ?*u32,
            LoadedImageNameBuffer: ?[*:0]u8,
            LoadedImageNameBufferSize: u32,
            LoadedImageNameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleParameters: fn(
            self: *const IDebugSymbols5,
            Count: u32,
            Bases: ?[*]u64,
            Start: u32,
            Params: [*]DEBUG_MODULE_PARAMETERS,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolModule: fn(
            self: *const IDebugSymbols5,
            Symbol: ?[*:0]const u8,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeName: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeId: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            Name: ?[*:0]const u8,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeSize: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            Size: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldOffset: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            Field: ?[*:0]const u8,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeId: fn(
            self: *const IDebugSymbols5,
            Symbol: ?[*:0]const u8,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetTypeId: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataVirtual: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataVirtual: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataVirtual: fn(
            self: *const IDebugSymbols5,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadTypedDataPhysical: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesRead: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteTypedDataPhysical: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            BytesWritten: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputTypedDataPhysical: fn(
            self: *const IDebugSymbols5,
            OutputControl: u32,
            Offset: u64,
            Module: u64,
            TypeId: u32,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScope: fn(
            self: *const IDebugSymbols5,
            InstructionOffset: ?*u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScope: fn(
            self: *const IDebugSymbols5,
            InstructionOffset: u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ResetScope: fn(
            self: *const IDebugSymbols5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeSymbolGroup: fn(
            self: *const IDebugSymbols5,
            Flags: u32,
            Update: ?*IDebugSymbolGroup,
            Symbols: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSymbolGroup: fn(
            self: *const IDebugSymbols5,
            Group: ?*?*IDebugSymbolGroup,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSymbolMatch: fn(
            self: *const IDebugSymbols5,
            Pattern: ?[*:0]const u8,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSymbolMatch: fn(
            self: *const IDebugSymbols5,
            Handle: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            MatchSize: ?*u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EndSymbolMatch: fn(
            self: *const IDebugSymbols5,
            Handle: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Reload: fn(
            self: *const IDebugSymbols5,
            Module: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolPath: fn(
            self: *const IDebugSymbols5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolPath: fn(
            self: *const IDebugSymbols5,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSymbolPath: fn(
            self: *const IDebugSymbols5,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImagePath: fn(
            self: *const IDebugSymbols5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImagePath: fn(
            self: *const IDebugSymbols5,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendImagePath: fn(
            self: *const IDebugSymbols5,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePath: fn(
            self: *const IDebugSymbols5,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathElement: fn(
            self: *const IDebugSymbols5,
            Index: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ElementSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePath: fn(
            self: *const IDebugSymbols5,
            Path: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSourcePath: fn(
            self: *const IDebugSymbols5,
            Addition: ?[*:0]const u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFile: fn(
            self: *const IDebugSymbols5,
            StartElement: u32,
            File: ?[*:0]const u8,
            Flags: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileLineOffsets: fn(
            self: *const IDebugSymbols5,
            File: ?[*:0]const u8,
            Buffer: ?[*]u64,
            BufferLines: u32,
            FileLines: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleVersionInformation: fn(
            self: *const IDebugSymbols5,
            Index: u32,
            Base: u64,
            Item: ?[*:0]const u8,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            VerInfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNameString: fn(
            self: *const IDebugSymbols5,
            Which: u32,
            Index: u32,
            Base: u64,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstantName: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            Value: u64,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldName: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            FieldIndex: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeOptions: fn(
            self: *const IDebugSymbols5,
            Options: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddTypeOptions: fn(
            self: *const IDebugSymbols5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveTypeOptions: fn(
            self: *const IDebugSymbols5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetTypeOptions: fn(
            self: *const IDebugSymbols5,
            Options: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByOffsetWide: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByNameWide: fn(
            self: *const IDebugSymbols5,
            Symbol: ?[*:0]const u16,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNearNameByOffsetWide: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Delta: i32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByOffsetWide: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Line: ?*u32,
            FileBuffer: ?[*:0]u16,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffsetByLineWide: fn(
            self: *const IDebugSymbols5,
            Line: u32,
            File: ?[*:0]const u16,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleNameWide: fn(
            self: *const IDebugSymbols5,
            Name: ?[*:0]const u16,
            StartIndex: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolModuleWide: fn(
            self: *const IDebugSymbols5,
            Symbol: ?[*:0]const u16,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeNameWide: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeIdWide: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            Name: ?[*:0]const u16,
            TypeId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldOffsetWide: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            Field: ?[*:0]const u16,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolTypeIdWide: fn(
            self: *const IDebugSymbols5,
            Symbol: ?[*:0]const u16,
            TypeId: ?*u32,
            Module: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeSymbolGroup2: fn(
            self: *const IDebugSymbols5,
            Flags: u32,
            Update: ?*IDebugSymbolGroup2,
            Symbols: ?*?*IDebugSymbolGroup2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSymbolGroup2: fn(
            self: *const IDebugSymbols5,
            Group: ?*?*IDebugSymbolGroup2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartSymbolMatchWide: fn(
            self: *const IDebugSymbols5,
            Pattern: ?[*:0]const u16,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNextSymbolMatchWide: fn(
            self: *const IDebugSymbols5,
            Handle: u64,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            MatchSize: ?*u32,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReloadWide: fn(
            self: *const IDebugSymbols5,
            Module: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolPathWide: fn(
            self: *const IDebugSymbols5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSymbolPathWide: fn(
            self: *const IDebugSymbols5,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSymbolPathWide: fn(
            self: *const IDebugSymbols5,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImagePathWide: fn(
            self: *const IDebugSymbols5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImagePathWide: fn(
            self: *const IDebugSymbols5,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendImagePathWide: fn(
            self: *const IDebugSymbols5,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathWide: fn(
            self: *const IDebugSymbols5,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            PathSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourcePathElementWide: fn(
            self: *const IDebugSymbols5,
            Index: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ElementSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetSourcePathWide: fn(
            self: *const IDebugSymbols5,
            Path: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AppendSourcePathWide: fn(
            self: *const IDebugSymbols5,
            Addition: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSourceFileWide: fn(
            self: *const IDebugSymbols5,
            StartElement: u32,
            File: ?[*:0]const u16,
            Flags: u32,
            FoundElement: ?*u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            FoundSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceFileLineOffsetsWide: fn(
            self: *const IDebugSymbols5,
            File: ?[*:0]const u16,
            Buffer: ?[*]u64,
            BufferLines: u32,
            FileLines: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleVersionInformationWide: fn(
            self: *const IDebugSymbols5,
            Index: u32,
            Base: u64,
            Item: ?[*:0]const u16,
            // TODO: what to do with BytesParamIndex 4?
            Buffer: ?*c_void,
            BufferSize: u32,
            VerInfoSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleNameStringWide: fn(
            self: *const IDebugSymbols5,
            Which: u32,
            Index: u32,
            Base: u64,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConstantNameWide: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            Value: u64,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldNameWide: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            TypeId: u32,
            FieldIndex: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsManagedModule: fn(
            self: *const IDebugSymbols5,
            Index: u32,
            Base: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName2: fn(
            self: *const IDebugSymbols5,
            Name: ?[*:0]const u8,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByModuleName2Wide: fn(
            self: *const IDebugSymbols5,
            Name: ?[*:0]const u16,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModuleByOffset2: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            StartIndex: u32,
            Flags: u32,
            Index: ?*u32,
            Base: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticModule: fn(
            self: *const IDebugSymbols5,
            Base: u64,
            Size: u32,
            ImagePath: ?[*:0]const u8,
            ModuleName: ?[*:0]const u8,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticModuleWide: fn(
            self: *const IDebugSymbols5,
            Base: u64,
            Size: u32,
            ImagePath: ?[*:0]const u16,
            ModuleName: ?[*:0]const u16,
            Flags: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSyntheticModule: fn(
            self: *const IDebugSymbols5,
            Base: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentScopeFrameIndex: fn(
            self: *const IDebugSymbols5,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFrameByIndex: fn(
            self: *const IDebugSymbols5,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFromJitDebugInfo: fn(
            self: *const IDebugSymbols5,
            OutputControl: u32,
            InfoOffset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFromStoredEvent: fn(
            self: *const IDebugSymbols5,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputSymbolByOffset: fn(
            self: *const IDebugSymbols5,
            OutputControl: u32,
            Flags: u32,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionEntryByOffset: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Flags: u32,
            // TODO: what to do with BytesParamIndex 3?
            Buffer: ?*c_void,
            BufferSize: u32,
            BufferNeeded: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldTypeAndOffset: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            ContainerTypeId: u32,
            Field: ?[*:0]const u8,
            FieldTypeId: ?*u32,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFieldTypeAndOffsetWide: fn(
            self: *const IDebugSymbols5,
            Module: u64,
            ContainerTypeId: u32,
            Field: ?[*:0]const u16,
            FieldTypeId: ?*u32,
            Offset: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticSymbol: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Size: u32,
            Name: ?[*:0]const u8,
            Flags: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddSyntheticSymbolWide: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Size: u32,
            Name: ?[*:0]const u16,
            Flags: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveSyntheticSymbol: fn(
            self: *const IDebugSymbols5,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByOffset: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            Displacements: ?[*]u64,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByName: fn(
            self: *const IDebugSymbols5,
            Symbol: ?[*:0]const u8,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntriesByNameWide: fn(
            self: *const IDebugSymbols5,
            Symbol: ?[*:0]const u16,
            Flags: u32,
            Ids: ?[*]DEBUG_MODULE_AND_ID,
            IdsCount: u32,
            Entries: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryByToken: fn(
            self: *const IDebugSymbols5,
            ModuleBase: u64,
            Token: u32,
            Id: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryInformation: fn(
            self: *const IDebugSymbols5,
            Id: ?*DEBUG_MODULE_AND_ID,
            Info: ?*DEBUG_SYMBOL_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryString: fn(
            self: *const IDebugSymbols5,
            Id: ?*DEBUG_MODULE_AND_ID,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryStringWide: fn(
            self: *const IDebugSymbols5,
            Id: ?*DEBUG_MODULE_AND_ID,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryOffsetRegions: fn(
            self: *const IDebugSymbols5,
            Id: ?*DEBUG_MODULE_AND_ID,
            Flags: u32,
            Regions: ?[*]DEBUG_OFFSET_REGION,
            RegionsCount: u32,
            RegionsAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolEntryBySymbolEntry: fn(
            self: *const IDebugSymbols5,
            FromId: ?*DEBUG_MODULE_AND_ID,
            Flags: u32,
            ToId: ?*DEBUG_MODULE_AND_ID,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByOffset: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByLine: fn(
            self: *const IDebugSymbols5,
            Line: u32,
            File: ?[*:0]const u8,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntriesByLineWide: fn(
            self: *const IDebugSymbols5,
            Line: u32,
            File: ?[*:0]const u16,
            Flags: u32,
            Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY,
            EntriesCount: u32,
            EntriesAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryString: fn(
            self: *const IDebugSymbols5,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Which: u32,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryStringWide: fn(
            self: *const IDebugSymbols5,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Which: u32,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            StringSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryOffsetRegions: fn(
            self: *const IDebugSymbols5,
            Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Flags: u32,
            Regions: ?[*]DEBUG_OFFSET_REGION,
            RegionsCount: u32,
            RegionsAvail: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSourceEntryBySourceEntry: fn(
            self: *const IDebugSymbols5,
            FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
            Flags: u32,
            ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetScopeEx: fn(
            self: *const IDebugSymbols5,
            InstructionOffset: ?*u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeEx: fn(
            self: *const IDebugSymbols5,
            InstructionOffset: u64,
            ScopeFrame: ?*DEBUG_STACK_FRAME_EX,
            // TODO: what to do with BytesParamIndex 3?
            ScopeContext: ?*c_void,
            ScopeContextSize: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByInlineContext: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            InlineContext: u32,
            NameBuffer: ?[*:0]u8,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNameByInlineContextWide: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            InlineContext: u32,
            NameBuffer: ?[*:0]u16,
            NameBufferSize: u32,
            NameSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByInlineContext: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            InlineContext: u32,
            Line: ?*u32,
            FileBuffer: ?[*:0]u8,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLineByInlineContextWide: fn(
            self: *const IDebugSymbols5,
            Offset: u64,
            InlineContext: u32,
            Line: ?*u32,
            FileBuffer: ?[*:0]u16,
            FileBufferSize: u32,
            FileSize: ?*u32,
            Displacement: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        OutputSymbolByInlineContext: fn(
            self: *const IDebugSymbols5,
            OutputControl: u32,
            Flags: u32,
            Offset: u64,
            InlineContext: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentScopeFrameIndexEx: fn(
            self: *const IDebugSymbols5,
            Flags: u32,
            Index: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetScopeFrameByIndexEx: fn(
            self: *const IDebugSymbols5,
            Flags: u32,
            Index: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolOptions(@ptrCast(*const IDebugSymbols5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AddSymbolOptions(@ptrCast(*const IDebugSymbols5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_RemoveSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).RemoveSymbolOptions(@ptrCast(*const IDebugSymbols5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSymbolOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetSymbolOptions(@ptrCast(*const IDebugSymbols5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNameByOffset(self: *const T, Offset: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNameByOffset(@ptrCast(*const IDebugSymbols5, self), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetByName(self: *const T, _param_Symbol: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetOffsetByName(@ptrCast(*const IDebugSymbols5, self), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNearNameByOffset(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNearNameByOffset(@ptrCast(*const IDebugSymbols5, self), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetLineByOffset(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetLineByOffset(@ptrCast(*const IDebugSymbols5, self), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetOffsetByLine(@ptrCast(*const IDebugSymbols5, self), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNumberModules(self: *const T, Loaded: ?*u32, Unloaded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNumberModules(@ptrCast(*const IDebugSymbols5, self), Loaded, Unloaded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByIndex(self: *const T, Index: u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleByIndex(@ptrCast(*const IDebugSymbols5, self), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByModuleName(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleByModuleName(@ptrCast(*const IDebugSymbols5, self), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByOffset(self: *const T, Offset: u64, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleByOffset(@ptrCast(*const IDebugSymbols5, self), Offset, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleNames(self: *const T, Index: u32, Base: u64, ImageNameBuffer: ?[*:0]u8, ImageNameBufferSize: u32, ImageNameSize: ?*u32, ModuleNameBuffer: ?[*:0]u8, ModuleNameBufferSize: u32, ModuleNameSize: ?*u32, LoadedImageNameBuffer: ?[*:0]u8, LoadedImageNameBufferSize: u32, LoadedImageNameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleNames(@ptrCast(*const IDebugSymbols5, self), Index, Base, ImageNameBuffer, ImageNameBufferSize, ImageNameSize, ModuleNameBuffer, ModuleNameBufferSize, ModuleNameSize, LoadedImageNameBuffer, LoadedImageNameBufferSize, LoadedImageNameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleParameters(self: *const T, Count: u32, Bases: ?[*]u64, Start: u32, Params: [*]DEBUG_MODULE_PARAMETERS) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleParameters(@ptrCast(*const IDebugSymbols5, self), Count, Bases, Start, Params);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolModule(self: *const T, _param_Symbol: ?[*:0]const u8, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolModule(@ptrCast(*const IDebugSymbols5, self), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeName(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetTypeName(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeId(self: *const T, Module: u64, Name: ?[*:0]const u8, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetTypeId(@ptrCast(*const IDebugSymbols5, self), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeSize(self: *const T, Module: u64, TypeId: u32, Size: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetTypeSize(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, Size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldOffset(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u8, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetFieldOffset(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolTypeId(self: *const T, _param_Symbol: ?[*:0]const u8, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolTypeId(@ptrCast(*const IDebugSymbols5, self), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetTypeId(self: *const T, Offset: u64, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetOffsetTypeId(@ptrCast(*const IDebugSymbols5, self), Offset, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_ReadTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).ReadTypedDataVirtual(@ptrCast(*const IDebugSymbols5, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_WriteTypedDataVirtual(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).WriteTypedDataVirtual(@ptrCast(*const IDebugSymbols5, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_OutputTypedDataVirtual(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).OutputTypedDataVirtual(@ptrCast(*const IDebugSymbols5, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_ReadTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesRead: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).ReadTypedDataPhysical(@ptrCast(*const IDebugSymbols5, self), Offset, Module, TypeId, Buffer, BufferSize, BytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_WriteTypedDataPhysical(self: *const T, Offset: u64, Module: u64, TypeId: u32, Buffer: ?*c_void, BufferSize: u32, BytesWritten: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).WriteTypedDataPhysical(@ptrCast(*const IDebugSymbols5, self), Offset, Module, TypeId, Buffer, BufferSize, BytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_OutputTypedDataPhysical(self: *const T, OutputControl: u32, Offset: u64, Module: u64, TypeId: u32, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).OutputTypedDataPhysical(@ptrCast(*const IDebugSymbols5, self), OutputControl, Offset, Module, TypeId, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetScope(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetScope(@ptrCast(*const IDebugSymbols5, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScope(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetScope(@ptrCast(*const IDebugSymbols5, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_ResetScope(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).ResetScope(@ptrCast(*const IDebugSymbols5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetScopeSymbolGroup(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup, Symbols: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetScopeSymbolGroup(@ptrCast(*const IDebugSymbols5, self), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_CreateSymbolGroup(self: *const T, Group: ?*?*IDebugSymbolGroup) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).CreateSymbolGroup(@ptrCast(*const IDebugSymbols5, self), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_StartSymbolMatch(self: *const T, Pattern: ?[*:0]const u8, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).StartSymbolMatch(@ptrCast(*const IDebugSymbols5, self), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNextSymbolMatch(self: *const T, Handle: u64, Buffer: ?[*:0]u8, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNextSymbolMatch(@ptrCast(*const IDebugSymbols5, self), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_EndSymbolMatch(self: *const T, Handle: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).EndSymbolMatch(@ptrCast(*const IDebugSymbols5, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_Reload(self: *const T, Module: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).Reload(@ptrCast(*const IDebugSymbols5, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolPath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolPath(@ptrCast(*const IDebugSymbols5, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSymbolPath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetSymbolPath(@ptrCast(*const IDebugSymbols5, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendSymbolPath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AppendSymbolPath(@ptrCast(*const IDebugSymbols5, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetImagePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetImagePath(@ptrCast(*const IDebugSymbols5, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetImagePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetImagePath(@ptrCast(*const IDebugSymbols5, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendImagePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AppendImagePath(@ptrCast(*const IDebugSymbols5, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourcePath(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourcePath(@ptrCast(*const IDebugSymbols5, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourcePathElement(self: *const T, Index: u32, Buffer: ?[*:0]u8, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourcePathElement(@ptrCast(*const IDebugSymbols5, self), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSourcePath(self: *const T, Path: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetSourcePath(@ptrCast(*const IDebugSymbols5, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendSourcePath(self: *const T, Addition: ?[*:0]const u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AppendSourcePath(@ptrCast(*const IDebugSymbols5, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_FindSourceFile(self: *const T, StartElement: u32, File: ?[*:0]const u8, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u8, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).FindSourceFile(@ptrCast(*const IDebugSymbols5, self), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceFileLineOffsets(self: *const T, File: ?[*:0]const u8, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceFileLineOffsets(@ptrCast(*const IDebugSymbols5, self), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleVersionInformation(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u8, Buffer: ?*c_void, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleVersionInformation(@ptrCast(*const IDebugSymbols5, self), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleNameString(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleNameString(@ptrCast(*const IDebugSymbols5, self), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetConstantName(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetConstantName(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldName(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetFieldName(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeOptions(self: *const T, Options: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetTypeOptions(@ptrCast(*const IDebugSymbols5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AddTypeOptions(@ptrCast(*const IDebugSymbols5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_RemoveTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).RemoveTypeOptions(@ptrCast(*const IDebugSymbols5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetTypeOptions(self: *const T, Options: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetTypeOptions(@ptrCast(*const IDebugSymbols5, self), Options);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNameByOffsetWide(self: *const T, Offset: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNameByOffsetWide(@ptrCast(*const IDebugSymbols5, self), Offset, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetOffsetByNameWide(@ptrCast(*const IDebugSymbols5, self), _param_Symbol, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNearNameByOffsetWide(self: *const T, Offset: u64, Delta: i32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNearNameByOffsetWide(@ptrCast(*const IDebugSymbols5, self), Offset, Delta, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetLineByOffsetWide(self: *const T, Offset: u64, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetLineByOffsetWide(@ptrCast(*const IDebugSymbols5, self), Offset, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetOffsetByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetOffsetByLineWide(@ptrCast(*const IDebugSymbols5, self), Line, File, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByModuleNameWide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleByModuleNameWide(@ptrCast(*const IDebugSymbols5, self), Name, StartIndex, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolModuleWide(self: *const T, _param_Symbol: ?[*:0]const u16, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolModuleWide(@ptrCast(*const IDebugSymbols5, self), _param_Symbol, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeNameWide(self: *const T, Module: u64, TypeId: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetTypeNameWide(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetTypeIdWide(self: *const T, Module: u64, Name: ?[*:0]const u16, TypeId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetTypeIdWide(@ptrCast(*const IDebugSymbols5, self), Module, Name, TypeId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldOffsetWide(self: *const T, Module: u64, TypeId: u32, Field: ?[*:0]const u16, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetFieldOffsetWide(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, Field, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolTypeIdWide(self: *const T, _param_Symbol: ?[*:0]const u16, TypeId: ?*u32, Module: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolTypeIdWide(@ptrCast(*const IDebugSymbols5, self), _param_Symbol, TypeId, Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetScopeSymbolGroup2(self: *const T, Flags: u32, Update: ?*IDebugSymbolGroup2, Symbols: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetScopeSymbolGroup2(@ptrCast(*const IDebugSymbols5, self), Flags, Update, Symbols);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_CreateSymbolGroup2(self: *const T, Group: ?*?*IDebugSymbolGroup2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).CreateSymbolGroup2(@ptrCast(*const IDebugSymbols5, self), Group);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_StartSymbolMatchWide(self: *const T, Pattern: ?[*:0]const u16, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).StartSymbolMatchWide(@ptrCast(*const IDebugSymbols5, self), Pattern, Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNextSymbolMatchWide(self: *const T, Handle: u64, Buffer: ?[*:0]u16, BufferSize: u32, MatchSize: ?*u32, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNextSymbolMatchWide(@ptrCast(*const IDebugSymbols5, self), Handle, Buffer, BufferSize, MatchSize, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_ReloadWide(self: *const T, Module: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).ReloadWide(@ptrCast(*const IDebugSymbols5, self), Module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolPathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolPathWide(@ptrCast(*const IDebugSymbols5, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSymbolPathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetSymbolPathWide(@ptrCast(*const IDebugSymbols5, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendSymbolPathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AppendSymbolPathWide(@ptrCast(*const IDebugSymbols5, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetImagePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetImagePathWide(@ptrCast(*const IDebugSymbols5, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetImagePathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetImagePathWide(@ptrCast(*const IDebugSymbols5, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendImagePathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AppendImagePathWide(@ptrCast(*const IDebugSymbols5, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourcePathWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, PathSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourcePathWide(@ptrCast(*const IDebugSymbols5, self), Buffer, BufferSize, PathSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourcePathElementWide(self: *const T, Index: u32, Buffer: ?[*:0]u16, BufferSize: u32, ElementSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourcePathElementWide(@ptrCast(*const IDebugSymbols5, self), Index, Buffer, BufferSize, ElementSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetSourcePathWide(self: *const T, Path: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetSourcePathWide(@ptrCast(*const IDebugSymbols5, self), Path);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AppendSourcePathWide(self: *const T, Addition: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AppendSourcePathWide(@ptrCast(*const IDebugSymbols5, self), Addition);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_FindSourceFileWide(self: *const T, StartElement: u32, File: ?[*:0]const u16, Flags: u32, FoundElement: ?*u32, Buffer: ?[*:0]u16, BufferSize: u32, FoundSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).FindSourceFileWide(@ptrCast(*const IDebugSymbols5, self), StartElement, File, Flags, FoundElement, Buffer, BufferSize, FoundSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceFileLineOffsetsWide(self: *const T, File: ?[*:0]const u16, Buffer: ?[*]u64, BufferLines: u32, FileLines: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceFileLineOffsetsWide(@ptrCast(*const IDebugSymbols5, self), File, Buffer, BufferLines, FileLines);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleVersionInformationWide(self: *const T, Index: u32, Base: u64, Item: ?[*:0]const u16, Buffer: ?*c_void, BufferSize: u32, VerInfoSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleVersionInformationWide(@ptrCast(*const IDebugSymbols5, self), Index, Base, Item, Buffer, BufferSize, VerInfoSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleNameStringWide(self: *const T, Which: u32, Index: u32, Base: u64, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleNameStringWide(@ptrCast(*const IDebugSymbols5, self), Which, Index, Base, Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetConstantNameWide(self: *const T, Module: u64, TypeId: u32, Value: u64, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetConstantNameWide(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, Value, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldNameWide(self: *const T, Module: u64, TypeId: u32, FieldIndex: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetFieldNameWide(@ptrCast(*const IDebugSymbols5, self), Module, TypeId, FieldIndex, NameBuffer, NameBufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_IsManagedModule(self: *const T, Index: u32, Base: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).IsManagedModule(@ptrCast(*const IDebugSymbols5, self), Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByModuleName2(self: *const T, Name: ?[*:0]const u8, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleByModuleName2(@ptrCast(*const IDebugSymbols5, self), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByModuleName2Wide(self: *const T, Name: ?[*:0]const u16, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleByModuleName2Wide(@ptrCast(*const IDebugSymbols5, self), Name, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetModuleByOffset2(self: *const T, Offset: u64, StartIndex: u32, Flags: u32, Index: ?*u32, Base: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetModuleByOffset2(@ptrCast(*const IDebugSymbols5, self), Offset, StartIndex, Flags, Index, Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSyntheticModule(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u8, ModuleName: ?[*:0]const u8, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AddSyntheticModule(@ptrCast(*const IDebugSymbols5, self), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSyntheticModuleWide(self: *const T, Base: u64, Size: u32, ImagePath: ?[*:0]const u16, ModuleName: ?[*:0]const u16, Flags: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AddSyntheticModuleWide(@ptrCast(*const IDebugSymbols5, self), Base, Size, ImagePath, ModuleName, Flags);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_RemoveSyntheticModule(self: *const T, Base: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).RemoveSyntheticModule(@ptrCast(*const IDebugSymbols5, self), Base);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetCurrentScopeFrameIndex(self: *const T, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetCurrentScopeFrameIndex(@ptrCast(*const IDebugSymbols5, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeFrameByIndex(self: *const T, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetScopeFrameByIndex(@ptrCast(*const IDebugSymbols5, self), Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeFromJitDebugInfo(self: *const T, OutputControl: u32, InfoOffset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetScopeFromJitDebugInfo(@ptrCast(*const IDebugSymbols5, self), OutputControl, InfoOffset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeFromStoredEvent(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetScopeFromStoredEvent(@ptrCast(*const IDebugSymbols5, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_OutputSymbolByOffset(self: *const T, OutputControl: u32, Flags: u32, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).OutputSymbolByOffset(@ptrCast(*const IDebugSymbols5, self), OutputControl, Flags, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFunctionEntryByOffset(self: *const T, Offset: u64, Flags: u32, Buffer: ?*c_void, BufferSize: u32, BufferNeeded: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetFunctionEntryByOffset(@ptrCast(*const IDebugSymbols5, self), Offset, Flags, Buffer, BufferSize, BufferNeeded);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldTypeAndOffset(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u8, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetFieldTypeAndOffset(@ptrCast(*const IDebugSymbols5, self), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetFieldTypeAndOffsetWide(self: *const T, Module: u64, ContainerTypeId: u32, Field: ?[*:0]const u16, FieldTypeId: ?*u32, Offset: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetFieldTypeAndOffsetWide(@ptrCast(*const IDebugSymbols5, self), Module, ContainerTypeId, Field, FieldTypeId, Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSyntheticSymbol(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u8, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AddSyntheticSymbol(@ptrCast(*const IDebugSymbols5, self), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_AddSyntheticSymbolWide(self: *const T, Offset: u64, Size: u32, Name: ?[*:0]const u16, Flags: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).AddSyntheticSymbolWide(@ptrCast(*const IDebugSymbols5, self), Offset, Size, Name, Flags, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_RemoveSyntheticSymbol(self: *const T, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).RemoveSyntheticSymbol(@ptrCast(*const IDebugSymbols5, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, Displacements: ?[*]u64, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntriesByOffset(@ptrCast(*const IDebugSymbols5, self), Offset, Flags, Ids, Displacements, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntriesByName(self: *const T, _param_Symbol: ?[*:0]const u8, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntriesByName(@ptrCast(*const IDebugSymbols5, self), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntriesByNameWide(self: *const T, _param_Symbol: ?[*:0]const u16, Flags: u32, Ids: ?[*]DEBUG_MODULE_AND_ID, IdsCount: u32, Entries: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntriesByNameWide(@ptrCast(*const IDebugSymbols5, self), _param_Symbol, Flags, Ids, IdsCount, Entries);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryByToken(self: *const T, ModuleBase: u64, Token: u32, Id: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntryByToken(@ptrCast(*const IDebugSymbols5, self), ModuleBase, Token, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryInformation(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Info: ?*DEBUG_SYMBOL_ENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntryInformation(@ptrCast(*const IDebugSymbols5, self), Id, Info);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryString(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntryString(@ptrCast(*const IDebugSymbols5, self), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryStringWide(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntryStringWide(@ptrCast(*const IDebugSymbols5, self), Id, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryOffsetRegions(self: *const T, Id: ?*DEBUG_MODULE_AND_ID, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntryOffsetRegions(@ptrCast(*const IDebugSymbols5, self), Id, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSymbolEntryBySymbolEntry(self: *const T, FromId: ?*DEBUG_MODULE_AND_ID, Flags: u32, ToId: ?*DEBUG_MODULE_AND_ID) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSymbolEntryBySymbolEntry(@ptrCast(*const IDebugSymbols5, self), FromId, Flags, ToId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntriesByOffset(self: *const T, Offset: u64, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceEntriesByOffset(@ptrCast(*const IDebugSymbols5, self), Offset, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntriesByLine(self: *const T, Line: u32, File: ?[*:0]const u8, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceEntriesByLine(@ptrCast(*const IDebugSymbols5, self), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntriesByLineWide(self: *const T, Line: u32, File: ?[*:0]const u16, Flags: u32, Entries: ?[*]DEBUG_SYMBOL_SOURCE_ENTRY, EntriesCount: u32, EntriesAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceEntriesByLineWide(@ptrCast(*const IDebugSymbols5, self), Line, File, Flags, Entries, EntriesCount, EntriesAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntryString(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u8, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceEntryString(@ptrCast(*const IDebugSymbols5, self), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntryStringWide(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Which: u32, Buffer: ?[*:0]u16, BufferSize: u32, StringSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceEntryStringWide(@ptrCast(*const IDebugSymbols5, self), Entry, Which, Buffer, BufferSize, StringSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntryOffsetRegions(self: *const T, Entry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, Regions: ?[*]DEBUG_OFFSET_REGION, RegionsCount: u32, RegionsAvail: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceEntryOffsetRegions(@ptrCast(*const IDebugSymbols5, self), Entry, Flags, Regions, RegionsCount, RegionsAvail);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetSourceEntryBySourceEntry(self: *const T, FromEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY, Flags: u32, ToEntry: ?*DEBUG_SYMBOL_SOURCE_ENTRY) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetSourceEntryBySourceEntry(@ptrCast(*const IDebugSymbols5, self), FromEntry, Flags, ToEntry);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetScopeEx(self: *const T, InstructionOffset: ?*u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetScopeEx(@ptrCast(*const IDebugSymbols5, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeEx(self: *const T, InstructionOffset: u64, ScopeFrame: ?*DEBUG_STACK_FRAME_EX, ScopeContext: ?*c_void, ScopeContextSize: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetScopeEx(@ptrCast(*const IDebugSymbols5, self), InstructionOffset, ScopeFrame, ScopeContext, ScopeContextSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNameByInlineContext(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u8, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNameByInlineContext(@ptrCast(*const IDebugSymbols5, self), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetNameByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, NameBuffer: ?[*:0]u16, NameBufferSize: u32, NameSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetNameByInlineContextWide(@ptrCast(*const IDebugSymbols5, self), Offset, InlineContext, NameBuffer, NameBufferSize, NameSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetLineByInlineContext(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u8, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetLineByInlineContext(@ptrCast(*const IDebugSymbols5, self), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetLineByInlineContextWide(self: *const T, Offset: u64, InlineContext: u32, Line: ?*u32, FileBuffer: ?[*:0]u16, FileBufferSize: u32, FileSize: ?*u32, Displacement: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetLineByInlineContextWide(@ptrCast(*const IDebugSymbols5, self), Offset, InlineContext, Line, FileBuffer, FileBufferSize, FileSize, Displacement);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_OutputSymbolByInlineContext(self: *const T, OutputControl: u32, Flags: u32, Offset: u64, InlineContext: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).OutputSymbolByInlineContext(@ptrCast(*const IDebugSymbols5, self), OutputControl, Flags, Offset, InlineContext);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_GetCurrentScopeFrameIndexEx(self: *const T, Flags: u32, Index: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).GetCurrentScopeFrameIndexEx(@ptrCast(*const IDebugSymbols5, self), Flags, Index);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSymbols5_SetScopeFrameByIndexEx(self: *const T, Flags: u32, Index: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSymbols5.VTable, self.vtable).SetScopeFrameByIndexEx(@ptrCast(*const IDebugSymbols5, self), Flags, Index);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects_Value = @import("../../zig.zig").Guid.initString("6b86fe2c-2c4f-4f0c-9da2-174311acc327");
pub const IID_IDebugSystemObjects = &IID_IDebugSystemObjects_Value;
pub const IDebugSystemObjects = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: fn(
            self: *const IDebugSystemObjects,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventProcess: fn(
            self: *const IDebugSystemObjects,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadId: fn(
            self: *const IDebugSystemObjects,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentThreadId: fn(
            self: *const IDebugSystemObjects,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessId: fn(
            self: *const IDebugSystemObjects,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentProcessId: fn(
            self: *const IDebugSystemObjects,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberThreads: fn(
            self: *const IDebugSystemObjects,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalNumberThreads: fn(
            self: *const IDebugSystemObjects,
            Total: ?*u32,
            LargestProcess: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdsByIndex: fn(
            self: *const IDebugSystemObjects,
            Start: u32,
            Count: u32,
            Ids: ?[*]u32,
            SysIds: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByProcessor: fn(
            self: *const IDebugSystemObjects,
            Processor: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadDataOffset: fn(
            self: *const IDebugSystemObjects,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByDataOffset: fn(
            self: *const IDebugSystemObjects,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadTeb: fn(
            self: *const IDebugSystemObjects,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByTeb: fn(
            self: *const IDebugSystemObjects,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadSystemId: fn(
            self: *const IDebugSystemObjects,
            SysId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdBySystemId: fn(
            self: *const IDebugSystemObjects,
            SysId: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadHandle: fn(
            self: *const IDebugSystemObjects,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByHandle: fn(
            self: *const IDebugSystemObjects,
            Handle: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcesses: fn(
            self: *const IDebugSystemObjects,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdsByIndex: fn(
            self: *const IDebugSystemObjects,
            Start: u32,
            Count: u32,
            Ids: ?[*]u32,
            SysIds: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessDataOffset: fn(
            self: *const IDebugSystemObjects,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByDataOffset: fn(
            self: *const IDebugSystemObjects,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessPeb: fn(
            self: *const IDebugSystemObjects,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByPeb: fn(
            self: *const IDebugSystemObjects,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessSystemId: fn(
            self: *const IDebugSystemObjects,
            SysId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdBySystemId: fn(
            self: *const IDebugSystemObjects,
            SysId: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessHandle: fn(
            self: *const IDebugSystemObjects,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByHandle: fn(
            self: *const IDebugSystemObjects,
            Handle: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessExecutableName: fn(
            self: *const IDebugSystemObjects,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ExeSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetEventThread(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetEventThread(@ptrCast(*const IDebugSystemObjects, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetEventProcess(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetEventProcess(@ptrCast(*const IDebugSystemObjects, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentThreadId(@ptrCast(*const IDebugSystemObjects, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_SetCurrentThreadId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).SetCurrentThreadId(@ptrCast(*const IDebugSystemObjects, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentProcessId(@ptrCast(*const IDebugSystemObjects, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_SetCurrentProcessId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).SetCurrentProcessId(@ptrCast(*const IDebugSystemObjects, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetNumberThreads(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetNumberThreads(@ptrCast(*const IDebugSystemObjects, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetTotalNumberThreads(@ptrCast(*const IDebugSystemObjects, self), Total, LargestProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetThreadIdsByIndex(@ptrCast(*const IDebugSystemObjects, self), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetThreadIdByProcessor(@ptrCast(*const IDebugSystemObjects, self), Processor, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentThreadDataOffset(@ptrCast(*const IDebugSystemObjects, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetThreadIdByDataOffset(@ptrCast(*const IDebugSystemObjects, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentThreadTeb(@ptrCast(*const IDebugSystemObjects, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetThreadIdByTeb(@ptrCast(*const IDebugSystemObjects, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentThreadSystemId(@ptrCast(*const IDebugSystemObjects, self), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetThreadIdBySystemId(@ptrCast(*const IDebugSystemObjects, self), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentThreadHandle(@ptrCast(*const IDebugSystemObjects, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetThreadIdByHandle(@ptrCast(*const IDebugSystemObjects, self), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetNumberProcesses(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetNumberProcesses(@ptrCast(*const IDebugSystemObjects, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetProcessIdsByIndex(@ptrCast(*const IDebugSystemObjects, self), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentProcessDataOffset(@ptrCast(*const IDebugSystemObjects, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetProcessIdByDataOffset(@ptrCast(*const IDebugSystemObjects, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentProcessPeb(@ptrCast(*const IDebugSystemObjects, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetProcessIdByPeb(@ptrCast(*const IDebugSystemObjects, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentProcessSystemId(@ptrCast(*const IDebugSystemObjects, self), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetProcessIdBySystemId(@ptrCast(*const IDebugSystemObjects, self), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentProcessHandle(@ptrCast(*const IDebugSystemObjects, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetProcessIdByHandle(@ptrCast(*const IDebugSystemObjects, self), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects.VTable, self.vtable).GetCurrentProcessExecutableName(@ptrCast(*const IDebugSystemObjects, self), Buffer, BufferSize, ExeSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects2_Value = @import("../../zig.zig").Guid.initString("0ae9f5ff-1852-4679-b055-494bee6407ee");
pub const IID_IDebugSystemObjects2 = &IID_IDebugSystemObjects2_Value;
pub const IDebugSystemObjects2 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: fn(
            self: *const IDebugSystemObjects2,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventProcess: fn(
            self: *const IDebugSystemObjects2,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadId: fn(
            self: *const IDebugSystemObjects2,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentThreadId: fn(
            self: *const IDebugSystemObjects2,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessId: fn(
            self: *const IDebugSystemObjects2,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentProcessId: fn(
            self: *const IDebugSystemObjects2,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberThreads: fn(
            self: *const IDebugSystemObjects2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalNumberThreads: fn(
            self: *const IDebugSystemObjects2,
            Total: ?*u32,
            LargestProcess: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdsByIndex: fn(
            self: *const IDebugSystemObjects2,
            Start: u32,
            Count: u32,
            Ids: ?[*]u32,
            SysIds: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByProcessor: fn(
            self: *const IDebugSystemObjects2,
            Processor: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadDataOffset: fn(
            self: *const IDebugSystemObjects2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByDataOffset: fn(
            self: *const IDebugSystemObjects2,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadTeb: fn(
            self: *const IDebugSystemObjects2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByTeb: fn(
            self: *const IDebugSystemObjects2,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadSystemId: fn(
            self: *const IDebugSystemObjects2,
            SysId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdBySystemId: fn(
            self: *const IDebugSystemObjects2,
            SysId: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadHandle: fn(
            self: *const IDebugSystemObjects2,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByHandle: fn(
            self: *const IDebugSystemObjects2,
            Handle: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcesses: fn(
            self: *const IDebugSystemObjects2,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdsByIndex: fn(
            self: *const IDebugSystemObjects2,
            Start: u32,
            Count: u32,
            Ids: ?[*]u32,
            SysIds: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessDataOffset: fn(
            self: *const IDebugSystemObjects2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByDataOffset: fn(
            self: *const IDebugSystemObjects2,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessPeb: fn(
            self: *const IDebugSystemObjects2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByPeb: fn(
            self: *const IDebugSystemObjects2,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessSystemId: fn(
            self: *const IDebugSystemObjects2,
            SysId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdBySystemId: fn(
            self: *const IDebugSystemObjects2,
            SysId: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessHandle: fn(
            self: *const IDebugSystemObjects2,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByHandle: fn(
            self: *const IDebugSystemObjects2,
            Handle: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessExecutableName: fn(
            self: *const IDebugSystemObjects2,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ExeSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessUpTime: fn(
            self: *const IDebugSystemObjects2,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplicitThreadDataOffset: fn(
            self: *const IDebugSystemObjects2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImplicitThreadDataOffset: fn(
            self: *const IDebugSystemObjects2,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplicitProcessDataOffset: fn(
            self: *const IDebugSystemObjects2,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImplicitProcessDataOffset: fn(
            self: *const IDebugSystemObjects2,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetEventThread(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetEventThread(@ptrCast(*const IDebugSystemObjects2, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetEventProcess(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetEventProcess(@ptrCast(*const IDebugSystemObjects2, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentThreadId(@ptrCast(*const IDebugSystemObjects2, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_SetCurrentThreadId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).SetCurrentThreadId(@ptrCast(*const IDebugSystemObjects2, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentProcessId(@ptrCast(*const IDebugSystemObjects2, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_SetCurrentProcessId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).SetCurrentProcessId(@ptrCast(*const IDebugSystemObjects2, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetNumberThreads(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetNumberThreads(@ptrCast(*const IDebugSystemObjects2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetTotalNumberThreads(@ptrCast(*const IDebugSystemObjects2, self), Total, LargestProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetThreadIdsByIndex(@ptrCast(*const IDebugSystemObjects2, self), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetThreadIdByProcessor(@ptrCast(*const IDebugSystemObjects2, self), Processor, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentThreadDataOffset(@ptrCast(*const IDebugSystemObjects2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetThreadIdByDataOffset(@ptrCast(*const IDebugSystemObjects2, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentThreadTeb(@ptrCast(*const IDebugSystemObjects2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetThreadIdByTeb(@ptrCast(*const IDebugSystemObjects2, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentThreadSystemId(@ptrCast(*const IDebugSystemObjects2, self), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetThreadIdBySystemId(@ptrCast(*const IDebugSystemObjects2, self), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentThreadHandle(@ptrCast(*const IDebugSystemObjects2, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetThreadIdByHandle(@ptrCast(*const IDebugSystemObjects2, self), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetNumberProcesses(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetNumberProcesses(@ptrCast(*const IDebugSystemObjects2, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetProcessIdsByIndex(@ptrCast(*const IDebugSystemObjects2, self), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentProcessDataOffset(@ptrCast(*const IDebugSystemObjects2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetProcessIdByDataOffset(@ptrCast(*const IDebugSystemObjects2, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentProcessPeb(@ptrCast(*const IDebugSystemObjects2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetProcessIdByPeb(@ptrCast(*const IDebugSystemObjects2, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentProcessSystemId(@ptrCast(*const IDebugSystemObjects2, self), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetProcessIdBySystemId(@ptrCast(*const IDebugSystemObjects2, self), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentProcessHandle(@ptrCast(*const IDebugSystemObjects2, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetProcessIdByHandle(@ptrCast(*const IDebugSystemObjects2, self), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentProcessExecutableName(@ptrCast(*const IDebugSystemObjects2, self), Buffer, BufferSize, ExeSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetCurrentProcessUpTime(@ptrCast(*const IDebugSystemObjects2, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetImplicitThreadDataOffset(@ptrCast(*const IDebugSystemObjects2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_SetImplicitThreadDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).SetImplicitThreadDataOffset(@ptrCast(*const IDebugSystemObjects2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).GetImplicitProcessDataOffset(@ptrCast(*const IDebugSystemObjects2, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects2_SetImplicitProcessDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects2.VTable, self.vtable).SetImplicitProcessDataOffset(@ptrCast(*const IDebugSystemObjects2, self), Offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects3_Value = @import("../../zig.zig").Guid.initString("e9676e2f-e286-4ea3-b0f9-dfe5d9fc330e");
pub const IID_IDebugSystemObjects3 = &IID_IDebugSystemObjects3_Value;
pub const IDebugSystemObjects3 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: fn(
            self: *const IDebugSystemObjects3,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventProcess: fn(
            self: *const IDebugSystemObjects3,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadId: fn(
            self: *const IDebugSystemObjects3,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentThreadId: fn(
            self: *const IDebugSystemObjects3,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessId: fn(
            self: *const IDebugSystemObjects3,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentProcessId: fn(
            self: *const IDebugSystemObjects3,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberThreads: fn(
            self: *const IDebugSystemObjects3,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalNumberThreads: fn(
            self: *const IDebugSystemObjects3,
            Total: ?*u32,
            LargestProcess: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdsByIndex: fn(
            self: *const IDebugSystemObjects3,
            Start: u32,
            Count: u32,
            Ids: ?[*]u32,
            SysIds: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByProcessor: fn(
            self: *const IDebugSystemObjects3,
            Processor: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadDataOffset: fn(
            self: *const IDebugSystemObjects3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByDataOffset: fn(
            self: *const IDebugSystemObjects3,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadTeb: fn(
            self: *const IDebugSystemObjects3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByTeb: fn(
            self: *const IDebugSystemObjects3,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadSystemId: fn(
            self: *const IDebugSystemObjects3,
            SysId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdBySystemId: fn(
            self: *const IDebugSystemObjects3,
            SysId: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadHandle: fn(
            self: *const IDebugSystemObjects3,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByHandle: fn(
            self: *const IDebugSystemObjects3,
            Handle: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcesses: fn(
            self: *const IDebugSystemObjects3,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdsByIndex: fn(
            self: *const IDebugSystemObjects3,
            Start: u32,
            Count: u32,
            Ids: ?[*]u32,
            SysIds: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessDataOffset: fn(
            self: *const IDebugSystemObjects3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByDataOffset: fn(
            self: *const IDebugSystemObjects3,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessPeb: fn(
            self: *const IDebugSystemObjects3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByPeb: fn(
            self: *const IDebugSystemObjects3,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessSystemId: fn(
            self: *const IDebugSystemObjects3,
            SysId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdBySystemId: fn(
            self: *const IDebugSystemObjects3,
            SysId: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessHandle: fn(
            self: *const IDebugSystemObjects3,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByHandle: fn(
            self: *const IDebugSystemObjects3,
            Handle: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessExecutableName: fn(
            self: *const IDebugSystemObjects3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ExeSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessUpTime: fn(
            self: *const IDebugSystemObjects3,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplicitThreadDataOffset: fn(
            self: *const IDebugSystemObjects3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImplicitThreadDataOffset: fn(
            self: *const IDebugSystemObjects3,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplicitProcessDataOffset: fn(
            self: *const IDebugSystemObjects3,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImplicitProcessDataOffset: fn(
            self: *const IDebugSystemObjects3,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventSystem: fn(
            self: *const IDebugSystemObjects3,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemId: fn(
            self: *const IDebugSystemObjects3,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentSystemId: fn(
            self: *const IDebugSystemObjects3,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSystems: fn(
            self: *const IDebugSystemObjects3,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemIdsByIndex: fn(
            self: *const IDebugSystemObjects3,
            Start: u32,
            Count: u32,
            Ids: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalNumberThreadsAndProcesses: fn(
            self: *const IDebugSystemObjects3,
            TotalThreads: ?*u32,
            TotalProcesses: ?*u32,
            LargestProcessThreads: ?*u32,
            LargestSystemThreads: ?*u32,
            LargestSystemProcesses: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemServer: fn(
            self: *const IDebugSystemObjects3,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemByServer: fn(
            self: *const IDebugSystemObjects3,
            Server: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemServerName: fn(
            self: *const IDebugSystemObjects3,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetEventThread(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetEventThread(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetEventProcess(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetEventProcess(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentThreadId(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetCurrentThreadId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).SetCurrentThreadId(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentProcessId(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetCurrentProcessId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).SetCurrentProcessId(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetNumberThreads(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetNumberThreads(@ptrCast(*const IDebugSystemObjects3, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetTotalNumberThreads(@ptrCast(*const IDebugSystemObjects3, self), Total, LargestProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetThreadIdsByIndex(@ptrCast(*const IDebugSystemObjects3, self), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetThreadIdByProcessor(@ptrCast(*const IDebugSystemObjects3, self), Processor, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentThreadDataOffset(@ptrCast(*const IDebugSystemObjects3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetThreadIdByDataOffset(@ptrCast(*const IDebugSystemObjects3, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentThreadTeb(@ptrCast(*const IDebugSystemObjects3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetThreadIdByTeb(@ptrCast(*const IDebugSystemObjects3, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentThreadSystemId(@ptrCast(*const IDebugSystemObjects3, self), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetThreadIdBySystemId(@ptrCast(*const IDebugSystemObjects3, self), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentThreadHandle(@ptrCast(*const IDebugSystemObjects3, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetThreadIdByHandle(@ptrCast(*const IDebugSystemObjects3, self), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetNumberProcesses(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetNumberProcesses(@ptrCast(*const IDebugSystemObjects3, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetProcessIdsByIndex(@ptrCast(*const IDebugSystemObjects3, self), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentProcessDataOffset(@ptrCast(*const IDebugSystemObjects3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetProcessIdByDataOffset(@ptrCast(*const IDebugSystemObjects3, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentProcessPeb(@ptrCast(*const IDebugSystemObjects3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetProcessIdByPeb(@ptrCast(*const IDebugSystemObjects3, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentProcessSystemId(@ptrCast(*const IDebugSystemObjects3, self), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetProcessIdBySystemId(@ptrCast(*const IDebugSystemObjects3, self), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentProcessHandle(@ptrCast(*const IDebugSystemObjects3, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetProcessIdByHandle(@ptrCast(*const IDebugSystemObjects3, self), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentProcessExecutableName(@ptrCast(*const IDebugSystemObjects3, self), Buffer, BufferSize, ExeSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentProcessUpTime(@ptrCast(*const IDebugSystemObjects3, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetImplicitThreadDataOffset(@ptrCast(*const IDebugSystemObjects3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetImplicitThreadDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).SetImplicitThreadDataOffset(@ptrCast(*const IDebugSystemObjects3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetImplicitProcessDataOffset(@ptrCast(*const IDebugSystemObjects3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetImplicitProcessDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).SetImplicitProcessDataOffset(@ptrCast(*const IDebugSystemObjects3, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetEventSystem(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetEventSystem(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentSystemId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentSystemId(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_SetCurrentSystemId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).SetCurrentSystemId(@ptrCast(*const IDebugSystemObjects3, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetNumberSystems(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetNumberSystems(@ptrCast(*const IDebugSystemObjects3, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetSystemIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetSystemIdsByIndex(@ptrCast(*const IDebugSystemObjects3, self), Start, Count, Ids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetTotalNumberThreadsAndProcesses(self: *const T, TotalThreads: ?*u32, TotalProcesses: ?*u32, LargestProcessThreads: ?*u32, LargestSystemThreads: ?*u32, LargestSystemProcesses: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetTotalNumberThreadsAndProcesses(@ptrCast(*const IDebugSystemObjects3, self), TotalThreads, TotalProcesses, LargestProcessThreads, LargestSystemThreads, LargestSystemProcesses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentSystemServer(self: *const T, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentSystemServer(@ptrCast(*const IDebugSystemObjects3, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetSystemByServer(self: *const T, Server: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetSystemByServer(@ptrCast(*const IDebugSystemObjects3, self), Server, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects3_GetCurrentSystemServerName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects3.VTable, self.vtable).GetCurrentSystemServerName(@ptrCast(*const IDebugSystemObjects3, self), Buffer, BufferSize, NameSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugSystemObjects4_Value = @import("../../zig.zig").Guid.initString("489468e6-7d0f-4af5-87ab-25207454d553");
pub const IID_IDebugSystemObjects4 = &IID_IDebugSystemObjects4_Value;
pub const IDebugSystemObjects4 = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetEventThread: fn(
            self: *const IDebugSystemObjects4,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventProcess: fn(
            self: *const IDebugSystemObjects4,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadId: fn(
            self: *const IDebugSystemObjects4,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentThreadId: fn(
            self: *const IDebugSystemObjects4,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessId: fn(
            self: *const IDebugSystemObjects4,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentProcessId: fn(
            self: *const IDebugSystemObjects4,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberThreads: fn(
            self: *const IDebugSystemObjects4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalNumberThreads: fn(
            self: *const IDebugSystemObjects4,
            Total: ?*u32,
            LargestProcess: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdsByIndex: fn(
            self: *const IDebugSystemObjects4,
            Start: u32,
            Count: u32,
            Ids: ?[*]u32,
            SysIds: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByProcessor: fn(
            self: *const IDebugSystemObjects4,
            Processor: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadDataOffset: fn(
            self: *const IDebugSystemObjects4,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByDataOffset: fn(
            self: *const IDebugSystemObjects4,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadTeb: fn(
            self: *const IDebugSystemObjects4,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByTeb: fn(
            self: *const IDebugSystemObjects4,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadSystemId: fn(
            self: *const IDebugSystemObjects4,
            SysId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdBySystemId: fn(
            self: *const IDebugSystemObjects4,
            SysId: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentThreadHandle: fn(
            self: *const IDebugSystemObjects4,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetThreadIdByHandle: fn(
            self: *const IDebugSystemObjects4,
            Handle: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberProcesses: fn(
            self: *const IDebugSystemObjects4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdsByIndex: fn(
            self: *const IDebugSystemObjects4,
            Start: u32,
            Count: u32,
            Ids: ?[*]u32,
            SysIds: ?[*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessDataOffset: fn(
            self: *const IDebugSystemObjects4,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByDataOffset: fn(
            self: *const IDebugSystemObjects4,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessPeb: fn(
            self: *const IDebugSystemObjects4,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByPeb: fn(
            self: *const IDebugSystemObjects4,
            Offset: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessSystemId: fn(
            self: *const IDebugSystemObjects4,
            SysId: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdBySystemId: fn(
            self: *const IDebugSystemObjects4,
            SysId: u32,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessHandle: fn(
            self: *const IDebugSystemObjects4,
            Handle: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetProcessIdByHandle: fn(
            self: *const IDebugSystemObjects4,
            Handle: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessExecutableName: fn(
            self: *const IDebugSystemObjects4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            ExeSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessUpTime: fn(
            self: *const IDebugSystemObjects4,
            UpTime: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplicitThreadDataOffset: fn(
            self: *const IDebugSystemObjects4,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImplicitThreadDataOffset: fn(
            self: *const IDebugSystemObjects4,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetImplicitProcessDataOffset: fn(
            self: *const IDebugSystemObjects4,
            Offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetImplicitProcessDataOffset: fn(
            self: *const IDebugSystemObjects4,
            Offset: u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventSystem: fn(
            self: *const IDebugSystemObjects4,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemId: fn(
            self: *const IDebugSystemObjects4,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetCurrentSystemId: fn(
            self: *const IDebugSystemObjects4,
            Id: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberSystems: fn(
            self: *const IDebugSystemObjects4,
            Number: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemIdsByIndex: fn(
            self: *const IDebugSystemObjects4,
            Start: u32,
            Count: u32,
            Ids: [*]u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTotalNumberThreadsAndProcesses: fn(
            self: *const IDebugSystemObjects4,
            TotalThreads: ?*u32,
            TotalProcesses: ?*u32,
            LargestProcessThreads: ?*u32,
            LargestSystemThreads: ?*u32,
            LargestSystemProcesses: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemServer: fn(
            self: *const IDebugSystemObjects4,
            Server: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSystemByServer: fn(
            self: *const IDebugSystemObjects4,
            Server: u64,
            Id: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemServerName: fn(
            self: *const IDebugSystemObjects4,
            Buffer: ?[*:0]u8,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentProcessExecutableNameWide: fn(
            self: *const IDebugSystemObjects4,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            ExeSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentSystemServerNameWide: fn(
            self: *const IDebugSystemObjects4,
            Buffer: ?[*:0]u16,
            BufferSize: u32,
            NameSize: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetEventThread(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetEventThread(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetEventProcess(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetEventProcess(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentThreadId(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetCurrentThreadId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).SetCurrentThreadId(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentProcessId(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetCurrentProcessId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).SetCurrentProcessId(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetNumberThreads(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetNumberThreads(@ptrCast(*const IDebugSystemObjects4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetTotalNumberThreads(self: *const T, Total: ?*u32, LargestProcess: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetTotalNumberThreads(@ptrCast(*const IDebugSystemObjects4, self), Total, LargestProcess);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetThreadIdsByIndex(@ptrCast(*const IDebugSystemObjects4, self), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdByProcessor(self: *const T, Processor: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetThreadIdByProcessor(@ptrCast(*const IDebugSystemObjects4, self), Processor, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentThreadDataOffset(@ptrCast(*const IDebugSystemObjects4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetThreadIdByDataOffset(@ptrCast(*const IDebugSystemObjects4, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadTeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentThreadTeb(@ptrCast(*const IDebugSystemObjects4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdByTeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetThreadIdByTeb(@ptrCast(*const IDebugSystemObjects4, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentThreadSystemId(@ptrCast(*const IDebugSystemObjects4, self), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetThreadIdBySystemId(@ptrCast(*const IDebugSystemObjects4, self), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentThreadHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentThreadHandle(@ptrCast(*const IDebugSystemObjects4, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetThreadIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetThreadIdByHandle(@ptrCast(*const IDebugSystemObjects4, self), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetNumberProcesses(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetNumberProcesses(@ptrCast(*const IDebugSystemObjects4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: ?[*]u32, SysIds: ?[*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetProcessIdsByIndex(@ptrCast(*const IDebugSystemObjects4, self), Start, Count, Ids, SysIds);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentProcessDataOffset(@ptrCast(*const IDebugSystemObjects4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdByDataOffset(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetProcessIdByDataOffset(@ptrCast(*const IDebugSystemObjects4, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessPeb(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentProcessPeb(@ptrCast(*const IDebugSystemObjects4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdByPeb(self: *const T, Offset: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetProcessIdByPeb(@ptrCast(*const IDebugSystemObjects4, self), Offset, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessSystemId(self: *const T, SysId: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentProcessSystemId(@ptrCast(*const IDebugSystemObjects4, self), SysId);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdBySystemId(self: *const T, SysId: u32, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetProcessIdBySystemId(@ptrCast(*const IDebugSystemObjects4, self), SysId, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessHandle(self: *const T, Handle: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentProcessHandle(@ptrCast(*const IDebugSystemObjects4, self), Handle);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetProcessIdByHandle(self: *const T, Handle: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetProcessIdByHandle(@ptrCast(*const IDebugSystemObjects4, self), Handle, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessExecutableName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentProcessExecutableName(@ptrCast(*const IDebugSystemObjects4, self), Buffer, BufferSize, ExeSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessUpTime(self: *const T, UpTime: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentProcessUpTime(@ptrCast(*const IDebugSystemObjects4, self), UpTime);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetImplicitThreadDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetImplicitThreadDataOffset(@ptrCast(*const IDebugSystemObjects4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetImplicitThreadDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).SetImplicitThreadDataOffset(@ptrCast(*const IDebugSystemObjects4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetImplicitProcessDataOffset(self: *const T, Offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetImplicitProcessDataOffset(@ptrCast(*const IDebugSystemObjects4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetImplicitProcessDataOffset(self: *const T, Offset: u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).SetImplicitProcessDataOffset(@ptrCast(*const IDebugSystemObjects4, self), Offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetEventSystem(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetEventSystem(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentSystemId(self: *const T, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentSystemId(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_SetCurrentSystemId(self: *const T, Id: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).SetCurrentSystemId(@ptrCast(*const IDebugSystemObjects4, self), Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetNumberSystems(self: *const T, Number: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetNumberSystems(@ptrCast(*const IDebugSystemObjects4, self), Number);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetSystemIdsByIndex(self: *const T, Start: u32, Count: u32, Ids: [*]u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetSystemIdsByIndex(@ptrCast(*const IDebugSystemObjects4, self), Start, Count, Ids);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetTotalNumberThreadsAndProcesses(self: *const T, TotalThreads: ?*u32, TotalProcesses: ?*u32, LargestProcessThreads: ?*u32, LargestSystemThreads: ?*u32, LargestSystemProcesses: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetTotalNumberThreadsAndProcesses(@ptrCast(*const IDebugSystemObjects4, self), TotalThreads, TotalProcesses, LargestProcessThreads, LargestSystemThreads, LargestSystemProcesses);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentSystemServer(self: *const T, Server: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentSystemServer(@ptrCast(*const IDebugSystemObjects4, self), Server);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetSystemByServer(self: *const T, Server: u64, Id: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetSystemByServer(@ptrCast(*const IDebugSystemObjects4, self), Server, Id);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentSystemServerName(self: *const T, Buffer: ?[*:0]u8, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentSystemServerName(@ptrCast(*const IDebugSystemObjects4, self), Buffer, BufferSize, NameSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentProcessExecutableNameWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, ExeSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentProcessExecutableNameWide(@ptrCast(*const IDebugSystemObjects4, self), Buffer, BufferSize, ExeSize);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugSystemObjects4_GetCurrentSystemServerNameWide(self: *const T, Buffer: ?[*:0]u16, BufferSize: u32, NameSize: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugSystemObjects4.VTable, self.vtable).GetCurrentSystemServerNameWide(@ptrCast(*const IDebugSystemObjects4, self), Buffer, BufferSize, NameSize);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PDEBUG_EXTENSION_INITIALIZE = fn(
    Version: ?*u32,
    Flags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_EXTENSION_UNINITIALIZE = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PDEBUG_EXTENSION_CANUNLOAD = fn(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_EXTENSION_UNLOAD = fn(
) callconv(@import("std").os.windows.WINAPI) void;

pub const PDEBUG_EXTENSION_NOTIFY = fn(
    Notify: u32,
    Argument: u64,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PDEBUG_EXTENSION_CALL = fn(
    Client: ?*IDebugClient,
    Args: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_EXTENSION_KNOWN_STRUCT = fn(
    Flags: u32,
    Offset: u64,
    TypeName: ?PSTR,
    Buffer: ?[*:0]u8,
    BufferChars: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_EXTENSION_KNOWN_STRUCT_EX = fn(
    Client: ?*IDebugClient,
    Flags: u32,
    Offset: u64,
    TypeName: ?[*:0]const u8,
    Buffer: ?[*:0]u8,
    BufferChars: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_EXTENSION_QUERY_VALUE_NAMES = fn(
    Client: ?*IDebugClient,
    Flags: u32,
    Buffer: [*:0]u16,
    BufferChars: u32,
    BufferNeeded: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_EXTENSION_PROVIDE_VALUE = fn(
    Client: ?*IDebugClient,
    Flags: u32,
    Name: ?[*:0]const u16,
    Value: ?*u64,
    TypeModBase: ?*u64,
    TypeId: ?*u32,
    TypeFlags: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION = fn(
    StreamType: u32,
    MiniDumpStreamBuffer: [*]u8,
    BufferSize: u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK = fn(
    SystemThreadId: u32,
    NativeFrames: [*]DEBUG_STACK_FRAME_EX,
    CountNativeFrames: u32,
    StackSymFrames: ?*?*STACK_SYM_FRAME_INFO,
    StackSymFramesFilled: ?*u32,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES = fn(
    StackSymFrames: ?*STACK_SYM_FRAME_INFO,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION = fn(
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub const DebugBaseEventCallbacks = extern struct {
    pub const VTable = extern struct {
        base: IDebugEventCallbacks.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugEventCallbacks.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const DebugBaseEventCallbacksWide = extern struct {
    pub const VTable = extern struct {
        base: IDebugEventCallbacksWide.VTable,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugEventCallbacksWide.MethodMixin(T);
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const Location = extern struct {
    HostDefined: u64,
    Offset: u64,
};

pub const ModelObjectKind = enum(i32) {
    PropertyAccessor = 0,
    Context = 1,
    TargetObject = 2,
    TargetObjectReference = 3,
    Synthetic = 4,
    NoValue = 5,
    Error = 6,
    Intrinsic = 7,
    Method = 8,
    KeyReference = 9,
};
pub const ObjectPropertyAccessor = ModelObjectKind.PropertyAccessor;
pub const ObjectContext = ModelObjectKind.Context;
pub const ObjectTargetObject = ModelObjectKind.TargetObject;
pub const ObjectTargetObjectReference = ModelObjectKind.TargetObjectReference;
pub const ObjectSynthetic = ModelObjectKind.Synthetic;
pub const ObjectNoValue = ModelObjectKind.NoValue;
pub const ObjectError = ModelObjectKind.Error;
pub const ObjectIntrinsic = ModelObjectKind.Intrinsic;
pub const ObjectMethod = ModelObjectKind.Method;
pub const ObjectKeyReference = ModelObjectKind.KeyReference;

pub const SymbolKind = enum(i32) {
    l = 0,
    Module = 1,
    Type = 2,
    Field = 3,
    Constant = 4,
    Data = 5,
    BaseClass = 6,
    Public = 7,
    Function = 8,
};
pub const Symbol = SymbolKind.l;
pub const SymbolModule = SymbolKind.Module;
pub const SymbolType = SymbolKind.Type;
pub const SymbolField = SymbolKind.Field;
pub const SymbolConstant = SymbolKind.Constant;
pub const SymbolData = SymbolKind.Data;
pub const SymbolBaseClass = SymbolKind.BaseClass;
pub const SymbolPublic = SymbolKind.Public;
pub const SymbolFunction = SymbolKind.Function;

pub const TypeKind = enum(i32) {
    UDT = 0,
    Pointer = 1,
    MemberPointer = 2,
    Array = 3,
    Function = 4,
    Typedef = 5,
    Enum = 6,
    Intrinsic = 7,
    ExtendedArray = 8,
};
pub const TypeUDT = TypeKind.UDT;
pub const TypePointer = TypeKind.Pointer;
pub const TypeMemberPointer = TypeKind.MemberPointer;
pub const TypeArray = TypeKind.Array;
pub const TypeFunction = TypeKind.Function;
pub const TypeTypedef = TypeKind.Typedef;
pub const TypeEnum = TypeKind.Enum;
pub const TypeIntrinsic = TypeKind.Intrinsic;
pub const TypeExtendedArray = TypeKind.ExtendedArray;

pub const IntrinsicKind = enum(i32) {
    Void = 0,
    Bool = 1,
    Char = 2,
    WChar = 3,
    Int = 4,
    UInt = 5,
    Long = 6,
    ULong = 7,
    Float = 8,
    HRESULT = 9,
    Char16 = 10,
    Char32 = 11,
};
pub const IntrinsicVoid = IntrinsicKind.Void;
pub const IntrinsicBool = IntrinsicKind.Bool;
pub const IntrinsicChar = IntrinsicKind.Char;
pub const IntrinsicWChar = IntrinsicKind.WChar;
pub const IntrinsicInt = IntrinsicKind.Int;
pub const IntrinsicUInt = IntrinsicKind.UInt;
pub const IntrinsicLong = IntrinsicKind.Long;
pub const IntrinsicULong = IntrinsicKind.ULong;
pub const IntrinsicFloat = IntrinsicKind.Float;
pub const IntrinsicHRESULT = IntrinsicKind.HRESULT;
pub const IntrinsicChar16 = IntrinsicKind.Char16;
pub const IntrinsicChar32 = IntrinsicKind.Char32;

pub const PointerKind = enum(i32) {
    Standard = 0,
    Reference = 1,
    RValueReference = 2,
    CXHat = 3,
    ManagedReference = 4,
};
pub const PointerStandard = PointerKind.Standard;
pub const PointerReference = PointerKind.Reference;
pub const PointerRValueReference = PointerKind.RValueReference;
pub const PointerCXHat = PointerKind.CXHat;
pub const PointerManagedReference = PointerKind.ManagedReference;

pub const CallingConventionKind = enum(i32) {
    Unknown = 0,
    CDecl = 1,
    FastCall = 2,
    StdCall = 3,
    SysCall = 4,
    ThisCall = 5,
};
pub const CallingConventionUnknown = CallingConventionKind.Unknown;
pub const CallingConventionCDecl = CallingConventionKind.CDecl;
pub const CallingConventionFastCall = CallingConventionKind.FastCall;
pub const CallingConventionStdCall = CallingConventionKind.StdCall;
pub const CallingConventionSysCall = CallingConventionKind.SysCall;
pub const CallingConventionThisCall = CallingConventionKind.ThisCall;

pub const LocationKind = enum(i32) {
    Member = 0,
    Static = 1,
    Constant = 2,
    None = 3,
};
pub const LocationMember = LocationKind.Member;
pub const LocationStatic = LocationKind.Static;
pub const LocationConstant = LocationKind.Constant;
pub const LocationNone = LocationKind.None;

pub const PreferredFormat = enum(i32) {
    None = 0,
    SingleCharacter = 1,
    QuotedString = 2,
    String = 3,
    QuotedUnicodeString = 4,
    UnicodeString = 5,
    QuotedUTF8String = 6,
    UTF8String = 7,
    BSTRString = 8,
    QuotedHString = 9,
    HString = 10,
    Raw = 11,
    EnumNameOnly = 12,
    EscapedStringWithQuote = 13,
    UTF32String = 14,
    QuotedUTF32String = 15,
};
pub const FormatNone = PreferredFormat.None;
pub const FormatSingleCharacter = PreferredFormat.SingleCharacter;
pub const FormatQuotedString = PreferredFormat.QuotedString;
pub const FormatString = PreferredFormat.String;
pub const FormatQuotedUnicodeString = PreferredFormat.QuotedUnicodeString;
pub const FormatUnicodeString = PreferredFormat.UnicodeString;
pub const FormatQuotedUTF8String = PreferredFormat.QuotedUTF8String;
pub const FormatUTF8String = PreferredFormat.UTF8String;
pub const FormatBSTRString = PreferredFormat.BSTRString;
pub const FormatQuotedHString = PreferredFormat.QuotedHString;
pub const FormatHString = PreferredFormat.HString;
pub const FormatRaw = PreferredFormat.Raw;
pub const FormatEnumNameOnly = PreferredFormat.EnumNameOnly;
pub const FormatEscapedStringWithQuote = PreferredFormat.EscapedStringWithQuote;
pub const FormatUTF32String = PreferredFormat.UTF32String;
pub const FormatQuotedUTF32String = PreferredFormat.QuotedUTF32String;

const IID_IHostDataModelAccess_Value = @import("../../zig.zig").Guid.initString("f2bce54e-4835-4f8a-836e-7981e29904d1");
pub const IID_IHostDataModelAccess = &IID_IHostDataModelAccess_Value;
pub const IHostDataModelAccess = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDataModel: fn(
            self: *const IHostDataModelAccess,
            manager: ?*?*IDataModelManager,
            host: ?*?*IDebugHost,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IHostDataModelAccess_GetDataModel(self: *const T, manager: ?*?*IDataModelManager, host: ?*?*IDebugHost) callconv(.Inline) HRESULT {
            return @ptrCast(*const IHostDataModelAccess.VTable, self.vtable).GetDataModel(@ptrCast(*const IHostDataModelAccess, self), manager, host);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IKeyStore_Value = @import("../../zig.zig").Guid.initString("0fc7557d-401d-4fca-9365-da1e9850697c");
pub const IID_IKeyStore = &IID_IKeyStore_Value;
pub const IKeyStore = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKey: fn(
            self: *const IKeyStore,
            key: ?[*:0]const u16,
            object: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKey: fn(
            self: *const IKeyStore,
            key: ?[*:0]const u16,
            object: ?*IModelObject,
            metadata: ?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyValue: fn(
            self: *const IKeyStore,
            key: ?[*:0]const u16,
            object: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeyValue: fn(
            self: *const IKeyStore,
            key: ?[*:0]const u16,
            object: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearKeys: fn(
            self: *const IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_GetKey(self: *const T, key: ?[*:0]const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKeyStore.VTable, self.vtable).GetKey(@ptrCast(*const IKeyStore, self), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_SetKey(self: *const T, key: ?[*:0]const u16, object: ?*IModelObject, metadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKeyStore.VTable, self.vtable).SetKey(@ptrCast(*const IKeyStore, self), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_GetKeyValue(self: *const T, key: ?[*:0]const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKeyStore.VTable, self.vtable).GetKeyValue(@ptrCast(*const IKeyStore, self), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_SetKeyValue(self: *const T, key: ?[*:0]const u16, object: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKeyStore.VTable, self.vtable).SetKeyValue(@ptrCast(*const IKeyStore, self), key, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyStore_ClearKeys(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKeyStore.VTable, self.vtable).ClearKeys(@ptrCast(*const IKeyStore, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const RawSearchFlags = enum(i32) {
    ne = 0,
    Bases = 1,
};
pub const RawSearchNone = RawSearchFlags.ne;
pub const RawSearchNoBases = RawSearchFlags.Bases;

const IID_IModelObject_Value = @import("../../zig.zig").Guid.initString("e28c7893-3f4b-4b96-baca-293cdc55f45d");
pub const IID_IModelObject = &IID_IModelObject_Value;
pub const IModelObject = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContext: fn(
            self: *const IModelObject,
            context: ?*?*IDebugHostContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKind: fn(
            self: *const IModelObject,
            kind: ?*ModelObjectKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIntrinsicValue: fn(
            self: *const IModelObject,
            intrinsicData: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIntrinsicValueAs: fn(
            self: *const IModelObject,
            vt: u16,
            intrinsicData: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyValue: fn(
            self: *const IModelObject,
            key: ?[*:0]const u16,
            object: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeyValue: fn(
            self: *const IModelObject,
            key: ?[*:0]const u16,
            object: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateKeyValues: fn(
            self: *const IModelObject,
            enumerator: ?*?*IKeyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawValue: fn(
            self: *const IModelObject,
            kind: SymbolKind,
            name: ?[*:0]const u16,
            searchFlags: u32,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateRawValues: fn(
            self: *const IModelObject,
            kind: SymbolKind,
            searchFlags: u32,
            enumerator: ?*?*IRawEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Dereference: fn(
            self: *const IModelObject,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        TryCastToRuntimeType: fn(
            self: *const IModelObject,
            runtimeTypedObject: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetConcept: fn(
            self: *const IModelObject,
            conceptId: ?*const Guid,
            conceptInterface: ?*?*IUnknown,
            conceptMetadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocation: fn(
            self: *const IModelObject,
            location: ?*Location,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypeInfo: fn(
            self: *const IModelObject,
            type: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTargetInfo: fn(
            self: *const IModelObject,
            location: ?*Location,
            type: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNumberOfParentModels: fn(
            self: *const IModelObject,
            numModels: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetParentModel: fn(
            self: *const IModelObject,
            i: u64,
            model: ?*?*IModelObject,
            contextObject: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AddParentModel: fn(
            self: *const IModelObject,
            model: ?*IModelObject,
            contextObject: ?*IModelObject,
            override: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RemoveParentModel: fn(
            self: *const IModelObject,
            model: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKey: fn(
            self: *const IModelObject,
            key: ?[*:0]const u16,
            object: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyReference: fn(
            self: *const IModelObject,
            key: ?[*:0]const u16,
            objectReference: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKey: fn(
            self: *const IModelObject,
            key: ?[*:0]const u16,
            object: ?*IModelObject,
            metadata: ?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearKeys: fn(
            self: *const IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateKeys: fn(
            self: *const IModelObject,
            enumerator: ?*?*IKeyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateKeyReferences: fn(
            self: *const IModelObject,
            enumerator: ?*?*IKeyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConcept: fn(
            self: *const IModelObject,
            conceptId: ?*const Guid,
            conceptInterface: ?*IUnknown,
            conceptMetadata: ?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ClearConcepts: fn(
            self: *const IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRawReference: fn(
            self: *const IModelObject,
            kind: SymbolKind,
            name: ?[*:0]const u16,
            searchFlags: u32,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateRawReferences: fn(
            self: *const IModelObject,
            kind: SymbolKind,
            searchFlags: u32,
            enumerator: ?*?*IRawEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetContextForDataModel: fn(
            self: *const IModelObject,
            dataModelObject: ?*IModelObject,
            context: ?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextForDataModel: fn(
            self: *const IModelObject,
            dataModelObject: ?*IModelObject,
            context: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Compare: fn(
            self: *const IModelObject,
            other: ?*IModelObject,
            ppResult: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsEqualTo: fn(
            self: *const IModelObject,
            other: ?*IModelObject,
            equal: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetContext(self: *const T, context: ?*?*IDebugHostContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetContext(@ptrCast(*const IModelObject, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetKind(self: *const T, kind: ?*ModelObjectKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetKind(@ptrCast(*const IModelObject, self), kind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetIntrinsicValue(self: *const T, intrinsicData: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetIntrinsicValue(@ptrCast(*const IModelObject, self), intrinsicData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetIntrinsicValueAs(self: *const T, vt: u16, intrinsicData: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetIntrinsicValueAs(@ptrCast(*const IModelObject, self), vt, intrinsicData);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetKeyValue(self: *const T, key: ?[*:0]const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetKeyValue(@ptrCast(*const IModelObject, self), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_SetKeyValue(self: *const T, key: ?[*:0]const u16, object: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).SetKeyValue(@ptrCast(*const IModelObject, self), key, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateKeyValues(self: *const T, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).EnumerateKeyValues(@ptrCast(*const IModelObject, self), enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetRawValue(self: *const T, kind: SymbolKind, name: ?[*:0]const u16, searchFlags: u32, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetRawValue(@ptrCast(*const IModelObject, self), kind, name, searchFlags, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateRawValues(self: *const T, kind: SymbolKind, searchFlags: u32, enumerator: ?*?*IRawEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).EnumerateRawValues(@ptrCast(*const IModelObject, self), kind, searchFlags, enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_Dereference(self: *const T, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).Dereference(@ptrCast(*const IModelObject, self), object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_TryCastToRuntimeType(self: *const T, runtimeTypedObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).TryCastToRuntimeType(@ptrCast(*const IModelObject, self), runtimeTypedObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetConcept(self: *const T, conceptId: ?*const Guid, conceptInterface: ?*?*IUnknown, conceptMetadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetConcept(@ptrCast(*const IModelObject, self), conceptId, conceptInterface, conceptMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetLocation(self: *const T, location: ?*Location) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetLocation(@ptrCast(*const IModelObject, self), location);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetTypeInfo(self: *const T, type_: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetTypeInfo(@ptrCast(*const IModelObject, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetTargetInfo(self: *const T, location: ?*Location, type_: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetTargetInfo(@ptrCast(*const IModelObject, self), location, type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetNumberOfParentModels(self: *const T, numModels: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetNumberOfParentModels(@ptrCast(*const IModelObject, self), numModels);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetParentModel(self: *const T, i: u64, model: ?*?*IModelObject, contextObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetParentModel(@ptrCast(*const IModelObject, self), i, model, contextObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_AddParentModel(self: *const T, model: ?*IModelObject, contextObject: ?*IModelObject, override: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).AddParentModel(@ptrCast(*const IModelObject, self), model, contextObject, override);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_RemoveParentModel(self: *const T, model: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).RemoveParentModel(@ptrCast(*const IModelObject, self), model);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetKey(self: *const T, key: ?[*:0]const u16, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetKey(@ptrCast(*const IModelObject, self), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetKeyReference(self: *const T, key: ?[*:0]const u16, objectReference: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetKeyReference(@ptrCast(*const IModelObject, self), key, objectReference, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_SetKey(self: *const T, key: ?[*:0]const u16, object: ?*IModelObject, metadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).SetKey(@ptrCast(*const IModelObject, self), key, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_ClearKeys(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).ClearKeys(@ptrCast(*const IModelObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateKeys(self: *const T, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).EnumerateKeys(@ptrCast(*const IModelObject, self), enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateKeyReferences(self: *const T, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).EnumerateKeyReferences(@ptrCast(*const IModelObject, self), enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_SetConcept(self: *const T, conceptId: ?*const Guid, conceptInterface: ?*IUnknown, conceptMetadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).SetConcept(@ptrCast(*const IModelObject, self), conceptId, conceptInterface, conceptMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_ClearConcepts(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).ClearConcepts(@ptrCast(*const IModelObject, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetRawReference(self: *const T, kind: SymbolKind, name: ?[*:0]const u16, searchFlags: u32, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetRawReference(@ptrCast(*const IModelObject, self), kind, name, searchFlags, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_EnumerateRawReferences(self: *const T, kind: SymbolKind, searchFlags: u32, enumerator: ?*?*IRawEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).EnumerateRawReferences(@ptrCast(*const IModelObject, self), kind, searchFlags, enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_SetContextForDataModel(self: *const T, dataModelObject: ?*IModelObject, context: ?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).SetContextForDataModel(@ptrCast(*const IModelObject, self), dataModelObject, context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_GetContextForDataModel(self: *const T, dataModelObject: ?*IModelObject, context: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).GetContextForDataModel(@ptrCast(*const IModelObject, self), dataModelObject, context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_Compare(self: *const T, other: ?*IModelObject, ppResult: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).Compare(@ptrCast(*const IModelObject, self), other, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelObject_IsEqualTo(self: *const T, other: ?*IModelObject, equal: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelObject.VTable, self.vtable).IsEqualTo(@ptrCast(*const IModelObject, self), other, equal);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelManager_Value = @import("../../zig.zig").Guid.initString("73fe19f4-a110-4500-8ed9-3c28896f508c");
pub const IID_IDataModelManager = &IID_IDataModelManager_Value;
pub const IDataModelManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Close: fn(
            self: *const IDataModelManager,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateNoValue: fn(
            self: *const IDataModelManager,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateErrorObject: fn(
            self: *const IDataModelManager,
            hrError: HRESULT,
            pwszMessage: ?[*:0]const u16,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTypedObject: fn(
            self: *const IDataModelManager,
            context: ?*IDebugHostContext,
            objectLocation: Location,
            objectType: ?*IDebugHostType,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTypedObjectReference: fn(
            self: *const IDataModelManager,
            context: ?*IDebugHostContext,
            objectLocation: Location,
            objectType: ?*IDebugHostType,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateSyntheticObject: fn(
            self: *const IDataModelManager,
            context: ?*IDebugHostContext,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateDataModelObject: fn(
            self: *const IDataModelManager,
            dataModel: ?*IDataModelConcept,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateIntrinsicObject: fn(
            self: *const IDataModelManager,
            objectKind: ModelObjectKind,
            intrinsicData: ?*VARIANT,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTypedIntrinsicObject: fn(
            self: *const IDataModelManager,
            intrinsicData: ?*VARIANT,
            type: ?*IDebugHostType,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModelForTypeSignature: fn(
            self: *const IDataModelManager,
            typeSignature: ?*IDebugHostTypeSignature,
            dataModel: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetModelForType: fn(
            self: *const IDataModelManager,
            type: ?*IDebugHostType,
            dataModel: ?*?*IModelObject,
            typeSignature: ?*?*IDebugHostTypeSignature,
            wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterModelForTypeSignature: fn(
            self: *const IDataModelManager,
            typeSignature: ?*IDebugHostTypeSignature,
            dataModel: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterModelForTypeSignature: fn(
            self: *const IDataModelManager,
            dataModel: ?*IModelObject,
            typeSignature: ?*IDebugHostTypeSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterExtensionForTypeSignature: fn(
            self: *const IDataModelManager,
            typeSignature: ?*IDebugHostTypeSignature,
            dataModel: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterExtensionForTypeSignature: fn(
            self: *const IDataModelManager,
            dataModel: ?*IModelObject,
            typeSignature: ?*IDebugHostTypeSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateMetadataStore: fn(
            self: *const IDataModelManager,
            parentStore: ?*IKeyStore,
            metadataStore: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetRootNamespace: fn(
            self: *const IDataModelManager,
            rootNamespace: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterNamedModel: fn(
            self: *const IDataModelManager,
            modelName: ?[*:0]const u16,
            modeObject: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterNamedModel: fn(
            self: *const IDataModelManager,
            modelName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        AcquireNamedModel: fn(
            self: *const IDataModelManager,
            modelName: ?[*:0]const u16,
            modelObject: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_Close(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).Close(@ptrCast(*const IDataModelManager, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateNoValue(self: *const T, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateNoValue(@ptrCast(*const IDataModelManager, self), object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateErrorObject(self: *const T, hrError: HRESULT, pwszMessage: ?[*:0]const u16, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateErrorObject(@ptrCast(*const IDataModelManager, self), hrError, pwszMessage, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateTypedObject(self: *const T, context: ?*IDebugHostContext, objectLocation: Location, objectType: ?*IDebugHostType, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateTypedObject(@ptrCast(*const IDataModelManager, self), context, objectLocation, objectType, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateTypedObjectReference(self: *const T, context: ?*IDebugHostContext, objectLocation: Location, objectType: ?*IDebugHostType, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateTypedObjectReference(@ptrCast(*const IDataModelManager, self), context, objectLocation, objectType, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateSyntheticObject(self: *const T, context: ?*IDebugHostContext, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateSyntheticObject(@ptrCast(*const IDataModelManager, self), context, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateDataModelObject(self: *const T, dataModel: ?*IDataModelConcept, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateDataModelObject(@ptrCast(*const IDataModelManager, self), dataModel, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateIntrinsicObject(self: *const T, objectKind: ModelObjectKind, intrinsicData: ?*VARIANT, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateIntrinsicObject(@ptrCast(*const IDataModelManager, self), objectKind, intrinsicData, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateTypedIntrinsicObject(self: *const T, intrinsicData: ?*VARIANT, type_: ?*IDebugHostType, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateTypedIntrinsicObject(@ptrCast(*const IDataModelManager, self), intrinsicData, type_, object);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_GetModelForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).GetModelForTypeSignature(@ptrCast(*const IDataModelManager, self), typeSignature, dataModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_GetModelForType(self: *const T, type_: ?*IDebugHostType, dataModel: ?*?*IModelObject, typeSignature: ?*?*IDebugHostTypeSignature, wildcardMatches: ?*?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).GetModelForType(@ptrCast(*const IDataModelManager, self), type_, dataModel, typeSignature, wildcardMatches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_RegisterModelForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).RegisterModelForTypeSignature(@ptrCast(*const IDataModelManager, self), typeSignature, dataModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_UnregisterModelForTypeSignature(self: *const T, dataModel: ?*IModelObject, typeSignature: ?*IDebugHostTypeSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).UnregisterModelForTypeSignature(@ptrCast(*const IDataModelManager, self), dataModel, typeSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_RegisterExtensionForTypeSignature(self: *const T, typeSignature: ?*IDebugHostTypeSignature, dataModel: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).RegisterExtensionForTypeSignature(@ptrCast(*const IDataModelManager, self), typeSignature, dataModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_UnregisterExtensionForTypeSignature(self: *const T, dataModel: ?*IModelObject, typeSignature: ?*IDebugHostTypeSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).UnregisterExtensionForTypeSignature(@ptrCast(*const IDataModelManager, self), dataModel, typeSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_CreateMetadataStore(self: *const T, parentStore: ?*IKeyStore, metadataStore: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).CreateMetadataStore(@ptrCast(*const IDataModelManager, self), parentStore, metadataStore);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_GetRootNamespace(self: *const T, rootNamespace: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).GetRootNamespace(@ptrCast(*const IDataModelManager, self), rootNamespace);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_RegisterNamedModel(self: *const T, modelName: ?[*:0]const u16, modeObject: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).RegisterNamedModel(@ptrCast(*const IDataModelManager, self), modelName, modeObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_UnregisterNamedModel(self: *const T, modelName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).UnregisterNamedModel(@ptrCast(*const IDataModelManager, self), modelName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager_AcquireNamedModel(self: *const T, modelName: ?[*:0]const u16, modelObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager.VTable, self.vtable).AcquireNamedModel(@ptrCast(*const IDataModelManager, self), modelName, modelObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelKeyReference_Value = @import("../../zig.zig").Guid.initString("5253dcf8-5aff-4c62-b302-56a289e00998");
pub const IID_IModelKeyReference = &IID_IModelKeyReference_Value;
pub const IModelKeyReference = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKeyName: fn(
            self: *const IModelKeyReference,
            keyName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOriginalObject: fn(
            self: *const IModelKeyReference,
            originalObject: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContextObject: fn(
            self: *const IModelKeyReference,
            containingObject: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKey: fn(
            self: *const IModelKeyReference,
            object: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetKeyValue: fn(
            self: *const IModelKeyReference,
            object: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKey: fn(
            self: *const IModelKeyReference,
            object: ?*IModelObject,
            metadata: ?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKeyValue: fn(
            self: *const IModelKeyReference,
            object: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetKeyName(self: *const T, keyName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelKeyReference.VTable, self.vtable).GetKeyName(@ptrCast(*const IModelKeyReference, self), keyName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetOriginalObject(self: *const T, originalObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelKeyReference.VTable, self.vtable).GetOriginalObject(@ptrCast(*const IModelKeyReference, self), originalObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetContextObject(self: *const T, containingObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelKeyReference.VTable, self.vtable).GetContextObject(@ptrCast(*const IModelKeyReference, self), containingObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetKey(self: *const T, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelKeyReference.VTable, self.vtable).GetKey(@ptrCast(*const IModelKeyReference, self), object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_GetKeyValue(self: *const T, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelKeyReference.VTable, self.vtable).GetKeyValue(@ptrCast(*const IModelKeyReference, self), object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_SetKey(self: *const T, object: ?*IModelObject, metadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelKeyReference.VTable, self.vtable).SetKey(@ptrCast(*const IModelKeyReference, self), object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference_SetKeyValue(self: *const T, object: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelKeyReference.VTable, self.vtable).SetKeyValue(@ptrCast(*const IModelKeyReference, self), object);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelPropertyAccessor_Value = @import("../../zig.zig").Guid.initString("5a0c63d9-0526-42b8-960c-9516a3254c85");
pub const IID_IModelPropertyAccessor = &IID_IModelPropertyAccessor_Value;
pub const IModelPropertyAccessor = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetValue: fn(
            self: *const IModelPropertyAccessor,
            key: ?[*:0]const u16,
            contextObject: ?*IModelObject,
            value: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetValue: fn(
            self: *const IModelPropertyAccessor,
            key: ?[*:0]const u16,
            contextObject: ?*IModelObject,
            value: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelPropertyAccessor_GetValue(self: *const T, key: ?[*:0]const u16, contextObject: ?*IModelObject, value: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelPropertyAccessor.VTable, self.vtable).GetValue(@ptrCast(*const IModelPropertyAccessor, self), key, contextObject, value);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelPropertyAccessor_SetValue(self: *const T, key: ?[*:0]const u16, contextObject: ?*IModelObject, value: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelPropertyAccessor.VTable, self.vtable).SetValue(@ptrCast(*const IModelPropertyAccessor, self), key, contextObject, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelMethod_Value = @import("../../zig.zig").Guid.initString("80600c1f-b90b-4896-82ad-1c00207909e8");
pub const IID_IModelMethod = &IID_IModelMethod_Value;
pub const IModelMethod = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Call: fn(
            self: *const IModelMethod,
            pContextObject: ?*IModelObject,
            argCount: u64,
            ppArguments: [*]?*IModelObject,
            ppResult: ?*?*IModelObject,
            ppMetadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelMethod_Call(self: *const T, pContextObject: ?*IModelObject, argCount: u64, ppArguments: [*]?*IModelObject, ppResult: ?*?*IModelObject, ppMetadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelMethod.VTable, self.vtable).Call(@ptrCast(*const IModelMethod, self), pContextObject, argCount, ppArguments, ppResult, ppMetadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IKeyEnumerator_Value = @import("../../zig.zig").Guid.initString("345fa92e-5e00-4319-9cae-971f7601cdcf");
pub const IID_IKeyEnumerator = &IID_IKeyEnumerator_Value;
pub const IKeyEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IKeyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IKeyEnumerator,
            key: ?*?BSTR,
            value: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKeyEnumerator.VTable, self.vtable).Reset(@ptrCast(*const IKeyEnumerator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IKeyEnumerator_GetNext(self: *const T, key: ?*?BSTR, value: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IKeyEnumerator.VTable, self.vtable).GetNext(@ptrCast(*const IKeyEnumerator, self), key, value, metadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IRawEnumerator_Value = @import("../../zig.zig").Guid.initString("e13613f9-3a3c-40b5-8f48-1e5ebfb9b21b");
pub const IID_IRawEnumerator = &IID_IRawEnumerator_Value;
pub const IRawEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IRawEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IRawEnumerator,
            name: ?*?BSTR,
            kind: ?*SymbolKind,
            value: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawEnumerator.VTable, self.vtable).Reset(@ptrCast(*const IRawEnumerator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IRawEnumerator_GetNext(self: *const T, name: ?*?BSTR, kind: ?*SymbolKind, value: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IRawEnumerator.VTable, self.vtable).GetNext(@ptrCast(*const IRawEnumerator, self), name, kind, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelConcept_Value = @import("../../zig.zig").Guid.initString("fcb98d1d-1114-4fbf-b24c-effcb5def0d3");
pub const IID_IDataModelConcept = &IID_IDataModelConcept_Value;
pub const IDataModelConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        InitializeObject: fn(
            self: *const IDataModelConcept,
            modelObject: ?*IModelObject,
            matchingTypeSignature: ?*IDebugHostTypeSignature,
            wildcardMatches: ?*IDebugHostSymbolEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IDataModelConcept,
            modelName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelConcept_InitializeObject(self: *const T, modelObject: ?*IModelObject, matchingTypeSignature: ?*IDebugHostTypeSignature, wildcardMatches: ?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelConcept.VTable, self.vtable).InitializeObject(@ptrCast(*const IDataModelConcept, self), modelObject, matchingTypeSignature, wildcardMatches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelConcept_GetName(self: *const T, modelName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelConcept.VTable, self.vtable).GetName(@ptrCast(*const IDataModelConcept, self), modelName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IStringDisplayableConcept_Value = @import("../../zig.zig").Guid.initString("d28e8d70-6c00-4205-940d-501016601ea3");
pub const IID_IStringDisplayableConcept = &IID_IStringDisplayableConcept_Value;
pub const IStringDisplayableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ToDisplayString: fn(
            self: *const IStringDisplayableConcept,
            contextObject: ?*IModelObject,
            metadata: ?*IKeyStore,
            displayString: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IStringDisplayableConcept_ToDisplayString(self: *const T, contextObject: ?*IModelObject, metadata: ?*IKeyStore, displayString: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IStringDisplayableConcept.VTable, self.vtable).ToDisplayString(@ptrCast(*const IStringDisplayableConcept, self), contextObject, metadata, displayString);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelIterator_Value = @import("../../zig.zig").Guid.initString("e4622136-927d-4490-874f-581f3e4e3688");
pub const IID_IModelIterator = &IID_IModelIterator_Value;
pub const IModelIterator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IModelIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IModelIterator,
            object: ?*?*IModelObject,
            dimensions: u64,
            indexers: ?[*]?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelIterator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelIterator.VTable, self.vtable).Reset(@ptrCast(*const IModelIterator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelIterator_GetNext(self: *const T, object: ?*?*IModelObject, dimensions: u64, indexers: ?[*]?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelIterator.VTable, self.vtable).GetNext(@ptrCast(*const IModelIterator, self), object, dimensions, indexers, metadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIterableConcept_Value = @import("../../zig.zig").Guid.initString("f5d49d0c-0b02-4301-9c9b-b3a6037628f3");
pub const IID_IIterableConcept = &IID_IIterableConcept_Value;
pub const IIterableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDefaultIndexDimensionality: fn(
            self: *const IIterableConcept,
            contextObject: ?*IModelObject,
            dimensionality: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIterator: fn(
            self: *const IIterableConcept,
            contextObject: ?*IModelObject,
            iterator: ?*?*IModelIterator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIterableConcept_GetDefaultIndexDimensionality(self: *const T, contextObject: ?*IModelObject, dimensionality: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIterableConcept.VTable, self.vtable).GetDefaultIndexDimensionality(@ptrCast(*const IIterableConcept, self), contextObject, dimensionality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIterableConcept_GetIterator(self: *const T, contextObject: ?*IModelObject, iterator: ?*?*IModelIterator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIterableConcept.VTable, self.vtable).GetIterator(@ptrCast(*const IIterableConcept, self), contextObject, iterator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IIndexableConcept_Value = @import("../../zig.zig").Guid.initString("d1fad99f-3f53-4457-850c-8051df2d3fb5");
pub const IID_IIndexableConcept = &IID_IIndexableConcept_Value;
pub const IIndexableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDimensionality: fn(
            self: *const IIndexableConcept,
            contextObject: ?*IModelObject,
            dimensionality: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetAt: fn(
            self: *const IIndexableConcept,
            contextObject: ?*IModelObject,
            indexerCount: u64,
            indexers: [*]?*IModelObject,
            object: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetAt: fn(
            self: *const IIndexableConcept,
            contextObject: ?*IModelObject,
            indexerCount: u64,
            indexers: [*]?*IModelObject,
            value: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIndexableConcept_GetDimensionality(self: *const T, contextObject: ?*IModelObject, dimensionality: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIndexableConcept.VTable, self.vtable).GetDimensionality(@ptrCast(*const IIndexableConcept, self), contextObject, dimensionality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIndexableConcept_GetAt(self: *const T, contextObject: ?*IModelObject, indexerCount: u64, indexers: [*]?*IModelObject, object: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIndexableConcept.VTable, self.vtable).GetAt(@ptrCast(*const IIndexableConcept, self), contextObject, indexerCount, indexers, object, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IIndexableConcept_SetAt(self: *const T, contextObject: ?*IModelObject, indexerCount: u64, indexers: [*]?*IModelObject, value: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IIndexableConcept.VTable, self.vtable).SetAt(@ptrCast(*const IIndexableConcept, self), contextObject, indexerCount, indexers, value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IPreferredRuntimeTypeConcept_Value = @import("../../zig.zig").Guid.initString("9d6c1d7b-a76f-4618-8068-5f76bd9a4e8a");
pub const IID_IPreferredRuntimeTypeConcept = &IID_IPreferredRuntimeTypeConcept_Value;
pub const IPreferredRuntimeTypeConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CastToPreferredRuntimeType: fn(
            self: *const IPreferredRuntimeTypeConcept,
            contextObject: ?*IModelObject,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IPreferredRuntimeTypeConcept_CastToPreferredRuntimeType(self: *const T, contextObject: ?*IModelObject, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IPreferredRuntimeTypeConcept.VTable, self.vtable).CastToPreferredRuntimeType(@ptrCast(*const IPreferredRuntimeTypeConcept, self), contextObject, object);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHost_Value = @import("../../zig.zig").Guid.initString("b8c74943-6b2c-4eeb-b5c5-35d378a6d99d");
pub const IID_IDebugHost = &IID_IDebugHost_Value;
pub const IDebugHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHostDefinedInterface: fn(
            self: *const IDebugHost,
            hostUnk: ?*?*IUnknown,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetCurrentContext: fn(
            self: *const IDebugHost,
            context: ?*?*IDebugHostContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultMetadata: fn(
            self: *const IDebugHost,
            defaultMetadataStore: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHost_GetHostDefinedInterface(self: *const T, hostUnk: ?*?*IUnknown) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHost.VTable, self.vtable).GetHostDefinedInterface(@ptrCast(*const IDebugHost, self), hostUnk);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHost_GetCurrentContext(self: *const T, context: ?*?*IDebugHostContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHost.VTable, self.vtable).GetCurrentContext(@ptrCast(*const IDebugHost, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHost_GetDefaultMetadata(self: *const T, defaultMetadataStore: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHost.VTable, self.vtable).GetDefaultMetadata(@ptrCast(*const IDebugHost, self), defaultMetadataStore);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostContext_Value = @import("../../zig.zig").Guid.initString("a68c70d8-5ec0-46e5-b775-3134a48ea2e3");
pub const IID_IDebugHostContext = &IID_IDebugHostContext_Value;
pub const IDebugHostContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsEqualTo: fn(
            self: *const IDebugHostContext,
            pContext: ?*IDebugHostContext,
            pIsEqual: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostContext_IsEqualTo(self: *const T, pContext: ?*IDebugHostContext, pIsEqual: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostContext.VTable, self.vtable).IsEqualTo(@ptrCast(*const IDebugHostContext, self), pContext, pIsEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ErrorClass = enum(i32) {
    Warning = 0,
    Error = 1,
};
pub const ErrorClassWarning = ErrorClass.Warning;
pub const ErrorClassError = ErrorClass.Error;

const IID_IDebugHostErrorSink_Value = @import("../../zig.zig").Guid.initString("c8ff0f0b-fce9-467e-8bb3-5d69ef109c00");
pub const IID_IDebugHostErrorSink = &IID_IDebugHostErrorSink_Value;
pub const IDebugHostErrorSink = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportError: fn(
            self: *const IDebugHostErrorSink,
            errClass: ErrorClass,
            hrError: HRESULT,
            message: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostErrorSink_ReportError(self: *const T, errClass: ErrorClass, hrError: HRESULT, message: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostErrorSink.VTable, self.vtable).ReportError(@ptrCast(*const IDebugHostErrorSink, self), errClass, hrError, message);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbol_Value = @import("../../zig.zig").Guid.initString("0f819103-87de-4e96-8277-e05cd441fb22");
pub const IID_IDebugHostSymbol = &IID_IDebugHostSymbol_Value;
pub const IDebugHostSymbol = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetContext: fn(
            self: *const IDebugHostSymbol,
            context: ?*?*IDebugHostContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateChildren: fn(
            self: *const IDebugHostSymbol,
            kind: SymbolKind,
            name: ?[*:0]const u16,
            ppEnum: ?*?*IDebugHostSymbolEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSymbolKind: fn(
            self: *const IDebugHostSymbol,
            kind: ?*SymbolKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetName: fn(
            self: *const IDebugHostSymbol,
            symbolName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetType: fn(
            self: *const IDebugHostSymbol,
            type: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContainingModule: fn(
            self: *const IDebugHostSymbol,
            containingModule: ?*?*IDebugHostModule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareAgainst: fn(
            self: *const IDebugHostSymbol,
            pComparisonSymbol: ?*IDebugHostSymbol,
            comparisonFlags: u32,
            pMatches: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetContext(self: *const T, context: ?*?*IDebugHostContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbol.VTable, self.vtable).GetContext(@ptrCast(*const IDebugHostSymbol, self), context);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_EnumerateChildren(self: *const T, kind: SymbolKind, name: ?[*:0]const u16, ppEnum: ?*?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbol.VTable, self.vtable).EnumerateChildren(@ptrCast(*const IDebugHostSymbol, self), kind, name, ppEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetSymbolKind(self: *const T, kind: ?*SymbolKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbol.VTable, self.vtable).GetSymbolKind(@ptrCast(*const IDebugHostSymbol, self), kind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetName(self: *const T, symbolName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbol.VTable, self.vtable).GetName(@ptrCast(*const IDebugHostSymbol, self), symbolName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetType(self: *const T, type_: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbol.VTable, self.vtable).GetType(@ptrCast(*const IDebugHostSymbol, self), type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_GetContainingModule(self: *const T, containingModule: ?*?*IDebugHostModule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbol.VTable, self.vtable).GetContainingModule(@ptrCast(*const IDebugHostSymbol, self), containingModule);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol_CompareAgainst(self: *const T, pComparisonSymbol: ?*IDebugHostSymbol, comparisonFlags: u32, pMatches: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbol.VTable, self.vtable).CompareAgainst(@ptrCast(*const IDebugHostSymbol, self), pComparisonSymbol, comparisonFlags, pMatches);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbolEnumerator_Value = @import("../../zig.zig").Guid.initString("28d96c86-10a3-4976-b14e-eaef4790aa1f");
pub const IID_IDebugHostSymbolEnumerator = &IID_IDebugHostSymbolEnumerator_Value;
pub const IDebugHostSymbolEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IDebugHostSymbolEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IDebugHostSymbolEnumerator,
            symbol: ?*?*IDebugHostSymbol,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbolEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbolEnumerator.VTable, self.vtable).Reset(@ptrCast(*const IDebugHostSymbolEnumerator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbolEnumerator_GetNext(self: *const T, symbol: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbolEnumerator.VTable, self.vtable).GetNext(@ptrCast(*const IDebugHostSymbolEnumerator, self), symbol);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostModule_Value = @import("../../zig.zig").Guid.initString("c9ba3e18-d070-4378-bbd0-34613b346e1e");
pub const IID_IDebugHostModule = &IID_IDebugHostModule_Value;
pub const IDebugHostModule = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetImageName: fn(
            self: *const IDebugHostModule,
            allowPath: u8,
            imageName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBaseLocation: fn(
            self: *const IDebugHostModule,
            moduleBaseLocation: ?*Location,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetVersion: fn(
            self: *const IDebugHostModule,
            fileVersion: ?*u64,
            productVersion: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindTypeByName: fn(
            self: *const IDebugHostModule,
            typeName: ?[*:0]const u16,
            type: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSymbolByRVA: fn(
            self: *const IDebugHostModule,
            rva: u64,
            symbol: ?*?*IDebugHostSymbol,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindSymbolByName: fn(
            self: *const IDebugHostModule,
            symbolName: ?[*:0]const u16,
            symbol: ?*?*IDebugHostSymbol,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_GetImageName(self: *const T, allowPath: u8, imageName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostModule.VTable, self.vtable).GetImageName(@ptrCast(*const IDebugHostModule, self), allowPath, imageName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_GetBaseLocation(self: *const T, moduleBaseLocation: ?*Location) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostModule.VTable, self.vtable).GetBaseLocation(@ptrCast(*const IDebugHostModule, self), moduleBaseLocation);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_GetVersion(self: *const T, fileVersion: ?*u64, productVersion: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostModule.VTable, self.vtable).GetVersion(@ptrCast(*const IDebugHostModule, self), fileVersion, productVersion);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_FindTypeByName(self: *const T, typeName: ?[*:0]const u16, type_: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostModule.VTable, self.vtable).FindTypeByName(@ptrCast(*const IDebugHostModule, self), typeName, type_);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_FindSymbolByRVA(self: *const T, rva: u64, symbol: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostModule.VTable, self.vtable).FindSymbolByRVA(@ptrCast(*const IDebugHostModule, self), rva, symbol);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule_FindSymbolByName(self: *const T, symbolName: ?[*:0]const u16, symbol: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostModule.VTable, self.vtable).FindSymbolByName(@ptrCast(*const IDebugHostModule, self), symbolName, symbol);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ArrayDimension = extern struct {
    LowerBound: i64,
    Length: u64,
    Stride: u64,
};

const IID_IDebugHostType_Value = @import("../../zig.zig").Guid.initString("3aadc353-2b14-4abb-9893-5e03458e07ee");
pub const IID_IDebugHostType = &IID_IDebugHostType_Value;
pub const IDebugHostType = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetTypeKind: fn(
            self: *const IDebugHostType,
            kind: ?*TypeKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetSize: fn(
            self: *const IDebugHostType,
            size: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBaseType: fn(
            self: *const IDebugHostType,
            baseType: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetHashCode: fn(
            self: *const IDebugHostType,
            hashCode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetIntrinsicType: fn(
            self: *const IDebugHostType,
            intrinsicKind: ?*IntrinsicKind,
            carrierType: ?*u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetBitField: fn(
            self: *const IDebugHostType,
            lsbOfField: ?*u32,
            lengthOfField: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPointerKind: fn(
            self: *const IDebugHostType,
            pointerKind: ?*PointerKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMemberType: fn(
            self: *const IDebugHostType,
            memberType: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreatePointerTo: fn(
            self: *const IDebugHostType,
            kind: PointerKind,
            newType: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetArrayDimensionality: fn(
            self: *const IDebugHostType,
            arrayDimensionality: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetArrayDimensions: fn(
            self: *const IDebugHostType,
            dimensions: u64,
            pDimensions: [*]ArrayDimension,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateArrayOf: fn(
            self: *const IDebugHostType,
            dimensions: u64,
            pDimensions: [*]ArrayDimension,
            newType: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionCallingConvention: fn(
            self: *const IDebugHostType,
            conventionKind: ?*CallingConventionKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionReturnType: fn(
            self: *const IDebugHostType,
            returnType: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionParameterTypeCount: fn(
            self: *const IDebugHostType,
            count: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionParameterTypeAt: fn(
            self: *const IDebugHostType,
            i: u64,
            parameterType: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsGeneric: fn(
            self: *const IDebugHostType,
            isGeneric: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenericArgumentCount: fn(
            self: *const IDebugHostType,
            argCount: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetGenericArgumentAt: fn(
            self: *const IDebugHostType,
            i: u64,
            argument: ?*?*IDebugHostSymbol,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetTypeKind(self: *const T, kind: ?*TypeKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetTypeKind(@ptrCast(*const IDebugHostType, self), kind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetSize(self: *const T, size: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetSize(@ptrCast(*const IDebugHostType, self), size);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetBaseType(self: *const T, baseType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetBaseType(@ptrCast(*const IDebugHostType, self), baseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetHashCode(self: *const T, hashCode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetHashCode(@ptrCast(*const IDebugHostType, self), hashCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetIntrinsicType(self: *const T, intrinsicKind: ?*IntrinsicKind, carrierType: ?*u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetIntrinsicType(@ptrCast(*const IDebugHostType, self), intrinsicKind, carrierType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetBitField(self: *const T, lsbOfField: ?*u32, lengthOfField: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetBitField(@ptrCast(*const IDebugHostType, self), lsbOfField, lengthOfField);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetPointerKind(self: *const T, pointerKind: ?*PointerKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetPointerKind(@ptrCast(*const IDebugHostType, self), pointerKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetMemberType(self: *const T, memberType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetMemberType(@ptrCast(*const IDebugHostType, self), memberType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_CreatePointerTo(self: *const T, kind: PointerKind, newType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).CreatePointerTo(@ptrCast(*const IDebugHostType, self), kind, newType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetArrayDimensionality(self: *const T, arrayDimensionality: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetArrayDimensionality(@ptrCast(*const IDebugHostType, self), arrayDimensionality);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetArrayDimensions(self: *const T, dimensions: u64, pDimensions: [*]ArrayDimension) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetArrayDimensions(@ptrCast(*const IDebugHostType, self), dimensions, pDimensions);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_CreateArrayOf(self: *const T, dimensions: u64, pDimensions: [*]ArrayDimension, newType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).CreateArrayOf(@ptrCast(*const IDebugHostType, self), dimensions, pDimensions, newType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetFunctionCallingConvention(self: *const T, conventionKind: ?*CallingConventionKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetFunctionCallingConvention(@ptrCast(*const IDebugHostType, self), conventionKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetFunctionReturnType(self: *const T, returnType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetFunctionReturnType(@ptrCast(*const IDebugHostType, self), returnType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetFunctionParameterTypeCount(self: *const T, count: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetFunctionParameterTypeCount(@ptrCast(*const IDebugHostType, self), count);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetFunctionParameterTypeAt(self: *const T, i: u64, parameterType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetFunctionParameterTypeAt(@ptrCast(*const IDebugHostType, self), i, parameterType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_IsGeneric(self: *const T, isGeneric: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).IsGeneric(@ptrCast(*const IDebugHostType, self), isGeneric);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetGenericArgumentCount(self: *const T, argCount: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetGenericArgumentCount(@ptrCast(*const IDebugHostType, self), argCount);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType_GetGenericArgumentAt(self: *const T, i: u64, argument: ?*?*IDebugHostSymbol) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType.VTable, self.vtable).GetGenericArgumentAt(@ptrCast(*const IDebugHostType, self), i, argument);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostConstant_Value = @import("../../zig.zig").Guid.initString("62787edc-fa76-4690-bd71-5e8c3e2937ec");
pub const IID_IDebugHostConstant = &IID_IDebugHostConstant_Value;
pub const IDebugHostConstant = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetValue: fn(
            self: *const IDebugHostConstant,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostConstant_GetValue(self: *const T, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostConstant.VTable, self.vtable).GetValue(@ptrCast(*const IDebugHostConstant, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostField_Value = @import("../../zig.zig").Guid.initString("e06f6495-16bc-4cc9-b11d-2a6b23fa72f3");
pub const IID_IDebugHostField = &IID_IDebugHostField_Value;
pub const IDebugHostField = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: fn(
            self: *const IDebugHostField,
            locationKind: ?*LocationKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetOffset: fn(
            self: *const IDebugHostField,
            offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocation: fn(
            self: *const IDebugHostField,
            location: ?*Location,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IDebugHostField,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostField_GetLocationKind(self: *const T, locationKind: ?*LocationKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostField.VTable, self.vtable).GetLocationKind(@ptrCast(*const IDebugHostField, self), locationKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostField_GetOffset(self: *const T, offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostField.VTable, self.vtable).GetOffset(@ptrCast(*const IDebugHostField, self), offset);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostField_GetLocation(self: *const T, location: ?*Location) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostField.VTable, self.vtable).GetLocation(@ptrCast(*const IDebugHostField, self), location);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostField_GetValue(self: *const T, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostField.VTable, self.vtable).GetValue(@ptrCast(*const IDebugHostField, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostData_Value = @import("../../zig.zig").Guid.initString("a3d64993-826c-44fa-897d-926f2fe7ad0b");
pub const IID_IDebugHostData = &IID_IDebugHostData_Value;
pub const IDebugHostData = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: fn(
            self: *const IDebugHostData,
            locationKind: ?*LocationKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocation: fn(
            self: *const IDebugHostData,
            location: ?*Location,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetValue: fn(
            self: *const IDebugHostData,
            value: ?*VARIANT,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostData_GetLocationKind(self: *const T, locationKind: ?*LocationKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostData.VTable, self.vtable).GetLocationKind(@ptrCast(*const IDebugHostData, self), locationKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostData_GetLocation(self: *const T, location: ?*Location) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostData.VTable, self.vtable).GetLocation(@ptrCast(*const IDebugHostData, self), location);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostData_GetValue(self: *const T, value: ?*VARIANT) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostData.VTable, self.vtable).GetValue(@ptrCast(*const IDebugHostData, self), value);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostPublic_Value = @import("../../zig.zig").Guid.initString("6c597ac9-fb4d-4f6d-9f39-22488539f8f4");
pub const IID_IDebugHostPublic = &IID_IDebugHostPublic_Value;
pub const IDebugHostPublic = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLocationKind: fn(
            self: *const IDebugHostPublic,
            locationKind: ?*LocationKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetLocation: fn(
            self: *const IDebugHostPublic,
            location: ?*Location,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostPublic_GetLocationKind(self: *const T, locationKind: ?*LocationKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostPublic.VTable, self.vtable).GetLocationKind(@ptrCast(*const IDebugHostPublic, self), locationKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostPublic_GetLocation(self: *const T, location: ?*Location) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostPublic.VTable, self.vtable).GetLocation(@ptrCast(*const IDebugHostPublic, self), location);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostBaseClass_Value = @import("../../zig.zig").Guid.initString("b94d57d2-390b-40f7-b5b4-b6db897d974b");
pub const IID_IDebugHostBaseClass = &IID_IDebugHostBaseClass_Value;
pub const IDebugHostBaseClass = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetOffset: fn(
            self: *const IDebugHostBaseClass,
            offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostBaseClass_GetOffset(self: *const T, offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostBaseClass.VTable, self.vtable).GetOffset(@ptrCast(*const IDebugHostBaseClass, self), offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostSymbols_Value = @import("../../zig.zig").Guid.initString("854fd751-c2e1-4eb2-b525-6619cb97a588");
pub const IID_IDebugHostSymbols = &IID_IDebugHostSymbols_Value;
pub const IDebugHostSymbols = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateModuleSignature: fn(
            self: *const IDebugHostSymbols,
            pwszModuleName: ?[*:0]const u16,
            pwszMinVersion: ?[*:0]const u16,
            pwszMaxVersion: ?[*:0]const u16,
            ppModuleSignature: ?*?*IDebugHostModuleSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTypeSignature: fn(
            self: *const IDebugHostSymbols,
            signatureSpecification: ?[*:0]const u16,
            module: ?*IDebugHostModule,
            typeSignature: ?*?*IDebugHostTypeSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTypeSignatureForModuleRange: fn(
            self: *const IDebugHostSymbols,
            signatureSpecification: ?[*:0]const u16,
            moduleName: ?[*:0]const u16,
            minVersion: ?[*:0]const u16,
            maxVersion: ?[*:0]const u16,
            typeSignature: ?*?*IDebugHostTypeSignature,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateModules: fn(
            self: *const IDebugHostSymbols,
            context: ?*IDebugHostContext,
            moduleEnum: ?*?*IDebugHostSymbolEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindModuleByName: fn(
            self: *const IDebugHostSymbols,
            context: ?*IDebugHostContext,
            moduleName: ?[*:0]const u16,
            module: ?*?*IDebugHostModule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindModuleByLocation: fn(
            self: *const IDebugHostSymbols,
            context: ?*IDebugHostContext,
            moduleLocation: Location,
            module: ?*?*IDebugHostModule,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetMostDerivedObject: fn(
            self: *const IDebugHostSymbols,
            pContext: ?*IDebugHostContext,
            location: Location,
            objectType: ?*IDebugHostType,
            derivedLocation: ?*Location,
            derivedType: ?*?*IDebugHostType,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_CreateModuleSignature(self: *const T, pwszModuleName: ?[*:0]const u16, pwszMinVersion: ?[*:0]const u16, pwszMaxVersion: ?[*:0]const u16, ppModuleSignature: ?*?*IDebugHostModuleSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbols.VTable, self.vtable).CreateModuleSignature(@ptrCast(*const IDebugHostSymbols, self), pwszModuleName, pwszMinVersion, pwszMaxVersion, ppModuleSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_CreateTypeSignature(self: *const T, signatureSpecification: ?[*:0]const u16, module: ?*IDebugHostModule, typeSignature: ?*?*IDebugHostTypeSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbols.VTable, self.vtable).CreateTypeSignature(@ptrCast(*const IDebugHostSymbols, self), signatureSpecification, module, typeSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_CreateTypeSignatureForModuleRange(self: *const T, signatureSpecification: ?[*:0]const u16, moduleName: ?[*:0]const u16, minVersion: ?[*:0]const u16, maxVersion: ?[*:0]const u16, typeSignature: ?*?*IDebugHostTypeSignature) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbols.VTable, self.vtable).CreateTypeSignatureForModuleRange(@ptrCast(*const IDebugHostSymbols, self), signatureSpecification, moduleName, minVersion, maxVersion, typeSignature);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_EnumerateModules(self: *const T, context: ?*IDebugHostContext, moduleEnum: ?*?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbols.VTable, self.vtable).EnumerateModules(@ptrCast(*const IDebugHostSymbols, self), context, moduleEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_FindModuleByName(self: *const T, context: ?*IDebugHostContext, moduleName: ?[*:0]const u16, module: ?*?*IDebugHostModule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbols.VTable, self.vtable).FindModuleByName(@ptrCast(*const IDebugHostSymbols, self), context, moduleName, module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_FindModuleByLocation(self: *const T, context: ?*IDebugHostContext, moduleLocation: Location, module: ?*?*IDebugHostModule) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbols.VTable, self.vtable).FindModuleByLocation(@ptrCast(*const IDebugHostSymbols, self), context, moduleLocation, module);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbols_GetMostDerivedObject(self: *const T, pContext: ?*IDebugHostContext, location: Location, objectType: ?*IDebugHostType, derivedLocation: ?*Location, derivedType: ?*?*IDebugHostType) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbols.VTable, self.vtable).GetMostDerivedObject(@ptrCast(*const IDebugHostSymbols, self), pContext, location, objectType, derivedLocation, derivedType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostMemory_Value = @import("../../zig.zig").Guid.initString("212149c9-9183-4a3e-b00e-4fd1dc95339b");
pub const IID_IDebugHostMemory = &IID_IDebugHostMemory_Value;
pub const IDebugHostMemory = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReadBytes: fn(
            self: *const IDebugHostMemory,
            context: ?*IDebugHostContext,
            location: Location,
            // TODO: what to do with BytesParamIndex 3?
            buffer: ?*c_void,
            bufferSize: u64,
            bytesRead: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WriteBytes: fn(
            self: *const IDebugHostMemory,
            context: ?*IDebugHostContext,
            location: Location,
            // TODO: what to do with BytesParamIndex 3?
            buffer: ?*c_void,
            bufferSize: u64,
            bytesWritten: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        ReadPointers: fn(
            self: *const IDebugHostMemory,
            context: ?*IDebugHostContext,
            location: Location,
            count: u64,
            pointers: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        WritePointers: fn(
            self: *const IDebugHostMemory,
            context: ?*IDebugHostContext,
            location: Location,
            count: u64,
            pointers: [*]u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDisplayStringForLocation: fn(
            self: *const IDebugHostMemory,
            context: ?*IDebugHostContext,
            location: Location,
            verbose: u8,
            locationName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_ReadBytes(self: *const T, context: ?*IDebugHostContext, location: Location, buffer: ?*c_void, bufferSize: u64, bytesRead: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostMemory.VTable, self.vtable).ReadBytes(@ptrCast(*const IDebugHostMemory, self), context, location, buffer, bufferSize, bytesRead);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_WriteBytes(self: *const T, context: ?*IDebugHostContext, location: Location, buffer: ?*c_void, bufferSize: u64, bytesWritten: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostMemory.VTable, self.vtable).WriteBytes(@ptrCast(*const IDebugHostMemory, self), context, location, buffer, bufferSize, bytesWritten);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_ReadPointers(self: *const T, context: ?*IDebugHostContext, location: Location, count: u64, pointers: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostMemory.VTable, self.vtable).ReadPointers(@ptrCast(*const IDebugHostMemory, self), context, location, count, pointers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_WritePointers(self: *const T, context: ?*IDebugHostContext, location: Location, count: u64, pointers: [*]u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostMemory.VTable, self.vtable).WritePointers(@ptrCast(*const IDebugHostMemory, self), context, location, count, pointers);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory_GetDisplayStringForLocation(self: *const T, context: ?*IDebugHostContext, location: Location, verbose: u8, locationName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostMemory.VTable, self.vtable).GetDisplayStringForLocation(@ptrCast(*const IDebugHostMemory, self), context, location, verbose, locationName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostEvaluator_Value = @import("../../zig.zig").Guid.initString("0fef9a21-577e-4997-ac7b-1c4883241d99");
pub const IID_IDebugHostEvaluator = &IID_IDebugHostEvaluator_Value;
pub const IDebugHostEvaluator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        EvaluateExpression: fn(
            self: *const IDebugHostEvaluator,
            context: ?*IDebugHostContext,
            expression: ?[*:0]const u16,
            bindingContext: ?*IModelObject,
            result: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EvaluateExtendedExpression: fn(
            self: *const IDebugHostEvaluator,
            context: ?*IDebugHostContext,
            expression: ?[*:0]const u16,
            bindingContext: ?*IModelObject,
            result: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostEvaluator_EvaluateExpression(self: *const T, context: ?*IDebugHostContext, expression: ?[*:0]const u16, bindingContext: ?*IModelObject, result: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostEvaluator.VTable, self.vtable).EvaluateExpression(@ptrCast(*const IDebugHostEvaluator, self), context, expression, bindingContext, result, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostEvaluator_EvaluateExtendedExpression(self: *const T, context: ?*IDebugHostContext, expression: ?[*:0]const u16, bindingContext: ?*IModelObject, result: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostEvaluator.VTable, self.vtable).EvaluateExtendedExpression(@ptrCast(*const IDebugHostEvaluator, self), context, expression, bindingContext, result, metadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SignatureComparison = enum(i32) {
    Unrelated = 0,
    Ambiguous = 1,
    LessSpecific = 2,
    MoreSpecific = 3,
    Identical = 4,
};
pub const Unrelated = SignatureComparison.Unrelated;
pub const Ambiguous = SignatureComparison.Ambiguous;
pub const LessSpecific = SignatureComparison.LessSpecific;
pub const MoreSpecific = SignatureComparison.MoreSpecific;
pub const Identical = SignatureComparison.Identical;

const IID_IDebugHostModuleSignature_Value = @import("../../zig.zig").Guid.initString("31e53a5a-01ee-4bbb-b899-4b46ae7d595c");
pub const IID_IDebugHostModuleSignature = &IID_IDebugHostModuleSignature_Value;
pub const IDebugHostModuleSignature = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        IsMatch: fn(
            self: *const IDebugHostModuleSignature,
            pModule: ?*IDebugHostModule,
            isMatch: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModuleSignature_IsMatch(self: *const T, pModule: ?*IDebugHostModule, isMatch: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostModuleSignature.VTable, self.vtable).IsMatch(@ptrCast(*const IDebugHostModuleSignature, self), pModule, isMatch);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostTypeSignature_Value = @import("../../zig.zig").Guid.initString("3aadc353-2b14-4abb-9893-5e03458e07ee");
pub const IID_IDebugHostTypeSignature = &IID_IDebugHostTypeSignature_Value;
pub const IDebugHostTypeSignature = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetHashCode: fn(
            self: *const IDebugHostTypeSignature,
            hashCode: ?*u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsMatch: fn(
            self: *const IDebugHostTypeSignature,
            type: ?*IDebugHostType,
            isMatch: ?*bool,
            wildcardMatches: ?*?*IDebugHostSymbolEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CompareAgainst: fn(
            self: *const IDebugHostTypeSignature,
            typeSignature: ?*IDebugHostTypeSignature,
            result: ?*SignatureComparison,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostTypeSignature_GetHashCode(self: *const T, hashCode: ?*u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostTypeSignature.VTable, self.vtable).GetHashCode(@ptrCast(*const IDebugHostTypeSignature, self), hashCode);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostTypeSignature_IsMatch(self: *const T, type_: ?*IDebugHostType, isMatch: ?*bool, wildcardMatches: ?*?*IDebugHostSymbolEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostTypeSignature.VTable, self.vtable).IsMatch(@ptrCast(*const IDebugHostTypeSignature, self), type_, isMatch, wildcardMatches);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostTypeSignature_CompareAgainst(self: *const T, typeSignature: ?*IDebugHostTypeSignature, result: ?*SignatureComparison) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostTypeSignature.VTable, self.vtable).CompareAgainst(@ptrCast(*const IDebugHostTypeSignature, self), typeSignature, result);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const SymbolSearchOptions = enum(i32) {
    None = 0,
    Completion = 1,
};
pub const SymbolSearchNone = SymbolSearchOptions.None;
pub const SymbolSearchCompletion = SymbolSearchOptions.Completion;

pub const LanguageKind = enum(i32) {
    Unknown = 0,
    C = 1,
    CPP = 2,
    Assembly = 3,
};
pub const LanguageUnknown = LanguageKind.Unknown;
pub const LanguageC = LanguageKind.C;
pub const LanguageCPP = LanguageKind.CPP;
pub const LanguageAssembly = LanguageKind.Assembly;

const IID_IDebugHostSymbol2_Value = @import("../../zig.zig").Guid.initString("21515b67-6720-4257-8a68-077dc944471c");
pub const IID_IDebugHostSymbol2 = &IID_IDebugHostSymbol2_Value;
pub const IDebugHostSymbol2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostSymbol.VTable,
        GetLanguage: fn(
            self: *const IDebugHostSymbol2,
            pKind: ?*LanguageKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostSymbol.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostSymbol2_GetLanguage(self: *const T, pKind: ?*LanguageKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostSymbol2.VTable, self.vtable).GetLanguage(@ptrCast(*const IDebugHostSymbol2, self), pKind);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const VarArgsKind = enum(i32) {
    None = 0,
    CStyle = 1,
};
pub const VarArgsNone = VarArgsKind.None;
pub const VarArgsCStyle = VarArgsKind.CStyle;

const IID_IDebugHostType2_Value = @import("../../zig.zig").Guid.initString("b28632b9-8506-4676-87ce-8f7e05e59876");
pub const IID_IDebugHostType2 = &IID_IDebugHostType2_Value;
pub const IDebugHostType2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostType.VTable,
        IsTypedef: fn(
            self: *const IDebugHostType2,
            isTypedef: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypedefBaseType: fn(
            self: *const IDebugHostType2,
            baseType: ?*?*IDebugHostType2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTypedefFinalBaseType: fn(
            self: *const IDebugHostType2,
            finalBaseType: ?*?*IDebugHostType2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionVarArgsKind: fn(
            self: *const IDebugHostType2,
            varArgsKind: ?*VarArgsKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetFunctionInstancePointerType: fn(
            self: *const IDebugHostType2,
            instancePointerType: ?*?*IDebugHostType2,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostType.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_IsTypedef(self: *const T, isTypedef: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType2.VTable, self.vtable).IsTypedef(@ptrCast(*const IDebugHostType2, self), isTypedef);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_GetTypedefBaseType(self: *const T, baseType: ?*?*IDebugHostType2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType2.VTable, self.vtable).GetTypedefBaseType(@ptrCast(*const IDebugHostType2, self), baseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_GetTypedefFinalBaseType(self: *const T, finalBaseType: ?*?*IDebugHostType2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType2.VTable, self.vtable).GetTypedefFinalBaseType(@ptrCast(*const IDebugHostType2, self), finalBaseType);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_GetFunctionVarArgsKind(self: *const T, varArgsKind: ?*VarArgsKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType2.VTable, self.vtable).GetFunctionVarArgsKind(@ptrCast(*const IDebugHostType2, self), varArgsKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostType2_GetFunctionInstancePointerType(self: *const T, instancePointerType: ?*?*IDebugHostType2) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostType2.VTable, self.vtable).GetFunctionInstancePointerType(@ptrCast(*const IDebugHostType2, self), instancePointerType);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostStatus_Value = @import("../../zig.zig").Guid.initString("4f3e1ce2-86b2-4c7a-9c65-d0a9d0eecf44");
pub const IID_IDebugHostStatus = &IID_IDebugHostStatus_Value;
pub const IDebugHostStatus = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        PollUserInterrupt: fn(
            self: *const IDebugHostStatus,
            interruptRequested: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostStatus_PollUserInterrupt(self: *const T, interruptRequested: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostStatus.VTable, self.vtable).PollUserInterrupt(@ptrCast(*const IDebugHostStatus, self), interruptRequested);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptClient_Value = @import("../../zig.zig").Guid.initString("3b362b0e-89f0-46c6-a663-dfdc95194aef");
pub const IID_IDataModelScriptClient = &IID_IDataModelScriptClient_Value;
pub const IDataModelScriptClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        ReportError: fn(
            self: *const IDataModelScriptClient,
            errClass: ErrorClass,
            hrFail: HRESULT,
            message: ?[*:0]const u16,
            line: u32,
            position: u32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptClient_ReportError(self: *const T, errClass: ErrorClass, hrFail: HRESULT, message: ?[*:0]const u16, line: u32, position: u32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptClient.VTable, self.vtable).ReportError(@ptrCast(*const IDataModelScriptClient, self), errClass, hrFail, message, line, position);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptTemplate_Value = @import("../../zig.zig").Guid.initString("1303dec4-fa3b-4f1b-9224-b953d16babb5");
pub const IID_IDataModelScriptTemplate = &IID_IDataModelScriptTemplate_Value;
pub const IDataModelScriptTemplate = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IDataModelScriptTemplate,
            templateName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDescription: fn(
            self: *const IDataModelScriptTemplate,
            templateDescription: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetContent: fn(
            self: *const IDataModelScriptTemplate,
            contentStream: ?*?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplate_GetName(self: *const T, templateName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptTemplate.VTable, self.vtable).GetName(@ptrCast(*const IDataModelScriptTemplate, self), templateName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplate_GetDescription(self: *const T, templateDescription: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptTemplate.VTable, self.vtable).GetDescription(@ptrCast(*const IDataModelScriptTemplate, self), templateDescription);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplate_GetContent(self: *const T, contentStream: ?*?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptTemplate.VTable, self.vtable).GetContent(@ptrCast(*const IDataModelScriptTemplate, self), contentStream);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScript_Value = @import("../../zig.zig").Guid.initString("7b4d30fc-b14a-49f8-8d87-d9a1480c97f7");
pub const IID_IDataModelScript = &IID_IDataModelScript_Value;
pub const IDataModelScript = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IDataModelScript,
            scriptName: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Rename: fn(
            self: *const IDataModelScript,
            scriptName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Populate: fn(
            self: *const IDataModelScript,
            contentStream: ?*IStream,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Execute: fn(
            self: *const IDataModelScript,
            client: ?*IDataModelScriptClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Unlink: fn(
            self: *const IDataModelScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsInvocable: fn(
            self: *const IDataModelScript,
            isInvocable: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        InvokeMain: fn(
            self: *const IDataModelScript,
            client: ?*IDataModelScriptClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_GetName(self: *const T, scriptName: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScript.VTable, self.vtable).GetName(@ptrCast(*const IDataModelScript, self), scriptName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_Rename(self: *const T, scriptName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScript.VTable, self.vtable).Rename(@ptrCast(*const IDataModelScript, self), scriptName);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_Populate(self: *const T, contentStream: ?*IStream) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScript.VTable, self.vtable).Populate(@ptrCast(*const IDataModelScript, self), contentStream);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_Execute(self: *const T, client: ?*IDataModelScriptClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScript.VTable, self.vtable).Execute(@ptrCast(*const IDataModelScript, self), client);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_Unlink(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScript.VTable, self.vtable).Unlink(@ptrCast(*const IDataModelScript, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_IsInvocable(self: *const T, isInvocable: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScript.VTable, self.vtable).IsInvocable(@ptrCast(*const IDataModelScript, self), isInvocable);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScript_InvokeMain(self: *const T, client: ?*IDataModelScriptClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScript.VTable, self.vtable).InvokeMain(@ptrCast(*const IDataModelScript, self), client);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptTemplateEnumerator_Value = @import("../../zig.zig").Guid.initString("69ce6ae2-2268-4e6f-b062-20ce62bfe677");
pub const IID_IDataModelScriptTemplateEnumerator = &IID_IDataModelScriptTemplateEnumerator_Value;
pub const IDataModelScriptTemplateEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IDataModelScriptTemplateEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IDataModelScriptTemplateEnumerator,
            templateContent: ?*?*IDataModelScriptTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplateEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptTemplateEnumerator.VTable, self.vtable).Reset(@ptrCast(*const IDataModelScriptTemplateEnumerator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptTemplateEnumerator_GetNext(self: *const T, templateContent: ?*?*IDataModelScriptTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptTemplateEnumerator.VTable, self.vtable).GetNext(@ptrCast(*const IDataModelScriptTemplateEnumerator, self), templateContent);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptProvider_Value = @import("../../zig.zig").Guid.initString("513461e0-4fca-48ce-8658-32f3e2056f3b");
pub const IID_IDataModelScriptProvider = &IID_IDataModelScriptProvider_Value;
pub const IDataModelScriptProvider = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IDataModelScriptProvider,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetExtension: fn(
            self: *const IDataModelScriptProvider,
            extension: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateScript: fn(
            self: *const IDataModelScriptProvider,
            script: ?*?*IDataModelScript,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetDefaultTemplateContent: fn(
            self: *const IDataModelScriptProvider,
            templateContent: ?*?*IDataModelScriptTemplate,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateTemplates: fn(
            self: *const IDataModelScriptProvider,
            enumerator: ?*?*IDataModelScriptTemplateEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_GetName(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptProvider.VTable, self.vtable).GetName(@ptrCast(*const IDataModelScriptProvider, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_GetExtension(self: *const T, extension: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptProvider.VTable, self.vtable).GetExtension(@ptrCast(*const IDataModelScriptProvider, self), extension);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_CreateScript(self: *const T, script: ?*?*IDataModelScript) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptProvider.VTable, self.vtable).CreateScript(@ptrCast(*const IDataModelScriptProvider, self), script);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_GetDefaultTemplateContent(self: *const T, templateContent: ?*?*IDataModelScriptTemplate) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptProvider.VTable, self.vtable).GetDefaultTemplateContent(@ptrCast(*const IDataModelScriptProvider, self), templateContent);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProvider_EnumerateTemplates(self: *const T, enumerator: ?*?*IDataModelScriptTemplateEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptProvider.VTable, self.vtable).EnumerateTemplates(@ptrCast(*const IDataModelScriptProvider, self), enumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptProviderEnumerator_Value = @import("../../zig.zig").Guid.initString("95ba00e2-704a-4fe2-a8f1-a7e7d8fb0941");
pub const IID_IDataModelScriptProviderEnumerator = &IID_IDataModelScriptProviderEnumerator_Value;
pub const IDataModelScriptProviderEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IDataModelScriptProviderEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IDataModelScriptProviderEnumerator,
            provider: ?*?*IDataModelScriptProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProviderEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptProviderEnumerator.VTable, self.vtable).Reset(@ptrCast(*const IDataModelScriptProviderEnumerator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptProviderEnumerator_GetNext(self: *const T, provider: ?*?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptProviderEnumerator.VTable, self.vtable).GetNext(@ptrCast(*const IDataModelScriptProviderEnumerator, self), provider);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptManager_Value = @import("../../zig.zig").Guid.initString("6fd11e33-e5ad-410b-8011-68c6bc4bf80d");
pub const IID_IDataModelScriptManager = &IID_IDataModelScriptManager_Value;
pub const IDataModelScriptManager = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDefaultNameBinder: fn(
            self: *const IDataModelScriptManager,
            ppNameBinder: ?*?*IDataModelNameBinder,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        RegisterScriptProvider: fn(
            self: *const IDataModelScriptManager,
            provider: ?*IDataModelScriptProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        UnregisterScriptProvider: fn(
            self: *const IDataModelScriptManager,
            provider: ?*IDataModelScriptProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindProviderForScriptType: fn(
            self: *const IDataModelScriptManager,
            scriptType: ?[*:0]const u16,
            provider: ?*?*IDataModelScriptProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindProviderForScriptExtension: fn(
            self: *const IDataModelScriptManager,
            scriptExtension: ?[*:0]const u16,
            provider: ?*?*IDataModelScriptProvider,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateScriptProviders: fn(
            self: *const IDataModelScriptManager,
            enumerator: ?*?*IDataModelScriptProviderEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_GetDefaultNameBinder(self: *const T, ppNameBinder: ?*?*IDataModelNameBinder) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptManager.VTable, self.vtable).GetDefaultNameBinder(@ptrCast(*const IDataModelScriptManager, self), ppNameBinder);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_RegisterScriptProvider(self: *const T, provider: ?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptManager.VTable, self.vtable).RegisterScriptProvider(@ptrCast(*const IDataModelScriptManager, self), provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_UnregisterScriptProvider(self: *const T, provider: ?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptManager.VTable, self.vtable).UnregisterScriptProvider(@ptrCast(*const IDataModelScriptManager, self), provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_FindProviderForScriptType(self: *const T, scriptType: ?[*:0]const u16, provider: ?*?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptManager.VTable, self.vtable).FindProviderForScriptType(@ptrCast(*const IDataModelScriptManager, self), scriptType, provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_FindProviderForScriptExtension(self: *const T, scriptExtension: ?[*:0]const u16, provider: ?*?*IDataModelScriptProvider) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptManager.VTable, self.vtable).FindProviderForScriptExtension(@ptrCast(*const IDataModelScriptManager, self), scriptExtension, provider);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptManager_EnumerateScriptProviders(self: *const T, enumerator: ?*?*IDataModelScriptProviderEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptManager.VTable, self.vtable).EnumerateScriptProviders(@ptrCast(*const IDataModelScriptManager, self), enumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicKeyProviderConcept_Value = @import("../../zig.zig").Guid.initString("e7983fa1-80a7-498c-988f-518ddc5d4025");
pub const IID_IDynamicKeyProviderConcept = &IID_IDynamicKeyProviderConcept_Value;
pub const IDynamicKeyProviderConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetKey: fn(
            self: *const IDynamicKeyProviderConcept,
            contextObject: ?*IModelObject,
            key: ?[*:0]const u16,
            keyValue: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
            hasKey: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetKey: fn(
            self: *const IDynamicKeyProviderConcept,
            contextObject: ?*IModelObject,
            key: ?[*:0]const u16,
            keyValue: ?*IModelObject,
            metadata: ?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateKeys: fn(
            self: *const IDynamicKeyProviderConcept,
            contextObject: ?*IModelObject,
            ppEnumerator: ?*?*IKeyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicKeyProviderConcept_GetKey(self: *const T, contextObject: ?*IModelObject, key: ?[*:0]const u16, keyValue: ?*?*IModelObject, metadata: ?*?*IKeyStore, hasKey: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicKeyProviderConcept.VTable, self.vtable).GetKey(@ptrCast(*const IDynamicKeyProviderConcept, self), contextObject, key, keyValue, metadata, hasKey);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicKeyProviderConcept_SetKey(self: *const T, contextObject: ?*IModelObject, key: ?[*:0]const u16, keyValue: ?*IModelObject, metadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicKeyProviderConcept.VTable, self.vtable).SetKey(@ptrCast(*const IDynamicKeyProviderConcept, self), contextObject, key, keyValue, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicKeyProviderConcept_EnumerateKeys(self: *const T, contextObject: ?*IModelObject, ppEnumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicKeyProviderConcept.VTable, self.vtable).EnumerateKeys(@ptrCast(*const IDynamicKeyProviderConcept, self), contextObject, ppEnumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDynamicConceptProviderConcept_Value = @import("../../zig.zig").Guid.initString("95a7f7dd-602e-483f-9d06-a15c0ee13174");
pub const IID_IDynamicConceptProviderConcept = &IID_IDynamicConceptProviderConcept_Value;
pub const IDynamicConceptProviderConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetConcept: fn(
            self: *const IDynamicConceptProviderConcept,
            contextObject: ?*IModelObject,
            conceptId: ?*const Guid,
            conceptInterface: ?*?*IUnknown,
            conceptMetadata: ?*?*IKeyStore,
            hasConcept: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetConcept: fn(
            self: *const IDynamicConceptProviderConcept,
            contextObject: ?*IModelObject,
            conceptId: ?*const Guid,
            conceptInterface: ?*IUnknown,
            conceptMetadata: ?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyParent: fn(
            self: *const IDynamicConceptProviderConcept,
            parentModel: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyParentChange: fn(
            self: *const IDynamicConceptProviderConcept,
            parentModel: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        NotifyDestruct: fn(
            self: *const IDynamicConceptProviderConcept,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_GetConcept(self: *const T, contextObject: ?*IModelObject, conceptId: ?*const Guid, conceptInterface: ?*?*IUnknown, conceptMetadata: ?*?*IKeyStore, hasConcept: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicConceptProviderConcept.VTable, self.vtable).GetConcept(@ptrCast(*const IDynamicConceptProviderConcept, self), contextObject, conceptId, conceptInterface, conceptMetadata, hasConcept);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_SetConcept(self: *const T, contextObject: ?*IModelObject, conceptId: ?*const Guid, conceptInterface: ?*IUnknown, conceptMetadata: ?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicConceptProviderConcept.VTable, self.vtable).SetConcept(@ptrCast(*const IDynamicConceptProviderConcept, self), contextObject, conceptId, conceptInterface, conceptMetadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_NotifyParent(self: *const T, parentModel: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicConceptProviderConcept.VTable, self.vtable).NotifyParent(@ptrCast(*const IDynamicConceptProviderConcept, self), parentModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_NotifyParentChange(self: *const T, parentModel: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicConceptProviderConcept.VTable, self.vtable).NotifyParentChange(@ptrCast(*const IDynamicConceptProviderConcept, self), parentModel);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDynamicConceptProviderConcept_NotifyDestruct(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDynamicConceptProviderConcept.VTable, self.vtable).NotifyDestruct(@ptrCast(*const IDynamicConceptProviderConcept, self));
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ScriptChangeKind = enum(i32) {
    e = 0,
};
pub const ScriptRename = ScriptChangeKind.e;

const IID_IDataModelScriptHostContext_Value = @import("../../zig.zig").Guid.initString("014d366a-1f23-4981-9219-b2db8b402054");
pub const IID_IDataModelScriptHostContext = &IID_IDataModelScriptHostContext_Value;
pub const IDataModelScriptHostContext = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyScriptChange: fn(
            self: *const IDataModelScriptHostContext,
            script: ?*IDataModelScript,
            changeKind: ScriptChangeKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNamespaceObject: fn(
            self: *const IDataModelScriptHostContext,
            namespaceObject: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptHostContext_NotifyScriptChange(self: *const T, script: ?*IDataModelScript, changeKind: ScriptChangeKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptHostContext.VTable, self.vtable).NotifyScriptChange(@ptrCast(*const IDataModelScriptHostContext, self), script, changeKind);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptHostContext_GetNamespaceObject(self: *const T, namespaceObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptHostContext.VTable, self.vtable).GetNamespaceObject(@ptrCast(*const IDataModelScriptHostContext, self), namespaceObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostScriptHost_Value = @import("../../zig.zig").Guid.initString("b70334a4-b92c-4570-93a1-d3eb686649a0");
pub const IID_IDebugHostScriptHost = &IID_IDebugHostScriptHost_Value;
pub const IDebugHostScriptHost = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateContext: fn(
            self: *const IDebugHostScriptHost,
            script: ?*IDataModelScript,
            scriptContext: ?*?*IDataModelScriptHostContext,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostScriptHost_CreateContext(self: *const T, script: ?*IDataModelScript, scriptContext: ?*?*IDataModelScriptHostContext) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostScriptHost.VTable, self.vtable).CreateContext(@ptrCast(*const IDebugHostScriptHost, self), script, scriptContext);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelNameBinder_Value = @import("../../zig.zig").Guid.initString("af352b7b-8292-4c01-b360-2dc3696c65e7");
pub const IID_IDataModelNameBinder = &IID_IDataModelNameBinder_Value;
pub const IDataModelNameBinder = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        BindValue: fn(
            self: *const IDataModelNameBinder,
            contextObject: ?*IModelObject,
            name: ?[*:0]const u16,
            value: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        BindReference: fn(
            self: *const IDataModelNameBinder,
            contextObject: ?*IModelObject,
            name: ?[*:0]const u16,
            reference: ?*?*IModelObject,
            metadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateValues: fn(
            self: *const IDataModelNameBinder,
            contextObject: ?*IModelObject,
            enumerator: ?*?*IKeyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateReferences: fn(
            self: *const IDataModelNameBinder,
            contextObject: ?*IModelObject,
            enumerator: ?*?*IKeyEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelNameBinder_BindValue(self: *const T, contextObject: ?*IModelObject, name: ?[*:0]const u16, value: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelNameBinder.VTable, self.vtable).BindValue(@ptrCast(*const IDataModelNameBinder, self), contextObject, name, value, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelNameBinder_BindReference(self: *const T, contextObject: ?*IModelObject, name: ?[*:0]const u16, reference: ?*?*IModelObject, metadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelNameBinder.VTable, self.vtable).BindReference(@ptrCast(*const IDataModelNameBinder, self), contextObject, name, reference, metadata);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelNameBinder_EnumerateValues(self: *const T, contextObject: ?*IModelObject, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelNameBinder.VTable, self.vtable).EnumerateValues(@ptrCast(*const IDataModelNameBinder, self), contextObject, enumerator);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelNameBinder_EnumerateReferences(self: *const T, contextObject: ?*IModelObject, enumerator: ?*?*IKeyEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelNameBinder.VTable, self.vtable).EnumerateReferences(@ptrCast(*const IDataModelNameBinder, self), contextObject, enumerator);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IModelKeyReference2_Value = @import("../../zig.zig").Guid.initString("80e2f7c5-7159-4e92-887e-7e0347e88406");
pub const IID_IModelKeyReference2 = &IID_IModelKeyReference2_Value;
pub const IModelKeyReference2 = extern struct {
    pub const VTable = extern struct {
        base: IModelKeyReference.VTable,
        OverrideContextObject: fn(
            self: *const IModelKeyReference2,
            newContextObject: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IModelKeyReference.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IModelKeyReference2_OverrideContextObject(self: *const T, newContextObject: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IModelKeyReference2.VTable, self.vtable).OverrideContextObject(@ptrCast(*const IModelKeyReference2, self), newContextObject);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostEvaluator2_Value = @import("../../zig.zig").Guid.initString("a117a435-1fb4-4092-a2ab-a929576c1e87");
pub const IID_IDebugHostEvaluator2 = &IID_IDebugHostEvaluator2_Value;
pub const IDebugHostEvaluator2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostEvaluator.VTable,
        AssignTo: fn(
            self: *const IDebugHostEvaluator2,
            assignmentReference: ?*IModelObject,
            assignmentValue: ?*IModelObject,
            assignmentResult: ?*?*IModelObject,
            assignmentMetadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostEvaluator.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostEvaluator2_AssignTo(self: *const T, assignmentReference: ?*IModelObject, assignmentValue: ?*IModelObject, assignmentResult: ?*?*IModelObject, assignmentMetadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostEvaluator2.VTable, self.vtable).AssignTo(@ptrCast(*const IDebugHostEvaluator2, self), assignmentReference, assignmentValue, assignmentResult, assignmentMetadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelManager2_Value = @import("../../zig.zig").Guid.initString("f412c5ea-2284-4622-a660-a697160d3312");
pub const IID_IDataModelManager2 = &IID_IDataModelManager2_Value;
pub const IDataModelManager2 = extern struct {
    pub const VTable = extern struct {
        base: IDataModelManager.VTable,
        AcquireSubNamespace: fn(
            self: *const IDataModelManager2,
            modelName: ?[*:0]const u16,
            subNamespaceModelName: ?[*:0]const u16,
            accessName: ?[*:0]const u16,
            metadata: ?*IKeyStore,
            namespaceModelObject: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        CreateTypedIntrinsicObjectEx: fn(
            self: *const IDataModelManager2,
            context: ?*IDebugHostContext,
            intrinsicData: ?*VARIANT,
            type: ?*IDebugHostType,
            object: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataModelManager.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager2_AcquireSubNamespace(self: *const T, modelName: ?[*:0]const u16, subNamespaceModelName: ?[*:0]const u16, accessName: ?[*:0]const u16, metadata: ?*IKeyStore, namespaceModelObject: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager2.VTable, self.vtable).AcquireSubNamespace(@ptrCast(*const IDataModelManager2, self), modelName, subNamespaceModelName, accessName, metadata, namespaceModelObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelManager2_CreateTypedIntrinsicObjectEx(self: *const T, context: ?*IDebugHostContext, intrinsicData: ?*VARIANT, type_: ?*IDebugHostType, object: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelManager2.VTable, self.vtable).CreateTypedIntrinsicObjectEx(@ptrCast(*const IDataModelManager2, self), context, intrinsicData, type_, object);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostMemory2_Value = @import("../../zig.zig").Guid.initString("eea033de-38f6-416b-a251-1d3771001270");
pub const IID_IDebugHostMemory2 = &IID_IDebugHostMemory2_Value;
pub const IDebugHostMemory2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostMemory.VTable,
        LinearizeLocation: fn(
            self: *const IDebugHostMemory2,
            context: ?*IDebugHostContext,
            location: Location,
            pLinearizedLocation: ?*Location,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostMemory.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostMemory2_LinearizeLocation(self: *const T, context: ?*IDebugHostContext, location: Location, pLinearizedLocation: ?*Location) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostMemory2.VTable, self.vtable).LinearizeLocation(@ptrCast(*const IDebugHostMemory2, self), context, location, pLinearizedLocation);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostExtensibility_Value = @import("../../zig.zig").Guid.initString("3c2b24e1-11d0-4f86-8ae5-4df166f73253");
pub const IID_IDebugHostExtensibility = &IID_IDebugHostExtensibility_Value;
pub const IDebugHostExtensibility = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CreateFunctionAlias: fn(
            self: *const IDebugHostExtensibility,
            aliasName: ?[*:0]const u16,
            functionObject: ?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        DestroyFunctionAlias: fn(
            self: *const IDebugHostExtensibility,
            aliasName: ?[*:0]const u16,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostExtensibility_CreateFunctionAlias(self: *const T, aliasName: ?[*:0]const u16, functionObject: ?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostExtensibility.VTable, self.vtable).CreateFunctionAlias(@ptrCast(*const IDebugHostExtensibility, self), aliasName, functionObject);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostExtensibility_DestroyFunctionAlias(self: *const T, aliasName: ?[*:0]const u16) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostExtensibility.VTable, self.vtable).DestroyFunctionAlias(@ptrCast(*const IDebugHostExtensibility, self), aliasName);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const ScriptDebugState = enum(i32) {
    NoDebugger = 0,
    NotExecuting = 1,
    Executing = 2,
    Break = 3,
};
pub const ScriptDebugNoDebugger = ScriptDebugState.NoDebugger;
pub const ScriptDebugNotExecuting = ScriptDebugState.NotExecuting;
pub const ScriptDebugExecuting = ScriptDebugState.Executing;
pub const ScriptDebugBreak = ScriptDebugState.Break;

pub const ScriptDebugEventFilter = enum(i32) {
    Entry = 0,
    Exception = 1,
    UnhandledException = 2,
    Abort = 3,
};
pub const ScriptDebugEventFilterEntry = ScriptDebugEventFilter.Entry;
pub const ScriptDebugEventFilterException = ScriptDebugEventFilter.Exception;
pub const ScriptDebugEventFilterUnhandledException = ScriptDebugEventFilter.UnhandledException;
pub const ScriptDebugEventFilterAbort = ScriptDebugEventFilter.Abort;

pub const ScriptDebugEvent = enum(i32) {
    Breakpoint = 0,
    Step = 1,
    Exception = 2,
    AsyncBreak = 3,
};
pub const ScriptDebugBreakpoint = ScriptDebugEvent.Breakpoint;
pub const ScriptDebugStep = ScriptDebugEvent.Step;
pub const ScriptDebugException = ScriptDebugEvent.Exception;
pub const ScriptDebugAsyncBreak = ScriptDebugEvent.AsyncBreak;

pub const ScriptExecutionKind = enum(i32) {
    Normal = 0,
    StepIn = 1,
    StepOut = 2,
    StepOver = 3,
};
pub const ScriptExecutionNormal = ScriptExecutionKind.Normal;
pub const ScriptExecutionStepIn = ScriptExecutionKind.StepIn;
pub const ScriptExecutionStepOut = ScriptExecutionKind.StepOut;
pub const ScriptExecutionStepOver = ScriptExecutionKind.StepOver;

pub const ScriptDebugPosition = extern struct {
    Line: u32,
    Column: u32,
};

pub const ScriptDebugEventInformation = extern struct {
    DebugEvent: ScriptDebugEvent,
    EventPosition: ScriptDebugPosition,
    EventSpanEnd: ScriptDebugPosition,
    u: extern union {
        ExceptionInformation: extern struct {
            IsUncaught: bool,
        },
        BreakpointInformation: extern struct {
            BreakpointId: u64,
        },
    },
};

const IID_IDataModelScriptDebugClient_Value = @import("../../zig.zig").Guid.initString("53159b6d-d4c4-471b-a863-5b110ca800ca");
pub const IID_IDataModelScriptDebugClient = &IID_IDataModelScriptDebugClient_Value;
pub const IDataModelScriptDebugClient = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        NotifyDebugEvent: fn(
            self: *const IDataModelScriptDebugClient,
            pEventInfo: ?*ScriptDebugEventInformation,
            pScript: ?*IDataModelScript,
            pEventDataObject: ?*IModelObject,
            resumeEventKind: ?*ScriptExecutionKind,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugClient_NotifyDebugEvent(self: *const T, pEventInfo: ?*ScriptDebugEventInformation, pScript: ?*IDataModelScript, pEventDataObject: ?*IModelObject, resumeEventKind: ?*ScriptExecutionKind) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugClient.VTable, self.vtable).NotifyDebugEvent(@ptrCast(*const IDataModelScriptDebugClient, self), pEventInfo, pScript, pEventDataObject, resumeEventKind);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugVariableSetEnumerator_Value = @import("../../zig.zig").Guid.initString("0f9feed7-d045-4ac3-98a8-a98942cf6a35");
pub const IID_IDataModelScriptDebugVariableSetEnumerator = &IID_IDataModelScriptDebugVariableSetEnumerator_Value;
pub const IDataModelScriptDebugVariableSetEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IDataModelScriptDebugVariableSetEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IDataModelScriptDebugVariableSetEnumerator,
            variableName: ?*?BSTR,
            variableValue: ?*?*IModelObject,
            variableMetadata: ?*?*IKeyStore,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugVariableSetEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugVariableSetEnumerator.VTable, self.vtable).Reset(@ptrCast(*const IDataModelScriptDebugVariableSetEnumerator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugVariableSetEnumerator_GetNext(self: *const T, variableName: ?*?BSTR, variableValue: ?*?*IModelObject, variableMetadata: ?*?*IKeyStore) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugVariableSetEnumerator.VTable, self.vtable).GetNext(@ptrCast(*const IDataModelScriptDebugVariableSetEnumerator, self), variableName, variableValue, variableMetadata);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugStackFrame_Value = @import("../../zig.zig").Guid.initString("dec6ed5e-6360-4941-ab4c-a26409de4f82");
pub const IID_IDataModelScriptDebugStackFrame = &IID_IDataModelScriptDebugStackFrame_Value;
pub const IDataModelScriptDebugStackFrame = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetName: fn(
            self: *const IDataModelScriptDebugStackFrame,
            name: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetPosition: fn(
            self: *const IDataModelScriptDebugStackFrame,
            position: ?*ScriptDebugPosition,
            positionSpanEnd: ?*ScriptDebugPosition,
            lineText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        IsTransitionPoint: fn(
            self: *const IDataModelScriptDebugStackFrame,
            isTransitionPoint: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetTransition: fn(
            self: *const IDataModelScriptDebugStackFrame,
            transitionScript: ?*?*IDataModelScript,
            isTransitionContiguous: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        Evaluate: fn(
            self: *const IDataModelScriptDebugStackFrame,
            pwszExpression: ?[*:0]const u16,
            ppResult: ?*?*IModelObject,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateLocals: fn(
            self: *const IDataModelScriptDebugStackFrame,
            variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateArguments: fn(
            self: *const IDataModelScriptDebugStackFrame,
            variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_GetName(self: *const T, name: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugStackFrame.VTable, self.vtable).GetName(@ptrCast(*const IDataModelScriptDebugStackFrame, self), name);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_GetPosition(self: *const T, position: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugStackFrame.VTable, self.vtable).GetPosition(@ptrCast(*const IDataModelScriptDebugStackFrame, self), position, positionSpanEnd, lineText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_IsTransitionPoint(self: *const T, isTransitionPoint: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugStackFrame.VTable, self.vtable).IsTransitionPoint(@ptrCast(*const IDataModelScriptDebugStackFrame, self), isTransitionPoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_GetTransition(self: *const T, transitionScript: ?*?*IDataModelScript, isTransitionContiguous: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugStackFrame.VTable, self.vtable).GetTransition(@ptrCast(*const IDataModelScriptDebugStackFrame, self), transitionScript, isTransitionContiguous);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_Evaluate(self: *const T, pwszExpression: ?[*:0]const u16, ppResult: ?*?*IModelObject) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugStackFrame.VTable, self.vtable).Evaluate(@ptrCast(*const IDataModelScriptDebugStackFrame, self), pwszExpression, ppResult);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_EnumerateLocals(self: *const T, variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugStackFrame.VTable, self.vtable).EnumerateLocals(@ptrCast(*const IDataModelScriptDebugStackFrame, self), variablesEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStackFrame_EnumerateArguments(self: *const T, variablesEnum: ?*?*IDataModelScriptDebugVariableSetEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugStackFrame.VTable, self.vtable).EnumerateArguments(@ptrCast(*const IDataModelScriptDebugStackFrame, self), variablesEnum);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugStack_Value = @import("../../zig.zig").Guid.initString("051364dd-e449-443e-9762-fe578f4a5473");
pub const IID_IDataModelScriptDebugStack = &IID_IDataModelScriptDebugStack_Value;
pub const IDataModelScriptDebugStack = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetFrameCount: fn(
            self: *const IDataModelScriptDebugStack,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        GetStackFrame: fn(
            self: *const IDataModelScriptDebugStack,
            frameNumber: u64,
            stackFrame: ?*?*IDataModelScriptDebugStackFrame,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStack_GetFrameCount(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const IDataModelScriptDebugStack.VTable, self.vtable).GetFrameCount(@ptrCast(*const IDataModelScriptDebugStack, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugStack_GetStackFrame(self: *const T, frameNumber: u64, stackFrame: ?*?*IDataModelScriptDebugStackFrame) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugStack.VTable, self.vtable).GetStackFrame(@ptrCast(*const IDataModelScriptDebugStack, self), frameNumber, stackFrame);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugBreakpoint_Value = @import("../../zig.zig").Guid.initString("6bb27b35-02e6-47cb-90a0-5371244032de");
pub const IID_IDataModelScriptDebugBreakpoint = &IID_IDataModelScriptDebugBreakpoint_Value;
pub const IDataModelScriptDebugBreakpoint = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetId: fn(
            self: *const IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) u64,
        IsEnabled: fn(
            self: *const IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) bool,
        Enable: fn(
            self: *const IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Disable: fn(
            self: *const IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) void,
        Remove: fn(
            self: *const IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) void,
        GetPosition: fn(
            self: *const IDataModelScriptDebugBreakpoint,
            position: ?*ScriptDebugPosition,
            positionSpanEnd: ?*ScriptDebugPosition,
            lineText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_GetId(self: *const T) callconv(.Inline) u64 {
            return @ptrCast(*const IDataModelScriptDebugBreakpoint.VTable, self.vtable).GetId(@ptrCast(*const IDataModelScriptDebugBreakpoint, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_IsEnabled(self: *const T) callconv(.Inline) bool {
            return @ptrCast(*const IDataModelScriptDebugBreakpoint.VTable, self.vtable).IsEnabled(@ptrCast(*const IDataModelScriptDebugBreakpoint, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_Enable(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDataModelScriptDebugBreakpoint.VTable, self.vtable).Enable(@ptrCast(*const IDataModelScriptDebugBreakpoint, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_Disable(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDataModelScriptDebugBreakpoint.VTable, self.vtable).Disable(@ptrCast(*const IDataModelScriptDebugBreakpoint, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_Remove(self: *const T) callconv(.Inline) void {
            return @ptrCast(*const IDataModelScriptDebugBreakpoint.VTable, self.vtable).Remove(@ptrCast(*const IDataModelScriptDebugBreakpoint, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpoint_GetPosition(self: *const T, position: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugBreakpoint.VTable, self.vtable).GetPosition(@ptrCast(*const IDataModelScriptDebugBreakpoint, self), position, positionSpanEnd, lineText);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebugBreakpointEnumerator_Value = @import("../../zig.zig").Guid.initString("39484a75-b4f3-4799-86da-691afa57b299");
pub const IID_IDataModelScriptDebugBreakpointEnumerator = &IID_IDataModelScriptDebugBreakpointEnumerator_Value;
pub const IDataModelScriptDebugBreakpointEnumerator = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        Reset: fn(
            self: *const IDataModelScriptDebugBreakpointEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetNext: fn(
            self: *const IDataModelScriptDebugBreakpointEnumerator,
            breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpointEnumerator_Reset(self: *const T) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugBreakpointEnumerator.VTable, self.vtable).Reset(@ptrCast(*const IDataModelScriptDebugBreakpointEnumerator, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebugBreakpointEnumerator_GetNext(self: *const T, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebugBreakpointEnumerator.VTable, self.vtable).GetNext(@ptrCast(*const IDataModelScriptDebugBreakpointEnumerator, self), breakpoint);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebug_Value = @import("../../zig.zig").Guid.initString("de8e0945-9750-4471-ab76-a8f79d6ec350");
pub const IID_IDataModelScriptDebug = &IID_IDataModelScriptDebug_Value;
pub const IDataModelScriptDebug = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        GetDebugState: fn(
            self: *const IDataModelScriptDebug,
        ) callconv(@import("std").os.windows.WINAPI) ScriptDebugState,
        GetCurrentPosition: fn(
            self: *const IDataModelScriptDebug,
            currentPosition: ?*ScriptDebugPosition,
            positionSpanEnd: ?*ScriptDebugPosition,
            lineText: ?*?BSTR,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetStack: fn(
            self: *const IDataModelScriptDebug,
            stack: ?*?*IDataModelScriptDebugStack,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetBreakpoint: fn(
            self: *const IDataModelScriptDebug,
            linePosition: u32,
            columnPosition: u32,
            breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        FindBreakpointById: fn(
            self: *const IDataModelScriptDebug,
            breakpointId: u64,
            breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        EnumerateBreakpoints: fn(
            self: *const IDataModelScriptDebug,
            breakpointEnum: ?*?*IDataModelScriptDebugBreakpointEnumerator,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        GetEventFilter: fn(
            self: *const IDataModelScriptDebug,
            eventFilter: ScriptDebugEventFilter,
            isBreakEnabled: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        SetEventFilter: fn(
            self: *const IDataModelScriptDebug,
            eventFilter: ScriptDebugEventFilter,
            isBreakEnabled: u8,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StartDebugging: fn(
            self: *const IDataModelScriptDebug,
            debugClient: ?*IDataModelScriptDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
        StopDebugging: fn(
            self: *const IDataModelScriptDebug,
            debugClient: ?*IDataModelScriptDebugClient,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_GetDebugState(self: *const T) callconv(.Inline) ScriptDebugState {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).GetDebugState(@ptrCast(*const IDataModelScriptDebug, self));
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_GetCurrentPosition(self: *const T, currentPosition: ?*ScriptDebugPosition, positionSpanEnd: ?*ScriptDebugPosition, lineText: ?*?BSTR) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).GetCurrentPosition(@ptrCast(*const IDataModelScriptDebug, self), currentPosition, positionSpanEnd, lineText);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_GetStack(self: *const T, stack: ?*?*IDataModelScriptDebugStack) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).GetStack(@ptrCast(*const IDataModelScriptDebug, self), stack);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_SetBreakpoint(self: *const T, linePosition: u32, columnPosition: u32, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).SetBreakpoint(@ptrCast(*const IDataModelScriptDebug, self), linePosition, columnPosition, breakpoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_FindBreakpointById(self: *const T, breakpointId: u64, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).FindBreakpointById(@ptrCast(*const IDataModelScriptDebug, self), breakpointId, breakpoint);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_EnumerateBreakpoints(self: *const T, breakpointEnum: ?*?*IDataModelScriptDebugBreakpointEnumerator) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).EnumerateBreakpoints(@ptrCast(*const IDataModelScriptDebug, self), breakpointEnum);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_GetEventFilter(self: *const T, eventFilter: ScriptDebugEventFilter, isBreakEnabled: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).GetEventFilter(@ptrCast(*const IDataModelScriptDebug, self), eventFilter, isBreakEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_SetEventFilter(self: *const T, eventFilter: ScriptDebugEventFilter, isBreakEnabled: u8) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).SetEventFilter(@ptrCast(*const IDataModelScriptDebug, self), eventFilter, isBreakEnabled);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_StartDebugging(self: *const T, debugClient: ?*IDataModelScriptDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).StartDebugging(@ptrCast(*const IDataModelScriptDebug, self), debugClient);
        }
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug_StopDebugging(self: *const T, debugClient: ?*IDataModelScriptDebugClient) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug.VTable, self.vtable).StopDebugging(@ptrCast(*const IDataModelScriptDebug, self), debugClient);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDataModelScriptDebug2_Value = @import("../../zig.zig").Guid.initString("cbb10ed3-839e-426c-9243-e23535c1ae1a");
pub const IID_IDataModelScriptDebug2 = &IID_IDataModelScriptDebug2_Value;
pub const IDataModelScriptDebug2 = extern struct {
    pub const VTable = extern struct {
        base: IDataModelScriptDebug.VTable,
        SetBreakpointAtFunction: fn(
            self: *const IDataModelScriptDebug2,
            functionName: ?[*:0]const u16,
            breakpoint: ?*?*IDataModelScriptDebugBreakpoint,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDataModelScriptDebug.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDataModelScriptDebug2_SetBreakpointAtFunction(self: *const T, functionName: ?[*:0]const u16, breakpoint: ?*?*IDataModelScriptDebugBreakpoint) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDataModelScriptDebug2.VTable, self.vtable).SetBreakpointAtFunction(@ptrCast(*const IDataModelScriptDebug2, self), functionName, breakpoint);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IDebugHostModule2_Value = @import("../../zig.zig").Guid.initString("b51887e8-bcd0-4e8f-a8c7-434398b78c37");
pub const IID_IDebugHostModule2 = &IID_IDebugHostModule2_Value;
pub const IDebugHostModule2 = extern struct {
    pub const VTable = extern struct {
        base: IDebugHostModule.VTable,
        FindContainingSymbolByRVA: fn(
            self: *const IDebugHostModule2,
            rva: u64,
            symbol: ?*?*IDebugHostSymbol,
            offset: ?*u64,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IDebugHostModule.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IDebugHostModule2_FindContainingSymbolByRVA(self: *const T, rva: u64, symbol: ?*?*IDebugHostSymbol, offset: ?*u64) callconv(.Inline) HRESULT {
            return @ptrCast(*const IDebugHostModule2.VTable, self.vtable).FindContainingSymbolByRVA(@ptrCast(*const IDebugHostModule2, self), rva, symbol, offset);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IComparableConcept_Value = @import("../../zig.zig").Guid.initString("a7830646-9f0c-4a31-ba19-503f33e6c8a3");
pub const IID_IComparableConcept = &IID_IComparableConcept_Value;
pub const IComparableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        CompareObjects: fn(
            self: *const IComparableConcept,
            contextObject: ?*IModelObject,
            otherObject: ?*IModelObject,
            comparisonResult: ?*i32,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IComparableConcept_CompareObjects(self: *const T, contextObject: ?*IModelObject, otherObject: ?*IModelObject, comparisonResult: ?*i32) callconv(.Inline) HRESULT {
            return @ptrCast(*const IComparableConcept.VTable, self.vtable).CompareObjects(@ptrCast(*const IComparableConcept, self), contextObject, otherObject, comparisonResult);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

const IID_IEquatableConcept_Value = @import("../../zig.zig").Guid.initString("c52d5d3d-609d-4d5d-8a82-46b0acdec4f4");
pub const IID_IEquatableConcept = &IID_IEquatableConcept_Value;
pub const IEquatableConcept = extern struct {
    pub const VTable = extern struct {
        base: IUnknown.VTable,
        AreObjectsEqual: fn(
            self: *const IEquatableConcept,
            contextObject: ?*IModelObject,
            otherObject: ?*IModelObject,
            isEqual: ?*bool,
        ) callconv(@import("std").os.windows.WINAPI) HRESULT,
    };
    vtable: *const VTable,
    pub fn MethodMixin(comptime T: type) type { return struct {
        pub usingnamespace IUnknown.MethodMixin(T);
        // NOTE: method is namespaced with interface name to avoid conflicts for now
        pub fn IEquatableConcept_AreObjectsEqual(self: *const T, contextObject: ?*IModelObject, otherObject: ?*IModelObject, isEqual: ?*bool) callconv(.Inline) HRESULT {
            return @ptrCast(*const IEquatableConcept.VTable, self.vtable).AreObjectsEqual(@ptrCast(*const IEquatableConcept, self), contextObject, otherObject, isEqual);
        }
    };}
    pub usingnamespace MethodMixin(@This());
};

pub const PWINDBG_OUTPUT_ROUTINE = fn(
    lpFormat: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_GET_EXPRESSION = fn(
    lpExpression: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) usize;

pub const PWINDBG_GET_EXPRESSION32 = fn(
    lpExpression: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_GET_EXPRESSION64 = fn(
    lpExpression: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) u64;

pub const PWINDBG_GET_SYMBOL = fn(
    offset: ?*c_void,
    pchBuffer: ?[*]u8,
    pDisplacement: ?*usize,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_GET_SYMBOL32 = fn(
    offset: u32,
    pchBuffer: ?[*]u8,
    pDisplacement: ?*u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_GET_SYMBOL64 = fn(
    offset: u64,
    pchBuffer: ?[*]u8,
    pDisplacement: ?*u64,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_DISASM = fn(
    lpOffset: ?*usize,
    lpBuffer: ?[*:0]const u8,
    fShowEffectiveAddress: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_DISASM32 = fn(
    lpOffset: ?*u32,
    lpBuffer: ?[*:0]const u8,
    fShowEffectiveAddress: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_DISASM64 = fn(
    lpOffset: ?*u64,
    lpBuffer: ?[*:0]const u8,
    fShowEffectiveAddress: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_CHECK_CONTROL_C = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE = fn(
    offset: usize,
    lpBuffer: ?*c_void,
    cb: u32,
    lpcbBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE32 = fn(
    offset: u32,
    lpBuffer: ?*c_void,
    cb: u32,
    lpcbBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_READ_PROCESS_MEMORY_ROUTINE64 = fn(
    offset: u64,
    lpBuffer: ?*c_void,
    cb: u32,
    lpcbBytesRead: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE = fn(
    offset: usize,
    lpBuffer: ?*const c_void,
    cb: u32,
    lpcbBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32 = fn(
    offset: u32,
    lpBuffer: ?*const c_void,
    cb: u32,
    lpcbBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64 = fn(
    offset: u64,
    lpBuffer: ?*const c_void,
    cb: u32,
    lpcbBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_GET_THREAD_CONTEXT_ROUTINE = fn(
    Processor: u32,
    lpContext: ?*CONTEXT,
    cbSizeOfContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_SET_THREAD_CONTEXT_ROUTINE = fn(
    Processor: u32,
    lpContext: ?*CONTEXT,
    cbSizeOfContext: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_IOCTL_ROUTINE = fn(
    IoctlType: u16,
    lpvData: ?*c_void,
    cbSize: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_OLDKD_READ_PHYSICAL_MEMORY = fn(
    address: u64,
    buffer: ?*c_void,
    count: u32,
    bytesread: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY = fn(
    address: u64,
    buffer: ?*c_void,
    length: u32,
    byteswritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const EXTSTACKTRACE = extern struct {
    FramePointer: u32,
    ProgramCounter: u32,
    ReturnAddress: u32,
    Args: [4]u32,
};

pub const EXTSTACKTRACE32 = extern struct {
    FramePointer: u32,
    ProgramCounter: u32,
    ReturnAddress: u32,
    Args: [4]u32,
};

pub const EXTSTACKTRACE64 = extern struct {
    FramePointer: u64,
    ProgramCounter: u64,
    ReturnAddress: u64,
    Args: [4]u64,
};

pub const PWINDBG_STACKTRACE_ROUTINE = fn(
    FramePointer: u32,
    StackPointer: u32,
    ProgramCounter: u32,
    StackFrames: ?*EXTSTACKTRACE,
    Frames: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_STACKTRACE_ROUTINE32 = fn(
    FramePointer: u32,
    StackPointer: u32,
    ProgramCounter: u32,
    StackFrames: ?*EXTSTACKTRACE32,
    Frames: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const PWINDBG_STACKTRACE_ROUTINE64 = fn(
    FramePointer: u64,
    StackPointer: u64,
    ProgramCounter: u64,
    StackFrames: ?*EXTSTACKTRACE64,
    Frames: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const WINDBG_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL,
    lpDisasmRoutine: ?PWINDBG_DISASM,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE,
};

pub const WINDBG_EXTENSION_APIS32 = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION32,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL32,
    lpDisasmRoutine: ?PWINDBG_DISASM32,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE32,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE32,
};

pub const WINDBG_EXTENSION_APIS64 = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION64,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL64,
    lpDisasmRoutine: ?PWINDBG_DISASM64,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadProcessMemoryRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE64,
    lpWriteProcessMemoryRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64,
    lpGetThreadContextRoutine: ?PWINDBG_GET_THREAD_CONTEXT_ROUTINE,
    lpSetThreadContextRoutine: ?PWINDBG_SET_THREAD_CONTEXT_ROUTINE,
    lpIoctlRoutine: ?PWINDBG_IOCTL_ROUTINE,
    lpStackTraceRoutine: ?PWINDBG_STACKTRACE_ROUTINE64,
};

pub const WINDBG_OLD_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL,
    lpDisasmRoutine: ?PWINDBG_DISASM,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
};

pub const WINDBG_OLDKD_EXTENSION_APIS = extern struct {
    nSize: u32,
    lpOutputRoutine: ?PWINDBG_OUTPUT_ROUTINE,
    lpGetExpressionRoutine: ?PWINDBG_GET_EXPRESSION32,
    lpGetSymbolRoutine: ?PWINDBG_GET_SYMBOL32,
    lpDisasmRoutine: ?PWINDBG_DISASM32,
    lpCheckControlCRoutine: ?PWINDBG_CHECK_CONTROL_C,
    lpReadVirtualMemRoutine: ?PWINDBG_READ_PROCESS_MEMORY_ROUTINE32,
    lpWriteVirtualMemRoutine: ?PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32,
    lpReadPhysicalMemRoutine: ?PWINDBG_OLDKD_READ_PHYSICAL_MEMORY,
    lpWritePhysicalMemRoutine: ?PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY,
};

pub const PWINDBG_OLD_EXTENSION_ROUTINE = fn(
    dwCurrentPc: u32,
    lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
    lpArgumentString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_EXTENSION_ROUTINE = fn(
    hCurrentProcess: ?HANDLE,
    hCurrentThread: ?HANDLE,
    dwCurrentPc: u32,
    dwProcessor: u32,
    lpArgumentString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_EXTENSION_ROUTINE32 = fn(
    hCurrentProcess: ?HANDLE,
    hCurrentThread: ?HANDLE,
    dwCurrentPc: u32,
    dwProcessor: u32,
    lpArgumentString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_EXTENSION_ROUTINE64 = fn(
    hCurrentProcess: ?HANDLE,
    hCurrentThread: ?HANDLE,
    dwCurrentPc: u64,
    dwProcessor: u32,
    lpArgumentString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_OLDKD_EXTENSION_ROUTINE = fn(
    dwCurrentPc: u32,
    lpExtensionApis: ?*WINDBG_OLDKD_EXTENSION_APIS,
    lpArgumentString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_EXTENSION_DLL_INIT = fn(
    lpExtensionApis: ?*WINDBG_EXTENSION_APIS,
    MajorVersion: u16,
    MinorVersion: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_EXTENSION_DLL_INIT32 = fn(
    lpExtensionApis: ?*WINDBG_EXTENSION_APIS32,
    MajorVersion: u16,
    MinorVersion: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_EXTENSION_DLL_INIT64 = fn(
    lpExtensionApis: ?*WINDBG_EXTENSION_APIS64,
    MajorVersion: u16,
    MinorVersion: u16,
) callconv(@import("std").os.windows.WINAPI) void;

pub const PWINDBG_CHECK_VERSION = fn(
) callconv(@import("std").os.windows.WINAPI) u32;

pub const EXT_API_VERSION = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    Revision: u16,
    Reserved: u16,
};

pub const PWINDBG_EXTENSION_API_VERSION = fn(
) callconv(@import("std").os.windows.WINAPI) ?*EXT_API_VERSION;

pub const PROCESSORINFO = extern struct {
    Processor: u16,
    NumberProcessors: u16,
};

pub const READCONTROLSPACE = extern struct {
    Processor: u16,
    Address: u32,
    BufLen: u32,
    Buf: [1]u8,
};

pub const READCONTROLSPACE32 = extern struct {
    Processor: u16,
    Address: u32,
    BufLen: u32,
    Buf: [1]u8,
};

pub const READCONTROLSPACE64 = extern struct {
    Processor: u16,
    Address: u64,
    BufLen: u32,
    Buf: [1]u8,
};

pub const IOSPACE = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
};

pub const IOSPACE32 = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
};

pub const IOSPACE64 = extern struct {
    Address: u64,
    Length: u32,
    Data: u32,
};

pub const IOSPACE_EX = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const IOSPACE_EX32 = extern struct {
    Address: u32,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const IOSPACE_EX64 = extern struct {
    Address: u64,
    Length: u32,
    Data: u32,
    InterfaceType: u32,
    BusNumber: u32,
    AddressSpace: u32,
};

pub const _GETSETBUSDATA = extern struct {
    BusDataType: u32,
    BusNumber: u32,
    SlotNumber: u32,
    Buffer: ?*c_void,
    Offset: u32,
    Length: u32,
};

pub const SEARCHMEMORY = extern struct {
    SearchAddress: u64,
    SearchLength: u64,
    FoundAddress: u64,
    PatternLength: u32,
    Pattern: ?*c_void,
};

pub const PHYSICAL = extern struct {
    Address: u64,
    BufLen: u32,
    Buf: [1]u8,
};

pub const PHYSICAL_WITH_FLAGS = extern struct {
    Address: u64,
    BufLen: u32,
    Flags: u32,
    Buf: [1]u8,
};

pub const READ_WRITE_MSR = extern struct {
    Msr: u32,
    Value: i64,
};

pub const GET_SET_SYMPATH = extern struct {
    Args: ?[*:0]const u8,
    Result: ?PSTR,
    Length: i32,
};

pub const GET_TEB_ADDRESS = extern struct {
    Address: u64,
};

pub const GET_PEB_ADDRESS = extern struct {
    CurrentThread: u64,
    Address: u64,
};

pub const GET_CURRENT_THREAD_ADDRESS = extern struct {
    Processor: u32,
    Address: u64,
};

pub const GET_CURRENT_PROCESS_ADDRESS = extern struct {
    Processor: u32,
    CurrentThread: u64,
    Address: u64,
};

pub const GET_INPUT_LINE = extern struct {
    Prompt: ?[*:0]const u8,
    Buffer: ?PSTR,
    BufferSize: u32,
    InputSize: u32,
};

pub const GET_EXPRESSION_EX = extern struct {
    Expression: ?[*:0]const u8,
    Remainder: ?[*:0]const u8,
    Value: u64,
};

pub const TRANSLATE_VIRTUAL_TO_PHYSICAL = extern struct {
    Virtual: u64,
    Physical: u64,
};

pub const VIRTUAL_TO_PHYSICAL = extern struct {
    Status: u32,
    Size: u32,
    PdeAddress: u64,
    Virtual: u64,
    Physical: u64,
};

pub const PHYSICAL_TO_VIRTUAL = extern struct {
    Status: u32,
    Size: u32,
    PdeAddress: u64,
};

pub const GET_CONTEXT_EX = extern struct {
    Status: u32,
    ContextSize: u32,
    pContext: ?*c_void,
};

pub const POINTER_SEARCH_PHYSICAL = extern struct {
    Offset: u64,
    Length: u64,
    PointerMin: u64,
    PointerMax: u64,
    Flags: u32,
    MatchOffsets: ?*u64,
    MatchOffsetsSize: u32,
    MatchOffsetsCount: u32,
};

pub const WDBGEXTS_THREAD_OS_INFO = extern struct {
    ThreadId: u32,
    ExitStatus: u32,
    PriorityClass: u32,
    Priority: u32,
    CreateTime: u64,
    ExitTime: u64,
    KernelTime: u64,
    UserTime: u64,
    StartOffset: u64,
    Affinity: u64,
};

pub const WDBGEXTS_CLR_DATA_INTERFACE = extern struct {
    Iid: ?*const Guid,
    Iface: ?*c_void,
};

pub const EXT_MATCH_PATTERN_A = extern struct {
    Str: ?[*:0]const u8,
    Pattern: ?[*:0]const u8,
    CaseSensitive: u32,
};

pub const EXT_FIND_FILE = extern struct {
    FileName: ?[*:0]const u16,
    IndexedSize: u64,
    ImageTimeDateStamp: u32,
    ImageCheckSum: u32,
    ExtraInfo: ?*c_void,
    ExtraInfoSize: u32,
    Flags: u32,
    FileMapping: ?*c_void,
    FileMappingSize: u64,
    FileHandle: ?HANDLE,
    FoundFileName: ?PWSTR,
    FoundFileNameChars: u32,
};

pub const DEBUG_TYPED_DATA = extern struct {
    ModBase: u64,
    Offset: u64,
    EngineHandle: u64,
    Data: u64,
    Size: u32,
    Flags: u32,
    TypeId: u32,
    BaseTypeId: u32,
    Tag: u32,
    Register: u32,
    Internal: [9]u64,
};

pub const EXT_TDOP = enum(i32) {
    COPY = 0,
    RELEASE = 1,
    SET_FROM_EXPR = 2,
    SET_FROM_U64_EXPR = 3,
    GET_FIELD = 4,
    EVALUATE = 5,
    GET_TYPE_NAME = 6,
    OUTPUT_TYPE_NAME = 7,
    OUTPUT_SIMPLE_VALUE = 8,
    OUTPUT_FULL_VALUE = 9,
    HAS_FIELD = 10,
    GET_FIELD_OFFSET = 11,
    GET_ARRAY_ELEMENT = 12,
    GET_DEREFERENCE = 13,
    GET_TYPE_SIZE = 14,
    OUTPUT_TYPE_DEFINITION = 15,
    GET_POINTER_TO = 16,
    SET_FROM_TYPE_ID_AND_U64 = 17,
    SET_PTR_FROM_TYPE_ID_AND_U64 = 18,
    COUNT = 19,
};
pub const EXT_TDOP_COPY = EXT_TDOP.COPY;
pub const EXT_TDOP_RELEASE = EXT_TDOP.RELEASE;
pub const EXT_TDOP_SET_FROM_EXPR = EXT_TDOP.SET_FROM_EXPR;
pub const EXT_TDOP_SET_FROM_U64_EXPR = EXT_TDOP.SET_FROM_U64_EXPR;
pub const EXT_TDOP_GET_FIELD = EXT_TDOP.GET_FIELD;
pub const EXT_TDOP_EVALUATE = EXT_TDOP.EVALUATE;
pub const EXT_TDOP_GET_TYPE_NAME = EXT_TDOP.GET_TYPE_NAME;
pub const EXT_TDOP_OUTPUT_TYPE_NAME = EXT_TDOP.OUTPUT_TYPE_NAME;
pub const EXT_TDOP_OUTPUT_SIMPLE_VALUE = EXT_TDOP.OUTPUT_SIMPLE_VALUE;
pub const EXT_TDOP_OUTPUT_FULL_VALUE = EXT_TDOP.OUTPUT_FULL_VALUE;
pub const EXT_TDOP_HAS_FIELD = EXT_TDOP.HAS_FIELD;
pub const EXT_TDOP_GET_FIELD_OFFSET = EXT_TDOP.GET_FIELD_OFFSET;
pub const EXT_TDOP_GET_ARRAY_ELEMENT = EXT_TDOP.GET_ARRAY_ELEMENT;
pub const EXT_TDOP_GET_DEREFERENCE = EXT_TDOP.GET_DEREFERENCE;
pub const EXT_TDOP_GET_TYPE_SIZE = EXT_TDOP.GET_TYPE_SIZE;
pub const EXT_TDOP_OUTPUT_TYPE_DEFINITION = EXT_TDOP.OUTPUT_TYPE_DEFINITION;
pub const EXT_TDOP_GET_POINTER_TO = EXT_TDOP.GET_POINTER_TO;
pub const EXT_TDOP_SET_FROM_TYPE_ID_AND_U64 = EXT_TDOP.SET_FROM_TYPE_ID_AND_U64;
pub const EXT_TDOP_SET_PTR_FROM_TYPE_ID_AND_U64 = EXT_TDOP.SET_PTR_FROM_TYPE_ID_AND_U64;
pub const EXT_TDOP_COUNT = EXT_TDOP.COUNT;

pub const EXT_TYPED_DATA = extern struct {
    Operation: EXT_TDOP,
    Flags: u32,
    InData: DEBUG_TYPED_DATA,
    OutData: DEBUG_TYPED_DATA,
    InStrIndex: u32,
    In32: u32,
    Out32: u32,
    In64: u64,
    Out64: u64,
    StrBufferIndex: u32,
    StrBufferChars: u32,
    StrCharsNeeded: u32,
    DataBufferIndex: u32,
    DataBufferBytes: u32,
    DataBytesNeeded: u32,
    Status: HRESULT,
    Reserved: [8]u64,
};

pub const WDBGEXTS_QUERY_INTERFACE = extern struct {
    Iid: ?*const Guid,
    Iface: ?*c_void,
};

pub const WDBGEXTS_DISASSEMBLE_BUFFER = extern struct {
    InOffset: u64,
    OutOffset: u64,
    AddrFlags: u32,
    FormatFlags: u32,
    DataBufferBytes: u32,
    DisasmBufferChars: u32,
    DataBuffer: ?*c_void,
    DisasmBuffer: ?PWSTR,
    Reserved0: [3]u64,
};

pub const WDBGEXTS_MODULE_IN_RANGE = extern struct {
    Start: u64,
    End: u64,
    FoundModBase: u64,
    FoundModSize: u32,
};

pub const DBGKD_MAJOR_TYPES = enum(i32) {
    NT = 0,
    XBOX = 1,
    BIG = 2,
    EXDI = 3,
    NTBD = 4,
    EFI = 5,
    TNT = 6,
    SINGULARITY = 7,
    HYPERVISOR = 8,
    MIDORI = 9,
    CE = 10,
    COUNT = 11,
};
pub const DBGKD_MAJOR_NT = DBGKD_MAJOR_TYPES.NT;
pub const DBGKD_MAJOR_XBOX = DBGKD_MAJOR_TYPES.XBOX;
pub const DBGKD_MAJOR_BIG = DBGKD_MAJOR_TYPES.BIG;
pub const DBGKD_MAJOR_EXDI = DBGKD_MAJOR_TYPES.EXDI;
pub const DBGKD_MAJOR_NTBD = DBGKD_MAJOR_TYPES.NTBD;
pub const DBGKD_MAJOR_EFI = DBGKD_MAJOR_TYPES.EFI;
pub const DBGKD_MAJOR_TNT = DBGKD_MAJOR_TYPES.TNT;
pub const DBGKD_MAJOR_SINGULARITY = DBGKD_MAJOR_TYPES.SINGULARITY;
pub const DBGKD_MAJOR_HYPERVISOR = DBGKD_MAJOR_TYPES.HYPERVISOR;
pub const DBGKD_MAJOR_MIDORI = DBGKD_MAJOR_TYPES.MIDORI;
pub const DBGKD_MAJOR_CE = DBGKD_MAJOR_TYPES.CE;
pub const DBGKD_MAJOR_COUNT = DBGKD_MAJOR_TYPES.COUNT;

pub const DBGKD_GET_VERSION32 = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    ProtocolVersion: u16,
    Flags: u16,
    KernBase: u32,
    PsLoadedModuleList: u32,
    MachineType: u16,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    KiCallUserMode: u32,
    KeUserCallbackDispatcher: u32,
    BreakpointWithStatus: u32,
    DebuggerDataList: u32,
};

pub const DBGKD_DEBUG_DATA_HEADER32 = extern struct {
    List: LIST_ENTRY32,
    OwnerTag: u32,
    Size: u32,
};

pub const KDDEBUGGER_DATA32 = extern struct {
    Header: DBGKD_DEBUG_DATA_HEADER32,
    KernBase: u32,
    BreakpointWithStatus: u32,
    SavedContext: u32,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    _bitfield: u16,
    KiCallUserMode: u32,
    KeUserCallbackDispatcher: u32,
    PsLoadedModuleList: u32,
    PsActiveProcessHead: u32,
    PspCidTable: u32,
    ExpSystemResourcesList: u32,
    ExpPagedPoolDescriptor: u32,
    ExpNumberOfPagedPools: u32,
    KeTimeIncrement: u32,
    KeBugCheckCallbackListHead: u32,
    KiBugcheckData: u32,
    IopErrorLogListHead: u32,
    ObpRootDirectoryObject: u32,
    ObpTypeObjectType: u32,
    MmSystemCacheStart: u32,
    MmSystemCacheEnd: u32,
    MmSystemCacheWs: u32,
    MmPfnDatabase: u32,
    MmSystemPtesStart: u32,
    MmSystemPtesEnd: u32,
    MmSubsectionBase: u32,
    MmNumberOfPagingFiles: u32,
    MmLowestPhysicalPage: u32,
    MmHighestPhysicalPage: u32,
    MmNumberOfPhysicalPages: u32,
    MmMaximumNonPagedPoolInBytes: u32,
    MmNonPagedSystemStart: u32,
    MmNonPagedPoolStart: u32,
    MmNonPagedPoolEnd: u32,
    MmPagedPoolStart: u32,
    MmPagedPoolEnd: u32,
    MmPagedPoolInformation: u32,
    MmPageSize: u32,
    MmSizeOfPagedPoolInBytes: u32,
    MmTotalCommitLimit: u32,
    MmTotalCommittedPages: u32,
    MmSharedCommit: u32,
    MmDriverCommit: u32,
    MmProcessCommit: u32,
    MmPagedPoolCommit: u32,
    MmExtendedCommit: u32,
    MmZeroedPageListHead: u32,
    MmFreePageListHead: u32,
    MmStandbyPageListHead: u32,
    MmModifiedPageListHead: u32,
    MmModifiedNoWritePageListHead: u32,
    MmAvailablePages: u32,
    MmResidentAvailablePages: u32,
    PoolTrackTable: u32,
    NonPagedPoolDescriptor: u32,
    MmHighestUserAddress: u32,
    MmSystemRangeStart: u32,
    MmUserProbeAddress: u32,
    KdPrintCircularBuffer: u32,
    KdPrintCircularBufferEnd: u32,
    KdPrintWritePointer: u32,
    KdPrintRolloverCount: u32,
    MmLoadedUserImageList: u32,
};

pub const DBGKD_GET_VERSION64 = extern struct {
    MajorVersion: u16,
    MinorVersion: u16,
    ProtocolVersion: u8,
    KdSecondaryVersion: u8,
    Flags: u16,
    MachineType: u16,
    MaxPacketType: u8,
    MaxStateChange: u8,
    MaxManipulate: u8,
    Simulation: u8,
    Unused: [1]u16,
    KernBase: u64,
    PsLoadedModuleList: u64,
    DebuggerDataList: u64,
};

pub const DBGKD_DEBUG_DATA_HEADER64 = extern struct {
    List: LIST_ENTRY64,
    OwnerTag: u32,
    Size: u32,
};

pub const KDDEBUGGER_DATA64 = extern struct {
    Header: DBGKD_DEBUG_DATA_HEADER64,
    KernBase: u64,
    BreakpointWithStatus: u64,
    SavedContext: u64,
    ThCallbackStack: u16,
    NextCallback: u16,
    FramePointer: u16,
    _bitfield: u16,
    KiCallUserMode: u64,
    KeUserCallbackDispatcher: u64,
    PsLoadedModuleList: u64,
    PsActiveProcessHead: u64,
    PspCidTable: u64,
    ExpSystemResourcesList: u64,
    ExpPagedPoolDescriptor: u64,
    ExpNumberOfPagedPools: u64,
    KeTimeIncrement: u64,
    KeBugCheckCallbackListHead: u64,
    KiBugcheckData: u64,
    IopErrorLogListHead: u64,
    ObpRootDirectoryObject: u64,
    ObpTypeObjectType: u64,
    MmSystemCacheStart: u64,
    MmSystemCacheEnd: u64,
    MmSystemCacheWs: u64,
    MmPfnDatabase: u64,
    MmSystemPtesStart: u64,
    MmSystemPtesEnd: u64,
    MmSubsectionBase: u64,
    MmNumberOfPagingFiles: u64,
    MmLowestPhysicalPage: u64,
    MmHighestPhysicalPage: u64,
    MmNumberOfPhysicalPages: u64,
    MmMaximumNonPagedPoolInBytes: u64,
    MmNonPagedSystemStart: u64,
    MmNonPagedPoolStart: u64,
    MmNonPagedPoolEnd: u64,
    MmPagedPoolStart: u64,
    MmPagedPoolEnd: u64,
    MmPagedPoolInformation: u64,
    MmPageSize: u64,
    MmSizeOfPagedPoolInBytes: u64,
    MmTotalCommitLimit: u64,
    MmTotalCommittedPages: u64,
    MmSharedCommit: u64,
    MmDriverCommit: u64,
    MmProcessCommit: u64,
    MmPagedPoolCommit: u64,
    MmExtendedCommit: u64,
    MmZeroedPageListHead: u64,
    MmFreePageListHead: u64,
    MmStandbyPageListHead: u64,
    MmModifiedPageListHead: u64,
    MmModifiedNoWritePageListHead: u64,
    MmAvailablePages: u64,
    MmResidentAvailablePages: u64,
    PoolTrackTable: u64,
    NonPagedPoolDescriptor: u64,
    MmHighestUserAddress: u64,
    MmSystemRangeStart: u64,
    MmUserProbeAddress: u64,
    KdPrintCircularBuffer: u64,
    KdPrintCircularBufferEnd: u64,
    KdPrintWritePointer: u64,
    KdPrintRolloverCount: u64,
    MmLoadedUserImageList: u64,
    NtBuildLab: u64,
    KiNormalSystemCall: u64,
    KiProcessorBlock: u64,
    MmUnloadedDrivers: u64,
    MmLastUnloadedDriver: u64,
    MmTriageActionTaken: u64,
    MmSpecialPoolTag: u64,
    KernelVerifier: u64,
    MmVerifierData: u64,
    MmAllocatedNonPagedPool: u64,
    MmPeakCommitment: u64,
    MmTotalCommitLimitMaximum: u64,
    CmNtCSDVersion: u64,
    MmPhysicalMemoryBlock: u64,
    MmSessionBase: u64,
    MmSessionSize: u64,
    MmSystemParentTablePage: u64,
    MmVirtualTranslationBase: u64,
    OffsetKThreadNextProcessor: u16,
    OffsetKThreadTeb: u16,
    OffsetKThreadKernelStack: u16,
    OffsetKThreadInitialStack: u16,
    OffsetKThreadApcProcess: u16,
    OffsetKThreadState: u16,
    OffsetKThreadBStore: u16,
    OffsetKThreadBStoreLimit: u16,
    SizeEProcess: u16,
    OffsetEprocessPeb: u16,
    OffsetEprocessParentCID: u16,
    OffsetEprocessDirectoryTableBase: u16,
    SizePrcb: u16,
    OffsetPrcbDpcRoutine: u16,
    OffsetPrcbCurrentThread: u16,
    OffsetPrcbMhz: u16,
    OffsetPrcbCpuType: u16,
    OffsetPrcbVendorString: u16,
    OffsetPrcbProcStateContext: u16,
    OffsetPrcbNumber: u16,
    SizeEThread: u16,
    L1tfHighPhysicalBitIndex: u8,
    L1tfSwizzleBitIndex: u8,
    Padding0: u32,
    KdPrintCircularBufferPtr: u64,
    KdPrintBufferSize: u64,
    KeLoaderBlock: u64,
    SizePcr: u16,
    OffsetPcrSelfPcr: u16,
    OffsetPcrCurrentPrcb: u16,
    OffsetPcrContainedPrcb: u16,
    OffsetPcrInitialBStore: u16,
    OffsetPcrBStoreLimit: u16,
    OffsetPcrInitialStack: u16,
    OffsetPcrStackLimit: u16,
    OffsetPrcbPcrPage: u16,
    OffsetPrcbProcStateSpecialReg: u16,
    GdtR0Code: u16,
    GdtR0Data: u16,
    GdtR0Pcr: u16,
    GdtR3Code: u16,
    GdtR3Data: u16,
    GdtR3Teb: u16,
    GdtLdt: u16,
    GdtTss: u16,
    Gdt64R3CmCode: u16,
    Gdt64R3CmTeb: u16,
    IopNumTriageDumpDataBlocks: u64,
    IopTriageDumpDataBlocks: u64,
    VfCrashDataBlock: u64,
    MmBadPagesDetected: u64,
    MmZeroedPageSingleBitErrorsDetected: u64,
    EtwpDebuggerData: u64,
    OffsetPrcbContext: u16,
    OffsetPrcbMaxBreakpoints: u16,
    OffsetPrcbMaxWatchpoints: u16,
    OffsetKThreadStackLimit: u32,
    OffsetKThreadStackBase: u32,
    OffsetKThreadQueueListEntry: u32,
    OffsetEThreadIrpList: u32,
    OffsetPrcbIdleThread: u16,
    OffsetPrcbNormalDpcState: u16,
    OffsetPrcbDpcStack: u16,
    OffsetPrcbIsrStack: u16,
    SizeKDPC_STACK_FRAME: u16,
    OffsetKPriQueueThreadListHead: u16,
    OffsetKThreadWaitReason: u16,
    Padding1: u16,
    PteBase: u64,
    RetpolineStubFunctionTable: u64,
    RetpolineStubFunctionTableSize: u32,
    RetpolineStubOffset: u32,
    RetpolineStubSize: u32,
};

pub const PSYM_DUMP_FIELD_CALLBACK = fn(
    pField: ?*FIELD_INFO,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

pub const FIELD_INFO = extern struct {
    pub const _BitField = extern struct {
        Position: u16,
        Size: u16,
    };
    fName: ?*u8,
    printName: ?*u8,
    size: u32,
    fOptions: u32,
    address: u64,
    Anonymous: extern union {
        fieldCallBack: ?*c_void,
        pBuffer: ?*c_void,
    },
    TypeId: u32,
    FieldOffset: u32,
    BufferSize: u32,
    BitField: _BitField,
    _bitfield: u32,
};

pub const SYM_DUMP_PARAM = extern struct {
    size: u32,
    sName: ?*u8,
    Options: u32,
    addr: u64,
    listLink: ?*FIELD_INFO,
    Anonymous: extern union {
        Context: ?*c_void,
        pBuffer: ?*c_void,
    },
    CallbackRoutine: ?PSYM_DUMP_FIELD_CALLBACK,
    nFields: u32,
    Fields: ?*FIELD_INFO,
    ModBase: u64,
    TypeId: u32,
    TypeSize: u32,
    BufferSize: u32,
    _bitfield: u32,
};
































pub const CONTEXT = switch(@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        ContextFlags: u32,
        Cpsr: u32,
        Anonymous: extern union {
            Anonymous: extern struct {
                X0: u64,
                X1: u64,
                X2: u64,
                X3: u64,
                X4: u64,
                X5: u64,
                X6: u64,
                X7: u64,
                X8: u64,
                X9: u64,
                X10: u64,
                X11: u64,
                X12: u64,
                X13: u64,
                X14: u64,
                X15: u64,
                X16: u64,
                X17: u64,
                X18: u64,
                X19: u64,
                X20: u64,
                X21: u64,
                X22: u64,
                X23: u64,
                X24: u64,
                X25: u64,
                X26: u64,
                X27: u64,
                X28: u64,
                Fp: u64,
                Lr: u64,
            },
            X: [31]u64,
        },
        Sp: u64,
        Pc: u64,
        V: [32]ARM64_NT_NEON128,
        Fpcr: u32,
        Fpsr: u32,
        Bcr: [8]u32,
        Bvr: [8]u64,
        Wcr: [2]u32,
        Wvr: [2]u64,
    },
    .X64 => extern struct {
        P1Home: u64,
        P2Home: u64,
        P3Home: u64,
        P4Home: u64,
        P5Home: u64,
        P6Home: u64,
        ContextFlags: u32,
        MxCsr: u32,
        SegCs: u16,
        SegDs: u16,
        SegEs: u16,
        SegFs: u16,
        SegGs: u16,
        SegSs: u16,
        EFlags: u32,
        Dr0: u64,
        Dr1: u64,
        Dr2: u64,
        Dr3: u64,
        Dr6: u64,
        Dr7: u64,
        Rax: u64,
        Rcx: u64,
        Rdx: u64,
        Rbx: u64,
        Rsp: u64,
        Rbp: u64,
        Rsi: u64,
        Rdi: u64,
        R8: u64,
        R9: u64,
        R10: u64,
        R11: u64,
        R12: u64,
        R13: u64,
        R14: u64,
        R15: u64,
        Rip: u64,
        Anonymous: extern union {
            FltSave: XSAVE_FORMAT,
            Anonymous: extern struct {
                Header: [2]M128A,
                Legacy: [8]M128A,
                Xmm0: M128A,
                Xmm1: M128A,
                Xmm2: M128A,
                Xmm3: M128A,
                Xmm4: M128A,
                Xmm5: M128A,
                Xmm6: M128A,
                Xmm7: M128A,
                Xmm8: M128A,
                Xmm9: M128A,
                Xmm10: M128A,
                Xmm11: M128A,
                Xmm12: M128A,
                Xmm13: M128A,
                Xmm14: M128A,
                Xmm15: M128A,
            },
        },
        VectorRegister: [26]M128A,
        VectorControl: u64,
        DebugControl: u64,
        LastBranchToRip: u64,
        LastBranchFromRip: u64,
        LastExceptionToRip: u64,
        LastExceptionFromRip: u64,
    },
    .X86 => extern struct {
        ContextFlags: u32,
        Dr0: u32,
        Dr1: u32,
        Dr2: u32,
        Dr3: u32,
        Dr6: u32,
        Dr7: u32,
        FloatSave: FLOATING_SAVE_AREA,
        SegGs: u32,
        SegFs: u32,
        SegEs: u32,
        SegDs: u32,
        Edi: u32,
        Esi: u32,
        Ebx: u32,
        Edx: u32,
        Ecx: u32,
        Eax: u32,
        Ebp: u32,
        Eip: u32,
        SegCs: u32,
        EFlags: u32,
        Esp: u32,
        SegSs: u32,
        ExtendedRegisters: [512]u8,
    },
};
pub const MINIDUMP_EXCEPTION_INFORMATION = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        ThreadId: u32,
        ExceptionPointers: ?*EXCEPTION_POINTERS,
        ClientPointers: BOOL,
    },
    .X86 => extern struct {
        ThreadId: u32,
        ExceptionPointers: ?*EXCEPTION_POINTERS,
        ClientPointers: BOOL,
    },
};
pub const MINIDUMP_USER_STREAM = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        Type: u32,
        BufferSize: u32,
        Buffer: ?*c_void,
    },
    .X86 => extern struct {
        Type: u32,
        BufferSize: u32,
        Buffer: ?*c_void,
    },
};
pub const MINIDUMP_USER_STREAM_INFORMATION = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        UserStreamCount: u32,
        UserStreamArray: ?*MINIDUMP_USER_STREAM,
    },
    .X86 => extern struct {
        UserStreamCount: u32,
        UserStreamArray: ?*MINIDUMP_USER_STREAM,
    },
};
pub const MINIDUMP_THREAD_CALLBACK = switch(@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Pad: u32,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
    },
    .X64 => extern struct {
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
    },
    .X86 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
    },
};
pub const MINIDUMP_THREAD_EX_CALLBACK = switch(@import("../../zig.zig").arch) {
    .Arm64 => extern struct {
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Pad: u32,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
        BackingStoreBase: u64,
        BackingStoreEnd: u64,
    },
    .X64 => extern struct {
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
        BackingStoreBase: u64,
        BackingStoreEnd: u64,
    },
    .X86 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        ThreadId: u32,
        ThreadHandle: ?HANDLE,
        Context: CONTEXT,
        SizeOfContext: u32,
        StackBase: u64,
        StackEnd: u64,
        BackingStoreBase: u64,
        BackingStoreEnd: u64,
    },
};
pub const MINIDUMP_CALLBACK_INFORMATION = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        // WARNING: unable to add field alignment because it's causing a compiler bug
        CallbackRoutine: ?MINIDUMP_CALLBACK_ROUTINE,
        CallbackParam: ?*c_void,
    },
    .X86 => extern struct {
        CallbackRoutine: ?MINIDUMP_CALLBACK_ROUTINE,
        CallbackParam: ?*c_void,
    },
};
pub const LOADED_IMAGE = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => extern struct {
        ModuleName: ?PSTR,
        hFile: ?HANDLE,
        MappedAddress: ?*u8,
        FileHeader: ?*IMAGE_NT_HEADERS64,
        LastRvaSection: ?*IMAGE_SECTION_HEADER,
        NumberOfSections: u32,
        Sections: ?*IMAGE_SECTION_HEADER,
        Characteristics: IMAGE_FILE_CHARACTERISTICS2,
        fSystemImage: BOOLEAN,
        fDOSImage: BOOLEAN,
        fReadOnly: BOOLEAN,
        Version: u8,
        Links: LIST_ENTRY,
        SizeOfImage: u32,
    },
    .X86 => extern struct {
        ModuleName: ?PSTR,
        hFile: ?HANDLE,
        MappedAddress: ?*u8,
        FileHeader: ?*IMAGE_NT_HEADERS32,
        LastRvaSection: ?*IMAGE_SECTION_HEADER,
        NumberOfSections: u32,
        Sections: ?*IMAGE_SECTION_HEADER,
        Characteristics: IMAGE_FILE_CHARACTERISTICS2,
        fSystemImage: BOOLEAN,
        fDOSImage: BOOLEAN,
        fReadOnly: BOOLEAN,
        Version: u8,
        Links: LIST_ENTRY,
        SizeOfImage: u32,
    },
};
pub const IMAGE_DEBUG_INFORMATION = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        List: LIST_ENTRY,
        ReservedSize: u32,
        ReservedMappedBase: ?*c_void,
        ReservedMachine: u16,
        ReservedCharacteristics: u16,
        ReservedCheckSum: u32,
        ImageBase: u32,
        SizeOfImage: u32,
        ReservedNumberOfSections: u32,
        ReservedSections: ?*IMAGE_SECTION_HEADER,
        ReservedExportedNamesSize: u32,
        ReservedExportedNames: ?PSTR,
        ReservedNumberOfFunctionTableEntries: u32,
        ReservedFunctionTableEntries: ?*IMAGE_FUNCTION_ENTRY,
        ReservedLowestFunctionStartingAddress: u32,
        ReservedHighestFunctionEndingAddress: u32,
        ReservedNumberOfFpoTableEntries: u32,
        ReservedFpoTableEntries: ?*FPO_DATA,
        SizeOfCoffSymbols: u32,
        CoffSymbols: ?*IMAGE_COFF_SYMBOLS_HEADER,
        ReservedSizeOfCodeViewSymbols: u32,
        ReservedCodeViewSymbols: ?*c_void,
        ImageFilePath: ?PSTR,
        ImageFileName: ?PSTR,
        ReservedDebugFilePath: ?PSTR,
        ReservedTimeDateStamp: u32,
        ReservedRomImage: BOOL,
        ReservedDebugDirectory: ?*IMAGE_DEBUG_DIRECTORY,
        ReservedNumberOfDebugDirectories: u32,
        ReservedOriginalFunctionTableBaseAddress: u32,
        Reserved: [2]u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const ADDRESS = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        Offset: u32,
        Segment: u16,
        Mode: ADDRESS_MODE,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const KDHELP = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        Thread: u32,
        ThCallbackStack: u32,
        NextCallback: u32,
        FramePointer: u32,
        KiCallUserMode: u32,
        KeUserCallbackDispatcher: u32,
        SystemRangeStart: u32,
        ThCallbackBStore: u32,
        KiUserExceptionDispatcher: u32,
        StackBase: u32,
        StackLimit: u32,
        Reserved: [5]u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const STACKFRAME = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        AddrPC: ADDRESS,
        AddrReturn: ADDRESS,
        AddrFrame: ADDRESS,
        AddrStack: ADDRESS,
        FuncTableEntry: ?*c_void,
        Params: [4]u32,
        Far: BOOL,
        Virtual: BOOL,
        Reserved: [3]u32,
        KdHelp: KDHELP,
        AddrBStore: ADDRESS,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PREAD_PROCESS_MEMORY_ROUTINE = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        hProcess: ?HANDLE,
        lpBaseAddress: u32,
        // TODO: what to do with BytesParamIndex 3?
        lpBuffer: ?*c_void,
        nSize: u32,
        lpNumberOfBytesRead: ?*u32,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PFUNCTION_TABLE_ACCESS_ROUTINE = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        hProcess: ?HANDLE,
        AddrBase: u32,
    ) callconv(@import("std").os.windows.WINAPI) ?*c_void,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PGET_MODULE_BASE_ROUTINE = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        hProcess: ?HANDLE,
        Address: u32,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PTRANSLATE_ADDRESS_ROUTINE = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        hProcess: ?HANDLE,
        hThread: ?HANDLE,
        lpaddr: ?*ADDRESS,
    ) callconv(@import("std").os.windows.WINAPI) u32,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMMODULES_CALLBACK = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        ModuleName: ?[*:0]const u8,
        BaseOfDll: u32,
        UserContext: ?*c_void,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMSYMBOLS_CALLBACK = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        SymbolName: ?[*:0]const u8,
        SymbolAddress: u32,
        SymbolSize: u32,
        UserContext: ?*c_void,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYM_ENUMSYMBOLS_CALLBACKW = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        SymbolName: ?[*:0]const u16,
        SymbolAddress: u32,
        SymbolSize: u32,
        UserContext: ?*c_void,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PENUMLOADED_MODULES_CALLBACK = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        ModuleName: ?[*:0]const u8,
        ModuleBase: u32,
        ModuleSize: u32,
        UserContext: ?*c_void,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const PSYMBOL_REGISTERED_CALLBACK = switch(@import("../../zig.zig").arch) {
    .X86 => fn(
        hProcess: ?HANDLE,
        ActionCode: u32,
        CallbackData: ?*c_void,
        UserContext: ?*c_void,
    ) callconv(@import("std").os.windows.WINAPI) BOOL,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOL = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Address: u32,
        Size: u32,
        Flags: u32,
        MaxNameLength: u32,
        Name: [1]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOL_PACKAGE = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        sym: IMAGEHLP_SYMBOL,
        name: [2001]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOLW = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Address: u32,
        Size: u32,
        Flags: u32,
        MaxNameLength: u32,
        Name: [1]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_SYMBOLW_PACKAGE = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        sym: IMAGEHLP_SYMBOLW,
        name: [2001]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_MODULE = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        ImageSize: u32,
        TimeDateStamp: u32,
        CheckSum: u32,
        NumSyms: u32,
        SymType: SYM_TYPE,
        ModuleName: [32]CHAR,
        ImageName: [256]CHAR,
        LoadedImageName: [256]CHAR,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_MODULEW = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        ImageSize: u32,
        TimeDateStamp: u32,
        CheckSum: u32,
        NumSyms: u32,
        SymType: SYM_TYPE,
        ModuleName: [32]u16,
        ImageName: [256]u16,
        LoadedImageName: [256]u16,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_LINE = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Key: ?*c_void,
        LineNumber: u32,
        FileName: ?[*]u8,
        Address: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_LINEW = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        Key: ?*c_void,
        LineNumber: u32,
        FileName: ?[*]u8,
        Address: u64,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_DEFERRED_SYMBOL_LOAD = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        BaseOfImage: u32,
        CheckSum: u32,
        TimeDateStamp: u32,
        FileName: [260]CHAR,
        Reparse: BOOLEAN,
        hFile: ?HANDLE,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
pub const IMAGEHLP_DUPLICATE_SYMBOL = switch(@import("../../zig.zig").arch) {
    .X86 => extern struct {
        SizeOfStruct: u32,
        NumberOfDups: u32,
        Symbol: ?*IMAGEHLP_SYMBOL,
        SelectedSymbol: u32,
    },
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};

//--------------------------------------------------------------------------------
// Section: Functions (300)
//--------------------------------------------------------------------------------
pub usingnamespace switch (@import("../../zig.zig").arch) {
.Arm64 => struct {

pub extern "KERNEL32" fn RtlAddFunctionTable(
    FunctionTable: [*]IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    EntryCount: u32,
    BaseAddress: usize,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.Arm64 => struct {

pub extern "KERNEL32" fn RtlDeleteFunctionTable(
    FunctionTable: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.Arm64 => struct {

pub extern "KERNEL32" fn RtlInstallFunctionTableCallback(
    TableIdentifier: usize,
    BaseAddress: usize,
    Length: u32,
    Callback: ?PGET_RUNTIME_FUNCTION_CALLBACK,
    Context: ?*c_void,
    OutOfProcessCallbackDll: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.Arm64 => struct {

// TODO: this type is limited to platform 'windows8.0'
pub extern "ntdll" fn RtlAddGrowableFunctionTable(
    DynamicTable: ?*?*c_void,
    FunctionTable: [*]IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    EntryCount: u32,
    MaximumEntryCount: u32,
    RangeBase: usize,
    RangeEnd: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows8.0'
pub extern "ntdll" fn RtlGrowFunctionTable(
    DynamicTable: ?*c_void,
    NewEntryCount: u32,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64, .Arm64 => struct {

// TODO: this type is limited to platform 'windows8.0'
pub extern "ntdll" fn RtlDeleteGrowableFunctionTable(
    DynamicTable: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.Arm64 => struct {

pub extern "KERNEL32" fn RtlLookupFunctionEntry(
    ControlPc: usize,
    ImageBase: ?*usize,
    HistoryTable: ?*UNWIND_HISTORY_TABLE,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn RtlRestoreContext(
    ContextRecord: ?*CONTEXT,
    ExceptionRecord: ?*EXCEPTION_RECORD,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "KERNEL32" fn RtlUnwindEx(
    TargetFrame: ?*c_void,
    TargetIp: ?*c_void,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ReturnValue: ?*c_void,
    ContextRecord: ?*CONTEXT,
    HistoryTable: ?*UNWIND_HISTORY_TABLE,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.Arm64 => struct {

pub extern "KERNEL32" fn RtlVirtualUnwind(
    HandlerType: RTL_VIRTUAL_UNWIND_HANDLER_TYPE,
    ImageBase: usize,
    ControlPc: usize,
    FunctionEntry: ?*IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    ContextRecord: ?*CONTEXT,
    HandlerData: ?*?*c_void,
    EstablisherFrame: ?*usize,
    ContextPointers: ?*KNONVOLATILE_CONTEXT_POINTERS,
) callconv(@import("std").os.windows.WINAPI) ?EXCEPTION_ROUTINE;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "dbghelp" fn ImageNtHeader(
    Base: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS64;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "dbghelp" fn ImageRvaToSection(
    NtHeaders: ?*IMAGE_NT_HEADERS64,
    Base: ?*c_void,
    Rva: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_SECTION_HEADER;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64, .Arm64 => struct {

pub extern "dbghelp" fn ImageRvaToVa(
    NtHeaders: ?*IMAGE_NT_HEADERS64,
    Base: ?*c_void,
    Rva: u32,
    LastRvaSection: ?*?*IMAGE_SECTION_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RtlCaptureStackBackTrace(
    FramesToSkip: u32,
    FramesToCapture: u32,
    BackTrace: [*]?*c_void,
    BackTraceHash: ?*u32,
) callconv(@import("std").os.windows.WINAPI) u16;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RtlCaptureContext(
    ContextRecord: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64 => struct {

pub extern "KERNEL32" fn RtlCaptureContext2(
    ContextRecord: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) void;

}, else => struct { } };

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RtlUnwind(
    TargetFrame: ?*c_void,
    TargetIp: ?*c_void,
    ExceptionRecord: ?*EXCEPTION_RECORD,
    ReturnValue: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64 => struct {

pub extern "KERNEL32" fn RtlAddFunctionTable(
    FunctionTable: [*]IMAGE_RUNTIME_FUNCTION_ENTRY,
    EntryCount: u32,
    BaseAddress: u64,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64 => struct {

pub extern "KERNEL32" fn RtlDeleteFunctionTable(
    FunctionTable: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64 => struct {

pub extern "KERNEL32" fn RtlInstallFunctionTableCallback(
    TableIdentifier: u64,
    BaseAddress: u64,
    Length: u32,
    Callback: ?PGET_RUNTIME_FUNCTION_CALLBACK,
    Context: ?*c_void,
    OutOfProcessCallbackDll: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOLEAN;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64 => struct {

// TODO: this type is limited to platform 'windows8.0'
pub extern "ntdll" fn RtlAddGrowableFunctionTable(
    DynamicTable: ?*?*c_void,
    FunctionTable: [*]IMAGE_RUNTIME_FUNCTION_ENTRY,
    EntryCount: u32,
    MaximumEntryCount: u32,
    RangeBase: usize,
    RangeEnd: usize,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64 => struct {

pub extern "KERNEL32" fn RtlLookupFunctionEntry(
    ControlPc: u64,
    ImageBase: ?*u64,
    HistoryTable: ?*UNWIND_HISTORY_TABLE,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_RUNTIME_FUNCTION_ENTRY;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X64 => struct {

pub extern "KERNEL32" fn RtlVirtualUnwind(
    HandlerType: RTL_VIRTUAL_UNWIND_HANDLER_TYPE,
    ImageBase: u64,
    ControlPc: u64,
    FunctionEntry: ?*IMAGE_RUNTIME_FUNCTION_ENTRY,
    ContextRecord: ?*CONTEXT,
    HandlerData: ?*?*c_void,
    EstablisherFrame: ?*u64,
    ContextPointers: ?*KNONVOLATILE_CONTEXT_POINTERS,
) callconv(@import("std").os.windows.WINAPI) ?EXCEPTION_ROUTINE;

}, else => struct { } };

pub extern "KERNEL32" fn RtlPcToFileHeader(
    PcValue: ?*c_void,
    BaseOfImage: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn IsDebuggerPresent(
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DebugBreak(
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OutputDebugStringA(
    lpOutputString: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn OutputDebugStringW(
    lpOutputString: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ContinueDebugEvent(
    dwProcessId: u32,
    dwThreadId: u32,
    dwContinueStatus: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WaitForDebugEvent(
    lpDebugEvent: ?*DEBUG_EVENT,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DebugActiveProcess(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DebugActiveProcessStop(
    dwProcessId: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn CheckRemoteDebuggerPresent(
    hProcess: ?HANDLE,
    pbDebuggerPresent: ?*BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows10.0.10240'
pub extern "KERNEL32" fn WaitForDebugEventEx(
    lpDebugEvent: ?*DEBUG_EVENT,
    dwMilliseconds: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "KERNEL32" fn EncodePointer(
    Ptr: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn DecodePointer(
    Ptr: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn EncodeSystemPointer(
    Ptr: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "KERNEL32" fn DecodeSystemPointer(
    Ptr: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "api-ms-win-core-util-l1-1-1" fn EncodeRemotePointer(
    ProcessHandle: ?HANDLE,
    Ptr: ?*c_void,
    EncodedPtr: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "api-ms-win-core-util-l1-1-1" fn DecodeRemotePointer(
    ProcessHandle: ?HANDLE,
    Ptr: ?*c_void,
    DecodedPtr: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn Beep(
    dwFreq: u32,
    dwDuration: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RaiseException(
    dwExceptionCode: u32,
    dwExceptionFlags: u32,
    nNumberOfArguments: u32,
    lpArguments: ?[*]const usize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn UnhandledExceptionFilter(
    ExceptionInfo: ?*EXCEPTION_POINTERS,
) callconv(@import("std").os.windows.WINAPI) i32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetUnhandledExceptionFilter(
    lpTopLevelExceptionFilter: ?LPTOP_LEVEL_EXCEPTION_FILTER,
) callconv(@import("std").os.windows.WINAPI) ?LPTOP_LEVEL_EXCEPTION_FILTER;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetLastError(
) callconv(@import("std").os.windows.WINAPI) WIN32_ERROR;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetLastError(
    dwErrCode: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn GetErrorMode(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetErrorMode(
    uMode: THREAD_ERROR_MODE,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn AddVectoredExceptionHandler(
    First: u32,
    Handler: ?PVECTORED_EXCEPTION_HANDLER,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn RemoveVectoredExceptionHandler(
    Handle: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn AddVectoredContinueHandler(
    First: u32,
    Handler: ?PVECTORED_EXCEPTION_HANDLER,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn RemoveVectoredContinueHandler(
    Handle: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn RaiseFailFastException(
    pExceptionRecord: ?*EXCEPTION_RECORD,
    pContextRecord: ?*CONTEXT,
    dwFlags: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FatalAppExitA(
    uAction: u32,
    lpMessageText: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FatalAppExitW(
    uAction: u32,
    lpMessageText: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetThreadErrorMode(
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetThreadErrorMode(
    dwNewMode: THREAD_ERROR_MODE,
    lpOldMode: ?*THREAD_ERROR_MODE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "api-ms-win-core-errorhandling-l1-1-3" fn TerminateProcessOnMemoryExhaustion(
    FailedAllocationSize: usize,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn OpenThreadWaitChainSession(
    Flags: OPEN_THREAD_WAIT_CHAIN_SESSION_FLAGS,
    callback: ?PWAITCHAINCALLBACK,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn CloseThreadWaitChainSession(
    WctHandle: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn GetThreadWaitChain(
    WctHandle: ?*c_void,
    Context: usize,
    Flags: WAIT_CHAIN_THREAD_OPTIONS,
    ThreadId: u32,
    NodeCount: ?*u32,
    NodeInfoArray: [*]WAITCHAIN_NODE_INFO,
    IsCycle: ?*i32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "ADVAPI32" fn RegisterWaitChainCOMCallback(
    CallStateCallback: ?PCOGETCALLSTATE,
    ActivationStateCallback: ?PCOGETACTIVATIONSTATE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn MiniDumpWriteDump(
    hProcess: ?HANDLE,
    ProcessId: u32,
    hFile: ?HANDLE,
    DumpType: MINIDUMP_TYPE,
    ExceptionParam: ?*MINIDUMP_EXCEPTION_INFORMATION,
    UserStreamParam: ?*MINIDUMP_USER_STREAM_INFORMATION,
    CallbackParam: ?*MINIDUMP_CALLBACK_INFORMATION,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn MiniDumpReadDumpStream(
    BaseOfDump: ?*c_void,
    StreamNumber: u32,
    Dir: ?*?*MINIDUMP_DIRECTORY,
    StreamPointer: ?*?*c_void,
    StreamSize: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindDebugInfoFile(
    hProcess: ?HANDLE,
    FileName: ?[*:0]const u8,
    DebugFilePath: ?PSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACK,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindDebugInfoFileW(
    hProcess: ?HANDLE,
    FileName: ?[*:0]const u16,
    DebugFilePath: ?PWSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACKW,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFile(
    FileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    DebugFilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFileEx(
    FileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    DebugFilePath: ?PSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACK,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindDebugInfoFileExW(
    FileName: ?[*:0]const u16,
    SymbolPath: ?[*:0]const u16,
    DebugFilePath: ?PWSTR,
    Callback: ?PFIND_DEBUG_FILE_CALLBACKW,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindFileInPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    id: ?*c_void,
    two: u32,
    three: u32,
    flags: SYM_FIND_ID_OPTION,
    FoundFile: ?PSTR,
    callback: ?PFINDFILEINPATHCALLBACK,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindFileInPathW(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]const u16,
    FileName: ?[*:0]const u16,
    id: ?*c_void,
    two: u32,
    three: u32,
    flags: SYM_FIND_ID_OPTION,
    FoundFile: ?PWSTR,
    callback: ?PFINDFILEINPATHCALLBACKW,
    context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFindExecutableImage(
    hProcess: ?HANDLE,
    FileName: ?[*:0]const u8,
    ImageFilePath: ?PSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACK,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn SymFindExecutableImageW(
    hProcess: ?HANDLE,
    FileName: ?[*:0]const u16,
    ImageFilePath: ?PWSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACKW,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImage(
    FileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    ImageFilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImageEx(
    FileName: ?[*:0]const u8,
    SymbolPath: ?[*:0]const u8,
    ImageFilePath: ?PSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACK,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn FindExecutableImageExW(
    FileName: ?[*:0]const u16,
    SymbolPath: ?[*:0]const u16,
    ImageFilePath: ?PWSTR,
    Callback: ?PFIND_EXE_FILE_CALLBACKW,
    CallerData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?HANDLE;

pub extern "dbghelp" fn ImageDirectoryEntryToDataEx(
    Base: ?*c_void,
    MappedAsImage: BOOLEAN,
    DirectoryEntry: IMAGE_DIRECTORY_ENTRY,
    Size: ?*u32,
    FoundHeader: ?*?*IMAGE_SECTION_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "dbghelp" fn ImageDirectoryEntryToData(
    Base: ?*c_void,
    MappedAsImage: BOOLEAN,
    DirectoryEntry: IMAGE_DIRECTORY_ENTRY,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "dbghelp" fn SearchTreeForFile(
    RootPath: ?[*:0]const u8,
    InputPathName: ?[*:0]const u8,
    OutputPathBuffer: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SearchTreeForFileW(
    RootPath: ?[*:0]const u16,
    InputPathName: ?[*:0]const u16,
    OutputPathBuffer: ?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumDirTree(
    hProcess: ?HANDLE,
    RootPath: ?[*:0]const u8,
    InputPathName: ?[*:0]const u8,
    OutputPathBuffer: ?PSTR,
    cb: ?PENUMDIRTREE_CALLBACK,
    data: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumDirTreeW(
    hProcess: ?HANDLE,
    RootPath: ?[*:0]const u16,
    InputPathName: ?[*:0]const u16,
    OutputPathBuffer: ?PWSTR,
    cb: ?PENUMDIRTREE_CALLBACKW,
    data: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn MakeSureDirectoryPathExists(
    DirPath: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn UnDecorateSymbolName(
    name: ?[*:0]const u8,
    outputString: [*:0]u8,
    maxStringLength: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn UnDecorateSymbolNameW(
    name: ?[*:0]const u16,
    outputString: [*:0]u16,
    maxStringLength: u32,
    flags: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn StackWalk64(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME64,
    ContextRecord: ?*c_void,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn StackWalkEx(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME_EX,
    ContextRecord: ?*c_void,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn ImagehlpApiVersion(
) callconv(@import("std").os.windows.WINAPI) ?*API_VERSION;

pub extern "dbghelp" fn ImagehlpApiVersionEx(
    AppVersion: ?*API_VERSION,
) callconv(@import("std").os.windows.WINAPI) ?*API_VERSION;

pub extern "dbghelp" fn GetTimestampForLoadedLibrary(
    Module: ?HINSTANCE,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymSetParentWindow(
    hwnd: ?HWND,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetHomeDirectory(
    hProcess: ?HANDLE,
    dir: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSetHomeDirectoryW(
    hProcess: ?HANDLE,
    dir: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetHomeDirectory(
    type: IMAGEHLP_HD_TYPE,
    dir: [*:0]u8,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymGetHomeDirectoryW(
    type: IMAGEHLP_HD_TYPE,
    dir: [*:0]u16,
    size: usize,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetOmaps(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    OmapTo: ?*?*OMAP,
    cOmapTo: ?*u64,
    OmapFrom: ?*?*OMAP,
    cOmapFrom: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetOptions(
    SymOptions: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymGetOptions(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymCleanup(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetExtendedOption(
    option: IMAGEHLP_EXTENDED_OPTIONS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetExtendedOption(
    option: IMAGEHLP_EXTENDED_OPTIONS,
    value: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchString(
    string: ?[*:0]const u8,
    expression: ?[*:0]const u8,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchStringA(
    string: ?[*:0]const u8,
    expression: ?[*:0]const u8,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchStringW(
    string: ?[*:0]const u16,
    expression: ?[*:0]const u16,
    fCase: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFiles(
    hProcess: ?HANDLE,
    ModBase: u64,
    Mask: ?[*:0]const u8,
    cbSrcFiles: ?PSYM_ENUMSOURCEFILES_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFilesW(
    hProcess: ?HANDLE,
    ModBase: u64,
    Mask: ?[*:0]const u16,
    cbSrcFiles: ?PSYM_ENUMSOURCEFILES_CALLBACKW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateModules64(
    hProcess: ?HANDLE,
    EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACK64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateModulesW64(
    hProcess: ?HANDLE,
    EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACKW64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModulesEx(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModulesExW(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACKW64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModules64(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn EnumerateLoadedModulesW64(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACKW64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFunctionTableAccess64(
    hProcess: ?HANDLE,
    AddrBase: u64,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "dbghelp" fn SymFunctionTableAccess64AccessRoutines(
    hProcess: ?HANDLE,
    AddrBase: u64,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE64,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE64,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "dbghelp" fn SymGetUnwindInfo(
    hProcess: ?HANDLE,
    Address: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*c_void,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetModuleInfo64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    ModuleInfo: ?*IMAGEHLP_MODULE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetModuleInfoW64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    ModuleInfo: ?*IMAGEHLP_MODULEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetModuleBase64(
    hProcess: ?HANDLE,
    qwAddr: u64,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "dbghelp" fn SymEnumLines(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]const u8,
    File: ?[*:0]const u8,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumLinesW(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]const u16,
    File: ?[*:0]const u16,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACKW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromAddr64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    pdwDisplacement: ?*u32,
    Line64: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromAddrW64(
    hProcess: ?HANDLE,
    dwAddr: u64,
    pdwDisplacement: ?*u32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromInlineContext(
    hProcess: ?HANDLE,
    qwAddr: u64,
    InlineContext: u32,
    qwModuleBaseAddress: u64,
    pdwDisplacement: ?*u32,
    Line64: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromInlineContextW(
    hProcess: ?HANDLE,
    dwAddr: u64,
    InlineContext: u32,
    qwModuleBaseAddress: u64,
    pdwDisplacement: ?*u32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceLines(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]const u8,
    File: ?[*:0]const u8,
    Line: u32,
    Flags: u32,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceLinesW(
    hProcess: ?HANDLE,
    Base: u64,
    Obj: ?[*:0]const u16,
    File: ?[*:0]const u16,
    Line: u32,
    Flags: u32,
    EnumLinesCallback: ?PSYM_ENUMLINES_CALLBACKW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddrIncludeInlineTrace(
    hProcess: ?HANDLE,
    Address: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymCompareInlineTrace(
    hProcess: ?HANDLE,
    Address1: u64,
    InlineContext1: u32,
    RetAddress1: u64,
    Address2: u64,
    RetAddress2: u64,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymQueryInlineTrace(
    hProcess: ?HANDLE,
    StartAddress: u64,
    StartContext: u32,
    StartRetAddress: u64,
    CurAddress: u64,
    CurContext: ?*u32,
    CurFrameIndex: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromName64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    dwLineNumber: u32,
    plDisplacement: ?*i32,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineFromNameW64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]const u16,
    FileName: ?[*:0]const u16,
    dwLineNumber: u32,
    plDisplacement: ?*i32,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineNext64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLineNextW64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLinePrev64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetLinePrevW64(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINEW64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetFileLineOffsets64(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    Buffer: [*]u64,
    BufferLines: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SymMatchFileName(
    FileName: ?[*:0]const u8,
    Match: ?[*:0]const u8,
    FileNameStop: ?*?PSTR,
    MatchStop: ?*?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymMatchFileNameW(
    FileName: ?[*:0]const u16,
    Match: ?[*:0]const u16,
    FileNameStop: ?*?PWSTR,
    MatchStop: ?*?PWSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFile(
    hProcess: ?HANDLE,
    Base: u64,
    Params: ?[*:0]const u8,
    FileSpec: ?[*:0]const u8,
    FilePath: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileW(
    hProcess: ?HANDLE,
    Base: u64,
    Params: ?[*:0]const u16,
    FileSpec: ?[*:0]const u16,
    FilePath: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileToken(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u8,
    Token: ?*?*c_void,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileChecksumW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u16,
    pCheckSumType: ?*u32,
    pChecksum: [*:0]u8,
    checksumSize: u32,
    pActualBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileChecksum(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u8,
    pCheckSumType: ?*u32,
    pChecksum: [*:0]u8,
    checksumSize: u32,
    pActualBytesWritten: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileTokenW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u16,
    Token: ?*?*c_void,
    Size: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromToken(
    hProcess: ?HANDLE,
    Token: ?*c_void,
    Params: ?[*:0]const u8,
    FilePath: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceFileFromTokenW(
    hProcess: ?HANDLE,
    Token: ?*c_void,
    Params: ?[*:0]const u16,
    FilePath: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceVarFromToken(
    hProcess: ?HANDLE,
    Token: ?*c_void,
    Params: ?[*:0]const u8,
    VarName: ?[*:0]const u8,
    Value: [*:0]u8,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSourceVarFromTokenW(
    hProcess: ?HANDLE,
    Token: ?*c_void,
    Params: ?[*:0]const u16,
    VarName: ?[*:0]const u16,
    Value: [*:0]u16,
    Size: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSourceFileTokens(
    hProcess: ?HANDLE,
    Base: u64,
    Callback: ?PENUMSOURCEFILETOKENSCALLBACK,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymInitialize(
    hProcess: ?HANDLE,
    UserSearchPath: ?[*:0]const u8,
    fInvadeProcess: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymInitializeW(
    hProcess: ?HANDLE,
    UserSearchPath: ?[*:0]const u16,
    fInvadeProcess: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSearchPath(
    hProcess: ?HANDLE,
    SearchPathA: [*:0]u8,
    SearchPathLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSearchPathW(
    hProcess: ?HANDLE,
    SearchPathA: [*:0]u16,
    SearchPathLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetSearchPath(
    hProcess: ?HANDLE,
    SearchPathA: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetSearchPathW(
    hProcess: ?HANDLE,
    SearchPathA: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// This function from dll 'dbghelp' is being skipped because it has some sort of issue
pub fn SymLoadModuleEx() void { @panic("this function is not working"); }

// This function from dll 'dbghelp' is being skipped because it has some sort of issue
pub fn SymLoadModuleExW() void { @panic("this function is not working"); }

pub extern "dbghelp" fn SymUnloadModule64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymUnDName64(
    sym: ?*IMAGEHLP_SYMBOL64,
    UnDecName: [*:0]u8,
    UnDecNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRegisterCallback64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRegisterCallbackW64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRegisterFunctionEntryCallback64(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_FUNCENTRY_CALLBACK64,
    UserContext: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetContext(
    hProcess: ?HANDLE,
    StackFrame: ?*IMAGEHLP_STACK_FRAME,
    Context: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromAddr(
    hProcess: ?HANDLE,
    Address: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromInlineContext(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSetScopeFromIndex(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumProcesses(
    EnumProcessesCallback: ?PSYM_ENUMPROCESSES_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromAddr(
    hProcess: ?HANDLE,
    Address: u64,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromAddrW(
    hProcess: ?HANDLE,
    Address: u64,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromInlineContext(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromInlineContextW(
    hProcess: ?HANDLE,
    Address: u64,
    InlineContext: u32,
    Displacement: ?*u64,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromToken(
    hProcess: ?HANDLE,
    Base: u64,
    Token: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromTokenW(
    hProcess: ?HANDLE,
    Base: u64,
    Token: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymNext(
    hProcess: ?HANDLE,
    si: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymNextW(
    hProcess: ?HANDLE,
    siw: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymPrev(
    hProcess: ?HANDLE,
    si: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymPrevW(
    hProcess: ?HANDLE,
    siw: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromName(
    hProcess: ?HANDLE,
    Name: ?[*:0]const u8,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromNameW(
    hProcess: ?HANDLE,
    Name: ?[*:0]const u16,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbols(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsEx(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*c_void,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsExW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Mask: ?[*:0]const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*c_void,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsForAddr(
    hProcess: ?HANDLE,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSymbolsForAddrW(
    hProcess: ?HANDLE,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSearch(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    SymTag: u32,
    Mask: ?[*:0]const u8,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*c_void,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSearchW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    SymTag: u32,
    Mask: ?[*:0]const u16,
    Address: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*c_void,
    Options: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetScope(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetScopeW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromIndex(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymFromIndexW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Index: u32,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeInfo(
    hProcess: ?HANDLE,
    ModBase: u64,
    TypeId: u32,
    GetType: IMAGEHLP_SYMBOL_TYPE_INFO,
    pInfo: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeInfoEx(
    hProcess: ?HANDLE,
    ModBase: u64,
    Params: ?*IMAGEHLP_GET_TYPE_INFO_PARAMS,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypes(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesByName(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    mask: ?[*:0]const u8,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumTypesByNameW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    mask: ?[*:0]const u16,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACKW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeFromName(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u8,
    Symbol: ?*SYMBOL_INFO,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetTypeFromNameW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u16,
    Symbol: ?*SYMBOL_INFOW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSymbol(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u8,
    Address: u64,
    Size: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSymbolW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u16,
    Address: u64,
    Size: u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymDeleteSymbol(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u8,
    Address: u64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymDeleteSymbolW(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    Name: ?[*:0]const u16,
    Address: u64,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymRefreshModuleList(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStream(
    hProcess: ?HANDLE,
    Base: u64,
    StreamFile: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStreamA(
    hProcess: ?HANDLE,
    Base: u64,
    StreamFile: ?[*:0]const u8,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymAddSourceStreamW(
    hProcess: ?HANDLE,
    Base: u64,
    FileSpec: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 4?
    Buffer: ?*u8,
    Size: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvIsStoreW(
    hProcess: ?HANDLE,
    path: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvIsStore(
    hProcess: ?HANDLE,
    path: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvDeltaName(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u8,
    Type: ?[*:0]const u8,
    File1: ?[*:0]const u8,
    File2: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvDeltaNameW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u16,
    Type: ?[*:0]const u16,
    File1: ?[*:0]const u16,
    File2: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvGetSupplement(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u8,
    Node: ?[*:0]const u8,
    File: ?[*:0]const u8,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvGetSupplementW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u16,
    Node: ?[*:0]const u16,
    File: ?[*:0]const u16,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvGetFileIndexes(
    File: ?[*:0]const u8,
    Id: ?*Guid,
    Val1: ?*u32,
    Val2: ?*u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexesW(
    File: ?[*:0]const u16,
    Id: ?*Guid,
    Val1: ?*u32,
    Val2: ?*u32,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexStringW(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u16,
    File: ?[*:0]const u16,
    Index: [*:0]u16,
    Size: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexString(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u8,
    File: ?[*:0]const u8,
    Index: [*:0]u8,
    Size: usize,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexInfo(
    File: ?[*:0]const u8,
    Info: ?*SYMSRV_INDEX_INFO,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvGetFileIndexInfoW(
    File: ?[*:0]const u16,
    Info: ?*SYMSRV_INDEX_INFOW,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymSrvStoreSupplement(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u8,
    Node: ?[*:0]const u8,
    File: ?[*:0]const u8,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvStoreSupplementW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u16,
    Node: ?[*:0]const u16,
    File: ?[*:0]const u16,
    Flags: u32,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymSrvStoreFile(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u8,
    File: ?[*:0]const u8,
    Flags: SYM_SRV_STORE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?PSTR;

pub extern "dbghelp" fn SymSrvStoreFileW(
    hProcess: ?HANDLE,
    SrvPath: ?[*:0]const u16,
    File: ?[*:0]const u16,
    Flags: SYM_SRV_STORE_FILE_FLAGS,
) callconv(@import("std").os.windows.WINAPI) ?PWSTR;

pub extern "dbghelp" fn SymGetSymbolFile(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u8,
    ImageFile: ?[*:0]const u8,
    Type: IMAGEHLP_SF_TYPE,
    SymbolFile: [*:0]u8,
    cSymbolFile: usize,
    DbgFile: [*:0]u8,
    cDbgFile: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymbolFileW(
    hProcess: ?HANDLE,
    SymPath: ?[*:0]const u16,
    ImageFile: ?[*:0]const u16,
    Type: IMAGEHLP_SF_TYPE,
    SymbolFile: [*:0]u16,
    cSymbolFile: usize,
    DbgFile: [*:0]u16,
    cDbgFile: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn DbgHelpCreateUserDump(
    FileName: ?[*:0]const u8,
    Callback: ?PDBGHELP_CREATE_USER_DUMP_CALLBACK,
    UserData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn DbgHelpCreateUserDumpW(
    FileName: ?[*:0]const u16,
    Callback: ?PDBGHELP_CREATE_USER_DUMP_CALLBACK,
    UserData: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymFromAddr64(
    hProcess: ?HANDLE,
    qwAddr: u64,
    pdwDisplacement: ?*u64,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymFromName64(
    hProcess: ?HANDLE,
    Name: ?[*:0]const u8,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn FindFileInPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    id: ?*c_void,
    two: u32,
    three: u32,
    flags: u32,
    FilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn FindFileInSearchPath(
    hprocess: ?HANDLE,
    SearchPathA: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    one: u32,
    two: u32,
    three: u32,
    FilePath: ?PSTR,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumSym(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMERATESYMBOLS_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateSymbols64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK64,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymEnumerateSymbolsW64(
    hProcess: ?HANDLE,
    BaseOfDll: u64,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK64W,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymLoadModule64(
    hProcess: ?HANDLE,
    hFile: ?HANDLE,
    ImageName: ?[*:0]const u8,
    ModuleName: ?[*:0]const u8,
    BaseOfDll: u64,
    SizeOfDll: u32,
) callconv(@import("std").os.windows.WINAPI) u64;

pub extern "dbghelp" fn SymGetSymNext64(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SymGetSymPrev64(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn SetCheckUserInterruptShared(
    lpStartAddress: ?LPCALL_BACK_USER_INTERRUPT_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn GetSymLoadError(
) callconv(@import("std").os.windows.WINAPI) u32;

pub extern "dbghelp" fn SetSymLoadError(
    @"error": u32,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn ReportSymbolLoadSummary(
    hProcess: ?HANDLE,
    pLoadModule: ?[*:0]const u16,
    pSymbolData: ?*DBGHELP_DATA_REPORT_STRUCT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RemoveInvalidModuleList(
    hProcess: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn RangeMapCreate(
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

pub extern "dbghelp" fn RangeMapFree(
    RmapHandle: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) void;

pub extern "dbghelp" fn RangeMapAddPeImageSections(
    RmapHandle: ?*c_void,
    ImageName: ?[*:0]const u16,
    // TODO: what to do with BytesParamIndex 3?
    MappedImage: ?*c_void,
    MappingBytes: u32,
    ImageBase: u64,
    UserTag: u64,
    MappingFlags: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapRemove(
    RmapHandle: ?*c_void,
    UserTag: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapRead(
    RmapHandle: ?*c_void,
    Offset: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*c_void,
    RequestBytes: u32,
    Flags: u32,
    DoneBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbghelp" fn RangeMapWrite(
    RmapHandle: ?*c_void,
    Offset: u64,
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*c_void,
    RequestBytes: u32,
    Flags: u32,
    DoneBytes: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub extern "dbgeng" fn DebugConnect(
    RemoteOptions: ?[*:0]const u8,
    InterfaceId: ?*const Guid,
    Interface: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugConnectWide(
    RemoteOptions: ?[*:0]const u16,
    InterfaceId: ?*const Guid,
    Interface: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugCreate(
    InterfaceId: ?*const Guid,
    Interface: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgeng" fn DebugCreateEx(
    InterfaceId: ?*const Guid,
    DbgEngOptions: u32,
    Interface: ?*?*c_void,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

pub extern "dbgmodel" fn CreateDataModelManager(
    debugHost: ?*IDebugHost,
    manager: ?*?*IDataModelManager,
) callconv(@import("std").os.windows.WINAPI) HRESULT;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn ReadProcessMemory(
    hProcess: ?HANDLE,
    lpBaseAddress: ?*const c_void,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*c_void,
    nSize: usize,
    lpNumberOfBytesRead: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn WriteProcessMemory(
    hProcess: ?HANDLE,
    lpBaseAddress: ?*c_void,
    // TODO: what to do with BytesParamIndex 3?
    lpBuffer: ?*const c_void,
    nSize: usize,
    lpNumberOfBytesWritten: ?*usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn MessageBeep(
    uType: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "USER32" fn SetLastErrorEx(
    dwErrCode: u32,
    dwType: u32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn SetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*const CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FlushInstructionCache(
    hProcess: ?HANDLE,
    // TODO: what to do with BytesParamIndex 2?
    lpBaseAddress: ?*const c_void,
    dwSize: usize,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn Wow64GetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*WOW64_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.0.6000'
pub extern "KERNEL32" fn Wow64SetThreadContext(
    hThread: ?HANDLE,
    lpContext: ?*const WOW64_CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FatalExit(
    ExitCode: i32,
) callconv(@import("std").os.windows.WINAPI) void;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn GetThreadSelectorEntry(
    hThread: ?HANDLE,
    dwSelector: u32,
    lpSelectorEntry: ?*LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn Wow64GetThreadSelectorEntry(
    hThread: ?HANDLE,
    dwSelector: u32,
    lpSelectorEntry: ?*WOW64_LDT_ENTRY,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DebugSetProcessKillOnExit(
    KillOnExit: BOOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn DebugBreakProcess(
    Process: ?HANDLE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FormatMessageA(
    dwFlags: FORMAT_MESSAGE_OPTIONS,
    lpSource: ?*const c_void,
    dwMessageId: u32,
    dwLanguageId: u32,
    lpBuffer: ?PSTR,
    nSize: u32,
    Arguments: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows5.1.2600'
pub extern "KERNEL32" fn FormatMessageW(
    dwFlags: FORMAT_MESSAGE_OPTIONS,
    lpSource: ?*const c_void,
    dwMessageId: u32,
    dwLanguageId: u32,
    lpBuffer: ?PWSTR,
    nSize: u32,
    Arguments: ?*?*i8,
) callconv(@import("std").os.windows.WINAPI) u32;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn CopyContext(
    Destination: ?*CONTEXT,
    ContextFlags: u32,
    Source: ?*CONTEXT,
) callconv(@import("std").os.windows.WINAPI) BOOL;

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn InitializeContext(
    // TODO: what to do with BytesParamIndex 3?
    Buffer: ?*c_void,
    ContextFlags: u32,
    Context: ?*?*CONTEXT,
    ContextLength: ?*u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86, .X64 => struct {

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetEnabledXStateFeatures(
) callconv(@import("std").os.windows.WINAPI) u64;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86, .X64 => struct {

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn GetXStateFeaturesMask(
    Context: ?*CONTEXT,
    FeatureMask: ?*u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86, .X64 => struct {

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn LocateXStateFeature(
    Context: ?*CONTEXT,
    FeatureId: u32,
    Length: ?*u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86, .X64 => struct {

// TODO: this type is limited to platform 'windows6.1'
pub extern "KERNEL32" fn SetXStateFeaturesMask(
    Context: ?*CONTEXT,
    FeatureMask: u64,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn ImageNtHeader(
    Base: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_NT_HEADERS32;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn ImageRvaToSection(
    NtHeaders: ?*IMAGE_NT_HEADERS32,
    Base: ?*c_void,
    Rva: u32,
) callconv(@import("std").os.windows.WINAPI) ?*IMAGE_SECTION_HEADER;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn ImageRvaToVa(
    NtHeaders: ?*IMAGE_NT_HEADERS32,
    Base: ?*c_void,
    Rva: u32,
    LastRvaSection: ?*?*IMAGE_SECTION_HEADER,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn StackWalk(
    MachineType: u32,
    hProcess: ?HANDLE,
    hThread: ?HANDLE,
    StackFrame: ?*STACKFRAME,
    ContextRecord: ?*c_void,
    ReadMemoryRoutine: ?PREAD_PROCESS_MEMORY_ROUTINE,
    FunctionTableAccessRoutine: ?PFUNCTION_TABLE_ACCESS_ROUTINE,
    GetModuleBaseRoutine: ?PGET_MODULE_BASE_ROUTINE,
    TranslateAddress: ?PTRANSLATE_ADDRESS_ROUTINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymEnumerateModules(
    hProcess: ?HANDLE,
    EnumModulesCallback: ?PSYM_ENUMMODULES_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn EnumerateLoadedModules(
    hProcess: ?HANDLE,
    EnumLoadedModulesCallback: ?PENUMLOADED_MODULES_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymFunctionTableAccess(
    hProcess: ?HANDLE,
    AddrBase: u32,
) callconv(@import("std").os.windows.WINAPI) ?*c_void;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetModuleInfo(
    hProcess: ?HANDLE,
    dwAddr: u32,
    ModuleInfo: ?*IMAGEHLP_MODULE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetModuleInfoW(
    hProcess: ?HANDLE,
    dwAddr: u32,
    ModuleInfo: ?*IMAGEHLP_MODULEW,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetModuleBase(
    hProcess: ?HANDLE,
    dwAddr: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetLineFromAddr(
    hProcess: ?HANDLE,
    dwAddr: u32,
    pdwDisplacement: ?*u32,
    Line: ?*IMAGEHLP_LINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetLineFromName(
    hProcess: ?HANDLE,
    ModuleName: ?[*:0]const u8,
    FileName: ?[*:0]const u8,
    dwLineNumber: u32,
    plDisplacement: ?*i32,
    Line: ?*IMAGEHLP_LINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetLineNext(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetLinePrev(
    hProcess: ?HANDLE,
    Line: ?*IMAGEHLP_LINE,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymUnloadModule(
    hProcess: ?HANDLE,
    BaseOfDll: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymUnDName(
    sym: ?*IMAGEHLP_SYMBOL,
    UnDecName: [*:0]u8,
    UnDecNameLength: u32,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymRegisterCallback(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_REGISTERED_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymRegisterFunctionEntryCallback(
    hProcess: ?HANDLE,
    CallbackFunction: ?PSYMBOL_FUNCENTRY_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetSymFromAddr(
    hProcess: ?HANDLE,
    dwAddr: u32,
    pdwDisplacement: ?*u32,
    Symbol: ?*IMAGEHLP_SYMBOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetSymFromName(
    hProcess: ?HANDLE,
    Name: ?[*:0]const u8,
    Symbol: ?*IMAGEHLP_SYMBOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymEnumerateSymbols(
    hProcess: ?HANDLE,
    BaseOfDll: u32,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACK,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymEnumerateSymbolsW(
    hProcess: ?HANDLE,
    BaseOfDll: u32,
    EnumSymbolsCallback: ?PSYM_ENUMSYMBOLS_CALLBACKW,
    UserContext: ?*c_void,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymLoadModule(
    hProcess: ?HANDLE,
    hFile: ?HANDLE,
    ImageName: ?[*:0]const u8,
    ModuleName: ?[*:0]const u8,
    BaseOfDll: u32,
    SizeOfDll: u32,
) callconv(@import("std").os.windows.WINAPI) u32;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetSymNext(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };

pub usingnamespace switch (@import("../../zig.zig").arch) {
.X86 => struct {

pub extern "dbghelp" fn SymGetSymPrev(
    hProcess: ?HANDLE,
    Symbol: ?*IMAGEHLP_SYMBOL,
) callconv(@import("std").os.windows.WINAPI) BOOL;

}, else => struct { } };


//--------------------------------------------------------------------------------
// Section: Unicode Aliases (3)
//--------------------------------------------------------------------------------
const thismodule = @This();
pub usingnamespace switch (@import("../../zig.zig").unicode_mode) {
    .ansi => struct {
        pub const OutputDebugString = thismodule.OutputDebugStringA;
        pub const FatalAppExit = thismodule.FatalAppExitA;
        pub const FormatMessage = thismodule.FormatMessageA;
    },
    .wide => struct {
        pub const OutputDebugString = thismodule.OutputDebugStringW;
        pub const FatalAppExit = thismodule.FatalAppExitW;
        pub const FormatMessage = thismodule.FormatMessageW;
    },
    .unspecified => if (@import("builtin").is_test) struct {
        pub const OutputDebugString = *opaque{};
        pub const FatalAppExit = *opaque{};
        pub const FormatMessage = *opaque{};
    } else struct {
        pub const OutputDebugString = @compileError("'OutputDebugString' requires that UNICODE be set to true or false in the root module");
        pub const FatalAppExit = @compileError("'FatalAppExit' requires that UNICODE be set to true or false in the root module");
        pub const FormatMessage = @compileError("'FormatMessage' requires that UNICODE be set to true or false in the root module");
    },
};
//--------------------------------------------------------------------------------
// Section: Imports (48)
//--------------------------------------------------------------------------------
const Guid = @import("../../zig.zig").Guid;
const BOOL = @import("../../foundation.zig").BOOL;
const BOOLEAN = @import("../../foundation.zig").BOOLEAN;
const BSTR = @import("../../foundation.zig").BSTR;
const CADWORD = @import("../../system/com.zig").CADWORD;
const CALPOLESTR = @import("../../system/com.zig").CALPOLESTR;
const CHAR = @import("../../system/system_services.zig").CHAR;
const DISPPARAMS = @import("../../system/ole_automation.zig").DISPPARAMS;
const EXCEPINFO = @import("../../system/ole_automation.zig").EXCEPINFO;
const FARPROC = @import("../../foundation.zig").FARPROC;
const HANDLE = @import("../../foundation.zig").HANDLE;
const HINSTANCE = @import("../../foundation.zig").HINSTANCE;
const HRESULT = @import("../../foundation.zig").HRESULT;
const HWND = @import("../../foundation.zig").HWND;
const IDispatch = @import("../../system/ole_automation.zig").IDispatch;
const IHTMLDocument2 = @import("../../web/ms_html.zig").IHTMLDocument2;
const IHTMLWindow2 = @import("../../web/ms_html.zig").IHTMLWindow2;
const ILockBytes = @import("../../storage/structured_storage.zig").ILockBytes;
const IMAGE_LOAD_CONFIG_CODE_INTEGRITY = @import("../../system/system_services.zig").IMAGE_LOAD_CONFIG_CODE_INTEGRITY;
const IServiceProvider = @import("../../system/system_services.zig").IServiceProvider;
const IStream = @import("../../storage/structured_storage.zig").IStream;
const ITypeInfo = @import("../../system/ole_automation.zig").ITypeInfo;
const IUnknown = @import("../../system/com.zig").IUnknown;
const LARGE_INTEGER = @import("../../system/system_services.zig").LARGE_INTEGER;
const LIST_ENTRY = @import("../../system/kernel.zig").LIST_ENTRY;
const LIST_ENTRY32 = @import("../../system/kernel.zig").LIST_ENTRY32;
const LIST_ENTRY64 = @import("../../system/kernel.zig").LIST_ENTRY64;
const LPTHREAD_START_ROUTINE = @import("../../system/system_services.zig").LPTHREAD_START_ROUTINE;
const MEMORY_BASIC_INFORMATION64 = @import("../../system/memory.zig").MEMORY_BASIC_INFORMATION64;
const NTSTATUS = @import("../../foundation.zig").NTSTATUS;
const PSTR = @import("../../foundation.zig").PSTR;
const PWSTR = @import("../../foundation.zig").PWSTR;
const TIME_ZONE_INFORMATION = @import("../../system/time.zig").TIME_ZONE_INFORMATION;
const TYPEDESC = @import("../../system/ole_automation.zig").TYPEDESC;
const VARIANT = @import("../../system/ole_automation.zig").VARIANT;
const VIRTUAL_ALLOCATION_TYPE = @import("../../system/memory.zig").VIRTUAL_ALLOCATION_TYPE;
const VS_FIXEDFILEINFO = @import("../../storage/file_system.zig").VS_FIXEDFILEINFO;
const XSTATE_FEATURE = @import("../../system/system_services.zig").XSTATE_FEATURE;
// 10 arch-specific imports
const ARM64_NT_NEON128 = switch(@import("../../zig.zig").arch) {
    .Arm64 => @import("../../system/system_services.zig").ARM64_NT_NEON128,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const EXCEPTION_ROUTINE = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => @import("../../system/kernel.zig").EXCEPTION_ROUTINE,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const FLOATING_SAVE_AREA = switch(@import("../../zig.zig").arch) {
    .X86 => @import("../../system/kernel.zig").FLOATING_SAVE_AREA,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY = switch(@import("../../zig.zig").arch) {
    .Arm64 => @import("../../system/system_services.zig").IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const IMAGE_RUNTIME_FUNCTION_ENTRY = switch(@import("../../zig.zig").arch) {
    .X64 => @import("../../system/system_services.zig").IMAGE_RUNTIME_FUNCTION_ENTRY,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const KNONVOLATILE_CONTEXT_POINTERS = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => @import("../../system/system_services.zig").KNONVOLATILE_CONTEXT_POINTERS,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const M128A = switch(@import("../../zig.zig").arch) {
    .X64 => @import("../../system/system_services.zig").M128A,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const PGET_RUNTIME_FUNCTION_CALLBACK = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => @import("../../system/system_services.zig").PGET_RUNTIME_FUNCTION_CALLBACK,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const UNWIND_HISTORY_TABLE = switch(@import("../../zig.zig").arch) {
    .X64, .Arm64 => @import("../../system/system_services.zig").UNWIND_HISTORY_TABLE,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};
const XSAVE_FORMAT = switch(@import("../../zig.zig").arch) {
    .X64 => @import("../../system/system_services.zig").XSAVE_FORMAT,
    else => usize, // NOTE: this should be a @compileError but can't because of https://github.com/ziglang/zig/issues/9682
};

test {
    // The following '_ = <FuncPtrType>' lines are a workaround for https://github.com/ziglang/zig/issues/4476
    if (@hasDecl(@This(), "PVECTORED_EXCEPTION_HANDLER")) { _ = PVECTORED_EXCEPTION_HANDLER; }
    if (@hasDecl(@This(), "LPTOP_LEVEL_EXCEPTION_FILTER")) { _ = LPTOP_LEVEL_EXCEPTION_FILTER; }
    if (@hasDecl(@This(), "PWAITCHAINCALLBACK")) { _ = PWAITCHAINCALLBACK; }
    if (@hasDecl(@This(), "PCOGETCALLSTATE")) { _ = PCOGETCALLSTATE; }
    if (@hasDecl(@This(), "PCOGETACTIVATIONSTATE")) { _ = PCOGETACTIVATIONSTATE; }
    if (@hasDecl(@This(), "MINIDUMP_CALLBACK_ROUTINE")) { _ = MINIDUMP_CALLBACK_ROUTINE; }
    if (@hasDecl(@This(), "RegisterAuthoringClientFunctionType")) { _ = RegisterAuthoringClientFunctionType; }
    if (@hasDecl(@This(), "UnregisterAuthoringClientFunctionType")) { _ = UnregisterAuthoringClientFunctionType; }
    if (@hasDecl(@This(), "PFIND_DEBUG_FILE_CALLBACK")) { _ = PFIND_DEBUG_FILE_CALLBACK; }
    if (@hasDecl(@This(), "PFIND_DEBUG_FILE_CALLBACKW")) { _ = PFIND_DEBUG_FILE_CALLBACKW; }
    if (@hasDecl(@This(), "PFINDFILEINPATHCALLBACK")) { _ = PFINDFILEINPATHCALLBACK; }
    if (@hasDecl(@This(), "PFINDFILEINPATHCALLBACKW")) { _ = PFINDFILEINPATHCALLBACKW; }
    if (@hasDecl(@This(), "PFIND_EXE_FILE_CALLBACK")) { _ = PFIND_EXE_FILE_CALLBACK; }
    if (@hasDecl(@This(), "PFIND_EXE_FILE_CALLBACKW")) { _ = PFIND_EXE_FILE_CALLBACKW; }
    if (@hasDecl(@This(), "PENUMDIRTREE_CALLBACK")) { _ = PENUMDIRTREE_CALLBACK; }
    if (@hasDecl(@This(), "PENUMDIRTREE_CALLBACKW")) { _ = PENUMDIRTREE_CALLBACKW; }
    if (@hasDecl(@This(), "PREAD_PROCESS_MEMORY_ROUTINE64")) { _ = PREAD_PROCESS_MEMORY_ROUTINE64; }
    if (@hasDecl(@This(), "PFUNCTION_TABLE_ACCESS_ROUTINE64")) { _ = PFUNCTION_TABLE_ACCESS_ROUTINE64; }
    if (@hasDecl(@This(), "PGET_MODULE_BASE_ROUTINE64")) { _ = PGET_MODULE_BASE_ROUTINE64; }
    if (@hasDecl(@This(), "PTRANSLATE_ADDRESS_ROUTINE64")) { _ = PTRANSLATE_ADDRESS_ROUTINE64; }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACK64")) { _ = PSYM_ENUMMODULES_CALLBACK64; }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACKW64")) { _ = PSYM_ENUMMODULES_CALLBACKW64; }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACK64")) { _ = PENUMLOADED_MODULES_CALLBACK64; }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACKW64")) { _ = PENUMLOADED_MODULES_CALLBACKW64; }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK64")) { _ = PSYM_ENUMSYMBOLS_CALLBACK64; }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK64W")) { _ = PSYM_ENUMSYMBOLS_CALLBACK64W; }
    if (@hasDecl(@This(), "PSYMBOL_REGISTERED_CALLBACK64")) { _ = PSYMBOL_REGISTERED_CALLBACK64; }
    if (@hasDecl(@This(), "PSYMBOL_FUNCENTRY_CALLBACK")) { _ = PSYMBOL_FUNCENTRY_CALLBACK; }
    if (@hasDecl(@This(), "PSYMBOL_FUNCENTRY_CALLBACK64")) { _ = PSYMBOL_FUNCENTRY_CALLBACK64; }
    if (@hasDecl(@This(), "PSYM_ENUMSOURCEFILES_CALLBACK")) { _ = PSYM_ENUMSOURCEFILES_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMSOURCEFILES_CALLBACKW")) { _ = PSYM_ENUMSOURCEFILES_CALLBACKW; }
    if (@hasDecl(@This(), "PSYM_ENUMLINES_CALLBACK")) { _ = PSYM_ENUMLINES_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMLINES_CALLBACKW")) { _ = PSYM_ENUMLINES_CALLBACKW; }
    if (@hasDecl(@This(), "PENUMSOURCEFILETOKENSCALLBACK")) { _ = PENUMSOURCEFILETOKENSCALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMPROCESSES_CALLBACK")) { _ = PSYM_ENUMPROCESSES_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMERATESYMBOLS_CALLBACK")) { _ = PSYM_ENUMERATESYMBOLS_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMERATESYMBOLS_CALLBACKW")) { _ = PSYM_ENUMERATESYMBOLS_CALLBACKW; }
    if (@hasDecl(@This(), "SYMADDSOURCESTREAM")) { _ = SYMADDSOURCESTREAM; }
    if (@hasDecl(@This(), "SYMADDSOURCESTREAMA")) { _ = SYMADDSOURCESTREAMA; }
    if (@hasDecl(@This(), "PDBGHELP_CREATE_USER_DUMP_CALLBACK")) { _ = PDBGHELP_CREATE_USER_DUMP_CALLBACK; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROC")) { _ = PSYMBOLSERVERPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROCA")) { _ = PSYMBOLSERVERPROCA; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPROCW")) { _ = PSYMBOLSERVERPROCW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROC")) { _ = PSYMBOLSERVERBYINDEXPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROCA")) { _ = PSYMBOLSERVERBYINDEXPROCA; }
    if (@hasDecl(@This(), "PSYMBOLSERVERBYINDEXPROCW")) { _ = PSYMBOLSERVERBYINDEXPROCW; }
    if (@hasDecl(@This(), "PSYMBOLSERVEROPENPROC")) { _ = PSYMBOLSERVEROPENPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERCLOSEPROC")) { _ = PSYMBOLSERVERCLOSEPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETOPTIONSPROC")) { _ = PSYMBOLSERVERSETOPTIONSPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETOPTIONSWPROC")) { _ = PSYMBOLSERVERSETOPTIONSWPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERCALLBACKPROC")) { _ = PSYMBOLSERVERCALLBACKPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETOPTIONSPROC")) { _ = PSYMBOLSERVERGETOPTIONSPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROC")) { _ = PSYMBOLSERVERPINGPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCA")) { _ = PSYMBOLSERVERPINGPROCA; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCW")) { _ = PSYMBOLSERVERPINGPROCW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETVERSION")) { _ = PSYMBOLSERVERGETVERSION; }
    if (@hasDecl(@This(), "PSYMBOLSERVERDELTANAME")) { _ = PSYMBOLSERVERDELTANAME; }
    if (@hasDecl(@This(), "PSYMBOLSERVERDELTANAMEW")) { _ = PSYMBOLSERVERDELTANAMEW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETSUPPLEMENT")) { _ = PSYMBOLSERVERGETSUPPLEMENT; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETSUPPLEMENTW")) { _ = PSYMBOLSERVERGETSUPPLEMENTW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTORESUPPLEMENT")) { _ = PSYMBOLSERVERSTORESUPPLEMENT; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTORESUPPLEMENTW")) { _ = PSYMBOLSERVERSTORESUPPLEMENTW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETINDEXSTRING")) { _ = PSYMBOLSERVERGETINDEXSTRING; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETINDEXSTRINGW")) { _ = PSYMBOLSERVERGETINDEXSTRINGW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTOREFILE")) { _ = PSYMBOLSERVERSTOREFILE; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSTOREFILEW")) { _ = PSYMBOLSERVERSTOREFILEW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERISSTORE")) { _ = PSYMBOLSERVERISSTORE; }
    if (@hasDecl(@This(), "PSYMBOLSERVERISSTOREW")) { _ = PSYMBOLSERVERISSTOREW; }
    if (@hasDecl(@This(), "PSYMBOLSERVERVERSION")) { _ = PSYMBOLSERVERVERSION; }
    if (@hasDecl(@This(), "PSYMBOLSERVERMESSAGEPROC")) { _ = PSYMBOLSERVERMESSAGEPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERWEXPROC")) { _ = PSYMBOLSERVERWEXPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERPINGPROCWEX")) { _ = PSYMBOLSERVERPINGPROCWEX; }
    if (@hasDecl(@This(), "PSYMBOLSERVERGETOPTIONDATAPROC")) { _ = PSYMBOLSERVERGETOPTIONDATAPROC; }
    if (@hasDecl(@This(), "PSYMBOLSERVERSETHTTPAUTHHEADER")) { _ = PSYMBOLSERVERSETHTTPAUTHHEADER; }
    if (@hasDecl(@This(), "LPCALL_BACK_USER_INTERRUPT_ROUTINE")) { _ = LPCALL_BACK_USER_INTERRUPT_ROUTINE; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_INITIALIZE")) { _ = PDEBUG_EXTENSION_INITIALIZE; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_UNINITIALIZE")) { _ = PDEBUG_EXTENSION_UNINITIALIZE; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_CANUNLOAD")) { _ = PDEBUG_EXTENSION_CANUNLOAD; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_UNLOAD")) { _ = PDEBUG_EXTENSION_UNLOAD; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_NOTIFY")) { _ = PDEBUG_EXTENSION_NOTIFY; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_CALL")) { _ = PDEBUG_EXTENSION_CALL; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_KNOWN_STRUCT")) { _ = PDEBUG_EXTENSION_KNOWN_STRUCT; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_KNOWN_STRUCT_EX")) { _ = PDEBUG_EXTENSION_KNOWN_STRUCT_EX; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_QUERY_VALUE_NAMES")) { _ = PDEBUG_EXTENSION_QUERY_VALUE_NAMES; }
    if (@hasDecl(@This(), "PDEBUG_EXTENSION_PROVIDE_VALUE")) { _ = PDEBUG_EXTENSION_PROVIDE_VALUE; }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION")) { _ = PDEBUG_STACK_PROVIDER_BEGINTHREADSTACKRECONSTRUCTION; }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK")) { _ = PDEBUG_STACK_PROVIDER_RECONSTRUCTSTACK; }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES")) { _ = PDEBUG_STACK_PROVIDER_FREESTACKSYMFRAMES; }
    if (@hasDecl(@This(), "PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION")) { _ = PDEBUG_STACK_PROVIDER_ENDTHREADSTACKRECONSTRUCTION; }
    if (@hasDecl(@This(), "PWINDBG_OUTPUT_ROUTINE")) { _ = PWINDBG_OUTPUT_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION")) { _ = PWINDBG_GET_EXPRESSION; }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION32")) { _ = PWINDBG_GET_EXPRESSION32; }
    if (@hasDecl(@This(), "PWINDBG_GET_EXPRESSION64")) { _ = PWINDBG_GET_EXPRESSION64; }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL")) { _ = PWINDBG_GET_SYMBOL; }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL32")) { _ = PWINDBG_GET_SYMBOL32; }
    if (@hasDecl(@This(), "PWINDBG_GET_SYMBOL64")) { _ = PWINDBG_GET_SYMBOL64; }
    if (@hasDecl(@This(), "PWINDBG_DISASM")) { _ = PWINDBG_DISASM; }
    if (@hasDecl(@This(), "PWINDBG_DISASM32")) { _ = PWINDBG_DISASM32; }
    if (@hasDecl(@This(), "PWINDBG_DISASM64")) { _ = PWINDBG_DISASM64; }
    if (@hasDecl(@This(), "PWINDBG_CHECK_CONTROL_C")) { _ = PWINDBG_CHECK_CONTROL_C; }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE")) { _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE32")) { _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE32; }
    if (@hasDecl(@This(), "PWINDBG_READ_PROCESS_MEMORY_ROUTINE64")) { _ = PWINDBG_READ_PROCESS_MEMORY_ROUTINE64; }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE")) { _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32")) { _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE32; }
    if (@hasDecl(@This(), "PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64")) { _ = PWINDBG_WRITE_PROCESS_MEMORY_ROUTINE64; }
    if (@hasDecl(@This(), "PWINDBG_GET_THREAD_CONTEXT_ROUTINE")) { _ = PWINDBG_GET_THREAD_CONTEXT_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_SET_THREAD_CONTEXT_ROUTINE")) { _ = PWINDBG_SET_THREAD_CONTEXT_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_IOCTL_ROUTINE")) { _ = PWINDBG_IOCTL_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_READ_PHYSICAL_MEMORY")) { _ = PWINDBG_OLDKD_READ_PHYSICAL_MEMORY; }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY")) { _ = PWINDBG_OLDKD_WRITE_PHYSICAL_MEMORY; }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE")) { _ = PWINDBG_STACKTRACE_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE32")) { _ = PWINDBG_STACKTRACE_ROUTINE32; }
    if (@hasDecl(@This(), "PWINDBG_STACKTRACE_ROUTINE64")) { _ = PWINDBG_STACKTRACE_ROUTINE64; }
    if (@hasDecl(@This(), "PWINDBG_OLD_EXTENSION_ROUTINE")) { _ = PWINDBG_OLD_EXTENSION_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE")) { _ = PWINDBG_EXTENSION_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE32")) { _ = PWINDBG_EXTENSION_ROUTINE32; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_ROUTINE64")) { _ = PWINDBG_EXTENSION_ROUTINE64; }
    if (@hasDecl(@This(), "PWINDBG_OLDKD_EXTENSION_ROUTINE")) { _ = PWINDBG_OLDKD_EXTENSION_ROUTINE; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT")) { _ = PWINDBG_EXTENSION_DLL_INIT; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT32")) { _ = PWINDBG_EXTENSION_DLL_INIT32; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_DLL_INIT64")) { _ = PWINDBG_EXTENSION_DLL_INIT64; }
    if (@hasDecl(@This(), "PWINDBG_CHECK_VERSION")) { _ = PWINDBG_CHECK_VERSION; }
    if (@hasDecl(@This(), "PWINDBG_EXTENSION_API_VERSION")) { _ = PWINDBG_EXTENSION_API_VERSION; }
    if (@hasDecl(@This(), "PSYM_DUMP_FIELD_CALLBACK")) { _ = PSYM_DUMP_FIELD_CALLBACK; }
    if (@hasDecl(@This(), "PREAD_PROCESS_MEMORY_ROUTINE")) { _ = PREAD_PROCESS_MEMORY_ROUTINE; }
    if (@hasDecl(@This(), "PFUNCTION_TABLE_ACCESS_ROUTINE")) { _ = PFUNCTION_TABLE_ACCESS_ROUTINE; }
    if (@hasDecl(@This(), "PGET_MODULE_BASE_ROUTINE")) { _ = PGET_MODULE_BASE_ROUTINE; }
    if (@hasDecl(@This(), "PTRANSLATE_ADDRESS_ROUTINE")) { _ = PTRANSLATE_ADDRESS_ROUTINE; }
    if (@hasDecl(@This(), "PSYM_ENUMMODULES_CALLBACK")) { _ = PSYM_ENUMMODULES_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACK")) { _ = PSYM_ENUMSYMBOLS_CALLBACK; }
    if (@hasDecl(@This(), "PSYM_ENUMSYMBOLS_CALLBACKW")) { _ = PSYM_ENUMSYMBOLS_CALLBACKW; }
    if (@hasDecl(@This(), "PENUMLOADED_MODULES_CALLBACK")) { _ = PENUMLOADED_MODULES_CALLBACK; }
    if (@hasDecl(@This(), "PSYMBOL_REGISTERED_CALLBACK")) { _ = PSYMBOL_REGISTERED_CALLBACK; }

    @setEvalBranchQuota(
        @import("std").meta.declarations(@This()).len * 3
    );

    // reference all the pub declarations
    if (!@import("builtin").is_test) return;
    inline for (@import("std").meta.declarations(@This())) |decl| {
        if (decl.is_pub) {
            _ = decl;
        }
    }
}
